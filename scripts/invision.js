;;
/*! main.js */
;;
var InVision = angular.module( "InVision", [ "ngResource", "ui", "truncate", "firebase" ] );
( function ( ng, app ) {
	app.constant( "MIN_PASSWORD_LENGTH", '5' );
	app.constant( "MAX_PASSWORD_LENGTH", '60' );
	app.constant( "MAX_COMMENT_LIKES_DISPLAYED", 10 );
	app.config(
		function ( $routeProvider ) {
			/** @ngInject */
			var routes = [ {
				resource: "/loading",
				action: "loading"
			}, {
				resource: "/dashboard",
				action: "standard.dashboard.default"
			}, {
				resource: "/activity",
				action: "standard.activity.default"
			}, {
				resource: "/new-features",
				action: "standard.new-features.default"
			}, {
				resource: "/snaps",
				action: "standard.snaps"
			}, {
				resource: "/team",
				action: "standard.team.list"
			}, {
				resource: "/team/:userID/activity",
				action: "standard.team.detail.activity"
			}, {
				resource: "/team/:userID/profile",
				action: "standard.team.detail.profile"
			}, {
				resource: "/team/:userID/account",
				action: "standard.team.detail.account"
			}, {
				resource: "/team/:userID/notifications",
				action: "standard.team.detail.notifications"
			}, {
				resource: "/resources",
				action: "standard.resources"
			}, {
				resource: "/projects/:projectID",
				action: "standard.project.detail"
			}, {
				resource: "/projects/:projectID/screens",
				action: "standard.project.detail.screens.list"
			}, {
				resource: "/projects/:projectID/screens/upload",
				action: "standard.project.detail.screens.list.upload"
			}, {
				resource: "/projects/:projectID/assets",
				action: "standard.project.detail.assets"
			}, {
				resource: "/projects/:projectID/assets/:assetID",
				action: "standard.project.detail.assets"
			}, {
				resource: "/projects/:projectID/comments/showConversation/:conversationID",
				action: "standard.project.detail.comments"
			}, {
				resource: "/projects/:projectID/comments/:readFilter/:statusFilter/:typeFilter",
				action: "standard.project.detail.comments"
			}, {
				resource: "/projects/:projectID/comments",
				action: "standard.project.detail.comments"
			}, {
				resource: "/projects/:projectID/testing/:testId/edit",
				action: "standard.project.detail.testing.edit"
			}, {
				resource: "/projects/:projectID/testing/:testId/view",
				action: "standard.project.detail.testing.view"
			}, {
				resource: "/projects/:projectID/testing",
				action: "standard.project.detail.testing.list"
			}, {
				resource: "/testing/:testId",
				action: "standard.project.detail.testing.view"
			}, {
				resource: "/projects/:projectID/screens/archive",
				action: "standard.project.detail.screens.archive"
			}, {
				resource: "/projects",
				action: "standard.projects"
			}, {
				resource: "/projects/activate/:id",
				action: "standard.projects.activate"
			}, {
				resource: "/dropbox/connected",
				action: "standard.projects.dropboxConnected"
			}, {
				resource: "/projects/:projectID/activity",
				action: "standard.project.detail.activity"
			}, {
				resource: "/snaps",
				action: "standard.snaps"
			}, {
				resource: "/notifications",
				action: "standard.notifications"
			}, {
				resource: "/presentations/:projectID",
				action: "standard.project.detail.presentations"
			}, {
				resource: "/presentations/:projectID/:presentationID",
				action: "presentationconsole.build"
			}, {
				resource: "/console/:projectID/:screenID/preview",
				action: "console.preview"
			}, {
				resource: "/console/:projectID/:screenID/build",
				action: "console.build"
			}, {
				resource: "/console/:projectID/:screenID/comments",
				action: "console.comments"
			}, {
				resource: "/console/:projectID/:screenID/comments/:commentID",
				action: "console.comments"
			}, {
				resource: "/console/:projectID/:screenID/history",
				action: "console.history"
			}, {
				resource: "/console/:projectID/:screenID/comments/:commentID/sketch/",
				action: "console.comments.sketch"
			}, {
				resource: "/console/:projectID/:screenID/comments/:commentID/sketch/:sketchID",
				action: "console.comments.sketch"
			}, {
				resource: "/company",
				action: "standard.company.members"
			}, {
				resource: "/company/members",
				action: "standard.company.members"
			}, {
				resource: "/company/teams",
				action: "standard.company.teams"
			}, {
				resource: "/company/advanced-permissions",
				action: "standard.company.advanced-permissions"
			}, {
				resource: "/company/custom-branding",
				action: "standard.company.custom-branding"
			}, {
				resource: "/company/account-information",
				action: "standard.company.account-information"
			}, {
				resource: "/company/account-information/billing",
				action: "standard.company.billing"
			}, {
				resource: "/company/account-information/plan-and-billing",
				action: "standard.company.plan-billing"
			} ];
			angular.forEach(
				routes,
				function ( route, index, collection ) {
					$routeProvider.when(
						route.resource, {
							resource: route.resource,
							action: route.action
						}
					);
				}
			);
			$routeProvider.otherwise( {
				redirectTo: "/projects"
			} );
		}
	);
	app.config(
		function ( $httpProvider ) {
			/** @ngInject */
			var httpInterceptorFor401Response = function ( $window, $q ) {
				var interceptor = function ( request ) {
					var interceptedResponse = request.then(
						function () {
							return ( request );
						},
						function ( httpResponse ) {
							if ( httpResponse.status === 401 ) {
								$window.setTimeout(
									function () {
										$window.location.href = "./";
									},
									100
								);
								return ( $q.defer().promise );
							}
							return ( request );
						}
					);
					return ( interceptedResponse );
				};
				return ( interceptor );
			};
			var httpInterceptorForHttpActivityTracking = function ( httpActivityService ) {
				var interceptor = function ( request ) {
					request.then(
						function ( httpResponse ) {
							var isPostRequest = ( httpResponse.config.method !== "GET" );
							var isBlacklisted = ( httpResponse.config.data && ( "X-Do-Not-Track-As-Post" in httpResponse.config.data ) );
							var trackAsPost = ( isPostRequest && !isBlacklisted );
							httpActivityService.requestCompleted( trackAsPost );
						},
						function ( httpResponse ) {
							var isPostRequest = ( httpResponse.config.method !== "GET" );
							var isBlacklisted = ( httpResponse.config.data && ( "X-Do-Not-Track-As-Post" in httpResponse.config.data ) );
							var trackAsPost = ( isPostRequest && !isBlacklisted );
							httpActivityService.requestCompleted( trackAsPost );
						}
					);
					return ( request );
				};
				return ( interceptor );
			};
			$httpProvider.responseInterceptors.push( httpInterceptorFor401Response );
			$httpProvider.responseInterceptors.push( httpInterceptorForHttpActivityTracking );
		}
	);
	app.provider(
		"$exceptionHandler", {
			$get: function ( errorLogService ) {
				/** @ngInject */
				return ( errorLogService.exceptionHandler );
			}
		}
	);
	app.run(
		function ( $http, httpActivityService, $window ) {
			/** @ngInject */
			function startInterceptor( data, getHeaders ) {
				var isPostRequest = ( "Content-Type" in getHeaders() );
				var isBlacklisted = ( ng.isString( data ) && ( data.indexOf( "X-Do-Not-Track-As-Post" ) != -1 ) );
				var trackAsPost = ( isPostRequest && !isBlacklisted );
				httpActivityService.requestStarted( trackAsPost );
				return ( data );
			}

			function addTimezoneOffsetHeader( data, getHeaders ) {
				var headers = getHeaders();
				var now = new Date();
				if ( now.getTimezoneOffset ) {
					headers[ "X-Timezone-Offset" ] = -now.getTimezoneOffset();
				}
				return ( data );
			}

			function addLoadedAtHeader( data, getHeaders ) {
				var headers = getHeaders();
				headers[ "X-Page-Loaded-At" ] = addLoadedAtHeader.loadedAt;
				return ( data );
			}
			addLoadedAtHeader.loadedAt = ( new Date() ).getTime();

			function addReferrerHeader( data, getHeaders ) {
				var headers = getHeaders();
				headers[ "X-Referrer-Hash" ] = $window.location.hash;
				return ( data );
			}
			$http.defaults.transformRequest.push( startInterceptor );
			$http.defaults.transformRequest.push( addTimezoneOffsetHeader );
			$http.defaults.transformRequest.push( addLoadedAtHeader );
			$http.defaults.transformRequest.push( addReferrerHeader );
		}
	);
} )( angular, InVision );;;
/*! debouncer.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "Debouncer", DebouncerFactory );
	/** @ngInject */
	function DebouncerFactory( _ ) {
		var Debouncer = function ( duration ) {
			function canProceed() {
				var now = new Date();
				if ( !lastInvokedAt ) {
					lastInvokedAt = now;
					return ( true );
				}
				if ( isTooSoon( lastInvokedAt, now, duration ) ) {
					lastInvokedAt = now;
					return ( false );
				} else {
					lastInvokedAt = now;
					return ( true );
				}
			}

			function isTooSoon( previousTime, currentTime, duration ) {
				var delta = ( currentTime.getTime() - previousTime.getTime() );
				return ( delta < duration );
			}
			if ( ng.isUndefined( duration ) ) {
				throw ( new Error( "InvalidArgument" ) );
			}
			var lastInvokedAt = null;
			return ( {
				canProceed: canProceed
			} );
		};
		Debouncer.ONE_SECOND = ( 1 * 1000 );
		Debouncer.TWO_SECONDS = ( 2 * 1000 );
		Debouncer.THREE_SECONDS = ( 3 * 1000 );
		Debouncer.FOUR_SECONDS = ( 4 * 1000 );
		Debouncer.FIVE_SECONDS = ( 5 * 1000 );
		return ( Debouncer );
	}
} )( angular, InVision );;;
/*! partial-cache.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "PartialCache", PartialCacheFactory );
	/** @ngInject */
	function PartialCacheFactory( $window, beforeUnloadService ) {
		function PartialCache( name, maxAge ) {
			this._name = ( "partialCache:" + name );
			this._maxAge = ( maxAge || ( 2 * PartialCache.WEEK ) );
			this._cache = {};
			try {
				this._supportsLocalStorage = ( ( "localStorage" in $window ) && ( $window.localStorage !== null ) );
			} catch ( error ) {
				this._supportsLocalStorage = false;
			}
			if ( this._supportsLocalStorage ) {
				var initialData = $window.localStorage.getItem( this._name );
				if ( initialData ) {
					this._cache = ng.fromJson( initialData );
					$window.localStorage.removeItem( this._name );
					this._clearExpiredEntries();
				}
			}
			beforeUnloadService.push( this, this._save );
			return ( this );
		}
		PartialCache.MINUTE = ( 60 * 1000 );
		PartialCache.HOUR = ( 60 * PartialCache.MINUTE );
		PartialCache.DAY = ( 24 * PartialCache.HOUR );
		PartialCache.WEEK = ( 7 * PartialCache.DAY );
		PartialCache.MONTH = ( 30 * PartialCache.DAY );
		PartialCache.prototype = {
			deleteResponse: function ( cacheKey ) {
				var localCacheKey = this._getLocalCacheKey( cacheKey );
				if ( this._cache[ localCacheKey ] ) {
					delete( this._cache[ localCacheKey ] );
				}
			},
			filterResponses: function ( comparator, context ) {
				context = ( context || {} );
				var isDirty = false;
				for ( var cacheKey in this._cache ) {
					var entry = this._cache[ cacheKey ];
					if (
						this._cache.hasOwnProperty( cacheKey ) &&
						( comparator.call( context, entry.response ) !== true ) // Check for non-truth.
					) {
						delete( this._cache[ cacheKey ] );
						isDirty = true;
					}
				}
			},
			getResponse: function ( cacheKey ) {
				var localCacheKey = this._getLocalCacheKey( cacheKey );
				var entry = this._cache[ localCacheKey ];
				if ( !entry ) {
					return ( null );
				}
				if ( this._isExpired( entry ) ) {
					delete( this._cache[ localCacheKey ] );
					return ( null );
				}
				return ( entry.response );
			},
			rejectResponses: function ( comparator, context ) {
				context = ( context || {} );
				var isDirty = false;
				for ( var cacheKey in this._cache ) {
					var entry = this._cache[ cacheKey ];
					if (
						this._cache.hasOwnProperty( cacheKey ) &&
						( comparator.call( context, entry.response ) === true ) // Check for truth.
					) {
						delete( this._cache[ cacheKey ] );
						isDirty = true;
					}
				}
			},
			setResponse: function ( cacheKey, response ) {
				var localCacheKey = this._getLocalCacheKey( cacheKey );
				this._cache[ localCacheKey ] = {
					response: ng.copy( response ),
					createdAt: ( new Date() ).getTime()
				};
			},
			updateAllResponses: function ( operator, context ) {
				context = ( context || {} );
				var isDirty = false;
				for ( var cacheKey in this._cache ) {
					if ( this._cache.hasOwnProperty( cacheKey ) ) {
						var entry = this._cache[ cacheKey ];
						if ( this._isExpired( entry ) ) {
							delete( this._cache[ cacheKey ] );
						} else {
							operator.call( context, entry.response );
							isDirty = true;
						}
					}
				}
			},
			updateResponse: function ( cacheKey, operator, context ) {
				var localCacheKey = this._getLocalCacheKey( cacheKey );
				var entry = this._cache[ localCacheKey ];
				context = ( context || {} );
				if ( !entry ) {
					return;
				}
				if ( this._isExpired( entry ) ) {
					delete( this._cache[ localCacheKey ] );
					return;
				}
				operator.call( context, entry.response );
			},
			updateResponses: function ( comparator, operator, context ) {
				context = ( context || {} );
				var isDirty = false;
				for ( var cacheKey in this._cache ) {
					if ( this._cache.hasOwnProperty( cacheKey ) ) {
						var entry = this._cache[ cacheKey ];
						if ( this._isExpired( entry ) ) {
							delete( this._cache[ cacheKey ] );
						} else if ( comparator.call( context, entry.response ) ) {
							operator.call( context, entry.response );
							isDirty = true;
						}
					}
				}
			},
			_clearExpiredEntries: function () {
				for ( var cacheKey in this._cache ) {
					if (
						this._cache.hasOwnProperty( cacheKey ) &&
						this._isExpired( this._cache[ cacheKey ] )
					) {
						delete( this._cache[ cacheKey ] );
					}
				}
			},
			_getLocalCacheKey: function ( cacheKey ) {
				return ( "cache-key:" + cacheKey );
			},
			_isExpired: function ( entry ) {
				var now = ( new Date() ).getTime();
				return ( ( entry.createdAt + this._maxAge ) < now );
			},
			_save: function () {
				if ( !this._supportsLocalStorage ) {
					return;
				}
				var serializedCache = ng.toJson( this._cache );
				try {
					$window.localStorage.setItem( this._name, serializedCache );
				} catch ( error ) {
					$window.localStorage.removeItem( this._name );
				}
			}
		};
		return ( PartialCache );
	}
} )( angular, InVision );;;
/*! pub-sub.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "PubSub", PubSubFactory );
	/** @ngInject */
	function PubSubFactory( _ ) {
		var PubSub = function () {
			function off( eventType, callback ) {
				var eventConfig = parseEventConfig( eventType );
				if ( !subscriptions.hasOwnProperty( eventConfig.type ) ) {
					return;
				}
				subscriptions[ eventConfig.type ] = _.reject(
					subscriptions[ eventConfig.type ],
					function ( subscription ) {
						if ( callback ) {
							return (
								( subscription.namespace === eventConfig.namespace ) &&
								( subscription.callback === callback )
							);
						} else {
							return ( subscription.namespace === eventConfig.namespace );
						}
					}
				);
			}

			function on( eventType, callback, context ) {
				if ( _.isArray( eventType ) ) {
					_.forEach(
						eventType,
						function ( eventType ) {
							on( eventType, callback, context );
						}
					);
					return;
				}
				var eventConfig = parseEventConfig( eventType );
				if ( !subscriptions.hasOwnProperty( eventConfig.type ) ) {
					subscriptions[ eventConfig.type ] = [];
				}
				subscriptions[ eventConfig.type ].push( {
					namespace: eventConfig.namespace,
					callback: callback,
					context: ( context || {} )
				} );
			}

			function parseEventConfig( eventType ) {
				var parts = eventType.split( "." );
				return ( {
					type: parts.shift(),
					namespace: ( parts.join( "," ) || null )
				} );
			}

			function trigger( eventType, eventData ) {
				var eventConfig = parseEventConfig( eventType );
				if ( eventConfig.type === "*" ) {
					throw ( new Error( "IllegalEventType" ) );
				}
				if ( !subscriptions.hasOwnProperty( eventConfig.type ) ) {
					return;
				}
				var eventArguments = arguments;
				eventArguments[ 0 ] = {
					type: eventConfig.type,
					namespace: eventConfig.namespace
				};
				_.forEach(
					subscriptions[ eventConfig.type ],
					function ( subscription ) {
						if (
							( eventConfig.namespace === null ) ||
							( eventConfig.namespace === subscription.namespace )
						) {
							subscription.callback.apply( subscription.context, eventArguments );
						}
					}
				);
				_.forEach(
					subscriptions[ "*" ],
					function ( subscription ) {
						subscription.callback.apply( subscription.context, eventArguments );
					}
				);
			}
			var subscriptions = {};
			subscriptions[ "*" ] = [];
			return ( {
				off: off,
				on: on,
				trigger: trigger
			} );
		};
		return ( PubSub );
	}
} )( angular, InVision );;;
/*! app-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "AppController", Controller );
	/** @ngInject */
	function Controller( $scope, $route, $routeParams, $location, config, requestContext, sessionService, userService, modelEvents, _, $window, $document, $timeout, Deferred, accountService ) {
		function assignUserToExperimentGroup() {
			var experiments = {
				planListing: {
					population: [ 1, 2, 18, 19, 21 ],
					variants: {
						"Multiple plans": 0,
						"Single plan": 100
					},
					fallback: "Single Plan",
					kmPropertyName: "Plan listing presentation"
				},
				showTeamPlan: {
					population: [ 1 ],
					variants: {
						"Team Plan is visible": 100,
						"Team Plan is hidden": 0
					},
					fallback: "Team Plan is hidden",
					kmPropertyName: "Visibility of Team Plan"
				}
			};
			setupExperiment(
				sessionService.subscription.subscriptionPlanID,
				"planListingPresentationGroup",
				experiments.planListing
			);
			setupExperiment(
				sessionService.subscription.subscriptionPlanID,
				"planListingTeamPlanVisibility",
				experiments.showTeamPlan
			);
		}

		function setupExperiment( currentSubscriptionPlanID, sessionServiceKey, experiment ) {
			if ( _.contains( experiment.population, currentSubscriptionPlanID ) ) {
				var kmLoadFallbackTimeout = $timeout( function () {
					sessionService.set( sessionServiceKey, experiment.fallback );
				}, 5000 );
				$window._kmq.push( function () {
					var testGroup = $window.KM.ab( experiment.kmPropertyName, experiment.variants );
					sessionService.set( sessionServiceKey, testGroup );
					$timeout.cancel( kmLoadFallbackTimeout );
				} );
			}
		}

		function setupOLarkEvents( olark ) {
			olark( 'api.chat.onOperatorsAway', function () {
				olark( 'api.box.hide' );
				sessionService.set( 'olarkOperatorAvailable', false );
			} );
			olark( 'api.chat.onOperatorsAvailable', function () {
				sessionService.set( 'olarkOperatorAvailable', true );
			} );
		}

		function authenticateSession() {
			sessionService.authenticate().then(
				function () {
					assignUserToExperimentGroup();
					if ( !_.isUndefined( config.newSignupForPlan ) ) {
						sessionService.set( "showUpgradeModalForPlan", config.newSignupForPlan );
					}
					$scope.user = sessionService.user;
					$scope.isAdmin = ( $scope.isEnterprise && $scope.user.companyMembership.roleID === userService.ROLES.ADMIN );
					$scope.isManager = ( $scope.isEnterprise && $scope.user.companyMembership.roleID === userService.ROLES.MANAGER );
					$scope.isContributor = ( $scope.isEnterprise && $scope.user.companyMembership.roleID === userService.ROLES.CONTRIBUTOR );
					$scope.isReviewer = ( $scope.isEnterprise && $scope.user.companyMembership.roleID === userService.ROLES.REVIEWER );
					if ( ( $scope.isAdmin || $scope.isManager ) && initiallyRequestedRoute === " /" ) {
						$location.path( "/dashboard" );
						return;
					}
					$location.path( initiallyRequestedRoute );
				},
				function () {}
			);
		}

		function getBrowserCompatibliity() {
			var userAgent = $window.navigator.userAgent.toLowerCase();
			var isIE6 = ( $window.ieVersion === 6 );
			var isIE7 = ( $window.ieVersion === 7 );
			var isIE8 = ( $window.ieVersion === 8 );
			var isCompatible = !( isIE6 || isIE7 || isIE8 );
			var reason = null;
			if ( !isCompatible ) {
				reason = "version";
				if ( userAgent.search( "trident/5\.0" ) !== -1 ) {
					reason = "mode";
				}
			}
			return ( {
				isCompatible: isCompatible,
				isNotCompatible: !isCompatible,
				reason: reason
			} );
		}

		function getXsrfTokenCookie() {
			var cookieString = ( $document.prop( "cookie" ) || "" );
			var matches = cookieString.match( /\bXSRF-TOKEN=([^;]+)/i );
			return ( ( matches && matches[ 1 ] ) || "" );
		}

		function isRouteRedirect( route ) {
			return ( !route.current.action );
		}
		$scope.clearBodyStyle = function () {
			$scope.bodyStyle = {};
		};
		$scope.clearSecondaryBodyClass = function () {
			$scope.secondaryBodyClass = "";
		};
		$scope.closeBrowserCompatibilityAlert = function () {
			$scope.browserCompatibility.isCompatible = true;
			$scope.browserCompatibility.isNotCompatible = false;
		};
		$scope.openModalWindow = function () {
			var modalData = _.toArray( arguments );
			var modalType = modalData.shift();
			$scope.$broadcast( "openModalWindow", modalType, modalData );
		};
		$scope.setBodyClass = function ( className ) {
			$scope.bodyClass = className;
		};
		$scope.updateBodyStyle = function ( style ) {
			_.merge( $scope.bodyStyle, style );
		};
		$scope.updateProjectConsoleStyle = function ( style ) {
			_.merge( $scope.projectConsoleStyle, style );
		};
		$scope.setWindowTitle = function ( title ) {
			$scope.windowTitle = $scope.windowTitlePrefix + title + " - InVision";
			$scope.lastTitle = title;
		};
		$scope.updateTitleWithNotifications = function ( count ) {
			if ( count > 0 ) {
				$scope.windowTitlePrefix = "(" + count + ") ";
			} else {
				$scope.windowTitlePrefix = "";
			}
			$scope.setWindowTitle( $scope.lastTitle );
		};
		$scope.setSecondaryBodyClass = function ( className ) {
			$scope.secondaryBodyClass = className;
		};
		$scope.submitFeebackForm = function () {
			if ( !$scope.feedbackText.length ) {
				return;
			}
			$scope.feedbackSent = true;
			Deferred.handlePromise(
				accountService.submitSupportTicket( "feature_from_footer", $scope.feedbackText ),
				function handleSupportTicketSubmissionSuccess( response ) {},
				function handleSupportTicketSubmissionFailure( response ) {}
			);
			$timeout( function resetFeedback() {
				var $footer = $( "#feedback_footer" ),
					$footerForm = $footer.find( "form" ),
					$success = $footer.find( ".feedback-success" );
				$success.fadeOut( 250, function showFeedbackForm() {
					$scope.feedbackSent = false;
					$scope.feedbackDisabled = true;
					$footer.find( "input[type=text]" ).val( "" );
					$( "#feedbackSubmit" ).attr( "disabled", "disabled" );
					$footerForm.fadeIn( 250 );
				} );
			}, 4000 );
		};
		$scope.$watch( "feedbackText", function watchFeedbackText( val ) {
			var $submit = $( "#feedbackSubmit" );
			if ( val.length ) {
				$submit.removeAttr( "disabled", "disabled" );
				$scope.feedbackDisabled = false;
			}
			if ( !val.length ) {
				$submit.attr( "disabled", "disabled" );
				$scope.feedbackDisabled = true;
			}
		} );
		var renderContext = requestContext.getRenderContext();
		var initiallyRequestedRoute = "";
		if ( $location.path() === "/loading" ) {
			initiallyRequestedRoute = "/";
		} else {
			initiallyRequestedRoute = ( $location.path() || "/" );
		}
		$scope.windowTitle = "InVision";
		$scope.windowTitlePrefix = "";
		$scope.lastTitle = "";
		$scope.bodyClass = "";
		$scope.secondaryBodyClass = "";
		$scope.bodyStyle = {};
		$scope.projectConsoleStyle = {};
		$scope.subview = renderContext.getNextSection();
		$scope.featureAnnouncementsLastUpdatedAt = config.lastFeatureAnnouncement;
		$scope.wwwUrl = config.wwwUrl;
		$scope.newFeaturesUrl = config.wwwUrl + "new-features/";
		$scope.isEnterprise = config.companySettings.isEnterprise;
		$scope.enterpriseConfig = config.companySettings;
		$scope.feedbackReplyToEmail = sessionService.user.email;
		$scope.feedbackText = "";
		$scope.feedbackSent = false;
		$scope.feedbackDisabled = true;
		$scope.xsrfToken = getXsrfTokenCookie();
		$scope.browserCompatibility = getBrowserCompatibliity();
		$scope.$on( "$destroy", function ( event ) {
			modelEvents.off( "newFeatureAnnounced.app" );
			modelEvents.off( "breakingChangesAnnounced.app" );
			modelEvents.off( "companyAccountUpdated.app" );
		} );
		$scope.$on( "$locationChangeStart", function ( event ) {
			if ( $scope.uploading ) {
				$scope.openModalWindow( "uploadInProgress", $location.path() );
				event.preventDefault();
			}
		} );
		$scope.$on( "autosubmit", function ( event, form, target ) {
			$scope.$broadcast( "autosubmit-" + form, target );
		} );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.subview = renderContext.getNextSection();
			}
		);
		$scope.$on(
			"$routeChangeSuccess",
			function ( event, currentRoute, previousRoute ) {
				if ( isRouteRedirect( $route ) ) {
					return;
				}
				if ( !sessionService.isAuthenticated() ) {
					if ( $route.current.action !== "loading" ) {
						return (
							$location.path( "/loading" )
						);
					}
				} else if ( $route.current.action === "loading" ) {
					return (
						$location.path( "/" )
					);
				}
				requestContext.setContext( $route.current.action, $routeParams );
				$scope.$broadcast( "requestContextChanged", requestContext );
			}
		);
		$scope.$on( "screenUploadStart", function ( event ) {
			$scope.uploading = true;
		} );
		$scope.$on( "screenUploadStop", function ( event ) {
			$scope.uploading = false;
		} );
		modelEvents.on(
			"newFeatureAnnounced.app",
			function ( event, mostRecentHeadline, utcArray, announcementID ) {
				$scope.featureAnnouncementsLastUpdatedAt = moment.utc( utcArray ).valueOf();
				$scope.$broadcast( "newFeatureAnnounced", mostRecentHeadline, announcementID );
			}
		);
		modelEvents.on(
			"breakingChangesAnnounced.app",
			function ( event, severity, message ) {
				$scope.$broadcast( "breakingChangesAnnounced", severity, message );
			}
		);
		modelEvents.on(
			"companyAccountUpdated.app",
			function ( event, companyInfo ) {
				$scope.enterpriseConfig.companyLogo = companyInfo.companyLogo;
				$scope.enterpriseConfig.companyName = companyInfo.name;
				$scope.enterpriseConfig.permissions.canDesignersViewAllProjects = companyInfo.canDesignersViewAllProjects;
				$scope.enterpriseConfig.permissions.canDesignersViewDashboards = companyInfo.canDesignersViewDashboards;
			}
		);
		setupOLarkEvents( $window.olark );
		authenticateSession();
	}
} )( angular, InVision );;;
/*! activity-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "activity.ActivityController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $location, accountService, requestContext, sessionService, _ ) {
		var renderContext = requestContext.getRenderContext( "standard.dashboard" );
		$scope.setWindowTitle( "Activity" );
		accountService.markActivitySeen();
		sessionService.user.activityLastViewedAt = moment.utc().valueOf();
		$window._kmq.push( [ 'record', 'All projects activity page viewed' ] );
	}
} )( angular, InVision );;;
/*! list-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "activity.ListController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, $timeout, Deferred, projectService, dashboardActivityPartial, dateHelper, hashKeyCopier, userService, _ ) {
		function addActivityToActivityPeriods( activity ) {
			for ( var i = 0; i < $scope.activityPeriods.length; i++ ) {
				var existingActivity = $scope.activityPeriods[ i ];
				if ( existingActivity.offset === activity.offset ) {
					_.extendExistingProperties(
						existingActivity,
						hashKeyCopier.copyHashKeys( existingActivity, activity )
					);
					return ( activity );
				}
			}
			$scope.activityPeriods.push( activity );
			return ( activity );
		}

		function applyProjectEventCount( activity ) {
			for ( var i = 0, length = activity.projects.length; i < length; i++ ) {
				var project = activity.projects[ i ];
				project.eventCount = ( project.comments.count + project.screensAdded.length + project.screensUpdated.length + project.views.length + project.members.length );
			}
			return ( activity );
		}

		function applyRemoteData( activity ) {
			if ( activity.alreadyAddedToActivityPeriods ) {
				return;
			}
			activity.alreadyAddedToActivityPeriods = true;
			if ( activity.actions.length > 0 ) {
				$scope.hasAnyActivity = true;
			}
			activity = augmentActivity( activity );
			addActivityToActivityPeriods( activity );
			updateHasMoreActivityToLoad();
		}

		function augmentActivity( activity ) {
			var days = groupActionsByDay( activity.actions );
			days = groupActionsByProjectAndTime( days );
			days = combineAdjacentProjects( days );
			activity.days = days;
			delete activity[ "actions" ];
			return ( activity );
		}

		function augmentCollaborators( members ) {
			for ( var i = 0, length = members.length; i < length; i++ ) {
				var user = members[ i ];
				user.shortName = userService.getShortName( user.name );
				user.initials = userService.getInitials( user.name );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			}
			return ( members );
		}

		function augmentComments( comments ) {
			for ( var s = 0, sLength = comments.screens.length; s < sLength; s++ ) {
				var screen = comments.screens[ s ];
				for ( var u = 0, uLength = screen.users.length; u < uLength; u++ ) {
					var user = screen.users[ u ];
					user.shortName = userService.getShortName( user.name );
					user.initials = userService.getInitials( user.name );
					user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				}
			}
			return ( comments );
		}

		function augmentProject( project ) {
			project.isRendered = !project.isMinimizedInTimeline;
			augmentComments( project.comments );
			augmentScreens( project.screensAdded );
			augmentScreens( project.screensUpdated );
			augmentViews( project.views );
			augmentCollaborators( project.members );
			return ( project );
		}

		function augmentProjects( projects ) {
			for ( var i = 0, length = projects.length; i < length; i++ ) {
				augmentProject( projects[ i ] );
			}
			return ( projects );
		}

		function augmentScreens( screens ) {
			for ( var i = 0, length = screens.length; i < length; i++ ) {
				var screen = screens[ i ];
				screen.shortUserName = userService.getShortName( screen.userName );
			}
			return ( screens );
		}

		function augmentViews( views ) {
			for ( var i = 0, length = views.length; i < length; i++ ) {
				var user = views[ i ];
				user.shortName = userService.getShortName( user.name );
				user.initials = userService.getInitials( user.name );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				if ( user.isAnonymous ) {
					user.shortName = "Anonymous";
				}
			}
			return ( views );
		}

		function combineAdjacentProjects( days ) {
			days = _.each( days, combineAdjacentProjectsForDay );
			return days;
		}

		function combineAdjacentProjectsForDay( day ) {
			var lastProject = null;
			day.projects = _.filter( day.projects, function ( project ) {
				if ( !_.isNull( lastProject ) &&
					lastProject.label.projectId == project.label.projectId ) {
					lastProject.actions = lastProject.actions.concat( project.actions );
					return false;
				}
				lastProject = project;
				return true;
			} );
			return day.projects;
		}

		function getLastKnownOffset() {
			return (
				_.last( $scope.activityPeriods ).offset
			);
		}

		function getOffsetsForCurrentWeek() {
			var offsets = [];
			var currentDay = dateHelper.today();
			if ( currentDay.getDay() === 0 ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			for ( var i = currentDay.getDay(); i >= 1; i-- ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			return ( offsets );
		}

		function groupActionsBy( arrayToGroup, options ) {
			var grouped = {};
			var defaultOptions = {
				groupByKeys: [ "id" ],
				timeBasedKeys: [],
				timeBucketInMinutes: 5
			}
			options = _.defaults( options, defaultOptions );
			grouped = _.groupBy( arrayToGroup, function ( item ) {
				var i = 0,
					key = "",
					compositeKey = "",
					isKeyTimeBased = false,
					keyDelimiter = "_",
					timeValueRounded = null;
				for ( i = 0; i < options.groupByKeys.length; i++ ) {
					key = options.groupByKeys[ i ];
					isKeyTimeBased = _.contains( options.timeBasedKeys, key );
					if ( isKeyTimeBased ) {
						if ( options.timeBucketInMinutes == 1440 ) {
							timeValueRounded = moment( item[ key ] ).format( "DDDYYYY" );
						} else {
							timeValueRounded = Math.round( moment( item[ key ] ).unix() / ( options.timeBucketInMinutes * 60 ) ) * ( options.timeBucketInMinutes * 60 );
						}
						compositeKey += ( compositeKey.length ? keyDelimiter : '' ) + timeValueRounded.toString();
					} else {
						compositeKey += ( compositeKey.length ? keyDelimiter : '' ) + item[ key ].toString();
					}
				}
				return compositeKey;
			} );
			return grouped;
		}

		function groupActionsByDay( actions ) {
			var groupingOptions = {
				groupByKeys: [ "actionOccuredAt" ],
				timeBasedKeys: [ "actionOccuredAt" ],
				timeBucketInMinutes: 1440
			};
			var groupedActions = groupActionsBy( actions, groupingOptions );
			groupedActions = _.map( groupedActions, function ( actionsOnThisDay ) {
				var firstItemDate = moment( _.first( actionsOnThisDay ).actionOccuredAt );
				var dateLabel = "";
				var todayStart = moment().startOf( "day" );
				var yesterdayStart = moment().subtract( "days", 1 ).startOf( "day" );
				if ( firstItemDate.isAfter( todayStart ) ) {
					dateLabel = "Today";
				} else if ( firstItemDate.isAfter( yesterdayStart ) ) {
					dateLabel = "Yesterday";
				} else {
					dateLabel = firstItemDate.format( "MMM D" );
				}
				return {
					label: dateLabel,
					sortOn: firstItemDate,
					items: actionsOnThisDay
				};
			} );
			groupedActions = _.sortOnProperty( groupedActions, "sortOn", "DESC" );
			return groupedActions;
		}

		function groupActionsByProjectAndTime( actionsGroupedByDay ) {
			var groupingOptions = {
				groupByKeys: [ "projectID", "actionOccuredAt" ],
				timeBasedKeys: [ "actionOccuredAt" ],
				timeBucketInMinutes: 60
			};
			_.forEach( actionsGroupedByDay, function ( day, index, fullArray ) {
				if ( day.label !== "Today" ) {
					groupingOptions.timeBucketInMinutes = 1440;
				}
				var groupedActions = groupActionsBy( day.items, groupingOptions );
				groupedActions = _.map( groupedActions, function ( actions, key ) {
					var firstItem = _.first( actions );
					var firstItemDate = firstItem.actionOccuredAt;
					var groupedActions = groupActionsBy(
						actions, {
							groupByKeys: [ "action" ],
							timeBasedKeys: [ "actionOccuredAt" ],
							timeBucketInMinutes: groupingOptions.timeBucketInMinutes
						}
					);
					return {
						label: {
							projectName: firstItem.projectName,
							projectId: firstItem.projectID,
							homeScreenID: firstItem.homeScreenID,
							time: moment( firstItem.actionOccuredAt ).format( 'h:mma' )
						},
						id: firstItem.projectID,
						isVisible: true,
						sortOn: firstItem.actionOccuredAt,
						actions: mapProjectActions( groupedActions )
					}
				} );
				groupedActions = _.sortOnProperty( groupedActions, "sortOn", "DESC" );
				day.projects = groupedActions;
				delete day[ "items" ];
				return true;
			} );
			return actionsGroupedByDay;
		}

		function toggleVisibilityForProject( projectToHide ) {
			_.each( $scope.activityPeriods, function ( activity ) {
				_.each( activity.days, function ( day ) {
					_.each( day.projects, function ( project ) {
						if ( project.id === projectToHide.id ) {
							project.isVisible = !project.isVisible;
						}
					} );
				} );
			} );
		}

		function removeInvisibleProjectsFromActivity() {
			_.each( $scope.activityPeriods, function ( activity ) {
				activity.days = _.reject( activity.days, function ( day ) {
					activity.days.projects = _.reject( day.projects,
						function ( project ) {
							return project.isVisible;
						} );
					return activity.days.projects.length > 0;
				} );
			} );
		}

		function loadActivityStream( ignoreCache ) {
			$scope.isLoadingActivity = true;
			$scope.isRefreshingData = ignoreCache;
			var offsets = getOffsetsForCurrentWeek();
			var promises = [];
			for ( var i = 0; i < offsets.length; i++ ) {
				promises.push(
					dashboardActivityPartial.get( offsets[ i ], 1, ignoreCache )
				);
			}
			Deferred.handleAllPromises(
				promises,
				function ( promise1, promise2, promiseN ) {
					var actionCount = 0;
					for ( var i = 0; i < arguments.length; i++ ) {
						applyRemoteData( arguments[ i ].activity );
						actionCount += arguments[ i ].activity.days.length;
					}
					if ( !actionCount ) {
						$scope.loadMoreActivity();
					}
					$scope.isLoadingActivity = false;
					$scope.isRefreshingData = false;
				},
				function () {
					$scope.isLoadingActivity = false;
					$scope.openModalWindow( "error", "For some reason, we couldn't load your activity stream. Try refreshing your browser." );
				}
			);
		}

		function mapProjectActions( projectActions ) {
			return _.map( projectActions, function ( actions ) {
				var action = {},
					usersInvolved = [],
					screensInvolved = [],
					userNameOrCount = "";
				action.time = moment( _.first( actions ).actionOccuredAt ).format( "h:mma" );
				action.type = _.first( actions ).action;
				action.users = _.map( actions, function ( actionGrouping ) {
					return {
						userID: actionGrouping.userID,
						name: actionGrouping.userName,
						shortName: userService.getShortName( actionGrouping.userName ),
						avatarID: actionGrouping.avatarID,
						hasSystemAvatar: userService.isSystemAvatar( actionGrouping.avatarID ),
						isAnonymous: actionGrouping.isAnonymous,
						onlineStatus: userService.getOnlineStatus( actionGrouping.lastRequestAt ),
						initials: userService.getInitials( actionGrouping.userName ),
						relationship: actionGrouping.relationship
					}
				} );
				action.users = _.uniq( action.users, function ( user ) {
					return user.userID;
				} );
				if ( action.users.length == 1 ) {
					action.userNameOrCount = _.first( action.users ).name;
				} else {
					action.userNameOrCount = action.users.length + ' people';
				}
				action.screens = _.map( actions, function ( actionGrouping, key, allActivity ) {
					var commentsOnScreen = _.filter( allActivity, function ( activity ) {
						if ( activity.screenID != actionGrouping.screenID ) {
							return false;
						}
						return ( activity.action == "commentCreated" || activity.action == "devnoteCreated" );
					} );
					var unreadComments = _.filterWithProperty( commentsOnScreen, "isUnread", true );
					var tmpScreen = {
						id: actionGrouping.screenID,
						name: actionGrouping.screenName,
						imageVersion: actionGrouping.imageVersion,
						backgroundColor: actionGrouping.backgroundColor,
						consoleUrl: actionGrouping.screenID,
						commentCount: unreadComments.length,
						isUnread: actionGrouping.isUnread
					};
					if ( commentsOnScreen.length > 0 ) {
						var firstComment = _.first( commentsOnScreen );
						if ( unreadComments.length ) {
							firstComment = _.first( unreadComments );
						}
						tmpScreen.consoleUrl += "/comments";
						if ( !_.isUndefined( firstComment.conversationID ) ) {
							tmpScreen.consoleUrl += "/" + firstComment.conversationID;
						}
					} else {
						tmpScreen.consoleUrl += "/preview";
					}
					return tmpScreen;
				} );
				action.screens = _.uniq( action.screens, function ( screen ) {
					return screen.id;
				} );
				action.commentCount = _.sumProperty( action.screens, "commentCount" );
				return action;
			} );
		}

		function sortActivityProjects( projects ) {
			projects.sort(
				function ( a, b ) {
					return ( a.updatedAt > b.updatedAt ? -1 : 1 );
				}
			);
			return ( projects );
		}

		function updateHasMoreActivityToLoad() {
			var activity = _.last( $scope.activityPeriods );
			$scope.hasMoreActivityToLoad = ( activity.offset > activity.minimumOffset );
		}
		$scope.loadMoreActivity = function () {
			if ( $scope.isLoadingPastActivity || !$scope.hasMoreActivityToLoad ) {
				return;
			}
			$scope.isLoadingPastActivity = true;
			var lastKnownOffset = getLastKnownOffset();
			var pastOffset = dateHelper.addDays( lastKnownOffset, -7 ).getTime();
			Deferred.handlePromise(
				dashboardActivityPartial.get( pastOffset, 7 ),
				function ( response ) {
					if ( ( !response.activity.alreadyAddedToActivityPeriods ) && response.activity.actions.length === 0 ) {
						$scope.loadMoreActivity();
					}
					applyRemoteData( response.activity );
					$scope.isLoadingPastActivity = false;
				},
				function () {
					$scope.isLoadingPastActivity = false;
					$scope.openModalWindow( "error", "For some reason, we couldn't load your past activity. Try refreshing your browser." );
				}
			);
		};
		$scope.toggleProject = function ( project ) {
			project.isRendered = true;
			project.isMinimizedInTimeline = !project.isMinimizedInTimeline;
			Deferred.handlePromise(
				projectService.setIsMinimizedInTimeline( project.id, project.isMinimizedInTimeline ),
				function () {},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't save your activity stream setting. Try refreshing your browser." );
				}
			);
		};
		$scope.hideProject = function ( project ) {
			$scope.recentlyHiddenProject.showMsg = true;
			$scope.recentlyHiddenProject.name = project.label.projectName;
			$scope.recentlyHiddenProject.id = project.id;
			$scope.isRefreshingData = true;
			toggleVisibilityForProject( project );
			removeInvisibleProjectsFromActivity();
			Deferred.handlePromise(
				projectService.setIsHiddenInTimeline( project.id, true ),
				function () {
					loadActivityStream( true );
				}
			);
			$timeout.cancel( unhideTimer );
			unhideTimer = $timeout( function () {
				$scope.recentlyHiddenProject.showMsg = false;
			}, 8000 );
		};
		$scope.unhideProject = function ( project ) {
			$scope.recentlyHiddenProject.showMsg = false;
			$scope.isRefreshingData = true;
			$timeout.cancel( unhideTimer );
			Deferred.handlePromise(
				projectService.setIsHiddenInTimeline( project.id, false ),
				function () {
					loadActivityStream( true );
				}
			);
		};
		$scope.viewUser = function ( user, project ) {
			if ( $scope.isEnterprise && user.relationship !== "affiliate" ) {
				$scope.openModalWindow( "enterpriseMember", user.userID );
			} else if ( user.relationship === "teamMember" ) {
				$location.path( "/team/" + user.userID + "/activity" );
			} else if ( user.relationship === "affiliate" ) {
				$scope.openModalWindow( "affiliateActivity", user.userID, project.id );
			} else {}
		};
		var unhideTimer = null;
		$scope.isLoadingActivity = false;
		$scope.isLoadingPastActivity = false;
		$scope.isRefreshingData = false;
		$scope.hasAnyActivity = false;
		$scope.activityPeriods = [];
		$scope.hasMoreActivityToLoad = false;
		$scope.recentlyHiddenProject = {
			showMsg: false,
			name: "",
			id: null
		};
		$scope.$on( "reloadActivity", function () {
			loadActivityStream();
		} );
		loadActivityStream();
	}
} )( angular, InVision );;;
/*! base-controller.js */
;;
( function ( ng, app, _ ) {
	"use strict";
	app.value( "BaseController", Controller );
	/** @ngInject */
	function Controller( $scope ) {
		assignPrototypeMethods( Controller, this );
		this.scope = $scope;
		this._isActiveController = true;
		this.scope.$on(
			"requestContextChanged",
			this.bindMethod( "handleRequestContextChanged" )
		);
		this.scope.$on(
			"$destroy",
			this.bindMethod( "handleDestroy" )
		);
		return ( Controller );
	}
	Controller.prototype = {
		bindMethod: function ( method ) {
			if ( ng.isString( method ) ) {
				method = this[ method ];
			}
			return (
				ng.bind( this, method )
			);
		},
		handleAllPromises: function ( promises, successCallback, errorCallback, runOnce ) {
			var _this = this;
			var results = [];
			var hasError = false;
			var hasRun = false;
			successCallback = ( successCallback || ng.noop );
			errorCallback = ( errorCallback || ng.noop );
			var handleSuccess = function ( index, response ) {
				results[ index ] = response;
				if ( hasError || _.contains( results, null ) ) {
					return;
				}
				if ( runOnce && hasRun ) {
					return;
				}
				hasRun = true;
				successCallback.apply( _this, results );
			};
			var handleError = function ( index, response ) {
				if ( hasError ) {
					return;
				}
				hasError = true;
				errorCallback.call( _this, response );
			};
			for ( var i = 0, length = promises.length; i < length; i++ ) {
				results.push( null );
			}
			_.forEach(
				promises,
				function ( promise, index ) {
					_this.handlePromise(
						promise,
						function ( response ) {
							handleSuccess( index, response );
						},
						function ( response ) {
							handleError( index, response );
						},
						"@success",
						"@error"
					);
				}
			);
		},
		handleAsyncCallback: function ( callback ) {
			var _this = this;
			var callbackDecorator = function () {
				if ( !_this._isActiveController ) {
					return;
				}
				callback.apply( _this, arguments );
			};
			return ( callbackDecorator );
		},
		handleDestroy: function () {
			this._isActiveController = false;
		},
		handlePromise: function ( promise, successCallback, errorCallback, updateCallback, mistakeCallback ) {
			promise.then(
				this.handleAsyncCallback( successCallback || ng.noop ),
				this.handleAsyncCallback( errorCallback || ng.noop )
			);
			if ( updateCallback ) {
				if ( updateCallback === "@success" ) {
					updateCallback = successCallback;
				}
				promise.update(
					this.handleAsyncCallback( updateCallback )
				);
			}
			if ( mistakeCallback ) {
				if ( mistakeCallback === "@error" ) {
					mistakeCallback = errorCallback;
				}
				promise.mistake(
					this.handleAsyncCallback( mistakeCallback )
				);
			}
			return ( promise );
		},
		handleRequestContextChanged: function ( requestContext ) {
			return;
		},
		initialize: function () {
			return;
		},
		isActiveController: function () {
			return ( this._isActiveController );
		},
		render: function () {
			return;
		}
	};

	function assignPrototypeMethods( constructorMethod, context ) {
		for ( var methodName in constructorMethod.prototype ) {
			if (
				constructorMethod.prototype.hasOwnProperty( methodName ) &&
				!context[ methodName ]
			) {
				context[ methodName ] = constructorMethod.prototype[ methodName ];
			}
		}
	}
} )( angular, InVision, _ );;;
/*! base-modal-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "BaseModalController", BaseModalController );
	/** @ngInject */
	function BaseModalController( BaseController ) {
		/** @ngInject */
		function Controller( $scope ) {
			BaseController.call( this, $scope );
			assignPrototypeMethods( Controller, this );
			this.scope.isModalOpen = false;
			this.scope.openModal = this.bindMethod( "openModal" );
			this.scope.closeModal = this.bindMethod( "closeModal" );
			this.scope.$on( "closeModalWindow", this.bindMethod( "closeModal" ) );
			return ( Controller.prototype );
		}
		Controller.prototype = {
			closeModal: function () {
				this.scope.isModalOpen = false;
			},
			openModal: function () {
				this.scope.isModalOpen = true;
			}
		};
		return ( Controller );
	}

	function assignPrototypeMethods( constructorMethod, context ) {
		for ( var methodName in constructorMethod.prototype ) {
			if (
				constructorMethod.prototype.hasOwnProperty( methodName ) &&
				!context[ methodName ]
			) {
				context[ methodName ] = constructorMethod.prototype[ methodName ];
			}
		}
	}
} )( angular, InVision );;;
/*! account-info-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.AccountInfoController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, companyService, validationService, sessionService, modelEvents, _ ) {
		function applyRemoteData( response ) {
			$scope.company = response;
			$scope.originalCompany = angular.copy( $scope.company );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}

		function cancel() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			$scope.company = angular.copy( $scope.originalCompany );
		}

		function saveCompany() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			var company = $scope.company;
			if ( !company.name.length ) {
				$scope.errorMessage = "Please enter your company name.";
				return;
			}
			if ( !/[^@]+@[^.]+\..+/.test( company.contactEmail ) ) {
				$scope.errorMessage = "Please enter a valid email address.";
				return;
			}
			var promise = companyService.updateCompany( {
				name: company.name,
				contactName: company.contactName,
				contactEmail: company.contactEmail,
				contactPhone: company.contactPhone
			} );
			Deferred.handlePromise(
				promise,
				function ( company ) {
					$scope.successMessage = "Your account information has been updated.";
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.save = saveCompany;
		$scope.cancel = cancel;
		$scope.isLoading = false;
		$scope.company = null;
		$scope.originalCompany = null;
		$scope.successMessage = null;
		$scope.errorMessage = null;
		modelEvents.on( 'companyAccountUpdated', function ( e, data ) {
			$scope.company = data;
		} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! add-to-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.addToProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, requestContext, Deferred, companyService, userService, projectService, projectMembersModalPartial, sessionService, modelEvents, modalWindowRequest, _ ) {
		function augmentMembers( member ) {
			var isSelected = ( initialMemberIds.indexOf( member.userID ) >= 0 );
			member.selected = isSelected;
			member.initiallySelected = isSelected;
			member.memberHasSystemAvatar = userService.isSystemAvatar( member.avatarID );
		}

		function augmentTeamMember( member ) {
			if ( member.userID === sessionService.user.id ) {
				member.userFullName = "You";
			}
		}

		function augmentTeam( team ) {
			team.selected = ( selectedTeamIds.indexOf( team.teamID ) >= 0 );
			team.members = _.forEach( team.members, augmentTeamMember );
			team.showLimit = 4;
			if ( team.selected ) {
				_.forEach( team.members, function ( teamMember ) {
					var member = _.find( $scope.members, {
						"userID": teamMember.userID
					} );
					member.teamSelected = true;
					member.selected = true;
				} );
			}
		}

		function toggleShowOthers( $event, team ) {
			$event.preventDefault();
			$event.stopImmediatePropagation();
			team.showLimit = ( team.showLimit === 4 ) ? 99 : 4;
			return false;
		}

		function toggleTeam( team ) {
			team.selected = !team.selected;
			_.forEach( team.members, function ( teamMember ) {
				var member = _.find( $scope.members, {
					"userID": teamMember.userID
				} );
				if ( !team.selected ) {
					var otherSelectedTeams = _.filter( $scope.teams, 'selected' );
					var found = false;
					for ( var i = 0, len = otherSelectedTeams.length; i < len; i++ ) {
						var targetMember = _.find( otherSelectedTeams[ i ].members, {
							"userID": teamMember.userID
						} );
						if ( targetMember ) {
							found = true;
							break;
						}
					}
					if ( !found ) {
						member.selected = false;
						member.teamSelected = false;
					}
				} else {
					member.selected = true;
					member.teamSelected = true;
				}
			} );
		}

		function toggleMember( member ) {
			if ( !member.teamSelected ) {
				member.selected = !member.selected;
			}
		}

		function applyRemoteData( members, teams, projectMembersPartial, currentTeams ) {
			selectedTeamIds = _.pluck( currentTeams, 'teamID' );
			initialMemberIds = _.pluck( projectMembersPartial.projectMembers, 'id' );
			$scope.members = _.forEach( members, augmentMembers );
			$scope.teams = _.forEach( teams, augmentTeam );
			$scope.isLoading = false;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handleAllPromises(
				[
					companyService.getCompanyMembership(),
					companyService.getCompanyTeams(),
					projectMembersModalPartial.get( $scope.projectId ),
					companyService.getProjectCompanyTeams( $scope.projectId )
				],
				function ( members, teams, currentMembers, currentTeams ) {
					applyRemoteData( members, teams, currentMembers, currentTeams );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your members. Try refreshing your browser." );
				}
			);
		}

		function update() {
			$scope.isLoading = true;
			var addUsersIDList = _.pluck( _.filter( $scope.members, {
				'selected': true,
				'initiallySelected': false
			} ), "userID" );
			var removeUsersIDList = _.pluck( _.filter( $scope.members, {
				'selected': false,
				'initiallySelected': true
			} ), "userID" );
			var companyTeamIDList = _.pluck( _.filter( $scope.teams, "selected" ), "teamID" );
			var hasRemovedSelf = removeUsersIDList.indexOf( sessionService.user.id ) >= 0;
			Deferred.handlePromise(
				projectService.changeEnterpriseUsersOnProject( $scope.projectId, addUsersIDList, removeUsersIDList, companyTeamIDList, "" ),
				function ( response ) {
					if ( hasRemovedSelf ) {
						modelEvents.trigger( 'projectDeleted' );
						$location.path( '/projects' );
					}
					$scope.closeModalWindow();
				}, function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't update team members. Try refreshing your browser." );
					$scope.isLoading = false;
				}
			);
		}
		var selectedTeamIds = [];
		var initialMemberIds = [];
		$scope.isLoading = false;
		$scope.members = [];
		$scope.teams = [];
		$scope.update = update;
		$scope.toggleTeam = toggleTeam;
		$scope.toggleMember = toggleMember;
		$scope.toggleShowOthers = toggleShowOthers;
		$scope.successMessage = null;
		$scope.errorMessage = null;
		$scope.projectId = modalWindowRequest.getData( 0 );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! add-to-team-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.addToTeamController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, companyService, userService, modalWindowRequest, _ ) {
		function augmentMembers( member ) {
			var selectedMember = _.findIndex( $scope.team.members, {
				'userID': member.userID
			} ) >= 0;
			member.selected = selectedMember;
			member.initiallySelected = selectedMember;
			member.memberHasSystemAvatar = userService.isSystemAvatar( member.avatarID );
		}

		function applyRemoteData( response ) {
			$scope.members = _.forEach( response, augmentMembers );
			$scope.isLoading = false;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.getCompanyMembership(),
				function ( response ) {
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your members. Try refreshing your browser." );
				}
			);
		}

		function update() {
			var addedMembers = _.pluck( _.filter( $scope.members, {
				'selected': true,
				'initiallySelected': false
			} ), 'userID' ).join( "," );
			var removedMembers = _.pluck( _.filter( $scope.members, {
				'selected': false,
				'initiallySelected': true
			} ), 'userID' ).join( "," );
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.updateCompanyTeamMembers( {
					companyTeamId: $scope.team.teamID,
					addUsersIDList: addedMembers,
					removeUsersIDList: removedMembers
				} ), function ( response ) {
					$scope.closeModalWindow();
				}, function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't update team members. Try refreshing your browser." );
				}
			);
		}
		$scope.isLoading = false;
		$scope.members = null;
		$scope.update = update;
		$scope.successMessage = null;
		$scope.errorMessage = null;
		$scope.team = modalWindowRequest.getData( 0 );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! advanced-permissions-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.AdvancedPermissionsController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, companyService, validationService, sessionService, modelEvents, _ ) {
		function applyRemoteData( response ) {
			$scope.company = response;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}

		function save( what ) {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			var company = $scope.company,
				toUpdate = {};
			toUpdate[ what ] = company[ what ];
			var promise = companyService.updateCompany( toUpdate );
			Deferred.handlePromise(
				promise,
				function ( company ) {
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.save = save;
		$scope.isLoading = false;
		$scope.company = null;
		$scope.successMessage = null;
		$scope.errorMessage = null;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! billing-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.BillingController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, billingService, companyService, validationService, sessionService, modelEvents, _ ) {
		function applyRemoteData( billing, countries ) {
			$scope.billing = billing;
			$scope.countries = countries;
			$scope.originalBilling = angular.copy( $scope.billing );
			$scope.isLoading = false;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handleAllPromises( [
					companyService.getBillingInformation(),
					billingService.getCountries()
				],
				applyRemoteData,
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}

		function cancel() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			$scope.billing = angular.copy( $scope.originalBilling );
		}

		function saveBilling() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			var billing = $scope.billing;
			if ( !billing.name.length ) {
				$scope.errorMessage = "Please enter main contact.";
				return;
			}
			billing.country = billing.country || "";
			if ( !/[^@]+@[^.]+\..+/.test( billing.email ) ) {
				$scope.errorMessage = "Please enter a valid email address.";
				return;
			}
			var promise = companyService.saveBillingInformation( billing );
			Deferred.handlePromise(
				promise,
				function ( billing ) {
					$scope.successMessage = "Your account information has been updated.";
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.save = saveBilling;
		$scope.cancel = cancel;
		$scope.isLoading = false;
		$scope.countries = null;
		$scope.billing = null;
		$scope.originalBilling = null;
		$scope.successMessage = null;
		$scope.errorMessage = null;
		modelEvents.on( 'companyBillingInformationUpdated', function ( e, data ) {
			$scope.billing = data;
		} );
		$scope.$on( "$destroy", function () {
			modelEvents.off( 'companyBillingInformationUpdated' );
		} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! company-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.CompanyController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, modelEvents, Deferred, companyService, _, $location ) {
		$scope.views = {
			'members': {
				nav: 'members-nav.htm',
				navClass: [ 'members-nav' ],
				body: 'members-list.htm'
			},
			'custom-branding': {
				nav: 'custom-branding-nav.htm',
				body: 'custom-branding.htm'
			},
			'advanced-permissions': {
				nav: 'advanced-permissions-nav.htm',
				body: 'advanced-permissions.htm'
			},
			'account-information': {
				nav: 'account-information-nav.htm',
				body: 'account-information.htm'
			},
			'billing': {
				nav: 'account-information-nav.htm',
				body: 'billing.htm'
			},
			'teams': {
				body: 'teams.htm'
			},
			'plan-billing': {
				body: 'plan-billing.htm'
			}
		};
		if ( $scope.isReviewer ) {
			$location.path( '/projects' );
		}
		var renderContext = requestContext.getRenderContext( "standard.company" );

		function loadRemoteData() {
			Deferred.handleAllPromises( [
					companyService.getCompanyMembershipCount(),
					companyService.getCompanyTeamsCount()
				],
				function ( members, teams ) {
					$scope.members.teamCount = teams.count;
				},
				function ( response ) {}
			);
		}

		function setMemberRoleCount( members, invites ) {
			$scope.members.memberCount = members.length + invites.length;
			$scope.members.adminCount = _.filter( members, {
				"roleID": 1
			} ).length + _.filter( invites, {
				"roleID": 1
			} ).length;
			$scope.members.managerCount = _.filter( members, {
				"roleID": 2
			} ).length + _.filter( invites, {
				"roleID": 2
			} ).length;
			$scope.members.contributerCount = _.filter( members, {
				"roleID": 3
			} ).length + _.filter( invites, {
				"roleID": 3
			} ).length;
			$scope.members.reviewerCount = _.filter( members, {
				"roleID": 4
			} ).length + _.filter( invites, {
				"roleID": 4
			} ).length;
		}

		function setCompanyMembership( members, invites ) {
			$scope.companyMembership = members;
			$scope.companyInvites = invites;
			setMemberRoleCount( members, invites );
		}
		$scope.filterRoles = function ( roleID ) {
			modelEvents.trigger( "memberRoleChange", roleID );
			$scope.roleTabID = roleID;
		};
		$scope.inviteToCompany = function () {
			$scope.openModalWindow( "enterpriseInviteToCompany" );
		};
		$scope.removeFromCompany = function () {
			var selectedMembers = _.filterWithProperty( $scope.companyMembership, 'isChecked', true );
			var selectedInvites = _.filterWithProperty( $scope.companyInvites, 'isChecked', true );
			if ( selectedMembers.length || selectedInvites.length ) {
				var dataForModal = {
					selectedMembers: selectedMembers,
					selectedInvites: selectedInvites,
					companyInfo: $scope.companyInfo
				};
				$scope.openModalWindow( "enterpriseRemoveFromCompany", dataForModal );
			}
		};
		$scope.subview = renderContext.getNextSection();
		$scope.members = {};
		$scope.members.memberCount = 0;
		$scope.members.teamCount = 0;
		$scope.roleTabID = 0;
		$scope.numberOfMembersChecked = 0;
		$scope.companyMembership = [];
		modelEvents.on(
			[
				'pulledCompanyMembershipWithInvites',
				'companyUserRoleChanged'
			],
			function ( e, data ) {
				setCompanyMembership( data.companyMembers, data.companyInvites );
			}
		);
		modelEvents.on( 'teamMembershipSelectCount', function ( e, count, teamMembers, invites ) {
			$scope.companyMembership = teamMembers;
			$scope.companyInvites = invites;
			$scope.numberOfMembersChecked = count;
		} );
		modelEvents.on( 'companyTeamCreated', function ( e, data ) {
			$scope.members.teamCount++;
		} );
		modelEvents.on( 'companyTeamDeleted', function ( e, data ) {
			$scope.members.teamCount--;
		} );
		modelEvents.on( 'usersRemovedFromCompany.company', function ( e, membersRemoved, invitesRemoved ) {
			var filteredMembers = _.filter( $scope.companyMembership, function ( member ) {
				return !_.contains( membersRemoved, member.userID );
			} );
			var filteredInvites = _.filter( $scope.companyInvites, function ( invite ) {
				return !_.contains( invitesRemoved, invite.inviteID );
			} );
			setCompanyMembership( filteredMembers, filteredInvites );
		} );
		$scope.$on( "$destroy", function () {
			modelEvents.off( 'companyTeamCreated' );
			modelEvents.off( 'teamMembershipSelectCount' );
			modelEvents.off( 'teamMembershipChange' );
			modelEvents.off( 'pulledCompanyMembership' );
			modelEvents.off( 'usersRemovedFromCompany' );
		} );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.subview = renderContext.getNextSection();
			}
		);
		if ( $location.search().hasOwnProperty( "inviteMembers" ) ) {
			$location.search( "inviteMembers", null );
			$scope.inviteToCompany();
		}
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! custom-branding-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.CustomBranding", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, companyService, validationService, sessionService, _ ) {
		function cancel() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			$scope.branding = {
				email: "",
				webColors: "",
				linkTo: "",
				tagline: "",
				comments: ""
			};
		}

		function saveBranding() {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			var branding = $scope.branding;
			/*if ( ! /^(http(?:s)?\:\/\/[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*\.[a-zA-Z]{2,6}(?:\/?|(?:\/[\w\-]+)*)(?:\/?|\/\w+\.[a-zA-Z]{2,4}(?:\?[\w]+\=[\w\-]+)?)?(?:\&[\w]+\=[\w\-]+)*)$/.text( branding.linkTo ) ) {
$scope.errorMessage = "Please enter a valid link";
return;
}*/
			if ( !/[^@]+@[^.]+\..+/.test( branding.contactEmail ) ) {
				$scope.errorMessage = "Please enter a valid email address.";
				return;
			}
			var promise = companyService.sendCustomBranding( {
				email: branding.contactEmail,
				webColors: branding.webColors,
				linkTo: branding.linkTo,
				tagline: branding.tagline,
				comments: branding.comments
			} );
			Deferred.handlePromise(
				promise,
				function ( branding ) {
					$scope.successMessage = "Your branding information has been submitted";
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.save = saveBranding;
		$scope.cancel = cancel;
		$scope.isLoading = false;
		cancel();
	}
} )( angular, InVision );;;
/*! invite-to-company-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.inviteToCompanyController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, companyService, modalWindowRequest, _, config ) {
		$scope.setRoleForInvite = function ( roleID ) {
			$scope.assignedRole = _.filter( $scope.userRoles, {
				"id": roleID
			} )[ 0 ];
		};
		$scope.addCompanyInvites = function () {
			$scope.errorMessage = null;
			var emailArray = $scope.newusers.email.split( ',' );
			for ( var e = 0; e < emailArray.length; e++ ) {
				emailArray[ e ] = $.trim( emailArray[ e ] );
				if ( !( /^[^@]+@[^.]+\..+$/i ).test( emailArray[ e ] ) ) {
					$scope.errorMessage = "Please enter a valid email address.";
					return; //only breaks the loop
				}
				$scope.newusers.email = emailArray.join( ',' );
			}
			if ( $scope.errorMessage ) {
				return;
			}
			var promise = companyService.inviteUsersToCompany( {
				emails: $scope.newusers.email,
				roleID: $scope.assignedRole.id
			} );
			Deferred.handlePromise(
				promise,
				function ( response ) {
					$scope.closeModalWindow();
				}, function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't invite team members. Try refreshing your browser." );
				}
			);
		};
		$scope.isLoading = false;
		$scope.userRoles = config.companySettings.userRoles;
		$scope.availableUserRoles = _.filter( $scope.userRoles, function ( role ) {
			return $scope.user.companyMembership.roleID <= role.id;
		} );
		$scope.assignedRole = $scope.userRoles[ 2 ];
		$scope.newusers = {};
		$scope.newusers.email = "";
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! member-listing-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.MemberListingController", Controller );
	/** @ngInject */
	function Controller( $scope, modelEvents, Deferred, companyService, config, _, userService, dateHelper ) {
		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.getCompanyMembershipWithInvites(),
				function ( response ) {
					var companyMembers = response.companyMembers;
					var companyInvites = response.companyInvites;
					$scope.isLoading = false;
					$scope.companyMembership = augmentTeamMembers( companyMembers );
					$scope.companyInvites = companyInvites;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}

		function augmentTeamMembers( companyMembers ) {
			var members = _.forEach( companyMembers, augmentTeamMember );
			members = _.sortBy( members, 'userFullName' );
			return members;
		}

		function augmentTeamMember( teamMember ) {
			teamMember.roleDescription = _.filter( $scope.userRoles, {
				"id": teamMember.roleID
			} )[ 0 ].description;
			teamMember.onlineStatus = userService.getOnlineStatus( teamMember.lastRequestAt );
			teamMember.lastActiveAtLabel = getLastActiveLabel( teamMember.lastRequestAt, teamMember.onlineStatus ).toLowerCase();
			teamMember.memberHasSystemAvatar = userService.isSystemAvatar( teamMember.avatarID );
		}

		function getLastActiveLabel( offset, isOnline ) {
			return isOnline === "Online" ? "Just now" : moment( offset ).fromNow();
		}

		function setSelectedCount() {
			var membersChecked = _.filter( $scope.companyMembership, {
				"isChecked": true
			} ).length;
			var invitesChecked = _.filter( $scope.companyInvites, {
				"isChecked": true
			} ).length;
			$scope.numberOfMembersChecked = membersChecked + invitesChecked;
			modelEvents.trigger( "teamMembershipSelectCount",
				$scope.numberOfMembersChecked,
				$scope.companyMembership,
				$scope.companyInvites );
		}
		/**
		 * Sets a single or multipe user IDs to a specific role ID
		 * @param {array} userIDs - array of user ID's to update
		 * @param {array} inviteIDsArr - array of invite ID's to update
		 * @param {number} roleID  - ID of the role
		 */
		function setUserRoles( userIDsArr, inviteIDsArr, roleID ) {
			var promise = companyService.setCompanyUserRoles( {
				userIDs: userIDsArr,
				inviteIDs: inviteIDsArr,
				roleID: roleID
			} );
			Deferred.handlePromise(
				promise,
				function ( usersUpdated ) {
					$scope.companyMembership = augmentTeamMembers( usersUpdated.companyMembers );
					$scope.companyInvites = usersUpdated.companyInvites;
				},
				function ( response ) {}
			);
		}
		$scope.showMemberModal = function ( member ) {
			$scope.openModalWindow( "enterpriseMember", member );
		};
		$scope.toggleMasterRole = function ( roleID ) {
			$scope.master.role = _.filter( $scope.userRoles, {
				"id": roleID
			} )[ 0 ];
			var userIDs = [];
			var inviteIDs = [];
			_.each( $scope.companyMembership, function ( m ) {
				if ( m.isChecked ) {
					userIDs.push( m.userID );
				}
			} );
			_.each( $scope.companyInvites, function ( i ) {
				if ( i.isChecked ) {
					inviteIDs.push( i.inviteID );
				}
			} );
			if ( userIDs.length || inviteIDs.length ) {
				setUserRoles( userIDs, inviteIDs, roleID );
			}
		};
		$scope.toggleMasterCkBx = function () {
			$scope.master.checkbox = !$scope.master.checkbox;
			if ( $scope.numberOfMembersChecked > 0 ) {
				$scope.master.checkbox = false;
			}
			if ( $scope.currentPageRoleID > 0 ) {
				_.each( $scope.companyMembership, function ( m ) {
					if ( m.roleID === $scope.currentPageRoleID ) {
						m.isChecked = $scope.master.checkbox;
					}
				} );
				_.each( $scope.companyInvites, function ( i ) {
					if ( i.roleID === $scope.currentPageRoleID ) {
						i.isChecked = $scope.master.checkbox;
					}
				} );
			} else {
				_.each( $scope.companyMembership, function ( m ) {
					m.isChecked = $scope.master.checkbox;
				} );
				_.each( $scope.companyInvites, function ( i ) {
					i.isChecked = $scope.master.checkbox;
				} );
			}
		};
		$scope.masterCkBxClass = function () {
			setSelectedCount();
			var selectedCount = $scope.numberOfMembersChecked;
			if ( selectedCount === 0 ) {
				return [];
			}
			if ( selectedCount === $scope.companyMembership.length ) {
				return [ 'checked' ];
			}
			return [ 'partial' ];
		};
		$scope.filterMembersByRole = function ( member ) {
			if ( $scope.currentPageRoleID === 0 ) {
				return true;
			}
			return member.roleID === $scope.currentPageRoleID;
		};
		$scope.changeUserRole = function ( member, roleID ) {
			setUserRoles( [ member.userID ], [], roleID );
		};
		$scope.changeInviteeRole = function ( invite, roleID ) {
			setUserRoles( [], [ invite.inviteID ], roleID );
		}
		modelEvents.on( 'companyTeamMemberCreated', function ( event, invitation ) {
			loadRemoteData();
		} );
		modelEvents.on( 'companyMembersInvited', function ( event, data ) {
			var newInvites = data.results;
			var existingInviteIDs = _.pluck( $scope.companyInvites, 'inviteID' );
			for ( var i = 0, len = newInvites.length; i < len; i++ ) {
				if ( !_.contains( existingInviteIDs, newInvites[ i ].inviteID ) ) {
					$scope.companyInvites.push( newInvites[ i ] );
				}
			}
			$scope.companyInvites = _.sortBy( $scope.companyInvites, 'email' );
		} );
		modelEvents.on( 'usersRemovedFromCompany.memberList', function ( e, membersRemoved, invitesRemoved ) {
			$scope.companyMembership = _.filter( $scope.companyMembership, function ( member ) {
				return !_.contains( membersRemoved, member.userID );
			} );
			$scope.companyInvites = _.filter( $scope.companyInvites, function ( invite ) {
				return !_.contains( invitesRemoved, invite.inviteID );
			} );
		} );
		modelEvents.on( 'memberRoleChange', function ( e, data ) {
			$scope.currentPageRoleID = data;
		} );
		$scope.userRoles = config.companySettings.userRoles;
		$scope.availableUserRoles = _.filter( $scope.userRoles, function ( role ) {
			return $scope.user.companyMembership.roleID <= role.id;
		} );
		$scope.currentPageRoleID = 0;
		$scope.master = {};
		$scope.master.checkbox = false; // default checked status of master checkbox
		$scope.master.role = $scope.userRoles[ 0 ]; // default value of master role select menu
		$scope.companyMembership = [];
		$scope.numberOfMembersChecked = 0;
		$scope.$on( "$destroy", function () {
			modelEvents.off( 'usersRemovedFromCompany' );
		} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! remove-from-company-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.removeFromCompanyController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, Deferred, companyService, sessionService, modelEvents, _ ) {
		$scope.removeUsers = function () {
			var memberIDs = _.pluck( $scope.membersToRemove, "userID" );
			var inviteIDs = _.pluck( $scope.invitesToRemove, "inviteID" );
			Deferred.handlePromise(
				companyService.removeUsersFromCompany( memberIDs, inviteIDs ),
				function removedUsersSuccessfully( status ) {
					$scope.closeModalWindow();
				}
			);
		};
		var modalData,
			modalDataDefaults = {
				selectedMembers: [],
				selectedInvites: [],
				companyInfo: {
					companyName: ""
				}
			};
		$scope.membersToRemove = [];
		$scope.invitesToRemove = [];
		modalData = _.defaults( modalWindowRequest.getData( 0 ), modalDataDefaults );
		$scope.membersToRemove = modalData.selectedMembers;
		$scope.invitesToRemove = modalData.selectedInvites;
		$scope.companyInfo = modalData.companyInfo;
	}
} )( angular, InVision );;;
/*! teams-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "company.TeamsController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, companyService, userService, modelEvents, _ ) {
		var MAX_VISIBLE_USERS = 11;

		function formatMoreMembers( val, i ) {
			return i > ( MAX_VISIBLE_USERS - 1 ) ? true : false;
		}
		var augmentTeamMember = function ( member ) {
			member.memberHasSystemAvatar = userService.isSystemAvatar( member.avatarID );
		};
		var augmentTeam = function ( team ) {
			team.members = _.forEach( team.members, augmentTeamMember );
			var moreMembers = _.remove( _.clone( team.members ), formatMoreMembers );
			team.moreMembersList = _.pluck( moreMembers, "userFullName" ).join( "<br />" );
		};
		var applyRemoteData = function ( teams ) {
			$scope.teams = _.forEach( teams, augmentTeam );
			$scope.isLoading = false;
		};
		var loadRemoteData = function () {
			$scope.isLoading = true;
			Deferred.handlePromise(
				companyService.getCompanyTeams(),
				applyRemoteData,
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your teams. Try refreshing your browser." );
				}
			);
		};
		var addToTeam = function ( team ) {
			if ( $scope.isContributor ) {
				return;
			}
			$scope.openModalWindow( "enterpriseAddToTeam", team );
		};
		var cancel = function () {
			$scope.showAddTeamForm = false;
			$scope.errorMessage = null;
			$scope.newTeam = {
				name: ""
			};
		};
		var confirmRemoval = function ( $event, team ) {
			$event.stopImmediatePropagation();
			$event.preventDefault();
			team.confirmDelete = true;
			return false;
		};
		var cancelRemoval = function ( $event, team ) {
			$event.stopImmediatePropagation();
			$event.preventDefault();
			team.confirmDelete = false;
			return false;
		};
		var removeTeam = function ( $event, companyTeamId ) {
			$event.stopImmediatePropagation();
			$event.preventDefault();
			var promise = companyService.deleteCompanyTeam( {
				companyTeamId: companyTeamId
			} );
			Deferred.handlePromise(
				promise,
				function ( team ) {
					_.remove( $scope.teams, {
						teamID: companyTeamId
					} );
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				} );
			return false;
		};
		var create = function () {
			$scope.successMessage = null;
			$scope.errorMessage = null;
			if ( !$scope.newTeam.name || !$scope.newTeam.name.length ) {
				$scope.errorMessage = "Please enter your team name.";
				return;
			}
			var promise = companyService.createCompanyTeam( {
				name: $scope.newTeam.name,
				sort: $scope.teams.length
			} );
			Deferred.handlePromise(
				promise,
				function ( team ) {
					$scope.teams.push( team );
					$scope.errorMessage = null;
					$scope.newTeam = {
						name: ""
					};
					$scope.showAddTeamForm = false;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		modelEvents.on( "updateCompanyTeamMembers", function ( e, data ) {
			loadRemoteData();
		} );
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "updateCompanyTeamMembers" );
			}
		);
		$scope.errorMessage = null;
		$scope.create = create;
		$scope.cancel = cancel;
		$scope.removeTeam = removeTeam;
		$scope.confirmRemoval = confirmRemoval;
		$scope.cancelRemoval = cancelRemoval;
		$scope.addToTeam = addToTeam;
		$scope.newTeam = {
			name: ""
		};
		$scope.showAddTeamForm = false;
		$scope.isLoading = false;
		$scope.maxVisibleUsers = MAX_VISIBLE_USERS;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! build-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "console.BuildController", Controller );
	/** @ngInject */
	function Controller( _, $timeout, $scope, BaseController, requestContext, hotspotService, screenService, templateService, Deferred, $location ) {
		if ( $scope.isReviewer ) {
			$location.path( '/projects' );
		}
		$scope.saveHotspot = function ( hotspot, screen ) {
			var promise = Deferred.handlePromise(
				hotspotService.saveHotspot( hotspot, screen ),
				null,
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't save your hotspot. Try refreshing your browser." );
				}
			);
			return ( promise );
		};
		$scope.deleteHotspot = function ( hotspot ) {
			if ( hotspot.isSaved ) {
				hotspotService.deleteHotspot( hotspot );
			}
			var hotSpotsMinusDeleted = _.reject( $scope.hotspots, function ( h ) {
				return h === hotspot;
			} );
			$scope.setHotspots( hotSpotsMinusDeleted );
		};
		$scope.saveFixedHeaderHeight = function ( screen ) {
			if ( screen.fixedHeaderHeight == "" || isNaN( screen.fixedHeaderHeight ) ) {
				screen.fixedHeaderHeight = 0;
			}
			screenService.setFixedHeaderHeight( screen );
			$scope.setIsEditingFixedHeaderHeight( false );
			$scope.setIsFixedHeaderInEditMode( false );
		}
		$scope.saveFixedFooterHeight = function ( screen ) {
			if ( screen.fixedFooterHeight == "" || isNaN( screen.fixedFooterHeight ) ) {
				screen.fixedFooterHeight = 0;
			}
			screenService.setFixedFooterHeight( screen );
			$scope.setIsEditingFixedFooterHeight( false );
			$scope.setIsFixedFooterInEditMode( false );
		}
		$scope.setIsDesktopFixedHeaderEnabled = function ( screen ) {
			if ( screen.fixedHeaderHeight > 0 ) {
				$scope.setIsFixedHeaderInEditMode( true );
				$scope.desktopFixedHeader.isEnabled = true;
			} else {
				$scope.setIsFixedHeaderInEditMode( false );
				$scope.desktopFixedHeader.isEnabled = false;
			}
		}
		$scope.toggleDesktopFixedHeaderActive = function ( screen ) {
			if ( $scope.setIsFixedFooterInEditMode == false || $scope.screen.fixedHeaderHeight == 0 ) {
				$scope.screen.fixedHeaderHeight = 80;
				$scope.saveFixedHeaderHeight( screen );
				$scope.setIsFixedHeaderInEditMode( true );
				$scope.isDesktopFixedHeaderEnabled = true;
			} else {
				$scope.screen.fixedHeaderHeight = 0;
				$scope.saveFixedHeaderHeight( screen );
				$scope.setIsFixedHeaderInEditMode( false );
				$scope.isDesktopFixedHeaderEnabled = false;
			}
		}
		$scope.startScreenAnchorSetter = function ( hotspotID ) {
			$scope.isShowingScreenAnchorSetter = true;
			$scope.hotspotIDForScreenAnchorSetter = hotspotID;
			$scope.$apply;
		}
		$scope.closeScreenAnchorSetter = function () {
			$scope.isShowingScreenAnchorSetter = false;
			$scope.$apply;
		}
		$scope.setScreenAnchorPosition = function ( position ) {
			$scope.screenAnchorPosition = position;
		}
		$scope.setIsEditingFixedHeaderHeight = function ( value ) {
			$scope.isEditingFixedHeaderHeight = value;
		}
		$scope.setIsEditingFixedFooterHeight = function ( value ) {
			$scope.isEditingFixedFooterHeight = value;
		}
		$scope.setIsFixedHeaderInEditMode = function ( value ) {
			$scope.isFixedHeaderInEditMode = value;
		}
		$scope.setIsFixedFooterInEditMode = function ( value ) {
			$scope.isFixedFooterInEditMode = value;
		}
		$scope.fixedHeaderInputKeypress = function ( screen, event ) {
			if ( event.which == 13 ) {
				$scope.saveFixedHeaderHeight( screen );
			} else if ( event.which == 38 ) { // up arrow, increment by one
				$scope.screen.fixedHeaderHeight++;
			} else if ( event.which == 40 ) { // down arrow, decrement by one
				$scope.screen.fixedHeaderHeight--;
			}
		}
		$scope.fixedFooterInputKeypress = function ( screen, event ) {
			if ( event.which == 13 ) {
				$scope.saveFixedFooterHeight( screen );
			} else if ( event.which == 38 ) { // up arrow, increment by one
				$scope.screen.fixedFooterHeight++;
			} else if ( event.which == 40 ) { // down arrow, decrement by one
				$scope.screen.fixedFooterHeight--;
			}
		}
		$scope.setFixedAreasMaximumPercentage = function () {
			var fixedHeaderCurrentLocation = ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) / $scope.project.mobileTemplate.viewportHeight;
			var fixedFooterCurrentLocation = ( $scope.screen.fixedFooterHeight * $scope.screen.displayScale ) / $scope.project.mobileTemplate.viewportHeight;
			$scope.fixedHeaderMaximumPercentage = $scope.maximumFixedAreaTotalPercentage - fixedFooterCurrentLocation;
			$scope.fixedFooterMaximumPercentage = $scope.maximumFixedAreaTotalPercentage - fixedHeaderCurrentLocation;
		}
		$scope.floor = function ( value ) {
			return Math.floor( value );
		}
		$scope.ceil = function ( value ) {
			return Math.ceil( value );
		}
		$scope.closeTimerMenu = function () {
			$scope.$broadcast( "build.closeTimerMenu" );
		}
		var renderContext = requestContext.getRenderContext( "console.build", [ "projectID", "screenID" ] );
		$scope.isShowingScreenAnchorSetter = false;
		$scope.hotspotIDForScreenAnchorSetter = 0;
		$scope.screenAnchorPosition = 0;
		$scope.setWindowTitle( $scope.project.name + " Build Mode" );
		$scope.isEditingFixedHeaderHeight = false;
		$scope.isFixedHeaderInEditMode = false;
		$scope.desktopFixedHeader = {
			isEnabled: false // Activates the checkbox and hides/shows elements
		};
		if ( !$scope.project.isMobile ) {
			$scope.setIsDesktopFixedHeaderEnabled( $scope.screen );
		}
		$scope.maximumFixedAreaTotalPercentage = 0.90;
		$scope.fixedHeaderMaximumPercentage = 0.90;
		$scope.fixedFooterMaximumPercentage = 0.90;
		$scope.setFixedAreasMaximumPercentage();
		$scope.allowFixedElements = ( ( $scope.screen.height * $scope.screen.displayScale ) >= ( $scope.project.mobileTemplate.viewportHeight - 20 ) );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( requestContext.hasParamChanged( "projectID" ) ||
					requestContext.hasParamChanged( "screenID" ) ) {
					$scope.setFixedAreasMaximumPercentage();
					$scope.allowFixedElements = ( ( $scope.screen.height * $scope.screen.displayScale ) >= ( $scope.project.mobileTemplate.viewportHeight - 20 ) );
					if ( !$scope.project.isMobile ) {
						$scope.setIsDesktopFixedHeaderEnabled( $scope.screen );
					}
				}
			}
		);
	}
} )( angular, InVision );;;
/*! comments-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "console.CommentsController", Controller );
	/** @ngInject */
	function Controller( _, $timeout, $scope, $location, BaseController, requestContext, conversationService, sessionService, projectService, Deferred, moment, modelEvents ) {
		function applyFilters() {
			var conversations = $scope.conversations;
			updateFilterCounts();
			showConversations( conversations );
			applyShowCompletedFilter( conversations );
			applyTypeFilter( conversations );
			showConversationsNotAffectedByFiltering( conversations );
		}

		function applyShowCompletedFilter( conversations ) {
			if ( !$scope.filters.showCompleted.value ) {
				hideConversations(
					_.withProperty( conversations, "isComplete", true )
				);
			}
		}

		function applyTypeFilter( conversations ) {
			if ( $scope.filters.type.value === "comments" ) {
				hideConversations(
					_.withProperty( conversations, "isForDevelopment", true )
				);
			} else if ( $scope.filters.type.value === "dev-notes" ) {
				hideConversations(
					_.withProperty( conversations, "isForDevelopment", false )
				);
			}
		}

		function clearExcludedConversationIDs() {
			conversationIDsNotAffectedByFiltering = [];
		}

		function excludeConversationIDFromFiltering( id ) {
			conversationIDsNotAffectedByFiltering.push( id );
			showConversationsNotAffectedByFiltering( $scope.conversations );
		}

		function getConversation( conversationID ) {
			return _.findWithProperty( $scope.conversations, "id", conversationID );
		}

		function getSessionKeyForDefaultUserIDs() {
			var sessionKeyForDefaultUserIDs = "defaultUserIDs-" + $scope.projectID;
			return sessionKeyForDefaultUserIDs;
		}

		function hideConversations( conversations ) {
			_.setProperty( conversations, "isShown", false );
		}

		function navigateToComments() {
			$location.path( "/console/" + $scope.projectID + "/" + $scope.screenID + "/comments" );
		}

		function showConversations( conversations ) {
			_.setProperty( conversations, "isShown", true );
		}

		function showConversationsNotAffectedByFiltering( conversations ) {
			showConversations(
				_.withPropertyRange( $scope.conversations, "id", conversationIDsNotAffectedByFiltering )
			);
		}

		function sortUnreadConversations( conversations ) {
			conversations.sort(
				function ( a, b ) {
					var commentA = _.last( a.comments );
					var commentB = _.last( b.comments );
					return ( commentA.createdAt < commentB.createdAt ? -1 : 1 );
				}
			);
			return ( conversations );
		}

		function updateFilterCounts() {
			var conversations = $scope.conversations;
			if ( !$scope.filters.showCompleted.value ) {
				conversations = _.withoutProperty( conversations, "isComplete", true );
			}
			if ( $scope.isReviewer ) {
				conversations = _.withoutProperty( conversations, "isForDevelopment", true );
			}
			$scope.typeFilterOptions[ 0 ].count = conversations.length;
			$scope.typeFilterOptions[ 1 ].count = _.withProperty( conversations, "isForDevelopment", false ).length;
			if ( !$scope.isReviewer ) {
				$scope.typeFilterOptions[ 2 ].count = _.withProperty( conversations, "isForDevelopment", true ).length;
			}
			if ( $scope.filters.type.value === "all" ) {
				$scope.filters.showCompleted.count = _.withProperty( $scope.conversations, "isComplete", true ).length;
			} else if ( $scope.filters.type.value === "comments" ) {
				$scope.filters.showCompleted.count = _.where( $scope.conversations, {
					isForDevelopment: false,
					isComplete: true
				} ).length;
			} else if ( $scope.filters.type.value === "dev-notes" ) {
				$scope.filters.showCompleted.count = _.where( $scope.conversations, {
					isForDevelopment: true,
					isComplete: true
				} ).length;
			}
		}

		function updateUnreadConversations() {
			var conversations = _.filter(
				$scope.conversations,
				function ( conversation ) {
					return (
						( conversation.isUnread && !conversation.isComplete ) ||
						_.contains( visitedUnreadConversationIDs, conversation.id )
					);
				}
			);
			$scope.unreadConversations = sortUnreadConversations( conversations );
			updateVisibleUnreadConversations();
		}

		function updateVisibleUnreadConversations() {
			$scope.visibleUnreadConversations = $scope.unreadConversations;
			$scope.hiddenUnreadConversations = [];
			if ( $scope.unreadConversations.length > $scope.unreadConversationCapacity ) {
				$scope.visibleUnreadConversations = $scope.unreadConversations.slice( 0, $scope.unreadConversationCapacity );
				$scope.hiddenUnreadConversations = $scope.unreadConversations.slice( $scope.unreadConversationCapacity );
			}
		}
		$scope.areConversationsDirty = function () {
			return ( hasActiveConversationWithDirtyData );
		};
		$scope.changeShowCompletedFilter = function () {
			clearExcludedConversationIDs();
			$scope.closeAllConversationPanels();
			navigateToComments();
			applyFilters();
		};
		$scope.changeTypeFilter = function ( option ) {
			clearExcludedConversationIDs();
			$scope.closeAllConversationPanels();
			navigateToComments();
			$scope.filters.type = option;
			applyFilters();
		};
		$scope.closeAllConversationPanels = function () {
			hasActiveConversationWithDirtyData = false;
			_.setProperty( $scope.conversations, "isConversationPanelVisible", false );
			_.each(
				_.withoutProperty( $scope.conversations, "isSaved", true ),
				function ( conversation ) {
					$scope.deleteConversation( conversation );
				}
			);
		};
		$scope.deleteConversation = function ( conversation ) {
			if ( conversation.id ) {
				conversationService.deleteConversation( conversation );
			}
			$scope.setConversations(
				_.reject( $scope.conversations, function ( c ) {
					return conversation === c;
				} )
			);
			navigateToComments();
		};
		$scope.getDefaultUserIDs = function () {
			return ( defaultUserIDs );
		};
		$scope.isConversationActive = function () {
			var activeConversation = _.findWithProperty( $scope.conversations, "isConversationPanelVisible", true );
			return ( !!activeConversation );
		};
		$scope.isProjectMember = _.memoize( function ( userID ) {
			if ( userID === $scope.userID ) {
				return true;
			}
			var isMember = false;
			_.each( $scope.projectMembers, function ( member ) {
				if ( member.id === userID ) {
					isMember = true;
					return false;
				}
			} );
			return isMember;
		} );
		$scope.markCommentsAsRead = function ( conversation ) {
			conversation.isUnread = false;
			var comments = _.filter( conversation.comments, function ( comment ) {
				return comment.isUnread === true;
			} );
			var commentIDs = _.pluck( comments, 'id' );
			modelEvents.trigger( "console:conversation:read", conversation );
			_.setProperty( conversation.comments, "isUnread", false );
			if ( commentIDs.length ) {
				conversationService.markCommentsAsRead( commentIDs );
			}
			var unreadConversations = _.filter(
				$scope.conversations,
				function ( convo ) {
					return (
						( convo.isUnread && !convo.isComplete ) ||
						_.contains( visitedUnreadConversationIDs, convo.id )
					);
				}
			);
			$scope.unreadConversations = unreadConversations;
		};
		$scope.setConversationsAsDirty = function () {
			hasActiveConversationWithDirtyData = true;
		};
		$scope.setConversationsAsClean = function () {
			hasActiveConversationWithDirtyData = false;
		};
		$scope.setDefaultUserIDs = function ( userIDs ) {
			sessionService.set(
				getSessionKeyForDefaultUserIDs(),
				userIDs
			);
			defaultUserIDs = userIDs;
		};
		$scope.showConversationPanel = function ( conversationID ) {
			if ( !conversationID ) {
				return;
			}
			var conversation = _.findWithProperty( $scope.conversations, "id", conversationID );
			if ( conversation ) {
				conversation.isConversationPanelVisible = true;
				if ( conversation.isUnread ) {
					visitedUnreadConversationIDs.push( conversationID );
				}
			} else {
				navigateToComments();
			}
		};
		$scope.saveConversation = function ( conversation, callback ) {
			var promise = conversationService.saveConversation( conversation );
			Deferred.handlePromise(
				promise,
				function ( savedConversation ) {
					if ( !conversation.isSaved ) {
						conversation.id = savedConversation.id;
						conversation.label = savedConversation.label;
					}
					conversation.isSaved = true;
					if ( callback ) {
						callback( conversation.id );
					}
				},
				function () {}
			);
		};
		$scope.updateConversationPosition = function ( conversation ) {
			var promise = conversationService.saveConversation( conversation );
			Deferred.handlePromise(
				promise,
				function ( savedConversation ) {},
				function () {}
			);
		};
		$scope.saveConversationIsCompleteStatus = function ( conversation ) {
			excludeConversationIDFromFiltering( conversation.id );
			$scope.saveConversation( conversation );
		};
		$scope.toggleLike = function ( comment ) {
			comment.hasUserLiked = !comment.hasUserLiked;
			if ( comment.hasUserLiked ) {
				comment.numberOfLikes++;
				var hasNotLiked = _.isUndefined( _.findWithProperty( comment.likedBy, 'email', sessionService.user.email ) );
				if ( hasNotLiked ) {
					comment.likedBy.unshift( {
						name: sessionService.user.name,
						email: sessionService.user.email
					} );
				}
			} else {
				comment.numberOfLikes--;
				comment.likedBy = _.rejectWithProperty( comment.likedBy, "email", sessionService.user.email );
			}
			comment.likedByList = conversationService.formatCommentLikers( comment );
			conversationService.toggleCommentLike( comment.id, comment.conversationID );
		};
		$scope.updateUnreadConversationCapacity = function ( capacity ) {
			$scope.unreadConversationCapacity = capacity;
			updateVisibleUnreadConversations();
		};
		$scope.startSketchBuilder = function () {
			$scope.isShowingSketchBuilder = true;
			$scope.isBottomBarShown = false;
		};
		$scope.hideSketchBuilder = function () {
			$scope.isShowingSketchBuilder = false;
			$scope.isBottomBarShown = true;
		};
		$scope.clearCommentSketches = function () {
			$scope.tempSketches = [];
		};
		$scope.deleteTempSketch = function ( tempID ) {
			$scope.tempSketches = _.withoutProperty( $scope.tempSketches, "tempID", tempID );
		};
		$scope.startSketchViewer = function ( sketch, isTemp, marker ) {
			if ( sketch.sketchID !== undefined ) {
				sketch.id = sketch.sketchID;
			}
			$scope.sketchViewerSketch = sketch;
			$scope.sketchViewerMarker = marker;
			$scope.sketchViewerSketchIsTemp = ( sketch.tempID !== undefined ? true : false );
			$scope.isShowingSketchViewer = true;
			$scope.isBottomBarShown = false;
			$scope.setSketchImageIsProcessing( false );
		};
		$scope.closeSketchViewer = function () {
			$scope.sketchViewerSketch = {};
			$scope.sketchViewerMarker = {};
			$scope.sketchViewerSketchIsTemp = false;
			$scope.isShowingSketchViewer = false;
			$scope.isBottomBarShown = true;
			$scope.setSketchImageIsProcessing( false );
		};
		$scope.setSketchImageIsProcessing = function ( isProcessing ) {
			$scope.sketchImageIsProcessing = isProcessing;
		};
		var renderContext = requestContext.getRenderContext( "console.comments", [ "projectID", "screenID", "commentID" ] );
		var conversationIDsNotAffectedByFiltering = [];
		var visitedUnreadConversationIDs = [];
		var defaultUserIDs = sessionService.get( getSessionKeyForDefaultUserIDs(), [] );
		var hasActiveConversationWithDirtyData = false;
		$scope.commentID = requestContext.getParamAsInt( "commentID" );
		$scope.typeFilterOptions = [ {
			label: "All Types",
			value: "all",
			count: 0
		}, {
			label: "Comments",
			value: "comments",
			count: 0
		} ];
		if ( !$scope.isReviewer ) {
			$scope.typeFilterOptions.push( {
				label: "Dev Notes",
				value: "dev-notes",
				count: 0
			} );
		}
		$scope.filters = {
			type: $scope.typeFilterOptions[ 0 ],
			showCompleted: {
				value: false,
				count: 0
			}
		};
		$scope.unreadConversations = [];
		$scope.visibleUnreadConversations = [];
		$scope.hiddenUnreadConversations = [];
		$scope.unreadConversationCapacity = 10;
		$scope.isShowingSketchBuilder = false;
		$scope.isShowingSketchViewer = false;
		$scope.sketchViewerSketchIsTemp = false;
		$scope.sketchViewerSketch = {};
		$scope.sketchViewerMarker = {};
		$scope.sketchImageIsProcessing = false;
		$scope.tempSketches = [];
		$scope.$on( "$destroy", function () {
			var conversation = _.find( $scope.conversations, function ( conversation ) {
				return conversation.id == $scope.commentID;
			} );
			if ( conversation ) {
				$scope.markCommentsAsRead( conversation );
			}
		} );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				hasActiveConversationWithDirtyData = false;
				if ( requestContext.haveParamsChanged( [ "projectID", "screenID" ] ) ) {
					clearExcludedConversationIDs();
					visitedUnreadConversationIDs = [];
				}
				if ( requestContext.hasParamChanged( "commentID" ) ) {
					$scope.commentID = requestContext.getParamAsInt( "commentID" );
					$scope.closeAllConversationPanels();
					if ( $scope.commentID ) {
						excludeConversationIDFromFiltering( $scope.commentID );
						$scope.showConversationPanel( $scope.commentID );
					}
				}
			}
		);
		$scope.$on(
			"conversationsChanged",
			function ( event, conversations ) {
				updateUnreadConversations();
				applyFilters();
				$scope.showConversationPanel( $scope.commentID );
			}
		);
		$scope.setWindowTitle( $scope.project.name + " Comment Mode" );
		if ( requestContext.getParamAsInt( "commentID" ) ) {
			excludeConversationIDFromFiltering( $scope.commentID );
		}
		if ( $scope.conversations.length ) {
			updateUnreadConversations();
			applyFilters();
			$scope.showConversationPanel( $scope.commentID );
		}
	}
} )( angular, InVision );;;
/*! history-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "console.HistoryController", Controller );
	/** @ngInject */
	function Controller( $location, $scope, requestContext, $window, _, $timeout, modelEvents, moment, Deferred, screenHistoryService, userService ) {
		function loadRemoteData() {
			Deferred.handlePromise(
				screenHistoryService.get( $scope.screenID ),
				function ( response ) {
					$scope.screenVersions = response.versions;
					$scope.screenComments = response.comments;
					$scope.activateVersion( _.last( $scope.screenVersions ) );
				},
				function ( response ) {}
			);
		}

		function augmentVersion( version ) {
			var start, end;
			version.isCurrent = ( version.endedAt === '' );
			version.lifespanHumanized = "";
			version.createdByUsersAvatar = "/avatars/" + version.avatarID;
			version.createdByUserInitials = userService.getInitials( version.userName );
			version.createdByUserHasSystemAvatar = userService.isSystemAvatar( version.avatarID );
			version.shortUserName = userService.getShortName( version.userName );
			version.timeLabel = moment( version.createdAt ).format( "MMM D [at] h:mma" );
			start = moment( version.createdAt );
			if ( !version.isCurrent ) {
				end = moment( version.endedAt );
			} else {
				end = moment();
			}
			version.lifespanHumanized = start.from( end, true );
		}

		function augmentUser( user ) {
			user.shortName = userService.getShortName( user.userName );
			user.initials = userService.getInitials( user.userName );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			return user;
		}

		function augmentUsers( users ) {
			_.each( users, augmentUser );
			return users;
		}

		function getIndexOfDisplayedVersion() {
			var versionIndex = _.indexOfWithProperty( $scope.screenVersions, "version", $scope.activeVersion.version );
			return versionIndex;
		}

		function handleConfigUpdateOrLoad( config ) {
			var cssToApply = {};
			if ( !$scope.isFullBrowser ) {
				return;
			}
			cssToApply.backgroundColor = "#" + config.backgroundColor;
			if ( config.alignment != "center" ) {
				cssToApply[ "float" ] = config.alignment;
			} else {
				cssToApply.margin = "0 auto";
				cssToApply[ "float" ] = "none";
			}
			if ( _.isObject( config.backgroundImage ) && ( config.backgroundImage.id > 0 ) ) {
				cssToApply.backgroundImage = "url('" + config.backgroundImage.imageUrl + "')";
				var backgroundPositionY = "0";
				if ( $scope.subview == "build" ) {
					backgroundPositionY = "47px";
				}
				switch ( config.backgroundImagePosition ) {
				case "center":
					cssToApply.backgroundRepeat = "no-repeat";
					cssToApply.backgroundPosition = "50% " + backgroundPositionY;
					break;
				case "tile":
					cssToApply.backgroundRepeat = "repeat";
					cssToApply.backgroundPosition = "0 " + backgroundPositionY;
					break;
				case "tile-horizontally":
					cssToApply.backgroundRepeat = "repeat-x";
					cssToApply.backgroundPosition = "0 " + backgroundPositionY;
					break;
				default:
					break;
				}
			} else {
				cssToApply.backgroundImage = "none";
			}
			$scope.screenFloat = {
				"float": cssToApply[ "float" ]
			};
			$scope.updateBodyStyle( cssToApply );
			if ( !_.isUndefined( $scope.bodyStyle.backgroundPosition ) ) {
				var currentBackgroundPosition = $scope.bodyStyle.backgroundPosition;
				var currentBackgroundPositionX = currentBackgroundPosition.split( " " )[ 0 ];
				var backgroundPositionY = "0";
				$scope.updateBodyStyle( {
					"backgroundPosition": currentBackgroundPositionX + " " + backgroundPositionY
				} );
			}
		}
		$scope.activateVersion = function ( version ) {
			augmentVersion( version );
			$scope.activeVersion = version;
			$scope.activeVersionParticipants = augmentUsers( $scope.screenComments[ version.version ] );
			$scope.totalCommentsThisVersion = _.reduce( $scope.activeVersionParticipants, function ( sum, commentors ) {
				return sum + commentors.commentCount;
			}, 0 );
			var versionIndex = _.indexOfWithProperty( $scope.screenVersions, "version", version.version );
			$scope.hasPreviousVersion = versionIndex > 0;
			$scope.hasNextVersion = versionIndex < ( $scope.screenVersions.length - 1 );
			handleConfigUpdateOrLoad( $scope.config );
		};
		$scope.toggleExpandedView = function () {
			$scope.isFullBrowser = !$scope.isFullBrowser;
			if ( $scope.isFullBrowser ) {
				$scope.clearBodyStyle();
				handleConfigUpdateOrLoad( $scope.config );
			} else {
				$scope.clearBodyStyle();
			}
		};
		$scope.closeExpandedView = function () {
			$scope.isFullBrowser = false;
			$scope.clearBodyStyle();
		};
		$scope.previousVersion = function () {
			var versionIndex = getIndexOfDisplayedVersion();
			var previousVersionIndex = Math.max( versionIndex - 1, 0 );
			$scope.activateVersion( $scope.screenVersions[ previousVersionIndex ] );
		};
		$scope.nextVersion = function () {
			var versionIndex = getIndexOfDisplayedVersion();
			var nextVersionIndex = Math.min( versionIndex + 1, $scope.screenVersions.length - 1 );
			$scope.activateVersion( $scope.screenVersions[ nextVersionIndex ] );
		};
		var renderContext = requestContext.getRenderContext( "console.history", [ "projectID", "screenID" ] );
		$scope.screenComments = {};
		$scope.screenVersions = [];
		$scope.activeVersion = null;
		$scope.totalCommentsThisVersion = 0;
		$scope.showSuccessMessage = false;
		$scope.isFullBrowser = false;
		$scope.hasNextVersion = false;
		$scope.hasPreviousVersion = false;
		$scope.screenFloat = {
			"float": "none"
		};
		$scope.$on( "$destroy", function () {
			modelEvents.trigger( "screenConfig:changed", $scope.config );
			modelEvents.off( "screenUploaded.historyMode" );
		} );
		$scope.$on(
			"historyImageLoaded",
			function ( event, imageElement ) {
				$scope.$emit( "consoleImageLoaded", imageElement );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( requestContext.hasParamChanged( "screenID" ) ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on(
			"screenUploaded.historyMode",
			function ( event, screen ) {
				if ( screen.projectID !== $scope.projectID ) {
					return;
				}
				loadRemoteData( screen );
			}
		);
		modelEvents.on(
			"screenConfig:changed",
			function ( event, newConfig ) {
				if ( _.isUndefined( newConfig ) ) {
					return;
				}
				handleConfigUpdateOrLoad( newConfig );
			}
		);
		$scope.setWindowTitle( $scope.project.name + " History Mode" );
		$scope.clearBodyStyle();
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! preview-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "console.PreviewController", Controller );
	/** @ngInject */
	function Controller( $location, $scope, BaseController, requestContext, $window, _, $timeout, hotspotService, screenService, Deferred, ipInfoService ) {
		function loadCountryCode() {
			Deferred.handlePromise(
				ipInfoService.getGeolocationData(),
				function ( response ) {
					$scope.sms.countryCode = response.country.toLowerCase();
				},
				function ( response ) {
					$scope.sms.countryCode = "us";
				}
			);
		}

		function overlayScreen( hotspot ) {
			var screenID,
				screen;
			if ( hotspot.targetTypeID === hotspotService.targetTypes.lastScreenVisited ) {
				screenID = $scope.navigateToPreviousScreen( "preview", true );
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.previousScreenInSort ) {
				screen = $scope.navigateToPreviousScreenInSort( true );
				$scope.openScreenAsOverlay( screen );
				return;
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.nextScreenInSort ) {
				screen = $scope.navigateToNextScreenInSort( true );
				$scope.openScreenAsOverlay( screen );
				return;
			} else {
				screenID = hotspot.targetScreenID;
			}
			if ( $scope.overlayScreen.id != screenID ) {
				$scope.cancelHover = false;
				Deferred.handlePromise(
					screenService.getByID( screenID, true ),
					function ( screen ) {
						if ( $scope.cancelHover == false ) {
							$scope.openScreenAsOverlay( screen );
						}
					},
					function ( response ) {}
				);
			} else {
				$scope.openScreenAsOverlay( $scope.overlayScreen );
			}
		}
		$scope.applyHotspotNavigation = function ( hotspot, eventType ) {
			if ( $scope.project.isMobile && hotspot.transitionTypeID > 1 ) {
				if ( hotspot.targetTypeID === hotspotService.targetTypes.lastScreenVisited ) {
					if ( $scope.previousScreenQueue.length ) {
						var id = $scope.previousScreenQueue[ $scope.previousScreenQueue.length - 1 ];
						var targetScreen = $scope.getScreenByID( id );
					}
				} else if ( hotspot.targetTypeID === hotspotService.targetTypes.previousScreenInSort ) {
					var targetScreen = $scope.getPreviousScreenInSort( $scope.screenID );
				} else if ( hotspot.targetTypeID === hotspotService.targetTypes.nextScreenInSort ) {
					var targetScreen = $scope.getNextScreenInSort( $scope.screenID );
				} else {
					var targetScreen = $scope.getScreenByID( hotspot.targetScreenID );
				}
				if ( targetScreen && !isNaN( targetScreen.id ) ) {
					$scope.transitionData = {
						transitionTypeID: hotspot.transitionTypeID,
						currentScreenID: $scope.screen.id,
						currentScreenImageVersion: $scope.screen.imageVersion,
						currentScreenFixedHeaderHeight: $scope.screen.fixedHeaderHeight,
						currentScreenFixedFooterHeight: $scope.screen.fixedFooterHeight,
						targetScreenID: targetScreen.id,
						targetScreenImageVersion: targetScreen.imageVersion
					}
					$scope.setIsTransitioning( true );
				}
			}
			if ( _.isUndefined( eventType ) ) {
				eventType = "click";
			}
			if ( eventType == "click" && hotspot.eventTypeID == 8 && !$scope.project.isMobile ) {
				return false;
			} else if ( eventType == "hover" && ( hotspot.eventTypeID != 8 || $scope.project.isMobile ) ) {
				return false;
			}
			if ( hotspot.eventTypeID == 8 && !$scope.project.isMobile ) {
				if ( !hotspot.metaData.stayOnScreen ) { // if we're staying on the current screen, we need an overlay
					overlayScreen( hotspot );
					return false;
				} else { // maintain scroll position by default if we're changing screens
					$scope.maintainScrollPositionOnNextScreenLoad();
				}
			}
			$scope.setIsHotspotNavigation( true );
			if ( hotspot.targetTypeID === hotspotService.targetTypes.lastScreenVisited ) {
				$scope.navigateToPreviousScreen( "preview" );
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.previousScreenInSort ) {
				if ( eventType == "clickFromOverlay" ) {
					$scope.navigateToPreviousScreenInSort( false, $scope.overlayScreen.id );
				} else {
					$scope.navigateToPreviousScreenInSort();
				}
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.nextScreenInSort ) {
				if ( eventType == "clickFromOverlay" ) {
					$scope.navigateToNextScreenInSort( false, $scope.overlayScreen.id );
				} else {
					$scope.navigateToNextScreenInSort();
				}
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.externalUrl ) {
				$scope.navigateToExternalUrl( hotspot.metaData.url, hotspot.metaData.isOpenInNewWindow );
			} else if ( hotspot.targetTypeID === hotspotService.targetTypes.positionOnScreen ) {
				if ( hotspot.metaData.isSmoothScroll ) {
					var animateTime = 500;
				} else {
					var animateTime = 0;
				}
				if ( $scope.project.isMobile ) {
					var scrollOffset = hotspot.metaData.scrollOffset * ( $scope.project.mobileTemplate.viewportWidth / $scope.screen.width );
					$scope.scrollMobileViewport( scrollOffset, animateTime );
				} else {
					var scrollOffset = hotspot.metaData.scrollOffset * $scope.screen.displayScale;
					$( "body, html" ).animate( {
							scrollTop: scrollOffset
						},
						animateTime
					);
				}
			} else {
				$scope.navigateToScreen( hotspot.targetScreenID, "preview" );
			}
			if ( hotspot.isScrollTo ) {
				$scope.maintainScrollPositionOnNextScreenLoad();
			}
			if ( eventType == "clickFromOverlay" ) {
				$scope.hideOverlay();
			}
		};
		$scope.hideOverlay = function ( event ) {
			$scope.cancelHover = true;
			if ( !_.isUndefined( event ) ) {
				var toElem = event.relatedTarget || event.toElement;
				if ( $( toElem ).hasClass( 'hotspotOverlay' ) ) {
					return; //cancel the hide
				}
			}
			$scope.overlayImage = "";
			$scope.overlayHotspots = {};
			$scope.overlayScreen = {};
		};
		$scope.setupOverlay = function ( overlayImage, overlayHotspots, overlayScreen ) {
			$scope.overlayImage = overlayImage;
			$scope.overlayHotspots = overlayHotspots;
			$scope.overlayScreen = overlayScreen;
		}
		$scope.setIsTransitioning = function ( value ) {
			$scope.isTransitioning = value;
		}
		$scope.getFixedDesktopHeaderStyle = function () {
			var style = {};
			style = $.extend( style, $scope.screenFloat );
			var scaledHeight = {
				height: $scope.screen.fixedHeaderHeight * $scope.screen.displayScale
			};
			style = $.extend( style, scaledHeight );
			var leftOffset = {
				"margin-left": "-" + $scope.fixedDesktopHeaderLeftOffset + "px"
			};
			style = $.extend( style, leftOffset );
			return style;
		}
		$scope.setFixedDesktopHeaderLeftOffset = function ( leftOffset ) {
			$scope.fixedDesktopHeaderLeftOffset = parseInt( leftOffset );
		}
		$scope.floor = function ( value ) {
			return Math.floor( value );
		}
		$scope.ceil = function ( value ) {
			return Math.ceil( value );
		}
		var renderContext = requestContext.getRenderContext( "console.preview", [ "projectID", "screenID" ] );
		$scope.overlayImage = "";
		$scope.overlayHotspots = {};
		$scope.overlayScreen = {}; // used for caching
		$scope.setWindowTitle( $scope.project.name + " Preview Mode" );
		$scope.isTransitioning = false;
		$scope.transitionData = {};
		$scope.cancelHover = false;
		$scope.fixedDesktopHeaderLeftOffset = 0;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
			}
		);
		loadCountryCode();
	}
} )( angular, InVision );;;
/*! dashboard-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "dashboard.DashboardController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $location, $timeout, requestContext ) {
		if ( $scope.isReviewer ) {
			$location.path( '/projects' );
		}
		$scope.isGoogleMapsApiLoaded = false;
		var renderContext = requestContext.getRenderContext( "standard.dashboard" );
		$scope.$on( "googleMapsLoaded", function () {
			$timeout( function () {
				$scope.isGoogleMapsApiLoaded = true;
			}, 0 );
		} );
		$scope.$on( 'teamDataChanged', function ( event, args ) {
			$scope.$broadcast( 'updateStats', args );
		} );
		if ( !( $scope.isEnterprise || $scope.isEnterpriseUser ) ) {
			$location.path( "/" );
		}
		$scope.setWindowTitle( "Enterprise Dashboard" );
		$window._kmq.push( [ 'record', 'Enterprise Dashboard page viewed' ] );
	}
} )( angular, InVision );;;
/*! dashboard-map-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "dashboard.DashboardMapController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $location, $timeout, Deferred, dashboardMapService, dashboardStatPartial, requestContext, sessionService, modelEvents, moment, userService, _ ) {
		function addMarkerForUser( user, openInfoBox ) {
			var latLong = new $window.google.maps.LatLng( user.latitude, user.longitude );
			var marker = new $window.google.maps.Marker( {
				position: latLong,
				customInfo: user,
				optimized: false
			} );
			var existingMarker = null;
			for ( var i = 0; i < $scope.myMarkers.length; i++ ) {
				if ( $scope.myMarkers[ i ].customInfo.id === user.id ) {
					existingMarker = $scope.myMarkers[ i ];
				}
			}
			if ( _.isNull( existingMarker ) ) {
				$scope.myMarkers.push( marker );
			} else {
				marker = existingMarker;
			}
			addMarkerToMap( marker, $scope.myMap );
			if ( openInfoBox ) {
				$scope.myInfoBox.open( $scope.myMap, marker );
			}
		}

		function addMarkerToMap( marker, map ) {
			marker.setMap( map );
		}

		function removeMarkerFromMap( marker ) {
			marker.setMap( null );
		}

		function addMarkerForUserID( userID ) {
			var user = _.findWithProperty( allTeamMembers, "id", userID );
			if ( !_.isUndefined( user ) ) {
				augmentUserWithMarker( user );
				loadMapMarkerForUser( user );
			}
		}

		function augmentUser( user ) {
			user.initials = userService.getInitials( user.name );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			if ( user.name.toLowerCase() == "anonymous user" ) {
				user.name = "A Share Link Viewer";
			}
			return ( user );
		}

		function augmentUsers( users ) {
			_.each( users, augmentUser );
			return ( users );
		}

		function augmentUsersWithMarkers( users ) {
			_.forEach( users, augmentUserWithMarker );
			return users;
		}

		function augmentUserWithMarker( user ) {
			if ( ( user.latitude === "" ) || ( user.longitude === "" ) ) {
				var coordinates = getRandomCoordinates();
				user.latitude = coordinates.latitude;
				user.longitude = coordinates.longitude;
			}
			if ( _.isUndefined( user.mapMarker ) ) {
				var latLong = new $window.google.maps.LatLng(
					user.latitude,
					user.longitude
				);
				var marker = new $window.google.maps.Marker( {
					position: latLong,
					customInfo: user
				} );
				user.mapMarker = marker;
			}
		}

		function getRandomCoordinates() {
			var options = [ {
				latitude: 19.611544,
				longitude: -155.505981
			}, {
				latitude: -17.640096,
				longitude: -149.454575
			}, {
				latitude: 18.177169,
				longitude: -76.712036
			}, {
				latitude: 21.796483,
				longitude: -72.282486
			} ];
			return (
				options[ _.random( options.length - 1 ) ]
			);
		}

		function getMarkerForUserID( userID ) {
			var marker = _.find( $scope.myMarkers, function ( marker ) {
				return ( marker.customInfo.id === userID );
			} );
			return marker;
		}

		function loadDataIntoScopeFromMarker( marker ) {
			var user = marker.customInfo;
			$scope.mapPopup.user.name = user.name;
			$scope.mapPopup.user.initials = user.initials;
			$scope.mapPopup.user.avatarUrl = "/avatars/" + user.avatarID;
		}

		function showNextActivityItem() {
			var currentActivity = teamActivityQueue.pop();
			$scope.myInfoBox.close();
			if ( _.isUndefined( currentActivity ) ) {
				$window.clearInterval( teamActivityDisplayTimer );
				return;
			}
			switch ( currentActivity.action ) {
			case "screenAdded":
				screenAdded( currentActivity );
				break;
			case "screenReplaced":
				screenReplaced( currentActivity );
				break;
			case "commentCreated":
				commentCreated( currentActivity );
				break;
			case "devNoteCreated":
				commentCreated( currentActivity );
				break;
			case "collaboratorAdded":
				collaboratorAdded( currentActivity );
				break;
			case "shareLinkViewed":
				shareLinkViewed( currentActivity );
				break;
			case "projectCreated":
				projectCreated( currentActivity );
				break;
			default:
				break;
			}
		}

		function processTeamActivity( newTeamActivity ) {
			var currentActivity = null,
				usersMarker = null,
				throttle = 10;
			teamActivityQueue = teamActivityQueue.concat( newTeamActivity );
			if ( teamActivityQueue.length < 4 ) {
				throttle = 24;
			} else if ( teamActivityQueue.length <= 10 ) {
				throttle = 12;
			} else if ( teamActivityQueue.length <= 20 ) {
				throttle = 6;
			}
			showNextActivityItem();
			teamActivityDisplayTimer = $window.setInterval( showNextActivityItem, throttle * 1000 );
		}

		function continuallyPollForActivity() {
			if ( _.isNull( onlineUserTimerID ) ) {
				loadOnlineUsersInTeam();
				onlineUserTimerID = $window.setInterval(
					loadOnlineUsersInTeam,
					60 * 1000
				);
			}
			if ( _.isNull( userActivityTimerID ) ) {
				loadRemoteActivity();
				userActivityTimerID = $window.setInterval(
					loadRemoteActivity,
					60 * 1000
				);
			}
		}

		function loadRemoteActivity() {
			Deferred.handlePromise(
				dashboardMapService.getRecentEvents( $scope.user.id ),
				function ( response ) {
					if ( response.teamActivity.length > 0 ) {
						processTeamActivity( response.teamActivity );
						$scope.$emit( 'teamDataChanged', response.teamActivity );
					}
				},
				function ( response ) {}
			);
		}

		function loadOnlineUsersInTeam() {
			Deferred.handlePromise(
				dashboardStatPartial.get( $scope.user.id, 1, 365 ),
				function ( response ) {
					var onlineTeamMembers = augmentUsers( response.onlineTeamMembers );
					var onlineStakeholders = augmentUsers( response.onlineStakeholders );
					removeStaleMarkers();
					allTeamMembers = response.teamMembers.concat( onlineStakeholders );
					augmentUsersWithMarkers( allTeamMembers );
					augmentUsersWithMarkers( onlineTeamMembers );
					loadMapMarkers( onlineTeamMembers );
					loadMapMarkers( onlineStakeholders );
					$scope.onlineUserCount = onlineTeamMembers.length;
					$scope.shareViewerCount = onlineStakeholders.length;
				},
				function ( response ) {}
			);
		}

		function initialize() {
			$scope.myMarkers = [];
			loadOnlineUsersInTeam();
			continuallyPollForActivity();
		}

		function loadMapMarkers( usersToAddMarkersFor ) {
			_.forEach( usersToAddMarkersFor, loadMapMarkerForUser );
		}

		function loadMapMarkerForUser( user ) {
			addMarkerForUser( user, false );
		}

		function zoomMapToShowAllMarkers( map ) {
			var bounds = new google.maps.LatLngBounds();
			_.forEach( $scope.myMarkers, function ( marker ) {
				bounds.extend( marker.position );
			} );
			map.fitBounds( bounds );
		}

		function triggerMapEvent( eventConfig ) {
			var userMarker = getMarkerForUserID( eventConfig.userID );
			if ( _.isUndefined( userMarker ) ) {
				addMarkerForUserID( eventConfig.userID );
				userMarker = getMarkerForUserID( eventConfig.userID );
			}
			if ( _.isUndefined( userMarker ) ) {
				loadOnlineUsersInTeam();
				return;
			}
			updateMarkerFreshness( userMarker );
			loadDataIntoScopeFromMarker( userMarker );
			$scope.mapPopup.hasAction = true;
			$scope.mapPopup.screenLink = eventConfig.screenLink;
			$scope.mapPopup.projectLink = eventConfig.projectLink;
			$scope.mapPopup.projectName = eventConfig.projectName;
			$scope.mapPopup.action = eventConfig.action;
			$scope.myInfoBox.open( $scope.myMap, userMarker );
		}

		function getProjectDetailUrl( projectID ) {
			return ( "/d/main#/projects/" + projectID );
		}

		function getScreenDetailUrl( projectID, screenID ) {
			return ( "/d/main#/console/" + projectID + "/" + screenID + "/preview" );
		}

		function updateMarkerFreshness( marker ) {
			marker.customInfo.considerInactiveAt = moment( marker.customInfo.considerInactiveAt ).add( "minutes", 1 ).valueOf();
		}

		function removeStaleMarkers() {
			for ( var i = 0; i < $scope.myMarkers.length; i++ ) {
				var user = $scope.myMarkers[ i ].customInfo;
				if ( $scope.user.id !== user.id && moment().utc().isAfter( user.considerInactiveAt ) ) {
					$scope.myMarkers[ i ].setMap( null );
					$scope.myMarkers.splice( i, 1 );
				}
			}
		}

		function commentCreated( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					isInstant: true,
					type: "commentCreated",
					quantity: data.actionOccuredXTimes
				},
				screenLink: getScreenDetailUrl( data.projectID, data.screenID ),
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			if ( data.action === "devNoteCreated" ) {
				event.action.type = "devNoteCreated";
			}
			triggerMapEvent( event );
		}

		function screenAdded( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					isInstant: true,
					type: "screenAdded",
					quantity: data.actionOccuredXTimes
				},
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			if ( data.actionOccuredXTimes === 1 ) {
				event.screenLink = getScreenDetailUrl( data.projectID, data.screenID );
			}
			triggerMapEvent( event );
		}

		function screenReplaced( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					isInstant: true,
					type: "screenReplaced",
					quantity: data.actionOccuredXTimes
				},
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			if ( data.actionOccuredXTimes === 1 ) {
				event.screenLink = getScreenDetailUrl( data.projectID, data.screenID );
			}
			triggerMapEvent( event );
		}

		function collaboratorAdded( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					isInstant: true,
					type: "collaboratorAdded",
					quantity: data.actionOccuredXTimes
				},
				screenLink: "",
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			triggerMapEvent( event );
		}

		function shareLinkViewed( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					isInstant: true,
					type: "viewedShareLink",
					quantity: data.actionOccuredXTimes
				},
				screenLink: "",
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			triggerMapEvent( event );
		}

		function projectCreated( data ) {
			var event = {
				userID: data.userID,
				hasAction: true,
				action: {
					type: "createdProject",
					quantity: data.actionOccuredXTimes
				},
				screenLink: "",
				projectLink: getProjectDetailUrl( data.projectID ),
				projectName: data.projectName
			};
			triggerMapEvent( event );
		}
		$scope.onMapClick = function () {
			$scope.myInfoBox.close();
		};
		$scope.onMapIdle = function () {
			if ( mapJustLoaded ) {
				zoomMapToShowAllMarkers( $scope.myMap );
				mapJustLoaded = false;
			}
		};
		$scope.markerClicked = function ( marker ) {
			$scope.mapPopup.hasAction = false;
			loadDataIntoScopeFromMarker( marker );
			$scope.myInfoBox.open( $scope.myMap, marker );
		};
		$scope.swapSizeState = function () {
			$scope.isFullScreen = ( !$scope.isFullScreen );
			if ( $scope.isFullScreen ) {
				var el = document.getElementById( "map-container" ),
					rfs = el.requestFullScreen ||
					el.webkitRequestFullScreen ||
					el.mozRequestFullScreen;
				rfs.call( el );
			} else {
				var el = document,
					efs = el.cancelFullScreen ||
					el.webkitCancelFullScreen ||
					el.mozCancelFullScreen;
				efs.call( el );
			}
		};
		var renderContext = requestContext.getRenderContext( "standard.dashboard" );
		var allTeamMembers = [];
		var userActivityTimerID = null;
		var onlineUserTimerID = null;
		var teamActivityDisplayTimer = null;
		var teamActivityQueue = [];
		var mapJustLoaded = true;
		$scope.mapInfoBoxConfig = {
			disableAutoPan: false,
			maxWidth: 0,
			pixelOffset: new google.maps.Size( -133, -120 ),
			zIndex: null,
			boxStyle: {
				opacity: 1,
				width: "250px"
			},
			closeBoxURL: "",
			infoBoxClearance: new google.maps.Size( 30, 30 ),
			isHidden: false,
			pane: "floatPane",
			enableEventPropagation: false
		};
		$scope.mapOptions = {
			center: new $window.google.maps.LatLng( 40.687537, -74.064331 ),
			zoom: 3,
			minZoom: 2,
			maxZoom: 12,
			panControl: false,
			streetViewControl: false,
			mapTypeId: $window.google.maps.MapTypeId.TERRAIN,
			mapTypeControlOptions: {
				mapTypeIds: $window.google.maps.MapTypeId.TERRAIN
			}
		};
		$scope.mapPopup = {
			user: {
				name: '',
				avatarUrl: ''
			},
			hasAction: false,
			action: {
				type: '',
				quantity: 0,
				subtype: '',
				isInstant: false
			},
			screenLink: '',
			projectLink: ''
		};
		$scope.myMarkers = [];
		$scope.onlineUserCount = 0;
		$scope.shareViewerCount = 0;
		$scope.isFullScreen = false;
		$scope.canUseFullScreenApi = false;
		$scope.remoteCalls = 0;
		$scope.$on( "$destroy", function () {
			$window.clearInterval( onlineUserTimerID );
			$window.clearInterval( userActivityTimerID );
			$window.clearInterval( teamActivityDisplayTimer );
		} );
		$scope.$watch( "onlineUserCount", function ( newValue, oldValue ) {
			if ( newValue == oldValue ) {
				return;
			}
			if ( newValue > oldValue ) {
				zoomMapToShowAllMarkers( $scope.myMap );
			}
		} );
		initialize();
	}
} )( angular, InVision );;;
/*! dashboard-stats-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "dashboard.DashboardStatsController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, requestContext, $location, Deferred, modelEvents, dashboardStatPartial, dateHelper, moment, _, projectOverviewService, projectService, dashboardMapService, userService ) {
		function applyRemoteData( stats, users, projects ) {
			$scope.stats.projectCount = stats.totalProjects;
			$scope.stats.screenCount = stats.totalScreens;
			$scope.stats.stakeholderCount = stats.totalStakeholderViews;
			$scope.stats.commentCount = stats.totalComments;
			$scope.stats.revisionsPerScreen = stats.totalRevsPerScreen;
			$scope.stats.commentsPerProject = stats.totalCommentsPerProject;
			_.defaults( $scope.stats, getDefaultStats() );
			var userViews = [];
			var i = 0;
			var projectViews = [];
			_.forEach( users, function ( user ) {
				i++;
				if ( $.trim( user.viewer_location ) === "," ||
					$.trim( user.viewer_location ) === "-, -" ) {
					user.viewer_location = "";
				}
				userViews.push( {
					avatarID: user.avatarID,
					companyID: user.companyID,
					userID: user.userID,
					userFullName: user.userFullName.replace( /Anonymous User/, "Anonymous" ),
					nameInitials: userService.getInitials( user.userFullName ),
					email: user.email,
					projectCount: user.projectCount,
					memberHasSystemAvatar: userService.isSystemAvatar( user.avatarID ),
					viewer_location: user.viewer_location,
					revisions: user.totalRevisions,
					comments: user.totalComments,
					rank: i,
					roleID: user.roleID,
					roleName: user.roleName
				} );
			} );
			viewStore[ 'users' ] = userViews;
			i = 0;
			_.forEach( projects, function ( project ) {
				i++;
				projectViews.push( {
					projectID: project.projectID,
					name: project.name,
					createdAt: project.createdAt,
					revisions: project.totalRevisions,
					views: project.totalViews,
					comments: project.totalComments,
					people: project.totalPeople,
					homeScreenID: project.homeScreenID,
					rank: i
				} );
			} );
			viewStore[ 'projects' ] = projectViews;
			$scope.projectViews[ 'users' ] = getViewsForPagination( viewStore, "users" );
			$scope.projectViews[ 'projects' ] = getViewsForPagination( viewStore, "projects" );
			$scope.setCurrentPage( 1, "users" );
			$scope.setCurrentPage( 1, "projects" );
			$scope.pagination.users.totalResults = userViews.length;
			$scope.pagination.projects.totalResults = projectViews.length;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			$scope.timespans = createTimespans( new Date(), new Date( 2001, 0, 1 ) );
			var timespan = "";
			if ( !$scope.selectedTimespan ) {
				$scope.selectedTimespan = getDefaultTimespan();
			}
			timespan = $scope.selectedTimespan;
			var startTime = Math.min( timespan.start.unix(), new Date( 2001, 0, 1 ) );
			var endTime = timespan.end.unix() + ( moment().zone() * 60 );
			if ( $scope.isContributor && !$scope.enterpriseConfig.permissions.canDesignersViewAllProjects ) {
				var promise = projectOverviewService.getStatsByUser( $scope.user.id, startTime, endTime );
			} else {
				var promise = projectOverviewService.getCompanyStats( $scope.user.id, startTime, endTime );
			}
			Deferred.handlePromise(
				promise,
				function ( statsData ) {
					$scope.isLoading = false;
					applyRemoteData( statsData.stats, statsData.users, statsData.projects );
				}
			);
		}

		function clearStats() {
			_.each( $scope.statJustChanged, function ( stat ) {
				stat = false;
			} );
		}

		function createTimespan( date, spanRange, earliestDate ) {
			var range = spanRange || "day";
			/*
range can be "day", "week", "earlier"
"day" maps to beginging of date to end of date passed in
"lastWeek" maps to begining of day that is -1 week from date to date end
"earlier" maps from epoch to end of date
*/
			var timespan = {};
			switch ( range ) {
			case "day":
				timespan.isDefault = false;
				timespan.start = moment( date ).startOf( "day" );
				timespan.end = moment( date ).endOf( "day" );
				timespan.label = dateHelper.formatRecentDate( date, "ddd" );
				break;
			case "lastWeek":
				timespan.start = moment( date ).clone().startOf( "day" ).subtract( "weeks", 1 );
				timespan.end = moment( date ).clone().endOf( "day" );
				timespan.label = "Last 7 Days";
				timespan.isDefault = true;
				break;
			case "last2Weeks":
				timespan.start = moment( date ).clone().startOf( "day" ).subtract( "weeks", 2 );
				timespan.end = moment( date ).clone().endOf( "day" );
				timespan.label = "Last 2 Weeks";
				timespan.isDefault = false;
				break;
			case "lastMonth":
				timespan.start = moment( date ).clone().startOf( "day" ).subtract( "month", 1 );
				timespan.end = moment( date ).clone().endOf( "day" );
				timespan.label = "Last Month";
				timespan.isDefault = false;
				break;
			case "earlier":
				timespan.start = moment.utc( earliestDate );
				timespan.end = moment.utc( date );
				timespan.label = "Overall";
				timespan.isDefault = false;
				break;
			}
			return timespan;
		}

		function createTimespans( currentDate, projectStartDate ) {
			var timeSpans = [];
			var today = moment( currentDate );
			var yesterday = today.clone().subtract( "days", 1 );
			var tmpDate = today.clone().subtract( "days", 2 );
			timeSpans.push( createTimespan( today, "day", projectStartDate ) );
			timeSpans.push( createTimespan( yesterday, "day", projectStartDate ) );
			/*
if( today.day() != 1 && today.day() != 2 ) {
for(
tmpDate = today.clone().subtract( "days", 2 ) ;
tmpDate.day() != 0;
tmpDate.subtract( "days", 1 )
) {
timeSpans.push( createTimespan( tmpDate, "day", projectStartDate ) );
}
}*/
			timeSpans.push( createTimespan( moment(), "lastWeek", projectStartDate ) );
			timeSpans.push( createTimespan( moment(), "last2Weeks", projectStartDate ) );
			timeSpans.push( createTimespan( moment(), "lastMonth", projectStartDate ) );
			timeSpans = _.filter( timeSpans, function ( timeSpan ) {
				if ( _.isUndefined( projectStartDate ) ) {
					return true;
				} else {
					var isTimeSpanAfterProject = (
						timeSpan.end.isAfter( moment( projectStartDate ).startOf( "day" ) ) ||
						timeSpan.end.isSame( moment( projectStartDate ).startOf( "day" ) )
					);
					return ( isTimeSpanAfterProject );
				}
			} );
			return timeSpans;
		}

		function emphasizeStat( stat ) {
			$scope.statJustChanged[ stat ] = true;
			$timeout(
				function () {
					$scope.statJustChanged[ stat ] = false;
				},
				6 * 1000
			);
		}

		function getViewsForPagination( viewCollection, type ) {
			var views = viewCollection[ type ];
			var pagination = $scope.pagination[ type ];
			var startIndex = ( pagination.currentPage - 1 ) * pagination.resultsPerPage;
			var endIndex = 0;
			endIndex = startIndex + pagination.resultsPerPage;
			$scope.pagination[ type ].firstResultBeingViewed = startIndex + 1;
			$scope.pagination[ type ].lastResultBeingViewed = _.min( [ endIndex, views.length ] );
			$scope.pagination[ type ].hasMorePages = ( endIndex < views.length );
			return views.slice( startIndex, endIndex );
		}

		function getDefaultTimespan() {
			return ( _.find( $scope.timespans, "isDefault" ) );
		}

		function getDefaultStats() {
			return ( {
				projectCount: 0,
				screenCount: 0,
				projectViews: 0,
				stakeholderCount: 0,
				revisionsPerScreen: 0,
				commentCount: 0,
				commentsPerProject: 0
			} );
		}
		$scope.setTimespan = function ( timespan ) {
			clearStats();
			$scope.respondingToRemoteData = false;
			$scope.selectedTimespan = timespan;
			loadRemoteData();
		};
		$scope.setResultsPerPage = function ( type ) { // we just add 10 to the number of results per page
			$scope.pagination[ type ].resultsPerPage = viewStore[ type ].length;
			$scope.setCurrentPage( 1, type );
			$scope.projectViews[ type ] = getViewsForPagination( viewStore, type );
		};
		$scope.setCurrentPage = function ( pageNum, type ) {
			var maxPages = Math.ceil( viewStore[ type ].length / $scope.pagination[ type ].resultsPerPage );
			var tmpPageNum = Math.max( pageNum, 1 );
			tmpPageNum = Math.min( tmpPageNum, maxPages );
			$scope.pagination[ type ].currentPage = tmpPageNum;
			$scope.projectViews[ type ] = getViewsForPagination( viewStore, type );
		};
		$scope.hasLocation = function ( loc ) {
			if ( !loc ) {
				return "noLocation";
			}
			return "";
		}
		$scope.showMemberModal = function ( member ) {
			$scope.openModalWindow( "enterpriseMember", member );
		};
		$scope.stats = {
			projectCount: 0,
			screenCount: 0,
			stakeholderCount: 0,
			projectViews: 0,
			revisionsPerScreen: 0,
			commentCount: 0,
			commentsPerProject: 0
		};
		$scope.pagination = {
			users: {
				resultsPerPage: 10,
				currentPage: 1,
				hasMorePages: false,
				firstResultBeingViewed: 1,
				lastResultBeingViewed: 1,
				totalResults: 0
			},
			projects: {
				resultsPerPage: 10,
				currentPage: 1,
				hasMorePages: false,
				firstResultBeingViewed: 1,
				lastResultBeingViewed: 1,
				totalResults: 0
			}
		}
		$scope.projectViews = {
			users: [],
			projects: []
		};
		$scope.projectViewStats = [];
		$scope.timespans = [];
		$scope.statJustChanged = {
			projectCount: false,
			screenCount: false,
			stakeholderCount: false,
			commentCount: false,
			revisionsPerScreen: false,
			commentsPerProject: false
		};
		$scope.respondingToRemoteData = false;
		$scope.$on( 'updateStats', function ( event, args ) {
			if ( $scope.selectedTimespan.label != 'Yesterday' ) {
				$scope.respondingToRemoteData = true;
				loadRemoteData();
			}
		} );
		$scope.$watch( 'stats', function ( newValue, oldValue ) {
			if ( $scope.respondingToRemoteData ) { // don't update anything in response to changing the date selector
				_.each( newValue, function ( val, stat ) {
					if ( val != oldValue[ stat ] ) {
						emphasizeStat( stat );
					}
				} );
				$scope.respondingToRemoteData = false;
			}
		}, true );
		$scope.$on(
			"$destroy",
			function () {}
		);
		var viewStore = {
			users: [],
			projects: []
		};
		var renderContext = requestContext.getRenderContext( "standard.dashboard" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! console-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.ConsoleController", Controller );
	/** @ngInject */
	function Controller( _, BaseController, sessionService, $rootScope, $scope, firebaseStateService, $window, $location, $timeout, requestContext, templateService, projectService, conversationService, consolePartial, modelEvents, screenService, hotspotService, Deferred, hashKeyCopier, userService, validationService, shareService, config, moment ) {
		var MOBILE_BUILD_BG = "afb2bd";

		function adjustBackgroundPosition( subview ) {
			if ( !_.isUndefined( $scope.bodyStyle.backgroundPosition ) ) {
				var currentBackgroundPosition = $scope.bodyStyle.backgroundPosition;
				var currentBackgroundPositionX = currentBackgroundPosition.split( " " )[ 0 ];
				var backgroundPositionY = "0";
				if ( subview === "build" || subview === "comments" ) {
					backgroundPositionY = "47px";
				}
				$scope.updateBodyStyle( {
					"backgroundPosition": currentBackgroundPositionX + " " + backgroundPositionY
				} );
			}
		}

		function augmentBackgroundImages( bgimages ) {
			var augmentedBgImages = [];
			var sort = 0;
			augmentedBgImages = _.sortBy( bgimages, "clientFilename" );
			_.forEach( augmentedBgImages, function ( img ) {
				img.sort = sort;
				img.type = "&nbsp;";
				if ( img.id == "autostretch" ) {
					img.sort = -2;
					img.type = "";
				} else if ( img.id == "frame" ) {
					img.sort = -1;
					img.type = "";
				} else if ( img.id === 0 ) {
					img.sort = -3;
					img.type = "";
				}
				sort++;
			} );
			return augmentedBgImages;
		}

		function augmentProjectPersons( persons ) {
			var augmentedPersons = [];
			augmentedPersons = _.rejectWithProperty( persons, "id", $scope.userID );
			augmentedPersons = _.setProperty( augmentedPersons, "isNotify", false );
			_.forEach( augmentedPersons, function ( person ) {
				person.initials = userService.getInitials( person.name );
				person.onlineStatus = userService.getOnlineStatus( person.lastRequestAt );
				person.hasSystemAvatar = userService.isSystemAvatar( person.avatarID );
			} );
			return augmentedPersons;
		}

		function augmentConversation( conversation ) {
			conversation.isShown = true;
			conversation.isUnread = hasUnreadComments( conversation );
			conversation.isSaved = ( conversation.id !== 0 );
			conversation.isConversationPanelVisible = false;
			_.each(
				conversation.comments,
				function ( comment, index, collection ) {
					var isFirstOrLastN = false,
						isCollapsed = false,
						isFirstCollapsed = false,
						previousCollapsedComments = [];
					isFirstOrLastN = ( index === 0 || index >= ( collection.length - 3 ) );
					previousCollapsedComments = _.filterWithProperty( collection.slice( 0, index ), "isCollapsed", true );
					isCollapsed = !( isFirstOrLastN || comment.isUnread );
					isFirstCollapsed = isCollapsed && ( previousCollapsedComments.length === 0 );
					comment.isFirstCollapsed = isFirstCollapsed;
					comment.isCollapsed = isCollapsed;
					comment.userInitials = userService.getInitials( comment.userName );
					comment.userHasSystemAvatar = userService.isSystemAvatar( comment.avatarID );
					comment.html = conversationService.getHtmlForComment( comment.comment );
					comment.userOnlineStatus = userService.getOnlineStatus( comment.lastRequestAt );
					comment.userFirstName = comment.userName.split( " " )[ 0 ];
					comment.niceDate = moment( comment.createdAt ).fromNow();
					comment.likedByList = conversationService.formatCommentLikers( comment );
				}
			);
			if ( !_.isUndefined( conversation.comments ) ) {
				conversation.collapsedCommentCount = _.countWithProperty( conversation.comments, "isCollapsed", true );
			} else {
				conversation.collapsedCommentCount = 0;
			}
			return ( conversation );
		}

		function augmentConversations( conversations ) {
			_.each( conversations, augmentConversation );
			conversations = filterConversations( conversations );
			return ( conversations );
		}

		function filterConversations( conversations ) {
			if ( $scope.isReviewer ) {
				conversations = _.withoutProperty( conversations, "isForDevelopment", true );
			}
			return conversations;
		}

		function augmentScreen( screen ) {
			screen.workflowStatus = "In Progress";
			screen.isCompleted = false;
			screen.isApproved = false;
			if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE ) {
				screen.workflowStatus = "Needs Approval";
				screen.isCompleted = true;
				screen.isApproved = false;
			} else if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE_AND_APPROVED ) {
				screen.workflowStatus = "Approved";
				screen.isCompleted = false;
				screen.isApproved = true;
			}
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function getNextAvailableConversationLabel() {
			var labels = _.pluck( $scope.conversations, "label" );
			var maxLabel = _.max(
				labels,
				function ( label ) {
					return ( parseInt( label, 10 ) );
				}
			);
			return ( ( parseInt( maxLabel, 10 ) || 0 ) + 1 );
		}
		/**
		 * Generates a GUID string, according to RFC4122 standards.
		 * @returns {String} The generated GUID.
		 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
		 * @author Slavik Meltser (slavik@meltser.info).
		 * @link http://slavik.meltser.info/?p=142
		 */
		function guid() {
			function _p8( s ) {
				var p = ( Math.random().toString( 16 ) + "000000000" ).substr( 2, 8 );
				return s ? "-" + p.substr( 0, 4 ) + "-" + p.substr( 4, 4 ) : p;
			}
			return _p8() + _p8( true ) + _p8( true ) + _p8();
		}

		function hasUnreadComments( conversation ) {
			return ( !!_.findWithProperty( conversation.comments, "isUnread", true ) );
		}

		function hideMenus() {
			$scope.hideScreenSizerMenu();
			$scope.hideConfigMenu();
			$scope.hideWorkflowStatusMenu();
			$scope.hideReplaceScreenUploader();
		}
		$scope.hideMenus = function () {
			hideMenus();
		};

		function setProjectAndScreenID() {
			$scope.addScreenToPreviousScreenQueue( $scope.screenID );
			$scope.projectID = requestContext.getParamAsInt( "projectID" );
			$scope.screenID = requestContext.getParamAsInt( "screenID" );
			$scope.currentScreenIndex = ( getScreenIndex( $scope.screenID ) + 1 );
		}

		function checkProcessingScreens() {
			$scope.isCheckProcessingScreens = true;
			var processingScreens = _.filterWithProperty( $scope.screens, "isProcessed", false );
			var screenIDsToCheck = _.difference(
				_.pluck( processingScreens, "id" ),
				$scope.checkingProcessingScreenIDs
			);
			for ( var i = 0; i < screenIDsToCheck.length; i++ ) {
				$scope.checkingProcessingScreenIDs.push( screenIDsToCheck[ i ] );
				Deferred.handlePromise(
					screenService.getByID( screenIDsToCheck[ i ], true ),
					function ( screen ) {
						if ( screen.isProcessed === true ) {
							updateScreenInCollection( screen );
						}
						$scope.checkingProcessingScreenIDs = _.without(
							$scope.checkingProcessingScreenIDs,
							screen.id
						);
					},
					function ( response ) {
						$scope.openModalWindow( "error", "For some reason, we can't check your screen's status. Try refreshing your browser." );
						$scope.checkingProcessingScreenIDs = _.without(
							$scope.checkingProcessingScreenIDs,
							screen.id
						);
					}
				);
			}
			processingScreens = _.filterWithProperty( $scope.screens, "isProcessed", false );
			if ( processingScreens.length > 0 ) {
				$timeout( checkProcessingScreens, 2000 );
			} else {
				$scope.isCheckProcessingScreens = false;
			}
		}

		function updateScreenInCollection( screen ) {
			var matchingScreen = _.findWithProperty( $scope.screens, "id", screen.id );
			if ( matchingScreen ) {
				_.extendExistingProperties( matchingScreen, screen );
			}
		}

		function convertBottomPositionedHotspots() {
			for ( var h = 0; h < $scope.hotspots.length; h++ ) {
				if ( $scope.hotspots[ h ].isBottomAligned ) {
					$scope.hotspots[ h ].y = $scope.screen.height - ( $scope.hotspots[ h ].y + $scope.hotspots[ h ].height );
				}
			}
		}

		function getScreen( screenID ) {
			return _.findWithProperty( $scope.screens, "id", screenID );
		}

		function getScreenIndex( screenID ) {
			return (
				_.indexOfWithProperty( $scope.screens, "id", screenID )
			);
		}

		function loadConfig( screen, project ) {
			$scope.config = _.pick( screen,
				"alignment",
				"zoomScrollBehavior",
				"backgroundColor",
				"backgroundImagePosition",
				"backgroundAutostretch",
				"backgroundFrame"
			);
			if ( !_.isUndefined( $scope.config.backgroundImagePosition ) ) {
				switch ( $scope.config.backgroundImagePosition ) {
				case "50% 0 no-repeat":
					$scope.config.backgroundImagePosition = "center";
					break;
				case "repeat":
					$scope.config.backgroundImagePosition = "tile";
					break;
				case "0 0 repeat-x":
					$scope.config.backgroundImagePosition = "tile-horizontally";
					break;
				}
			}
			if ( _.isNumber( screen.backgroundImageID ) ) {
				$scope.config.backgroundImage = getBackgroundById( screen.backgroundImageID );
				$scope.config.backgroundAutostretch = false;
				$scope.config.backgroundFrame = false;
			} else if ( screen.backgroundAutostretch ) {
				$scope.config.backgroundImage = getBackgroundById( "autostretch" );
				$scope.config.backgroundAutostretch = true;
			} else if ( screen.backgroundFrame ) {
				$scope.config.backgroundImage = getBackgroundById( "frame" );
				$scope.config.backgroundFrame = true;
			} else {
				$scope.config.backgroundImage = getBackgroundById( 0 );
				$scope.config.backgroundAutostretch = false;
				$scope.config.backgroundFrame = false;
			}
			$scope.config.mobileStatusbarIsVisible = project.mobileStatusbarIsVisible;
			$scope.config.mobileStatusbarIsHidden = !project.mobileStatusbarIsVisible; // only used in the ui.  The checkbox displays the opositie of the actual value
			$scope.config.mobileStatusbarIsOpaque = project.mobileStatusbarIsOpaque;
			$scope.config.mobileStatusbarBackgroundColor = project.mobileStatusbarBackgroundColor;
			$scope.config.mobileStatusbarFontColor = project.mobileStatusbarFontColor;
			$scope.config.mobileDeviceID = project.mobileDeviceID;
			if ( $scope.config.mobileStatusbarBackgroundColor === "" ) {
				if ( $scope.config.mobileStatusbarFontColor == "black" ) {
					$scope.config.mobileStatusbarBackgroundColorLabel = "#FFFFFF";
				} else if ( $scope.config.mobileStatusbarFontColor == "white" ) {
					$scope.config.mobileStatusbarBackgroundColorLabel = "#000000";
				}
				$scope.config.mobileStatusbarBackgroundIsTransparent = true;
			} else { // otherwise, display the actual color
				$scope.config.mobileStatusbarBackgroundColorLabel = $scope.config.mobileStatusbarBackgroundColor;
				$scope.config.mobileStatusbarBackgroundIsTransparent = false;
			}
			$scope.config.forceRefreshGUID = guid();
		}

		function getBackgroundById( backgroundId ) {
			return (
				_.find(
					$scope.backgroundImages,
					function ( aBackground ) {
						return ( aBackground.id == backgroundId );
					}
				)
			);
		}

		function getBackgroundPath( background ) {
			return ( "url( '" + background.imageUrl + "' )" );
		}

		function getDefaultIsImageLoading() {
			return ( true );
		}
		$scope.getNextScreenInSort = function ( currentScreenID ) {
			var currentScreenIndex = getScreenIndex( currentScreenID || $scope.screenID );
			if (
				( currentScreenIndex === -1 ) ||
				( currentScreenIndex === ( $scope.screens.length - 1 ) )
			) {
				return ( null );
			}
			return ( $scope.screens[ currentScreenIndex + 1 ] );
		};
		$scope.getPreviousScreenInSort = function ( currentScreenID ) {
			var currentScreenIndex = getScreenIndex( currentScreenID || $scope.screenID );
			if (
				( currentScreenIndex === -1 ) ||
				( currentScreenIndex === 0 )
			) {
				return ( null );
			}
			return ( $scope.screens[ currentScreenIndex - 1 ] );
		};

		function getScreenNextOrPreviousScreen( currentScreenID, nextOrPrevious ) {
			var movesInDirection = ( nextOrPrevious == "next" ) ? 1 : -1;
			var targetScreenIndex = 0;
			var targetScreen = null;
			var currentScreenID = currentScreenID || $scope.screenID;
			var currentScreenIndex = 0;
			_.find( $scope.screens,
				function ( screen, index ) {
					if ( screen.id === currentScreenID ) {
						currentScreenIndex = index;
						return true;
					}
				}
			);
			targetScreenIndex = currentScreenIndex + movesInDirection;
			if ( $scope.screens.length > targetScreenIndex && targetScreenIndex >= 0 ) {
				return $scope.screens[ targetScreenIndex ];
			} else {
				return $scope.screens[ currentScreenIndex ];
			}
		}

		function getScreensToPreload( currentScreenID ) {
			var screenIDIndex = {};
			var nextScreen = $scope.getNextScreenInSort( currentScreenID );
			var previousScreen = $scope.getPreviousScreenInSort( currentScreenID );
			if ( nextScreen ) {
				screenIDIndex[ nextScreen.id ] = true;
			}
			if ( previousScreen ) {
				screenIDIndex[ previousScreen.id ] = true;
			}
			for ( var i = 0, length = $scope.hotspots.length; i < length; i++ ) {
				var hotspot = $scope.hotspots[ i ];
				if ( hotspot.targetScreenID ) {
					screenIDIndex[ hotspot.targetScreenID ] = true;
				}
			}
			var screensToPreload = _.filter(
				$scope.screens,
				function ( screen ) {
					return ( screenIDIndex.hasOwnProperty( screen.id ) );
				}
			);
			return ( screensToPreload );
		}

		function addConversation( conversationID ) {
			var conversationExists = _.findWithProperty( $scope.conversations, "id", conversationID );
			if ( !conversationExists ) {
				Deferred.handlePromise(
					conversationService.getConversation( conversationID ),
					function ( conversation ) {
						$scope.conversations.push( augmentConversation( conversation ) );
						$scope.conversations = filterConversations( $scope.conversations );
						$scope.$broadcast( "conversationsChanged" );
					},
					function () {}
				);
				$scope.loadStakeholders();
			}
		}

		function deleteConversation( conversationID ) {
			$scope.conversations = _.rejectWithProperty( $scope.conversations, "id", conversationID );
			$scope.$broadcast( "conversationsChanged" );
		}

		function setTourSessions( subviewOrConfig ) {
			if ( !$scope.project ) {
				return false;
			}
			var seenTours = sessionService.get( "seenTours", {} ),
				projectID = $scope.project.id;
			if ( !( projectID in seenTours ) ) {
				seenTours[ projectID ] = [];
			}
			if ( !_.contains( seenTours[ projectID ], subviewOrConfig ) ) {
				seenTours[ projectID ].push( subviewOrConfig );
			}
			sessionService.set( "seenTours", seenTours );
		}

		function hasSeenTourForThisMode( subviewOrConfig ) {
			var seenTours = sessionService.get( "seenTours", {} );
			if ( !$scope.project || !seenTours ) {
				return false;
			}
			return _.contains( seenTours[ $scope.project.id ], subviewOrConfig );
		}

		function loadTourStepIfNeeded( subviewOrConfig ) {
			if ( !sessionService.user.hasSeenConsoleIntroModal && !hasSeenTourForThisMode( subviewOrConfig ) ) {
				if ( $scope.isConsoleTourOpen ) {
					$rootScope.$broadcast( "consoleSubviewChanged", subviewOrConfig );
				} else {
					$scope.openModalWindow( "consoleFirstUse", subviewOrConfig );
				}
			} else if ( $scope.isConsoleTourOpen ) {
				$rootScope.$broadcast( "consoleSubviewChanged", subviewOrConfig, true );
			}
			setTourSessions( subviewOrConfig );
		}
		$scope.views = {
			'preview': 'preview/preview.htm',
			'build': 'build/build.htm',
			'comments': 'comments/comments.htm',
			'history': 'history/history.htm'
		};
		$scope.reloadHotspots = function () {
			Deferred.handleAllPromises(
				[
					hotspotService.getByScreenID( $scope.screenID )
				],
				function ( hotspots ) {
					$scope.hotspots = hotspots;
					convertBottomPositionedHotspots();
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we can't load your screen's hotspots. Try refreshing your browser." );
				}
			);
		};
		$scope.setHotspots = function ( hotspots ) {
			$scope.hotspots = hotspots;
		};
		$scope.startNewConversation = function ( x, y, isForDevelopment ) {
			var conversation = augmentConversation( {
				id: 0,
				x: x,
				y: y,
				screenID: $scope.screenID,
				label: getNextAvailableConversationLabel(),
				isPrivate: false,
				isForDevelopment: isForDevelopment,
				isComplete: false,
				subscribers: []
			} );
			conversation.isConversationPanelVisible = true;
			$scope.conversations.push( conversation );
			$scope.$broadcast( "conversationsChanged" );
		};
		$scope.markScreenAsRead = function () {
			Deferred.handlePromise(
				screenService.markScreenAsRead( $scope.screenID )
			);
		};
		$scope.getScreenByID = function ( screenID ) {
			return _.findWithProperty( $scope.screens, "id", screenID );
		};
		$scope.loadData = function ( isFullLoad ) {
			if ( !isFullLoad ) {
				$scope.screen = getScreen( $scope.screenID );
			}
			$scope.isLoading = true;
			$scope.isDataLoading = true;
			$scope.hotspots = [];
			$scope.conversations = [];
			Deferred.handleAllPromises(
				[
					consolePartial.get( $scope.screenID )
				],
				function ( consolePartialResponse ) {
					if ( consolePartialResponse.project.isMobile === "" ) {
						$location.path( "/projects/" + consolePartialResponse.project.id + "/screens" );
					}
					if ( isFullLoad ) {
						$scope.project = consolePartialResponse.project;
						$scope.formAction = '/liveshare/create/' + consolePartialResponse.project.id;
						$scope.screens = augmentScreens( consolePartialResponse.activeScreens );
						$scope.currentScreenIndex = ( getScreenIndex( $scope.screenID ) + 1 );
						$scope.dividers = consolePartialResponse.dividers;
						$scope.mergeScreensAndDividersForDisplay();
						$scope.backgroundSwatches = consolePartialResponse.projectBackgroundColors;
						$scope.templates = consolePartialResponse.templates;
						$scope.projectOwner = consolePartialResponse.projectOwner;
						$scope.projectOwner.firstName = $scope.projectOwner.name.split( /\s/ )[ 0 ];
						$scope.isOwnedByUser = ( $scope.user.id === $scope.project.userID );
						$scope.templates = _.setProperty( $scope.templates, "isDeleted", false );
						$scope.backgroundImages = consolePartialResponse.projectBackgroundImages;
						$scope.backgroundImages.unshift( {
							id: "autostretch",
							clientFilename: "Auto Stretch"
						} );
						$scope.backgroundImages.unshift( {
							id: "frame",
							clientFilename: "Frame"
						} );
						$scope.backgroundImages.unshift( {
							id: 0,
							clientFilename: "No Image"
						} );
						$scope.backgroundImages = augmentBackgroundImages( $scope.backgroundImages );
						$scope.projectMembers = augmentProjectPersons( consolePartialResponse.projectMembers );
						$scope.projectStakeholders = augmentProjectPersons( consolePartialResponse.projectStakeholders );
						$scope.mobileDeviceTemplates = consolePartialResponse.mobileDevices;
						$scope.project.mobileTemplate = _.withProperty( $scope.mobileDeviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
						$scope.mobileDeviceTemplateSwitchingOptions = $scope.getDeviceTemplateSwitchingOptions();
						$scope.project.appIconScreen = _.withProperty( $scope.screens, "clientFilename", "apple-touch-icon.png" )[ 0 ] || "";
						$scope.project.loadingScreen = _.withProperty( $scope.screens, "clientFilename", "apple-touch-startup-image.png" )[ 0 ] || "";
						$scope.project.homeScreen = $scope.screens[ 0 ];
						$scope.applyScreenDisplayScaleToScreens();
					}
					$scope.hotspots = consolePartialResponse.hotspots;
					$scope.screensToPreload = hashKeyCopier.copyHashKeys( $scope.screensToPreload, getScreensToPreload( $scope.screenID ) );
					var openConversation = _.findWithProperty( $scope.conversations, "isConversationPanelVisible", true );
					$scope.conversations = augmentConversations( consolePartialResponse.conversations );
					if ( openConversation ) {
						var conversationToOpen = _.findWithProperty( $scope.conversations, "id", openConversation.id );
						if ( conversationToOpen ) {
							conversationToOpen.isConversationPanelVisible = true;
						}
					}
					$scope.$broadcast( "conversationsChanged" );
					$scope.screen = getScreen( $scope.screenID );
					loadConfig( $scope.screen, $scope.project );
					$scope.isDataLoading = false;
					$scope.isLoading = $scope.isImageLoading;
					if ( $scope.project.isOverQuota ) {
						$location.path( "/projects/" + $scope.project.id );
					}
					if ( $scope.screen.isUnread ) {
						$scope.screen.isUnread = false;
						$scope.markScreenAsRead();
					}
					$scope.subview = ( renderContext.getNextSection() || "preview" );
					convertBottomPositionedHotspots();
				},
				function ( error ) {
					if ( validationService.isMissingProjectPermission( error ) ) {
						$scope.openModalWindow( "requestPermission", $scope.projectID );
					} else if ( validationService.canJoinProject( error ) ) {
						$scope.openModalWindow( "joinTeamProject", $scope.projectID );
					} else {
						if ( validationService.isScreenNotFound( error ) ) {
							var message = "The screen the comment was left on has been deleted or archived.";
						} else if ( validationService.isProjectNotFound( error ) ) {
							var message = "The project you were attempting to view was not found.";
						} else {
							var message = "For some reason, we can't load your project. Try refreshing your browser.";
						}
						if ( error.id ) {
							message += ( " [ID: " + error.id + "]" );
						}
						$scope.openModalWindow( "error", message );
					}
					$location.path( "/" );
				}
			);
		};
		$scope.loadStakeholders = function () {
			$scope.isLoading = true;
			var promise = Deferred.handlePromise(
				projectService.getStakeholders( $scope.projectID ),
				function ( response ) {
					$scope.isLoading = false;
					$scope.projectStakeholders = augmentProjectPersons( _.setProperty( response, "isNotify", false ) );
				}
			);
			return ( promise );
		};
		$scope.addScreenToPreviousScreenQueue = function ( screenID ) {
			if ( screenID && !isNavigatingToPreviousScreen ) {
				$scope.previousScreenQueue.push( screenID );
			}
			isNavigatingToPreviousScreen = false;
		};
		$scope.mergeScreensAndDividersForDisplay = function () {
			var displayObjectsTemp = [];
			for ( var s = 0; s < $scope.screens.length; s++ ) {
				var dividers = _.filter( $scope.dividers, function ( divider ) {
					return divider.position == s;
				} );
				if ( dividers.length ) {
					for ( var d = 0; d < dividers.length; d++ ) {
						displayObjectsTemp.push( dividers[ d ] );
					}
				}
				if ( s === 0 ) {
					displayObjectsTemp.push( {
						type: "screen_upload_tile",
						label: "screen uploader"
					} );
				}
				var screenObj = $scope.screens[ s ];
				screenObj.type = "screenObj";
				displayObjectsTemp.push( screenObj );
			}
			var dividers = _.filter( $scope.dividers, function ( divider ) {
				return divider.position >= $scope.screens.length;
			} );
			if ( dividers ) {
				for ( var d = 0; d < dividers.length; d++ ) {
					displayObjectsTemp.push( dividers[ d ] );
				}
			}
			$scope.displayObjects = hashKeyCopier.copyHashKeys( $scope.displayObject, displayObjectsTemp );
		};
		$scope.getDividerIDByScreen = function ( screen ) {
			var dividerID = 0;
			if ( !$scope.dividers.length ) {
				return dividerID;
			}
			var screenDisplayObjectsIndex = _.indexOfWithProperty( $scope.displayObjects, "id", screen.id );
			var objects = $scope.displayObjects.slice( 0, screenDisplayObjectsIndex );
			var i = objects.length;
			while ( i-- ) {
				var isDivider = objects[ i ].type === "divider" ? true : false;
				if ( isDivider ) {
					dividerID = objects[ i ].dividerID;
					break;
				}
			}
			return dividerID;
		};
		$scope.applyScreenDisplayScaleToScreen = function ( screen, isConfigChange ) {
			if ( isConfigChange && isConfigChange === true ) {
				screen = $.extend( screen, $scope.config );
			}
			screen.displayScale = 1;
			if ( $scope.project.isMobile ) {
				screen.displayScale = ( $scope.project.mobileTemplate.viewportWidth / screen.width );
			}
			if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				screen.displayScale = 0.5;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				screen.displayScale = 0.3333;
			}
			if ( !$scope.project.isMobile && screen.zoomScrollBehavior == screenService.zoomScrollBehaviors.ZOOM_OUT_TO_BROWSER_WIDTH ) {
				var windowWidth = $( window ).width();
				if ( screen.width * screen.displayScale > windowWidth ) {
					screen.displayScale = ( windowWidth / screen.width );
				}
			}
			return ( screen );
		};
		$scope.getReverseDisplayScale = function ( screen ) {
			if ( $scope.project.isMobile ) {
				var displayScale = ( screen.width / $scope.project.mobileTemplate.viewportWidth );
			} else if ( !$scope.project.isMobile && screen.zoomScrollBehavior == screenService.zoomScrollBehaviors.ZOOM_OUT_TO_BROWSER_WIDTH && screen.displayScale < 1 ) {
				var windowWidth = $( window ).width();
				if ( screen.width > windowWidth ) {
					var displayScale = ( screen.width / windowWidth );
				} else {
					var displayScale = 1;
				}
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				var displayScale = 2;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				var displayScale = 0.3333;
			} else {
				var displayScale = 1;
			}
			return displayScale;
		};
		$scope.applyScreenDisplayScaleToScreens = function () {
			_.each( $scope.screens, $scope.applyScreenDisplayScaleToScreen );
		};
		$scope.backgroundAlignmentDisabled = function () {
			return $scope.config.backgroundImage && (
				$scope.config.backgroundImage.id === "autostretch" ||
				$scope.config.backgroundImage.id === 0 ||
				$scope.config.backgroundImage.id === "frame"
			);
		};
		$scope.showThumbnailTray = function () {
			$scope.isBrowseMode = false;
			$scope.isSelectingBulkScreens = false;
			$scope.$broadcast( "openThumbnailTray" );
		};
		$scope.hideThumbnailTray = function () {
			$scope.isBrowseMode = false;
			$scope.isSelectingBulkScreens = false;
			$scope.$broadcast( "closeThumbnailTray" );
		};
		$scope.toggleThumbnailTray = function () {
			$scope.$broadcast( "toggleThumbnailTray" );
		};
		$scope.showScreenMenu = function ( isBrowse, browseForHotspotID ) {
			hideMenus();
			$scope.isBrowseMode = true;
			$scope.browseForHotspotID = browseForHotspotID;
			$scope.$broadcast( "openHotspotBrowseMenu", browseForHotspotID );
		};
		$scope.selectScreen = function ( screen, mode, fromBrowse ) {
			if ( $scope.isSelectingBulkScreens ) {
				$scope.toggleTemplateForScreen( $scope.bulkScreensTemplate.id, screen.id );
			} else if ( $scope.isBrowseMode ) {
				$scope.$broadcast( "hotspot.browse.screen.selected", screen.id, $scope.browseForHotspotID );
				$scope.isBrowse = false;
				$scope.isBrowseMode = false;
				$scope.$broadcast( "closeThumbnailTray" );
			} else if ( fromBrowse ) {
				$scope.navigateToScreen( screen.id, mode );
				$scope.$broadcast( "closeThumbnailTray" );
			} else {
				$scope.navigateToScreen( screen.id, mode );
				$timeout( function delayCloseThumbnailTray() {
					$scope.$broadcast( "closeThumbnailTray" );
				}, 600 );
			}
		};
		$scope.hideWorkflowStatusMenu = function () {
			$scope.isWorkflowStatusMenuActive = false;
		};
		$scope.setWorkflowStatus = function ( workflowStatusID ) {
			if ( $scope.screen.workflowStatusID == workflowStatusID ) {
				return ( $scope.hideWorkflowStatusMenu() );
			}
			Deferred.handlePromise(
				screenService.setWorkflowStatus( $scope.screen.id, workflowStatusID ),
				function ( respons ) {
					if (
						( workflowStatusID != 1 ) &&
						$scope.projectMembers.length > 1
					) {
						$scope.openModalWindow( "workflowStatusNotification", $scope.screen.projectID, $scope.screen.id );
					}
				},
				function ( resposne ) {
					$scope.openModalWindow( "error", "For some reason we couldn't update your screen status. Try refreshing your browser." );
				}
			);
			$scope.screen.workflowStatusID = workflowStatusID;
			augmentScreen( $scope.screen );
			$scope.hideWorkflowStatusMenu();
		};
		$scope.showWorkflowStatusMenu = function () {
			hideMenus();
			$scope.isWorkflowStatusMenuActive = true;
		};
		$scope.toggleWorkflowStatusMenu = function ( $event ) {
			if ( $scope.isWorkflowStatusMenuActive ) {
				$scope.hideWorkflowStatusMenu();
			} else {
				$scope.showWorkflowStatusMenu();
			}
		};
		$scope.toggleConfigMenu = function ( event ) {
			if ( $scope.isConfigMenuActive ) {
				$scope.hideConfigMenu();
			} else {
				$scope.showConfigMenu();
			}
			event.preventDefault();
			return false;
		};
		$scope.hideConfigMenu = function () {
			if ( $scope.isConfigMenuActive ) {
				$scope.config = ng.copy( $scope.configBackup );
			}
			$scope.isConfigMenuActive = false;
		};
		$scope.showConfigMenu = function () {
			hideMenus();
			$scope.isConfigMenuActive = true;
			if ( _.isUndefined( $scope.config ) ) {
				loadConfig( $scope.screen, $scope.project );
			}
			$scope.configBackup = ng.copy( $scope.config );
			if ( !_.isUndefined( $scope.config.backgroundImage ) ) {
				$scope.config.backgroundImage = getBackgroundById( $scope.config.backgroundImage.id );
			}
			loadTourStepIfNeeded( "config" );
		};
		$scope.saveConfig = function () {
			$scope.isConfigMenuActive = false;
			if ( $scope.config.applyToAll === true ) {
				if ( $scope.config.backgroundImage.id == "autostretch" ) {
					$scope.config.backgroundAutostretch = true;
				} else {
					$scope.config.backgroundAutostretch = false;
				}
				if ( $scope.config.backgroundImage.id == "frame" ) {
					$scope.config.backgroundFrame = true;
				} else {
					$scope.config.backgroundFrame = false;
				}
				$scope.configBackup = ng.copy( $scope.config );
				projectService.setConfigDefaults( $scope.projectID, $scope.config );
				_.forEach( $scope.screens, function ( screen ) {
					screen.backgroundColor = $scope.config.backgroundColor;
					screen.backgroundImageID = $scope.config.backgroundImage.id;
					screen.backgroundImagePosition = $scope.config.backgroundImagePosition;
					screen.backgroundAutostretch = $scope.config.backgroundAutostretch;
					screen.backgroundFrame = $scope.config.backgroundFrame;
					screen.alignment = $scope.config.alignment;
					screen.zoomScrollBehavior = $scope.config.zoomScrollBehavior;
					screenService.saveConfig( screen );
				} );
				$scope.config.applyToAll = false;
			} else {
				if ( $scope.config.backgroundImage.id == "autostretch" ) {
					$scope.config.backgroundAutostretch = true;
				} else {
					$scope.config.backgroundAutostretch = false;
				}
				if ( $scope.config.backgroundImage.id == "frame" ) {
					$scope.config.backgroundFrame = true;
				} else {
					$scope.config.backgroundFrame = false;
				}
				$scope.configBackup = ng.copy( $scope.config );
				$scope.screen.backgroundColor = $scope.config.backgroundColor;
				$scope.screen.backgroundImageID = $scope.config.backgroundImage.id;
				$scope.screen.backgroundImagePosition = $scope.config.backgroundImagePosition;
				$scope.screen.backgroundAutostretch = $scope.config.backgroundAutostretch;
				$scope.screen.backgroundFrame = $scope.config.backgroundFrame;
				$scope.screen.alignment = $scope.config.alignment;
				$scope.screen.zoomScrollBehavior = $scope.config.zoomScrollBehavior;
				screenService.saveConfig( $scope.screen );
			}
			$scope.applyScreenDisplayScaleToScreens();
		};
		$scope.mobileStatusbarIsOpaqueChanged = function () {
			if ( $scope.config.mobileStatusbarIsOpaque ) {
				if ( $scope.config.mobileStatusbarBackgroundColor.length === 0 ) {
					if ( $scope.config.mobileStatusbarBackgroundColorLabel.length !== 0 ) {
						$scope.config.mobileStatusbarBackgroundColor = $scope.config.mobileStatusbarBackgroundColorLabel;
					} else {
						if ( $scope.config.mobileStatusbarFontColor == "white" ) {
							$scope.config.mobileStatusbarBackgroundColor = "#000000";
							$scope.config.mobileStatusbarBackgroundColorLabel = "#000000";
						} else {
							$scope.config.mobileStatusbarBackgroundColor = "#FFFFFF";
							$scope.config.mobileStatusbarBackgroundColorLabel = "#FFFFFF";
						}
					}
				}
				$scope.config.mobileStatusbarBackgroundIsTransparent = false;
			}
			$scope.applyTempMobileConfig();
		};
		$scope.toggleMobileStatusbarIsOpaque = function () {
			$scope.config.mobileStatusbarIsOpaque = !( $scope.config.mobileStatusbarIsOpaque );
		};
		$scope.toggleMobileStatusbarIsVisible = function () {
			$scope.config.mobileStatusbarIsVisible = !( $scope.config.mobileStatusbarIsVisible );
			$scope.config.mobileStatusbarIsHidden = !$scope.config.mobileStatusbarIsVisible;
			if ( $scope.config.mobileStatusbarIsHidden ) {
				$scope.openModalWindow( "mobileStatusbarIsVisibleWarning", $scope.project );
			}
		};
		$scope.setMobileStatusbarBackgroundIsTransparent = function ( status ) {
			if ( !$scope.config.mobileStatusbarIsOpaque ) {
				$scope.config.mobileStatusbarBackgroundIsTransparent = status;
			}
		};
		$scope.setMobileStatusbarFontColor = function ( color ) {
			$scope.config.mobileStatusbarFontColor = color;
			if ( $scope.config.mobileStatusbarFontColor == "black" && $scope.config.mobileStatusbarBackgroundColor == "#000000" ) {
				$scope.config.mobileStatusbarBackgroundColor = "#FFFFFF";
				$scope.config.mobileStatusbarBackgroundColorLabel = "#FFFFFF";
			} else if ( $scope.config.mobileStatusbarBackgroundColor.toUpperCase() == "#FFFFFF" && $scope.config.mobileStatusbarFontColor == "white" ) {
				$scope.config.mobileStatusbarBackgroundColor = "#000000";
				$scope.config.mobileStatusbarBackgroundColorLabel = "#000000";
			}
			$scope.applyTempMobileConfig();
		};
		$scope.setMobileStatusbarBackgroundColor = function ( color ) {
			$scope.config.mobileStatusbarBackgroundColor = color;
			if ( $scope.config.mobileStatusbarBackgroundColor !== "" ) {
				$scope.config.mobileStatusbarBackgroundColorLabel = $scope.config.mobileStatusbarBackgroundColor;
			}
			$scope.config.mobileStatusbarBackgroundIsTransparent = false;
		};
		$scope.setMobileConfig = function () {
			$scope.applyTempMobileConfig();
			projectService.setMobileConfig( $scope.project.id, $scope.config );
			$scope.isConfigMenuActive = false;
		};
		$scope.applyTempMobileConfig = function () {
			if ( $scope.config.mobileStatusbarBackgroundIsTransparent ) {
				$scope.config.mobileStatusbarBackgroundColor = ""; // this does not change the label in the input box!
			} else {
				if ( $scope.config.mobileStatusbarBackgroundColor === "" &&
					( $scope.config.mobileStatusbarBackgroundColorLabel == "#000000" || $scope.config.mobileStatusbarBackgroundColorLabel == "#FFFFFF" )
				) {
					if ( $scope.config.mobileStatusbarFontColor == "white" ) {
						$scope.config.mobileStatusbarBackgroundColor = "#000000";
						$scope.config.mobileStatusbarBackgroundColorLabel = "#000000";
					} else {
						$scope.config.mobileStatusbarBackgroundColor = "#FFFFFF";
						$scope.config.mobileStatusbarBackgroundColorLabel = "#FFFFFF";
					}
				} else { //make sure the actual color matches whatever is in the input box
					$scope.config.mobileStatusbarBackgroundColor = $scope.config.mobileStatusbarBackgroundColorLabel;
				}
			}
			if ( $scope.config.mobileStatusbarBackgroundColor == "#000000" && $scope.config.mobileStatusbarFontColor == "black" ) {
				$scope.config.mobileStatusbarFontColor = "white";
			} else if ( $scope.config.mobileStatusbarBackgroundColor.toUpperCase() == "#FFFFFF" && $scope.config.mobileStatusbarFontColor == "white" ) {
				$scope.config.mobileStatusbarFontColor = "black";
			}
			$scope.project.mobileStatusbarIsVisible = $scope.config.mobileStatusbarIsVisible;
			$scope.project.mobileStatusbarIsOpaque = $scope.config.mobileStatusbarIsOpaque;
			$scope.project.mobileStatusbarBackgroundColor = $scope.config.mobileStatusbarBackgroundColor;
			$scope.project.mobileStatusbarFontColor = $scope.config.mobileStatusbarFontColor;
		};
		$scope.applyDefaultBackgroundColor = function ( backgroundImageID ) {
			if ( backgroundImageID == "frame" ) {
				$scope.config.backgroundColor = "f9f9fa";
			}
		};
		$scope.getConversations = function () {
			return $scope.conversations;
		};
		$scope.setConversations = function ( conversations ) {
			$scope.conversations = conversations;
			$scope.$broadcast( "conversationsChanged" );
		};
		$scope.expandComments = function ( marker ) {
			var comments = marker.comments;
			_.setProperty( comments, "isCollapsed", false );
		};
		$scope.navigateToExternalUrl = function ( url, isOpenInNewWindow ) {
			var newWindow = $window.open( url, "_blank" );
			newWindow.focus();
		};
		$scope.navigateToNextScreenInSort = function ( returnOnly, screenID ) {
			if ( _.isUndefined( returnOnly ) ) {
				returnOnly = false;
			}
			if ( _.isUndefined( screenID ) ) {
				screenID = $scope.screenID;
			}
			var nextScreen = $scope.getNextScreenInSort( screenID );
			if ( nextScreen ) {
				if ( returnOnly ) {
					return nextScreen;
				} else {
					$scope.navigateToScreen( nextScreen.id, $scope.subview );
				}
			}
		};
		$scope.navigateToPreviousScreen = function ( mode, returnOnly ) {
			if ( _.isUndefined( returnOnly ) ) {
				returnOnly = false;
			}
			if ( $scope.previousScreenQueue.length ) {
				var hasFoundPreviousScreen = false;
				while ( !hasFoundPreviousScreen && $scope.previousScreenQueue.length ) {
					var id = $scope.previousScreenQueue.pop();
					if ( id !== $scope.screenID ) {
						hasFoundPreviousScreen = true;
						isNavigatingToPreviousScreen = true;
						if ( returnOnly ) {
							return id;
						} else {
							$scope.navigateToScreen( id, mode );
						}
					}
				}
			}
		};
		$scope.navigateToPreviousScreenInSort = function ( returnOnly, screenID ) {
			if ( _.isUndefined( returnOnly ) ) {
				returnOnly = false;
			}
			if ( _.isUndefined( screenID ) ) {
				screenID = $scope.screenID;
			}
			var previousScreen = $scope.getPreviousScreenInSort( screenID );
			if ( previousScreen ) {
				if ( returnOnly ) {
					return previousScreen;
				} else {
					$scope.navigateToScreen( previousScreen.id, $scope.subview );
				}
			}
		};
		$scope.navigateToScreen = function ( screenID, mode ) {
			hideMenus();
			mode = mode || "preview";
			$location.path( "/console/" + $scope.projectID + "/" + screenID + "/" + mode );
		};
		$scope.navigateToProjectStart = function () {
			$scope.setHasShownSimulatedMobileLoadingScreen( false );
			$scope.$broadcast( "relaunchMobileApp", $scope.project.homeScreen.id );
			$scope.navigateToScreen( $scope.project.homeScreen.id );
		};
		$scope.toggleSmsShareForm = function () {
			$scope.isShowingSmsForm = !$scope.isShowingSmsForm;
		};
		$scope.sendShareSms = function () {
			$scope.sms.phoneNumber = $scope.sms.phoneNumber.replace( /[^\d+]+/g, "" );
			if ( $scope.sms.phoneNumber.length < 10 ) {
				$scope.sms.message = "Invalid phone number.";
				return;
			} else if ( $scope.sms.phoneNumber.length == 10 ) {
				$scope.sms.message = "Please add country code.";
				return;
			}
			$scope.sms.messageSent = false;
			$scope.sms.message = "";
			Deferred.handlePromise(
				shareService.createShare(
					$scope.projectID,
					$scope.screenID,
					true, //isCommentingAllowed
					true, //isNavigateAllowed
					false, //isResizeWindow
					true, //isLoadAllScreens
					false, //isUserTesting
					true, //isAnonymousViewingAllowed
					true, //isForceAddToHomescreenOnMobile
					"" //password
				),
				function ( response ) {
					Deferred.handlePromise(
						shareService.sendSMS( response.id, $scope.sms.phoneNumber ),
						function ( response ) {
							$scope.sms.messageSent = true;
							if ( $window.localStorage ) {
								localStorage.setItem( "smsPhoneNumber", $scope.sms.phoneNumber );
							}
							$timeout( function () {
								$scope.sms.messageSent = false;
								$scope.sms.message = "";
								$scope.isShowingSmsForm = false;
							}, 15000 );
						},
						function ( response ) {
							$scope.sms.message = "Error: Unable to send SMS.";
						}
					);
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't create that share. This was unexpected!" );
				}
			);
		};
		$scope.openLiveShare = function () {
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan" )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			}
			if ( $scope.user.hasClosedLiveshareIntro ) {
				if ( $scope.liveshare.currentTarget !== null && $scope.liveshare.participants > 0 ) {
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( $scope.project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.currentTarget, $scope.liveshare.conferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else if ( $scope.liveshare.currentTarget !== null ) { // if the presenter is the only one in the LiveShare, just reuse that tab
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( $scope.project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.currentTarget );
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else { // if not, force a new target
					$scope.liveshare.target = "liveshare_" + firebaseStateService.guid();
					firebaseStateService.setTarget( $scope.liveshare.target );
					$scope.$broadcast( "autosubmit-#liveshareProject", $scope.liveshare.target );
				}
			} else {
				$scope.openModalWindow( "liveshare-intro", $scope.project.id );
			}
		};
		$scope.openShareModal = function () {
			$scope.openModalWindow( "share", $scope.project.id, $scope.screenID, "new" );
		};
		$scope.toggleReplaceScreenUploader = function () {
			if ( $scope.isScreenReplaceUploaderActive ) {
				$scope.$broadcast( "toggleScreenReplaceUploader", {
					showUploader: false
				} );
			} else {
				hideMenus();
				$scope.$broadcast( "toggleScreenReplaceUploader", {
					showUploader: true
				} );
			}
		};
		$scope.setIsScreenReplaceUploaderActive = function ( val ) {
			$scope.isScreenReplaceUploaderActive = val;
		}
		$scope.hideReplaceScreenUploader = function () {
			if ( $scope.isScreenReplaceUploaderActive ) {
				$scope.$broadcast( "toggleScreenReplaceUploader", {
					showUploader: false
				} );
			}
		};
		$scope.showReplaceScreenUploader = function () {
			if ( !$scope.isScreenReplaceUploaderActive ) {
				$scope.$broadcast( "toggleScreenReplaceUploader", {
					showUploader: true
				} );
			}
		};
		$scope.hideDropZoneUploaders = function () {
			if ( $scope.isDropZoneUploadersActive && !$scope.isFilteringScreens ) {
				$scope.isDropZoneUploadersActive = false;
			}
		};
		$scope.showDropZoneUploaders = function () {
			if ( !$scope.isDropZoneUploadersActive && !$scope.isFilteringScreens ) {
				$scope.isDropZoneUploadersActive = true;
			}
		};
		$scope.showScreenPosition = function () {
			$scope.isShowingSlideshowNav = true;
			$timeout.cancel( slideShowFlashTimer );
			slideShowFlashTimer = $timeout( $scope.hideScreenPosition, 1000 );
		};
		$scope.hideScreenPosition = function () {
			$scope.isShowingSlideshowNav = false;
		};
		$scope.setIsBottomBarShown = function ( isBottomBarShown ) {
			hideMenus();
			$scope.isBottomBarShown = isBottomBarShown;
		};
		$scope.toggleBottomBar = function () {
			hideMenus();
			$scope.isBottomBarShown = !$scope.isBottomBarShown;
		};
		$scope.saveTemplate = function ( template, successCallback ) {
			var promise = Deferred.handlePromise(
				templateService.saveTemplate( template ),
				function ( response ) {
					template.id = response.id;
					if ( successCallback ) {
						successCallback();
					}
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we can't save your template. Try refreshing your browser." );
				}
			);
			return ( promise );
		};
		$scope.deleteTemplate = function ( template ) {
			template.isDeleted = true;
			$scope.$broadcast( "templateDeleted" );
			if ( template.id ) {
				Deferred.handlePromise(
					templateService.deleteTemplate( template ),
					function () {
						$scope.hotspots = _.rejectWithProperty( $scope.hotspots, "templateID", template.id );
						$scope.templates = _.rejectWithProperty( $scope.templates, "id", template.id );
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we can't delete your template. Try refreshing your browser." );
					}
				);
			}
		};
		$scope.duplicateTemplate = function ( template, event ) {
			if ( !template.id ) {
				return;
			}
			Deferred.handleAllPromises(
				[
					templateService.duplicateTemplate( template.id )
				],
				function ( template ) {
					$scope.templates.push( template );
					$scope.$broadcast( "templateDuplicated" );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we can't duplicate your template. Try refreshing your browser." );
				}
			);
			event.stopPropagation();
			event.preventDefault();
			return false;
		};
		$scope.addTemplateToScreen = function ( templateID, screenID, reloadHotspots ) {
			if ( reloadHotspots === undefined ) {
				reloadHotspots = true;
			}
			var template = _.findWithProperty( $scope.templates, "id", templateID );
			template.screens = template.screens || [];
			if ( _.contains( template.screens, screenID ) === false ) {
				template.screens.push( screenID );
				Deferred.handleAllPromises(
					[
						templateService.addScreen( templateID, screenID )
					],
					function ( template ) {
						if ( reloadHotspots ) {
							$scope.reloadHotspots();
						}
						$scope.$broadcast( "sceenAddedToTemplate" );
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we can't add this screen to your template. Try refreshing your browser." );
					}
				);
			}
		};
		$scope.removeTemplateFromScreen = function ( templateID, screenID ) {
			var template = _.findWithProperty( $scope.templates, "id", templateID );
			template.screens = template.screens || [];
			template.screens = _.reject( template.screens, function ( id ) {
				return id === screenID;
			} );
			Deferred.handleAllPromises(
				[
					templateService.removeScreen( templateID, screenID )
				],
				function ( template ) {
					$scope.hotspots = _.rejectWithProperty( $scope.hotspots, "templateID", template.id );
					$scope.$broadcast( "sceenDeletedFromTemplate" );
				},
				function () {
					$scope.reloadHotspots();
				}
			);
		};
		$scope.getActiveTemplateCount = function ( screenID ) {
			var activeCount = 0;
			_.each( $scope.templates, function ( template ) {
				if ( _.indexOf( template.screens, screenID ) !== -1 &&
					!template.isDeleted ) {
					activeCount++;
				}
			} );
			return activeCount;
		};
		$scope.isTemplateActiveForScreen = function ( templateID, screenID ) {
			var isActive = false;
			_.each( $scope.templates, function ( template ) {
				if ( template.id === templateID ) {
					if ( _.indexOf( template.screens, screenID ) !== -1 ) {
						isActive = true;
						return false;
					}
				}
			} );
			return isActive;
		};
		$scope.setIsImageLoading = function ( isImageLoading ) {
			$scope.isImageLoading = isImageLoading;
			$scope.isLoading = true;
		};
		$scope.toggleTemplateForScreen = function ( templateID, screenID ) {
			var template = _.findWithProperty( $scope.templates, "id", templateID );
			if ( _.contains( template.screens, screenID ) ) {
				$scope.removeTemplateFromScreen( templateID, screenID );
			} else {
				$scope.addTemplateToScreen( templateID, screenID );
			}
		};
		$scope.setHasShownSimulatedMobileLoadingScreen = function ( value ) {
			$scope.hasShownSimulatedMobileLoadingScreen = value;
		};
		$scope.applyBulkTemplates = function ( template, event ) {
			if ( !$scope.isSelectingBulkScreens ) {
				$scope.hideThumbnailTray();
				$timeout( function () {
					$scope.isSelectingBulkScreens = true;
					$scope.bulkScreensTemplate = template;
					$scope.toggleThumbnailTray();
				}, 600 );
			}
		};
		$scope.toggleIsSelectingBulkScreen = function () {
			if ( $scope.isSelectingBulkScreens ) {
				$scope.isSelectingBulkScreens = false;
				$scope.hideThumbnailTray();
			} else {
				$scope.isSelectingBulkScreens = true;
			}
		};
		$scope.isAppliedToTemplate = function ( screenID ) {
			if ( $scope.isSelectingBulkScreens ) {
				return _.contains( $scope.bulkScreensTemplate.screens, screenID );
			}
		};
		$scope.hideScreenSizer = function () {
			$scope.screenSizer.selectedSize = null;
		};
		$scope.hideScreenSizerMenu = function () {
			$scope.screenSizer.isMenuVisible = false;
		};
		$scope.showScreenSizerMenu = function () {
			hideMenus();
			$scope.screenSizer.isMenuVisible = true;
		};
		$scope.toggleScreenSizer = function ( size ) {
			$scope.screenSizer.isMenuVisible = false;
			if ( $scope.screenSizer.selectedSize === size ) {
				$scope.screenSizer.selectedSize = null;
			} else {
				$scope.screenSizer.selectedSize = size;
			}
		};
		$scope.toggleScreenSizerMenu = function () {
			if ( $scope.screenSizer.isMenuVisible ) {
				$scope.hideScreenSizerMenu();
			} else {
				$scope.showScreenSizerMenu();
			}
		};
		$scope.setIsMobileStatusbarHovered = function ( hovered ) {
			$scope.isMobileStatusbarHovered = hovered;
		};
		$scope.updateDeviceTemplate = function () {
			$scope.project.mobileTemplate = _.withProperty( $scope.mobileDeviceTemplates, "mobileDeviceID", parseInt( $scope.project.mobileDeviceID ) )[ 0 ];
			$scope.config.mobileDeviceID = $scope.project.mobileDeviceID;
			$scope.applyScreenDisplayScaleToScreens();
			$scope.applyTempMobileConfig();
		};
		$scope.getDeviceTemplateSwitchingOptions = function () {
			var mobileTemplate = _.withProperty( $scope.mobileDeviceTemplates, "mobileDeviceID", parseInt( $scope.project.mobileDeviceID ) )[ 0 ];
			var options = _.withProperty( $scope.mobileDeviceTemplates, "platform", mobileTemplate.platform );
			options = _.withProperty( options, "deviceType", mobileTemplate.deviceType );
			options = _.withProperty( options, "orientation", mobileTemplate.orientation );
			if ( mobileTemplate.mobileSkin == "iPhone" ) {
				var sortedMobileDeviceIDs = [ 1, 2, 11, 12, 5, 6, 15, 16 ];
				var newOptions = [];
				for ( var o = 0; o < sortedMobileDeviceIDs.length; o++ ) {
					var newOption = _.withProperty( options, "mobileDeviceID", sortedMobileDeviceIDs[ o ] )[ 0 ];
					if ( newOption ) {
						newOptions.push( newOption );
					}
				}
				options = newOptions;
			} else {
				options = _.sortOnProperty( options, "description" );
			}
			return options;
		};
		var LAST_CONSOLE_TOUR_STEP = 31;
		var renderContext = requestContext.getRenderContext( "console", [ "projectID", "screenID" ] );
		var isNavigatingToPreviousScreen = false;
		var slideShowFlashTimer = null;
		var fbStatusRef;
		var fbRedirectTarget;
		$scope.config = {
			applyToAll: false,
			alignment: "center",
			zoomScrollBehavior: 1,
			backgroundColor: "",
			backgroundImage: null,
			backgroundImagePosition: "tile-horizontally", // center, tile, tile-horizontally
			mobileStatusbarIsVisible: true, // the actual value that gets applied to the project
			mobileStatusbarIsHidden: false, // only used in the ui for the checkbox to display properly
			mobileStatusbarIsOpaque: true,
			mobileStatusbarBackgroundIsTransparent: false,
			mobileStatusbarBackgroundColor: "#000000",
			mobileStatusbarFontColor: "Light"
		};
		$scope.showAutoStretchTooltip = true;
		$scope.isMobileStatusbarHovered = false;
		$scope.screenFloat = {
			"float": "none"
		};
		$scope.isScreenReplaceUploaderActive = false;
		$scope.isDropZoneUploadersActive = false;
		$scope.isFilteringScreens = false;
		$scope.isWorkflowStatusMenuActive = false;
		$scope.liveshare = firebaseStateService.getState();
		$scope.projectID = null;
		$scope.screenID = null;
		$scope.previousScreenQueue = [];
		$scope.project = null;
		$scope.screen = null;
		$scope.formAction = null;
		$scope.screens = [];
		$scope.loadingScreens = [];
		$scope.hasAlreadyBeenRebuiltAfterUpload = false;
		$scope.screensToPreload = [];
		$scope.isLoading = true;
		$scope.isDataLoading = true;
		$scope.isImageLoading = getDefaultIsImageLoading();
		$scope.isBottomBarShown = true;
		$scope.shouldHide = false;
		$scope.isCheckProcessingScreens = false;
		$scope.checkingProcessingScreenIDs = [];
		$scope.subview = null;
		$scope.tourSubview = null;
		$scope.user = sessionService.user;
		$scope.userID = sessionService.user.id;
		$scope.projectBackgroundImages = [];
		$scope.backgroundSwatches = [];
		$scope.projectMembers = [];
		$scope.isConsoleTourOpen = false;
		$scope.isSelectingBulkScreens = false;
		$scope.bulkScreensTemplate = null;
		$scope.bulkScreens = [];
		$scope.mobileDeviceTemplates = [];
		$scope.hasShownSimulatedMobileLoadingScreen = false;
		$scope.mobileDeviceTemplateSwitchingOptions = [];
		$scope.isShowingSmsForm = false;
		$scope.sms = {
			phoneNumber: "",
			messageSent: false,
			message: ""
		};
		if ( $window.localStorage && localStorage.getItem( 'smsPhoneNumber' ) ) {
			$scope.sms.phoneNumber = localStorage.getItem( "smsPhoneNumber" );
		}
		$scope.screenSizer = {
			isMenuVisible: false,
			selectedSize: null,
			sizes: [ {
				width: 800,
				height: 600
			}, {
				width: 1024,
				height: 768
			}, {
				width: 1366,
				height: 768
			}, {
				width: 1280,
				height: 800
			}, {
				width: 1280,
				height: 1024
			}, {
				width: 1440,
				height: 900
			}, {
				width: 1600,
				height: 900
			}, {
				width: 1920,
				height: 1080
			} ]
		};
		$scope.conversations = [];
		$scope.isShowingSlideshowNav = false;
		$scope.currentScreenIndex = 0;
		$scope.$watch(
			"screens",
			function ( newValue ) {
				if ( !$scope.isCheckProcessingScreens && $scope.screens.length > 0 ) {
					checkProcessingScreens();
				}
				$scope.mergeScreensAndDividersForDisplay();
			},
			true
		);
		$scope.$watch(
			"screenID",
			function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				$scope.currentScreenIndex = ( getScreenIndex( newValue ) + 1 );
			}
		);
		$scope.$watch(
			"config",
			function ( newConfig ) {
				modelEvents.trigger( "screenConfig:changed", newConfig );
			},
			true
		);
		$scope.$watch(
			"project.mobileDeviceID",
			function ( newValue, oldValue ) {
				if ( newValue != oldValue ) {
					$scope.$broadcast( "mobileSkinChanged" );
				}
			}
		);
		$scope.$watch(
			"subview",
			function ( newSubview ) {
				if ( newSubview !== "preview" ) {
					$scope.isBottomBarShown = true;
				}
				adjustBackgroundPosition( newSubview );
				loadTourStepIfNeeded( $scope.subview );
			}
		);
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "screenUploaded.console" );
				modelEvents.off( "subscriptionChanged.console" );
				modelEvents.off( "console:conversation:read" );
				modelEvents.off( "screenConfig:changed" );
				modelEvents.off( "conversationAdded" );
				modelEvents.off( "conversationDeleted" );
				modelEvents.off( "projectStakeholderRemoved" );
				modelEvents.off( "projectUpdated.console" );
				modelEvents.off( "dividerCreated.console" );
				modelEvents.off( "dividerUpdated.console" );
				modelEvents.off( "dividerPositionsUpdated.console" );
				modelEvents.off( "dividerDeleted.console" );
				modelEvents.off( "rebuildAfterUpload.console" );
				$( window ).off( "resize.console" );
				$scope.clearBodyStyle();
				$rootScope.$broadcast( "closingConsole" );
			}
		);
		$( window ).on( "resize.console", function windowResize() {
			$scope.applyScreenDisplayScaleToScreens();
			$scope.$apply();
		} );
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.liveshare = data;
		} );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				setProjectAndScreenID();
				hideMenus();
				if ( renderContext.getNextSection() !== "preview" ) {
					$scope.hideScreenSizer();
				}
				var shouldSwitchSubview = ( !$scope.isLoading || $scope.subview !== renderContext.getNextSection() );
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					$scope.loadData( true );
					$scope.subview = null;
				} else if ( requestContext.hasParamChanged( "screenID" ) ) {
					$scope.loadData( false );
					$scope.subview = ( renderContext.getNextSection() || "preview" );
				} else if ( shouldSwitchSubview ) {
					$scope.subview = ( renderContext.getNextSection() || "preview" );
					$scope.loadData( false );
				}
			}
		);
		$scope.$on(
			"consoleImageLoaded",
			function ( event, imageElement ) {
				$scope.isImageLoading = false;
				$scope.isLoading = $scope.isDataLoading;
			}
		);
		$scope.$on(
			"consoleTourClosed",
			function () {
				$scope.tourSubview = null;
				$scope.isConsoleTourOpen = false;
			}
		);
		$scope.$on(
			"consoleTourOpened",
			function ( event, mode ) {
				$scope.tourSubview = mode;
				$scope.isConsoleTourOpen = true;
			}
		);
		$scope.$on(
			"consoleTourChangedModes",
			function ( event, mode ) {
				$scope.tourSubview = mode;
			}
		);
		$scope.$on(
			"toggleMobileStatusbarIsVisible",
			function () {
				$scope.toggleMobileStatusbarIsVisible();
				$scope.applyTempMobileConfig();
			}
		);
		$scope.$on(
			"showReplaceScreen",
			function () {
				$scope.showReplaceScreenUploader();
			}
		);
		$scope.$on(
			"hideReplaceScreen",
			function () {
				$scope.hideReplaceScreenUploader();
			}
		);
		$scope.$on(
			"showDropZones",
			function () {
				$scope.showDropZoneUploaders();
			}
		);
		$scope.$on(
			"hideDropZones",
			function () {
				$scope.hideDropZoneUploaders();
			}
		);
		$scope.$on(
			"isFilteringScreens",
			function ( event, isFiltering ) {
				$scope.isFilteringScreens = isFiltering;
			}
		);
		modelEvents.on(
			"screenConfig:changed",
			function ( event, newConfig ) {
				if ( !$scope.project ) {
					return;
				}
				var cssToApply = {};
				var projectConsoleCssToApply = {};
				var secondaryBodyClass = "";
				if ( _.isUndefined( newConfig ) ) {
					return;
				}
				if ( $scope.subview === "history" ) {
					return;
				}
				$scope.screen = $scope.applyScreenDisplayScaleToScreen( $scope.screen, true );
				if ( newConfig.zoomScrollBehavior === screenService.zoomScrollBehaviors.ZOOM_OUT_TO_BROWSER_WIDTH ) {
					if ( $scope.screen.width * $scope.screen.displayScale > $( window ).width() ) {
						$scope.screen.displayScale = $( window ).width() / $scope.screen.width;
					}
				}
				if ( newConfig.zoomScrollBehavior == screenService.zoomScrollBehaviors.DISABLE_HORIZONTAL_SCROLLING ) {
					cssToApply.overflowX = "hidden";
				} else {
					cssToApply.overflowX = "";
				}
				cssToApply.backgroundColor = "#" + newConfig.backgroundColor;
				if ( !$scope.project.isMobile ) {
					projectConsoleCssToApply.textAlign = newConfig.alignment;
				} else {
					cssToApply.margin = "0 auto";
					cssToApply[ "float" ] = "none";
				}
				cssToApply.backgroundAttachment = "";
				cssToApply.backgroundPosition = "";
				projectConsoleCssToApply.borderStyle = "";
				projectConsoleCssToApply.borderImage = "none";
				projectConsoleCssToApply.borderWidth = "";
				projectConsoleCssToApply.height = "";
				projectConsoleCssToApply.borderImageOutset = "";
				if ( _.isObject( newConfig.backgroundImage ) && ( newConfig.backgroundImage.id > 0 ||
					newConfig.backgroundImage.id === "autostretch" ||
					newConfig.backgroundImage.id === "frame" ) ) {
					cssToApply.backgroundImage = getBackgroundPath( newConfig.backgroundImage );
					var backgroundPositionY = "0";
					if ( $scope.subview === "build" ) {
						backgroundPositionY = "47px";
					}
					switch ( newConfig.backgroundImagePosition ) {
					case "center":
						cssToApply.backgroundRepeat = "no-repeat";
						cssToApply.backgroundPosition = "50% " + backgroundPositionY;
						break;
					case "tile":
						cssToApply.backgroundRepeat = "repeat";
						cssToApply.backgroundPosition = "0 " + backgroundPositionY;
						break;
					case "tile-horizontally":
						cssToApply.backgroundRepeat = "repeat-x";
						cssToApply.backgroundPosition = "0 " + backgroundPositionY;
						break;
					case "fixed":
						cssToApply.backgroundAttachment = "fixed";
						cssToApply.backgroundRepeat = "no-repeat";
						switch ( $scope.screen.alignment ) {
						case "left":
							cssToApply.backgroundPosition = "left top";
							break;
						case "center":
							cssToApply.backgroundPosition = "center top";
							break;
						case "right":
							cssToApply.backgroundPosition = "right top";
							break;
						default:
							break;
						}
						break;
					default:
						break;
					}
					if ( newConfig.backgroundImage.clientFilename.indexOf( "@2x" ) > 0 ) {
						if ( !isNaN( newConfig.backgroundImage.height ) && !isNaN( newConfig.backgroundImage.width ) ) {
							cssToApply.backgroundSize = ( newConfig.backgroundImage.width * 0.5 ) + "px " + ( newConfig.backgroundImage.height * 0.5 ) + "px";
						}
					} else {
						cssToApply.backgroundSize = "auto";
					}
					if ( newConfig.backgroundImage.id === "autostretch" ) {
						secondaryBodyClass = "autostretch";
						cssToApply.backgroundImage = "";
						projectConsoleCssToApply.borderStyle = "solid";
						projectConsoleCssToApply.borderImage = "url('/screens/" + $scope.screen.id + "/" + $scope.screen.imageVersion + "') 0 0 0 " + ( $scope.screen.width - 1 ) + " fill stretch";
						projectConsoleCssToApply.borderWidth = "0px 1px 0px 1px";
						projectConsoleCssToApply.height = $scope.screen.height * $scope.screen.displayScale;
					} else if ( newConfig.backgroundImage.id === "frame" ) {
						secondaryBodyClass = "framed";
						cssToApply.backgroundImage = "";
					}
				} else {
					cssToApply.backgroundImage = "none";
				}
				$scope.screenFloat = {
					"float": cssToApply[ "float" ]
				};
				if ( $scope.project.isMobile ) {
					$scope.config.backgroundColor = MOBILE_BUILD_BG;
				}
				$scope.updateBodyStyle( cssToApply );
				$scope.updateProjectConsoleStyle( projectConsoleCssToApply );
				$scope.setSecondaryBodyClass( secondaryBodyClass );
				adjustBackgroundPosition( $scope.subview );
			}
		);
		modelEvents.on(
			"subscriptionChanged.console",
			function ( newPlan ) {
				$scope.loadData( true );
			}
		);
		modelEvents.on(
			"screenUploaded.console",
			function handleScreenUploaded( event, screen ) {
				if ( screen.projectID !== $scope.projectID ) {
					return;
				}
				/*
When we upload a file, everything is handled in the response via rebuildAfterUpload.
However, the other browers need to be aware of the upload so we need to reload the data for them.
*/
				if ( $scope.hasAlreadyBeenRebuiltAfterUpload == false ) {
					$scope.loadData( true );
				}
			}
		);
		modelEvents.on(
			"rebuildAfterUpload.console",
			function ( event, uploadedResponse ) {
				if ( uploadedResponse.uploadedScreen.projectID !== $scope.projectID ) {
					return;
				}
				var newlyUploadedScreen = uploadedResponse.uploadedScreen;
				/*
uploadedResponse.screens is ordered by sort, id and comes from the db.
It does not know of our dummy loading screens.
we need to re-insert them if they haven't been loaded yet.
*/
				var loaderToBeRemoved = _.find( $scope.loadingScreens, {
					"name": newlyUploadedScreen.clientFilename
				} );
				$scope.loadingScreens = _.pull( $scope.loadingScreens, loaderToBeRemoved );
				var screenIds = _.pluck( uploadedResponse.screens, "id" );
				var newlyUploadedScreenIndex = _.indexOf( screenIds, newlyUploadedScreen.id );
				for ( var i = $scope.loadingScreens.length - 1; i >= 0; i-- ) {
					uploadedResponse.screens.splice( ( newlyUploadedScreenIndex + 1 ), 0, $scope.loadingScreens[ i ] );
				}
				var existingScreen = _.findWithProperty( $scope.screens, "id", newlyUploadedScreen.id );
				if ( existingScreen ) {
					_.extend( existingScreen, uploadedResponse.screens[ newlyUploadedScreenIndex ] );
					$scope.screen = uploadedResponse.screens[ newlyUploadedScreenIndex ];
					$scope.screen.displayScale = $scope.applyScreenDisplayScaleToScreen( newlyUploadedScreen ).displayScale;
					$scope.reloadHotspots();
				} else {
					uploadedResponse.screens[ newlyUploadedScreenIndex ].unreadConversationCount = 0;
					uploadedResponse.screens[ newlyUploadedScreenIndex ].updatedByUserName = sessionService.user.name;
					$scope.applyScreenDisplayScaleToScreen( uploadedResponse.screens[ newlyUploadedScreenIndex ] );
				}
				$scope.screens = augmentScreens( hashKeyCopier.copyHashKeys( $scope.screens, uploadedResponse.screens ) );
			}
		);
		modelEvents.on(
			"conversationAdded",
			function ( event, conversationID, screenID ) {
				if ( $scope.subview === "comments" &&
					$scope.screenID === screenID ) {
					addConversation( conversationID );
				}
				var screen = _.findWithProperty( $scope.screens, "id", screenID );
				if ( screen ) {
					screen.unreadConversationCount++;
				}
			} );
		modelEvents.on(
			"conversationDeleted",
			function ( event, conversationID ) {
				if ( $scope.subview === "comments" ) {
					deleteConversation( conversationID );
				}
			} );
		modelEvents.on(
			"console:conversation:read",
			function ( event, conversation ) {
				var screen = _.findWithProperty( $scope.screens, "id", conversation.screenID );
				if ( screen ) {
					screen.unreadConversationCount = Math.max( 0, screen.unreadConversationCount - 1 );
				}
			}
		);
		modelEvents.on(
			"projectStakeholderRemoved",
			function ( event, projectID, userID ) {
				$scope.projectStakeholders = _.rejectWithProperty( $scope.projectStakeholders, "id", userID );
			}
		);
		modelEvents.on(
			"dividerCreated.console",
			function ( event, divider ) {
				$scope.dividers.push( divider );
				$scope.mergeScreensAndDividersForDisplay();
			}
		);
		modelEvents.on(
			"dividerDeleted.console",
			function ( event, dividerID ) {
				if ( _.findWithProperty( $scope.dividers, "dividerID", dividerID ) ) {
					$scope.dividers = _.withoutProperty( $scope.dividers, "dividerID", dividerID );
					$scope.mergeScreensAndDividersForDisplay();
				}
			}
		);
		modelEvents.on(
			"dividerUpdated.console",
			function ( event, response ) {
				for ( var d = 0; d < $scope.dividers.length; d++ ) {
					if ( $scope.dividers[ d ].dividerID == response.dividerID ) {
						$scope.dividers[ d ].label = response.label;
						break;
					}
				}
				for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
					if ( $scope.displayObjects[ d ].dividerID == response.dividerID ) {
						$scope.displayObjects[ d ].label = response.label;
						break;
					}
				}
			}
		);
		modelEvents.on(
			"dividerPositionsUpdated.console",
			function ( event, dividers, screens ) {
				var isPositionChanged = false;
				for ( var sd = 0; sd < $scope.dividers.length; sd++ ) {
					for ( var d = 0; d < dividers.length; d++ ) {
						if ( $scope.dividers[ sd ].dividerID == dividers[ d ].dividerID &&
							$scope.dividers[ sd ].position != dividers[ d ].position
						) {
							isPositionChanged = true;
							break;
						}
					}
				}
				if ( isPositionChanged ) {
					$scope.dividers = dividers;
					$scope.mergeScreensAndDividersForDisplay();
				}
			}
		);
		modelEvents.on(
			"projectUpdated.console",
			function ( event, project ) {
				if ( $scope.project && ( $scope.project.id === project.id ) ) {
					_.extendExistingProperties( $scope.project, project );
					$scope.projectMembers = augmentProjectPersons( project.projectMembers );
					$scope.projectStakeholders = augmentProjectPersons( project.projectStakeholders );
				}
			}
		);
		modelEvents.on(
			"createLoadingScreens",
			function handleCreationOfLoadingScreens( event, files ) {
				if ( !files.length ) {
					return;
				}
				$scope.hasAlreadyBeenRebuiltAfterUpload = true;
				var uploadedFilesSuggestedSort = typeof files[ 0 ].getSource().suggestedSort !== 'undefined' ? files[ 0 ].getSource().suggestedSort : $scope.screens.length;
				var screensTempArray = angular.copy( $scope.screens );
				var dummyScreens = [];
				for ( var f = 0, lenf = files.length; f < lenf; f++ ) {
					dummyScreens.push( {
						type: "screenObj",
						id: 0,
						clientFilename: files[ f ].name,
						name: files[ f ].name,
						label: files[ f ].name,
						progress: 0,
						isPlaceholder: true
					} );
				}
				Array.prototype.splice.apply( screensTempArray, [ uploadedFilesSuggestedSort, 0 ].concat( dummyScreens ) );
				$scope.screens = hashKeyCopier.copyHashKeys( $scope.screens, screensTempArray );
				$scope.loadingScreens = angular.copy( dummyScreens );
			}
		);
		modelEvents.on(
			"updateLoadingScreenProgress",
			function handleUpdatingOfLoadingScreens( event, queueItem ) {
				var loadingScreen = _.find( $scope.screens, {
					"name": queueItem.name
				} );
				loadingScreen.progress = queueItem.percentage;
			}
		);
		$scope.setBodyClass( "l-console" );
		$window.olark( 'api.box.hide' );
		$window._kiq.push( [ 'hideSurvey' ] );
		setProjectAndScreenID();
		$scope.loadData( true );
	}
} )( angular, InVision );;;
/*! loading-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.LoadingController", Controller );
	/** @ngInject */
	function Controller( $scope ) {}
} )( angular, InVision );;;
/*! modal-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.ModalController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, beforeUnloadService, _ ) {
		$scope.views = {
			'annualUpgrade': 'annual-upgrade.htm',
			'activateProject': 'activate-project.htm',
			'addToProject': 'add-to-project.htm',
			'affiliateActivity': 'affiliate-activity.htm',
			'alert': 'alert.htm',
			'archiveProject': 'archive-project.htm',
			'archiveUpgrade': 'archive-upgrade.htm',
			'bulkInviteProjectMembers': 'bulk-invite-project-members.htm',
			'changePlan': 'change-plan.htm',
			'changePlanBilling': 'change-plan-billing.htm',
			'changePlanConfirm': 'change-plan-confirm.htm',
			'downgradePlan': 'downgrade-plan.htm',
			'downgradePlanBilling': 'downgrade-plan-billing.htm',
			'downgradePlanConfirm': 'downgrade-plan-confirm.htm',
			'changePlanEnterprise': 'change-plan-enterprise.htm',
			'changePlanBillingEnterprise': 'change-plan-billing-enterprise.htm',
			'changePlanConfirmEnterprise': 'change-plan-confirm-enterprise.htm',
			'clickableWireframes': 'clickable-wireframes.htm',
			'convertToCompanyTour': 'convert-to-company-tour.htm',
			'consoleFirstUse': 'console-first-use.htm',
			'consoleHelp': 'console-help.htm',
			'contactUs': 'contact-us.htm',
			'contactUsEnterprise': 'contact-us-enterprise.htm',
			'createTeamModal': 'create-team.htm',
			'deleteProject': 'delete-project.htm',
			'duplicateProject': 'duplicate-project.htm',
			'exportPDF': 'export-pdf.htm',
			'exportPDF_Upgrade': 'export-pdf-upgrade.htm',
			'exportZip_Upgrade': 'export-zip-upgrade.htm',
			'error': 'error.htm',
			'gettingStarted': 'getting-started.htm',
			'gravatarAvatar': 'gravatar-avatar.htm',
			'highFidelityPrototypes': 'high-fidelity-prototypes.htm',
			'joinTeamProject': 'join-team-project.htm',
			'liveshare': 'liveshare.htm',
			'liveshare-intro': 'liveshare-intro.htm',
			'liveshare-target-prompt': 'liveshare-target-prompt.htm',
			'mobileDemos': 'mobile-demos.htm',
			'macAppAdvert': 'mac-app-advert.htm',
			'mobileStatusbarIsVisibleWarning': 'mobile-statusbar-is-visible-warning.htm',
			'mobileTips': 'mobile-tips.htm',
			'newProject': 'new-project.htm',
			'newTeamMember': 'new-team-member.htm',
			'onboardingTour': 'onboarding-tour.htm',
			'presentation-share': 'presentation/share.htm',
			'projectMembers': 'project-members.htm',
			'requestPermission': 'request-permission.htm',
			'requestPermissionConfirmation': 'request-permission-confirmation.htm',
			'saveProjectOffline': 'save-project-offline.htm',
			'share': 'share/share.htm',
			'teamInviteJoinedConfirmation': 'team-invite-joined-confirmation.htm',
			'tellAFriendEmailPreview': 'tell-a-friend-email-preview.htm',
			'transferProject': 'transfer-project.htm',
			'twitterAvatar': 'twitter-avatar.htm',
			'uploadInProgress': 'upload-in-progress.htm',
			'video': 'video.htm',
			'workflowStatusNotification': 'workflow-status-notification.htm',
			'changeProjectType': 'change-project-type.htm',
			'projectComments': 'project-comments.htm',
			'snaps': 'snaps.htm',
			'move-to-project': 'move-to-project.htm',
			'syncDownload': 'sync-download.htm',
			'assetsIntro': 'assets-intro.htm',
			'dropboxConnected': 'dropbox-connected.htm',
			'downloadingSync': 'downloading-sync.htm',
			'layerSyncInfo': 'layersync-info.htm',
			'layerSync': 'layersync.htm',
			'assetsRevokeLinks': 'assets-revoke-links.htm',
			'assetsDelete': 'assets-delete.htm',
			'teamEnterpriseChoice': 'team-enterprise-choice.htm',
			'enterpriseContactForm': 'enterprise-contact-form.htm',
			'enterpriseAddToTeam': 'enterprise/add-to-team.htm',
			'enterpriseInviteToCompany': 'enterprise/invite-to-company.htm',
			'enterpriseRemoveFromCompany': 'enterprise/remove-members.htm',
			'enterpriseProjectMembers': 'enterprise/add-to-project.htm',
			'enterpriseMember': 'enterprise/user-modal.htm',
			'screenSource': 'screen-source.htm',
			'retinaHelper': 'retina-helper.htm',
			'sketchSoon': 'sketch-soon.htm',
			'screenSourceError': 'screen-source-error.htm',
			'newTest': 'new-test.htm',
			'testing-share': 'share-test/share.htm',
			'newPresentation': 'new-presentation.htm',
			'presentationIntro': 'presentation-intro.htm',
			'liveEmbed': 'live-embed/live-embed.htm'
		};
		var originalBodyClass = "";
		var isPageRefreshing = false;
		$scope.subview = null;
		$scope.nextSubview = null;
		$scope.$on(
			"modalWindowHidden",
			function ( event ) {
				$scope.subview = $scope.nextSubview;
				$scope.nextSubview = null;
				if ( $scope.subview === null ) {
					$scope.setBodyClass( originalBodyClass );
				}
			}
		);
		$scope.$on(
			"openModalWindow",
			function ( event, modalType, modalData ) {
				if ( isPageRefreshing ) {
					return;
				}
				if ( $scope.subview === null ) {
					modalWindowRequest.setRequest( modalType, modalData );
					$scope.subview = modalType;
					originalBodyClass = $scope.bodyClass;
					$scope.setBodyClass( $scope.bodyClass + " modal-open" );
				} else if ( $scope.subview === modalType ) {
					return;
				} else if ( $scope.subview === modalType ) {
					return;
				} else {
					modalWindowRequest.setRequest( modalType, modalData, true ); // TRUE == suppress fade
					$scope.nextSubview = modalType;
					$scope.$broadcast( "closeModalWindowWithoutFade" );
				}
			}
		);
		beforeUnloadService.push(
			this,
			function () {
				isPageRefreshing = true;
				setTimeout(
					function () {
						isPageRefreshing = false;
					},
					1000
				);
			}
		);
	}
} )( angular, InVision );;;
/*! standard-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.StandardController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, Deferred, Debouncer, requestContext, accountService, sessionService, modelEvents, moment, standardPartial, dashboardActivityPartial, dateHelper, $location, userService, releaseNotificationService, hashKeyCopier, _, userPreferenceService, companyService, firebaseStateService ) {
		function applyRemoteData( projects, mobileDevices ) {
			$scope.projects = sortProjects( projects );
			applyShouldShowSampleScreens();
			applyScreenCountFormatting();
			$scope.deviceTemplates = hashKeyCopier.copyHashKeys( $scope.deviceTemplates, mobileDevices );
		}

		function applyScreenCountFormatting() {
			for ( var i = 0, length = $scope.projects.length; i < length; i++ ) {
				if ( $scope.projects[ i ].screenCount !== 1 ) {
					$scope.projects[ i ].formattedScreenCount = $scope.projects[ i ].screenCount + ' screens';
				} else {
					$scope.projects[ i ].formattedScreenCount = $scope.projects[ i ].screenCount + ' screen';
				}
			}
		}

		function applyShouldShowSampleScreens() {
			var nonSampleProjects = _.filterWithProperty( $scope.projects, "isSample", false );
			var highestScreenCount = _.maxProperty( nonSampleProjects, "screenCount" );
			$scope.showSampleScreens = ( highestScreenCount === 0 );
		}

		function isEnterprisePlan( subscription ) {
			var enterprisePlanIds = [ 20, 22, 23, 24 ];
			return ( _.contains( enterprisePlanIds, subscription.subscriptionPlanID ) );
		}

		function shouldShowUpgradeLink( subscription, user ) {
			if ( $scope.isEnterprise || $scope.isEnterpriseUser ) {
				return false;
			}
			var memberSince = Math.abs( moment( user.accountCreatedAt ).diff( moment(), "days" ) );
			if ( memberSince < 2 ) {
				return false;
			}
			return _.contains( [ 1, 2, 16, 17, 30 ], subscription.subscriptionPlanID );
		}

		function isPausePlan( subscription ) {
			return ( subscription.subscriptionPlanID == 30 );
		}

		function showAppropriateUpgradeModal( planSignedUpFor ) {
			if ( !_.contains( [ 'starterMonthly', 'premiumMonthly', 'teamMonthly' ], planSignedUpFor ) ) {
				return;
			}
			$scope.openModalWindow( 'changePlan', {
				openedDueTo: 'signup from plan page',
				forwardToPlan: planSignedUpFor,
				upgradeIntent: "seeOnboardingVideo"
			} );
		}

		function isInVisionAppUser() {
			return $scope.user.email.indexOf( "@invisionapp.com" ) > -1;
		}

		function loadFeatureAnnouncements() {
			Deferred.handlePromise(
				releaseNotificationService.getReleaseNotificationsWithoutContent(),
				function handleFeatureReleaseResponse( response ) {
					featureAnnouncements = response;
					_.setProperty( featureAnnouncements, "isHidden", false );
					showOrHideNewFeatureLink();
				}
			);
		}

		function loadProjectsData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				standardPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.projects, response.mobileDevices );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your projects. Try refreshing your browser." );
				}
			);
		}

		function prepareToLoadProjectsData() {
			if ( loadProjectsDataTimer ) {
				$timeout.cancel( loadProjectsDataTimer );
			}
			loadProjectsDataTimer = $timeout( loadProjectsData, loadProjectsDataTimerDuration );
		}

		function showOrHideNewFeatureLink() {
			var localFeatureAnnouncements = featureAnnouncements || [],
				howManyToShow = 5,
				cookie = $.cookie( "announcementIDsDismissed" ),
				announcementIDsDismissed = [],
				announcementsFiltered = [];
			if ( !_.isUndefined( cookie ) ) {
				announcementIDsDismissed = _.map( cookie.split( "," ), function ( i ) {
					return parseInt( i, 10 );
				} );
			}
			localFeatureAnnouncements = _.first( localFeatureAnnouncements, howManyToShow );
			announcementsFiltered = _.filter( localFeatureAnnouncements, function filterAnnouncements( announcement ) {
				if ( _.contains( announcementIDsDismissed, announcement.id ) ) {
					return false;
				}
				return ( announcement.createdAt > $scope.user.featureAnnouncementsLastViewedAt );
			} );
			$scope.shouldShowNewFeatureLink = announcementsFiltered.length > 0;
			if ( $scope.shouldShowNewFeatureLink ) {
				$scope.announcements = announcementsFiltered;
				$scope.showAnnouncements = ( announcementsFiltered.length > 0 );
				$scope.numberOfAnnouncements = announcementsFiltered.length;
			}
		}

		function sortProjects( projects ) {
			projects.sort(
				function ( a, b ) {
					return ( a.lastUpdatedByUserAt > b.lastUpdatedByUserAt ? -1 : 1 );
				}
			);
			return ( projects );
		}

		function loadNewActivityFlag() {
			if ( checkNewActivityDebouncer.canProceed() &&
				!$scope.hasNewActivity
			) {
				Deferred.handlePromise(
					dashboardActivityPartial.hasNewActivity( lastCheckedOffset ),
					function ( response ) {
						$scope.hasNewActivity = response.isNew;
					},
					function ( response ) {}
				);
				lastCheckedOffset = moment.utc().valueOf();
			}
		}

		function pollForNewActivity() {
			loadNewActivityFlag();
			activityPollTimer = $window.setInterval(
				loadNewActivityFlag,
				ACTIVITY_CHECK_INTERVAL * ( 60 * 1000 )
			);
		}

		function updateTellAFriendTooltipLastViewedAt( formattedDatetime ) {
			userPreferenceService.updateTellAFriendTooltipLastViewedAt( formattedDatetime );
			$scope.user.tellAFriendTooltipLastViewedAt = formattedDatetime;
		}

		function loadEnterprisePreferences() {
			userPreferenceService.getPreferenceTypeByName( 'showEnterpiseWelcome', true, 'string' ).then(
				function ( typeResponse ) {
					if ( typeResponse.exists ) {
						enterpriseWelcomePreferenceID = typeResponse.data.id;
						userPreferenceService.getUserPreferenceById( typeResponse.data.id ).then(
							function ( valueResponse ) {
								if ( valueResponse.exists === 'false' ) {
									$scope.showEnterpriseWelcome = true;
								}
							}
						);
					}
				}
			);
		}

		function canSeeDashboard() {
			if ( $scope.isEnterprise || $scope.isEnterpriseUser ) {
				if ( $scope.isReviewer || ( $scope.isContributor && !$scope.enterpriseConfig.permissions.canDesignersViewDashboards ) ) {
					return false;
				}
				return true;
			}
			return false;
		}
		$scope.views = {
			'activity': 'activity/activity.htm',
			'dashboard': 'dashboard/dashboard.htm',
			'projects': 'projects/projects.htm',
			'team': 'team/team.htm',
			'resources': 'resources/resources.htm',
			'project': 'project/project.htm',
			'new-features': 'new-features/new-features.htm',
			'snaps': 'snaps/snaps.htm',
			'snap': 'snaps/snap.htm',
			'company': 'company/company.htm',
			'notifications': 'notifications/view-all.htm'
		};
		$scope.updateProjectLastAccessed = function ( projectID ) {
			for ( var p = 0; p < $scope.projects.length; p++ ) {
				if ( $scope.projects[ p ].id === projectID ) {
					var UTCtimestamp = new Date().getTime();
					$scope.projects[ p ].lastAccessedAt = UTCtimestamp;
					break; // escape loop if we found the project
				}
			}
		};
		$scope.closeLiveShareNotification = function ( key ) {
			firebaseStateService.closeScheduledLiveShareNotification( key );
		};
		$scope.closeProjectsMenu = function () {
			$scope.showProjectsMenu = false;
		};
		$scope.formatDate = function ( date, format ) {
			return moment( date ).format( format );
		};
		$scope.goToLiveShare = function ( liveshare ) {
			var target = "liveshare_" + firebaseStateService.guid(); // force a new target
			firebaseStateService.setTarget( target );
			$scope.$emit( "autosubmit", "#scheduledLiveshareForm", target );
		};
		$scope.hideMacAppAdvert = function () {
			$scope.showMacAppAdvert = false;
			accountService.markMacAppAdvertisementClosed();
		};
		$scope.hideNewFeatureLink = function () {
			$scope.shouldShowNewFeatureLink = false;
		};
		$scope.hideTeamSetupTip = function ( tipId ) {
			if ( tipId === 1 ) {
				$scope.showTeamSetupTip1 = false;
			}
			accountService.markTeamSetupTipClosed( tipId );
		};
		$scope.isScheduledLiveShare = function ( liveshare ) {
			return liveshare && moment().isBefore( moment( liveshare.date ) ) && moment().add( "minutes", 30 ).isAfter( moment( liveshare.date ) );
		};
		$scope.logout = function () {
			try {
				$window.localStorage.clear();
			} catch ( error ) {}
		};
		$scope.openChangePlanModal = function ( reason ) {
			reason = typeof reason !== 'undefined' ? reason : "account menu";
			if ( $scope.isEnterprise || $scope.isEnterpriseUser ) {
				$scope.openModalWindow( "changePlanEnterprise" );
			} else {
				$scope.openModalWindow( "changePlan", {
					openedDueTo: reason
				} );
			}
		};
		$scope.openContactUsModal = function () {
			if ( !$scope.isEnterprise && !$scope.isEnterpriseUser ) {
				$scope.openModalWindow( "contactUs" );
			} else {
				$scope.openModalWindow( "contactUsEnterprise" );
			}
		};
		$scope.openGettingStartedModal = function () {
			$scope.openModalWindow( "gettingStarted" );
		};
		$scope.openNewProjectModal = function () {
			if ( $scope.isPausePlan ) {
				$scope.openChangePlanModal( 'project quota' );
			} else {
				$scope.openModalWindow( "newProject" );
			}
		};
		$scope.openMacAppAdvertModal = function () {
			$scope.openModalWindow( "macAppAdvert" );
		};
		$scope.openOnboardingModal = function () {
			$scope.openModalWindow( "onboardingTour" );
		};
		$scope.openWhiteboardLiveShare = function () {
			$scope.$emit( "autosubmit", "#whiteboardForm" ); // if we're redirecting, prompt the form to specify our conferenceId
		};
		$scope.toggleNotificationDropdown = function () {
			$scope.notificationDropdownOpen = !$scope.notificationDropdownOpen;
		};
		$scope.toggleTellAFriendPopup = function () {
			$scope.isShowingTellAFriendPopup = !$scope.isShowingTellAFriendPopup;
			if ( $scope.isShowingTellAFriendPopup ) {
				$window._kmq.push( [ 'record', 'Clicked to open Tell-A-Friend modal' ] );
			}
		};
		$scope.reloadActivityIfActive = function () {
			$scope.$broadcast( 'reloadActivity' );
			$scope.hasNewActivity = false;
			lastCheckedOffset = moment.utc().valueOf();
		};
		$scope.setShowSampleScreens = function ( shouldShowSampleScreens ) {
			$scope.showSampleScreens = shouldShowSampleScreens;
		};
		$scope.closeEnterpriseWelcome = function () {
			$scope.showEnterpriseWelcome = false;
			userPreferenceService.setUserPreferenceById( enterpriseWelcomePreferenceID, 1 );
		};
		$scope.viewAllNotifications = function () {
			$location.path( "/notifications" );
			$timeout( function () {
				$scope.notificationDropdownOpen = false;
			}, 200 );
		};
		var ACTIVITY_CHECK_INTERVAL = 5;
		var renderContext = requestContext.getRenderContext( "standard" );
		var activityPollTimer = null;
		var lastCheckedOffset = ( sessionService.user.activityLastViewedAt || moment.utc().subtract( "days", 7 ).valueOf() );
		var checkNewActivityDebouncer = new Debouncer( ( ACTIVITY_CHECK_INTERVAL * 60 * 1000 ) - ( 60 * 1000 ) );
		var featureAnnouncements = [];
		var favicon;
		var enterpriseWelcomePreferenceID = 0;
		var loadProjectsDataTimer = null;
		var loadProjectsDataTimerDuration = ( 2 * 1000 );
		$scope.user = sessionService.user;
		$scope.isUserOnFreePlan = shouldShowUpgradeLink( sessionService.subscription, sessionService.user );
		if ( sessionService.subscription.expiresAt ) {
			$scope.daysUntilSubscriptionExpires = moment( sessionService.subscription.expiresAt ).diff( moment(), "days" );
		} else {
			$scope.daysUntilSubscriptionExpires = 99999;
		}
		$scope.subview = renderContext.getNextSection();
		$scope.copyrightYear = ( new Date() ).getFullYear();
		$scope.shouldShowNewFeatureLink = false;
		$scope.projects = [];
		$scope.deviceTemplates = [];
		$scope.showProjectsMenu = false;
		$scope.isEnterpriseUser = isEnterprisePlan( sessionService.subscription );
		$scope.isPausePlan = isPausePlan( sessionService.subscription );
		$scope.showSampleScreens = false;
		$scope.showMacAppAdvert = ( !$scope.user.hasClosedMacAppAdvert );
		$scope.showTeamSetupTip1 = ( !$scope.user.hasClosedTeamSetupTip1 );
		$scope.hasNewActivity = false;
		$scope.socialShareTheLoveLink = "http://www.invisionapp.com/redeem/s/" + $scope.user.id;
		$scope.isShowingTellAFriendPopup = false;
		$scope.couldntRedeemTellAFriendPromo = false;
		$scope.showEnterpriseWelcome = false;
		$scope.canSeeDashboard = canSeeDashboard();
		$scope.settings = {
			debug: false,
			notifications: [],
			features: {
				notifications: isInVisionAppUser() ? true : false,
				scheduledLiveShare: isInVisionAppUser() ? true : false
			}
		};
		$scope.unreadNotifications = 0;
		$scope.notificationDropdownOpen = false;
		if ( $location.search().hasOwnProperty( "hasRedeemedTellAFriendPromo" ) ) {
			$scope.hasRedeemedTellAFriendPromo = ( $location.search().hasRedeemedTellAFriendPromo === "true" );
			if ( $scope.hasRedeemedTellAFriendPromo ) {
				$window._kmq.push( [ 'record', 'Redeemed Tell-A-Friend modal' ] );
				$scope.isShowingTellAFriendPopup = true;
				$scope.couldntRedeemTellAFriendPromo = false;
			} else {
				$scope.isShowingTellAFriendPopup = true;
				$scope.couldntRedeemTellAFriendPromo = true;
			}
			$location.search( "hasRedeemedTellAFriendPromo", null );
		}
		var now = new Date();
		var minutesAfterSignup = ( now - $scope.user.userCreatedAt );
		minutesAfterSignup = ( minutesAfterSignup / 1000 ) / 60;
		if ( minutesAfterSignup < 30 ) {
			$scope.isShowingTellAFriendPopup = false;
		} else if ( !isNaN( $scope.user.tellAFriendTooltipLastViewedAt ) &&
			dateHelper.addDays( $scope.user.tellAFriendTooltipLastViewedAt, 14 ).getTime() < now.getTime()
		) {
			$scope.isShowingTellAFriendPopup = true;
		}
		$scope.breakingChangesMessage = "";
		$scope.nextScheduledLiveShare = "";
		$scope.formAction = "";
		$scope.$on(
			"$destroy",
			function () {
				$window.clearInterval( activityPollTimer );
				modelEvents.off( "accountUpdated.standardLayout" );
				modelEvents.off( "newFeatureAnnounced.standardLayout" );
				modelEvents.off( "projectCreated.standardLayout" );
				modelEvents.off( "projectDeleted.standardLayout" );
				modelEvents.off( "projectUpdated.standardLayout" );
				modelEvents.off( "screenSortUpdated.standardLayout" );
				modelEvents.off( "subscriptionChanged.standardLayout" );
				modelEvents.off( "screenUploaded.standardLayout" );
				modelEvents.off( "screenDeleted.standardLayout" );
				modelEvents.off( "screenUpdated.standardLayout" );
				modelEvents.off( "screenActivated.standardLayout" );
				modelEvents.off( "screenArchived.standardLayout" );
				modelEvents.off( "companyAccountUpdated.standardLayout" );
				modelEvents.off( "projectUserAdded.standardLayout" );
				modelEvents.off( "projectUsersRemoved.standardLayout" );
				modelEvents.off( "projectUserRemoved.standardLayout" );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.subview = renderContext.getNextSection();
				$scope.showProjectsMenu = false;
			}
		);
		$scope.$on(
			"newFeatureAnnounced",
			function onNewFeatureAnnouncement( event, mostRecentHeadline, announcementID ) {
				var hasAnnouncement = _.containsWithProperty( featureAnnouncements, "id", announcementID );
				if ( !hasAnnouncement ) {
					loadFeatureAnnouncements();
				}
			}
		);
		$scope.$on(
			"breakingChangesAnnounced",
			function onBreakingChangesAnnounced( event, severity, message ) {
				$scope.breakingChangesMessage = message;
			}
		);
		$scope.$on(
			"allFeatureAnnouncementsHidden",
			function onAllFeatureAnnouncementsHidden() {
				$scope.showAnnouncements = false;
				$scope.shouldShowNewFeatureLink = false;
			}
		);
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.settings.notifications = data.notifications;
			$scope.settings.features = data.featureFlags;
			$scope.settings.debug = data.debug;
			$scope.nextScheduledLiveShare = data.nextScheduledLiveShare;
			if ( data.nextScheduledLiveShare && data.nextScheduledLiveShare.sharekey ) {
				$scope.formAction = '/liveshare/' + data.nextScheduledLiveShare.sharekey;
			}
			if ( !$scope.settings.debug && isInVisionAppUser() ) {
				$scope.settings.features.notifications = true;
				$scope.settings.features.scheduledLiveShare = true;
			}
			var notificationsCount = _.countBy( data.notifications, function ( notification ) {
				return notification.unread;
			} );
			$scope.unreadNotifications = notificationsCount[ "true" ] || 0;
		} );
		$scope.$watch( "unreadNotifications", function ( newVal, oldVal ) {
			if ( newVal === oldVal ) {
				return;
			}
			var image = document.getElementById( 'favicon_notification' );
			if ( !favicon ) {
				favicon = new Favico( {
					animation: "none",
					position: "up",
					bgColor: "transparent",
					textColor: "#fff"
				} );
				favicon.image( image );
			}
			if ( newVal !== 0 && $scope.settings.features.notifications ) {
				favicon.image( image );
			} else {
				favicon.badge( "" ); // clear the notifications
			}
			if ( $scope.settings.features.notifications ) {
				$scope.updateTitleWithNotifications( newVal );
			}
		} );
		$scope.$watch( "notificationDropdownOpen", function ( isOpen, old ) {
			if ( isOpen === old ) {
				return;
			}
			if ( !isOpen && !$scope.isLoading ) {
				firebaseStateService.markAllNotificationsAsRead();
			}
		} );
		$scope.$watch( "subview", function ( newValue, oldValue ) {
			var state = firebaseStateService.getState();
			$scope.settings.notifications = state.notifications;
			$scope.settings.features = state.featureFlags;
			$scope.settings.debug = state.debug;
			$scope.nextScheduledLiveShare = state.nextScheduledLiveShare;
			if ( state.nextScheduledLiveShare && state.nextScheduledLiveShare.sharekey ) {
				$scope.formAction = '/liveshare/' + state.nextScheduledLiveShare.sharekey;
			}
			if ( !$scope.settings.debug && isInVisionAppUser() ) {
				$scope.settings.features.notifications = true;
				$scope.settings.features.scheduledLiveShare = true;
			}
			var notificationsCount = _.countBy( state.notifications, function ( notification ) {
				return notification.unread;
			} );
			$scope.unreadNotifications = notificationsCount[ "true" ] || 0;
			if ( newValue === oldValue ) {
				return;
			}
			if ( newValue === "activity" ) {
				$scope.hasNewActivity = false;
			}
		} );
		$scope.$watch( "isShowingTellAFriendPopup", function ( newValue, oldValue ) {
			if ( newValue === true ) {
				$window._kmq.push( [ 'record', 'Viewed Tell-A-Friend modal' ] );
				updateTellAFriendTooltipLastViewedAt( moment.utc().format( "YYYY-MM-DD HH:mm:ss" ) );
			} else {
				$scope.hasRedeemedTellAFriendPromo = false;
				$scope.couldntRedeemTellAFriendPromo = false;
			}
			if ( oldValue === true && newValue === false ) {
				updateTellAFriendTooltipLastViewedAt( moment.utc().format( "YYYY-MM-DD HH:mm:ss" ) );
			}
		} );
		modelEvents.on(
			"accountUpdated.standardLayout",
			function ( event, account ) {
				$scope.user.name = account.name;
				$scope.user.avatarID = account.avatarID;
				$scope.user.initials = userService.getInitials( account.name );
				$scope.user.hasClosedLiveshareIntro = account.hasClosedLiveshareIntro;
				$scope.user.hasClosedShareIntro = account.hasClosedShareIntro;
				$scope.user.hasSystemAvatar = userService.isSystemAvatar( account.avatarID );
				$scope.user.featureAnnouncementsLastViewedAt = account.featureAnnouncementsLastViewedAt;
				showOrHideNewFeatureLink();
			}
		);
		modelEvents.on(
			[
				"projectCreated.standardLayout",
				"projectUserAdded.standardLayout",
				"screenDeleted.standardLayout",
				"screenActivated.standardLayout",
				"screenArchived.standardLayout",
				"screenUploaded.standardLayout",
				"projectUsersRemoved.standardLayout",
				"projectUserRemoved.standardLayout",
				"screenSortUpdated.standardLayout",
				"screenUpdated.standardLayout"
			],
			prepareToLoadProjectsData
		);
		modelEvents.on(
			"projectDeleted.standardLayout",
			function ( event, projectID ) {
				$scope.projects = _.withoutProperty( $scope.projects, "id", projectID );
			}
		);
		modelEvents.on(
			"projectUpdated.standardLayout",
			function ( event, project ) {
				var cachedProject = _.findWithProperty( $scope.projects, "id", project.id );
				if ( cachedProject ) {
					_.extendExistingProperties( cachedProject, project );
				} else {
					prepareToLoadProjectsData();
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged.standardLayout",
			function ( event, newPlan ) {
				$scope.isEnterprise = isEnterprisePlan( newPlan );
				$scope.isPausePlan = isPausePlan( newPlan );
				if ( newPlan.expiresAt ) {
					$scope.daysUntilSubscriptionExpires = moment( newPlan ).diff( moment(), "days" );
				} else {
					$scope.daysUntilSubscriptionExpires = 99999;
				}
			}
		);
		modelEvents.on( 'companyAccountUpdated', function ( e, data ) {
			$scope.companyInfo = angular.copy( data );
			if ( !$scope.companyInfo.companyName ) {
				$scope.companyInfo.companyName = $scope.companyInfo.name;
			}
		} );
		$scope.setBodyClass( "l-standard" );
		loadProjectsData();
		pollForNewActivity();
		if ( $scope.isEnterprise ) {
			loadEnterprisePreferences();
		}
		loadFeatureAnnouncements();
		if ( !$scope.isReviewer ) {
			if ( sessionService.get( "showUpgradeModalForPlan", false ) ) {
				showAppropriateUpgradeModal( sessionService.get( "showUpgradeModalForPlan", '' ) );
				sessionService.set( "showUpgradeModalForPlan", false );
			} else if ( !sessionService.user.hasSeenDashboardTour ) {
				$scope.openOnboardingModal();
			}
		}
		if ( $location.search().hasOwnProperty( "annualUpgrade" ) ) {
			$location.search( "annualUpgrade", null );
			$scope.openModalWindow( "changePlan" );
		}
	}
} )( angular, InVision );;;
/*! activate-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ActivateProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, modalWindowRequest, _ ) {
		$scope.activateProject = function () {
			Deferred.handlePromise(
				projectService.activateProject( $scope.projectID ),
				function ( project ) {
					$scope.closeModalWindow();
					$location.path( "/projects/" + $scope.projectID );
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.deleteProject = function () {
			$scope.openModalWindow( "deleteProject", $scope.projectID );
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.projectName = modalWindowRequest.getData( 1 );
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! add-to-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.AddToProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modelEvents, projectService, addToProjectModalPartial, modalWindowRequest, validationService ) {
		function applyRemoteData( addToProjectUser, commonProjects, user ) {
			$scope.addToProjectUser = addToProjectUser;
			$scope.commonProjects = commonProjects;
			$scope.user = user;
		}

		function loadRemoteData() {
			$scope.isLoadingMemberToAdd = true;
			Deferred.handlePromise(
				addToProjectModalPartial.get( $scope.addToProjectUserID, $scope.projectID ),
				function ( response ) {
					$scope.isLoadingMemberToAdd = false;
					applyRemoteData( response.addToProject.addToProjectUser, response.addToProject.commonProjects, response.user );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't find that user. Try refreshing your browser." );
				}
			);
		}

		function handlePromises( promises, success, error ) {
			Deferred.handleAllPromises( promises, success, error );
		}
		$scope.addToProject = function () {
			Deferred.handlePromise(
				projectService.addUserToTeamProject( $scope.projectID, $scope.addToProjectUser.id ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					if ( validationService.isAlreadyExists( response ) ) {
						$scope.openModalWindow( "error", "That user has already been added to this project" );
					} else if ( isOverQuota( response ) ) {
						$scope.openModalWindow( "error", "The user cannot be added to this project because you have to many people on this project for the plan you are on." );
					} else {
						$scope.openModalWindow( "error", "For some reason, we can't load your project. Try refreshing your browser." );
					}
				}
			);
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.addToProjectUserID = modalWindowRequest.getData( 1 );
		$scope.addToProjectUser = {};
		$scope.commonProjects = [];
		$scope.isLoadingMemberToAdd = false;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! affiliate-activity-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.AffiliateActivityController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, affiliateActivityModalPartial, modalWindowRequest, dateHelper, userService, _ ) {
		function applyRemoteData( user, viewings ) {
			$scope.user = user;
			$scope.user.initials = userService.getInitials( user.name );
			$scope.user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			$scope.viewings = augmentViewings( viewings );
			$scope.viewCount = viewings.length;
			$scope.commentCount = _.sumProperty( viewings, "commentCount" );
		}

		function augmentViewings( viewings ) {
			var today = dateHelper.today().getTime();
			var yesterday = dateHelper.yesterday().getTime();
			for ( var i = 0; i < viewings.length; i++ ) {
				var viewing = viewings[ i ];
				viewing.isDateStamp = true;
				viewing.dateLabel = dateHelper.formatDate( viewing.startedAt, "mm/dd/yyyy" );
				viewing.timeLabel = dateHelper.formatTime( viewing.startedAt, "h:mmtt" );
				if ( viewing.startedAt >= today ) {
					viewing.dateLabel = "Today";
					viewing.isDateStamp = false;
				} else if ( viewing.startedAt >= yesterday ) {
					viewing.dateLabel = "Yesterday";
					viewing.isDateStamp = false;
				}
			}
			viewings = _.sortOnProperty( viewings, "startedAt", "desc" );
			return ( viewings );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				affiliateActivityModalPartial.get( $scope.userID, $scope.projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.user, response.viewings );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load that stakeholder. Try refreshing your browser." );
				}
			);
		}
		$scope.userID = modalWindowRequest.getData( 0 );
		$scope.projectID = modalWindowRequest.getData( 1 );
		$scope.isLoading = false;
		$scope.user = null;
		$scope.viewings = [];
		$scope.viewCount = 0;
		$scope.commentCount = 0;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! alert-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.AlertController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.alertMessage = modalWindowRequest.getData( 0 );
	}
} )( angular, InVision );;;
/*! annual-upgrade-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.AnnualUpgradeController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, modalWindowRequest, changePlansPartial, subscriptionService, billingService, sessionService, Deferred, modelEvents, _ ) {
		function loadRemoteData() {
			Deferred.handlePromise(
				changePlansPartial.get(),
				function ( response ) {
					var currentPlan = response.currentPlan;
					var projects = response.projects;
					var plans = response.plans;
					var isCurrentPlanFree = isEquivalentToFreePlan( currentPlan.subscriptionPlanID );
					$scope.user.projectCount = projects.length;
					$scope.user.maxProjectMembersInAnyProject = ( _.maxProperty( projects, "projectMemberCount" ) || 0 );
					var isOverProjectQuota = ( $scope.user.projectCount > currentPlan.maxProjectCount );
					var isOverProjectMemberQuota = ( $scope.user.maxProjectMembersInAnyProject > currentPlan.maxProjectMemberCount );
					var isOverAnyQuota = ( isOverProjectQuota || isOverProjectMemberQuota );
					if ( isOverAnyQuota || currentPlan.subscriptionPlanID == PLAN_IDS.custom || isCurrentPlanFree || currentPlan.termLength != 1 ) {
						$scope.showAllPlans();
					}
					$scope.rawPlans = plans;
					$scope.plans = preparePlansForDisplay( currentPlan, plans );
					$scope.currentPlan = currentPlan;
					$scope.yearlySavings = getYearlySavings( currentPlan, plans );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				},
				true
			);
		};

		function getYearlySavings( currentPlan, plans ) {
			var costOfYearOnCurrent = currentPlan.price * 12;
			var yearlyPlan = _.first(
				_.where( plans, {
					"monthlyPlanEquiv": currentPlan.subscriptionPlanID,
					"termLength": 12
				} )
			);
			return ( costOfYearOnCurrent - yearlyPlan.price );
		}

		function preparePlansForDisplay( currentPlan, plans ) {
			var isCurrentPlanFree = isPlanFree( currentPlan );
			var filteredPlans = _.where(
				_.rejectWithProperty( plans, "termLength", 24 ), {
					"monthlyPlanEquiv": currentPlan.subscriptionPlanID
				}
			);
			var planToFeature = _.where( filteredPlans, {
				"monthlyPlanEquiv": currentPlan.subscriptionPlanID,
				"termLength": 12
			} );
			_.each( filteredPlans, function ( plan ) {
				plan.className = plan.name.toLowerCase().replace( /\s/gi, '-' );
				plan.isShownByDefault = true;
				plan.isFeatured = ( _.first( planToFeature ).id === plan.id );
				plan.isCurrent = ( plan.id === currentPlan.subscriptionPlanID );
			} );
			return filteredPlans;
		};

		function isPlanFree( plan ) {
			return plan.price == 0;
		};

		function isEquivalentToFreePlan( planID ) {
			return (
				planID == PLAN_IDS.freeMonthly || planID == PLAN_IDS.freeOneYear || planID == PLAN_IDS.freeTwoYear
			);
		}
		$scope.closeModalWindow = function () {
			$scope.closeModalWindow();
		};
		$scope.showAllPlans = function () {
			$scope.openModalWindow( "changePlan", {
				showAllPlans: true,
				subview: "oneYear"
			} );
		};
		$scope.changePlanTo = function ( $event, plan ) {
			$event.preventDefault();
			$scope.selectedPlan = plan;
			var termForAlternativeOption = ( plan.termLength == 1 ) ? 12 : 1;
			var isZeroCost = isPlanFree( plan );
			var isOverProjectQuota = ( $scope.user.projectCount > plan.maxProjectCount );
			var isOverProjectMemberQuota = ( $scope.user.maxProjectMembersInAnyProject > plan.maxProjectMemberCount );
			var planData = {
				"isProrated": false,
				"prorateAmount": 0,
				"selectedPlan": plan,
				"alternativeTermOption": null
			};
			if ( !isZeroCost ) {
				isGoingToBillingModal = true;
				return ( $scope.openModalWindow( "changePlanBilling", planData ) );
			}
			Deferred.handlePromise(
				subscriptionService.changePlan( $scope.selectedPlan ),
				function ( newPlan ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't change your subscription plan. Try refreshing your browser." );
				}
			);
		}
		var PLAN_IDS = {
			freeMonthly: 1,
			freeOneYear: 16,
			freeTwoYear: 17,
			starterMonthly: 2,
			starterOneYear: 18,
			starterTwoYear: 19,
			professionalMonthly: 3,
			professionalOneYear: 8,
			professionalTwoYear: 9,
			studioMonthly: 4,
			studioOneYear: 10,
			studioTwoYear: 11,
			studioPlusMonthly: 7,
			studioPlusOneYear: 12,
			studioPlusTwoYear: 13,
			agencyMonthly: 5,
			agencyOneYear: 14,
			agencyTwoYear: 15,
			enterprise: 20,
			custom: 21
		};
		var isGoingToBillingModal = false;
		var modalData = ( modalWindowRequest.getData( 0 ) || {} );
		_.defaults( modalData, {
			showAllPlans: false
		} );
		$scope.plans = [];
		$scope.selectedPlan = null;
		$scope.showOverProjectWarning = false;
		$scope.showOverProjectMemberWarning = false;
		$scope.yearlySavings = 0;
		$scope.user = {
			projectCount: 0,
			maxProjectMembersInAnyProject: 0
		};
		$scope.$on(
			"$destroy",
			function () {}
		);
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! archive-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ArchiveProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, projectService, modalWindowRequest, _ ) {
		$scope.archiveProject = function () {
			Deferred.handlePromise(
				projectService.archiveProject( $scope.projectID ),
				function ( project ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! archive-upgrade-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ArchiveUpgradeController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.openChangePlanModal = function () {
			$scope.openModalWindow( "changePlan", {
				openedDueTo: "project quota"
			} );
		}
	}
} )( angular, InVision );;;
/*! asset-full-view-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.AssetFullViewController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, projectService, modalWindowRequest, _ ) {}
} )( angular, InVision );;;
/*! assets-delete-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.assets.DeleteController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, assetService, assetFolderService, modalWindowRequest, _ ) {
		$scope.deleteAsset = function () {
			Deferred.handlePromise(
				assetService.deleteAsset( $scope.item.id ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.deleteFolder = function () {
			Deferred.handlePromise(
				assetFolderService.deleteFolder( $scope.item.projectID, $scope.item.id ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.item = modalWindowRequest.getData( 0 );
		$scope.isFolder = !$scope.item.hasOwnProperty( 'clientFilename' )
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! assets-intro-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.assets.IntroController", Controller );

	function Controller( $scope, modalWindowRequest, _, config, accountService ) {
		var slide = {
			"1": {
				header: "Sync design source files, documents and more from your desktop to InVision!",
				subtitle: "Download our Mac app or set-up Dropbox or Box to sync your assets & screens from your desktop!",
				button: "Ok, next..."
			},
			"2": {
				header: "Create and sync screens directly from your design source files! <span>(.PSD, .AI & .Sketch)</span>",
				subtitle: "Use LayerSync to generate multiple screens from a single PSD! Syncing with .ai and .sketch files is also supported. ",
				button: "Ok, next..."
			},
			"3": {
				header: "Take a quick tour to see the magic happen",
				subtitle: "",
				button: "Get Started"
			}
		};
		$scope.goBack = function () {
			$scope.slidePosition--;
		};
		$scope.goForward = function () {
			$scope.slidePosition++;
		};
		$scope.goTo = function ( pos ) {
			$scope.slidePosition = pos;
		}
		$scope.getButton = function () {
			return slide[ $scope.slidePosition ].button;
		};
		$scope.getHeader = function () {
			return slide[ $scope.slidePosition ].header;
		};
		$scope.getSubtitle = function () {
			return slide[ $scope.slidePosition ].subtitle;
		};
		$scope.gotIt = function () {
			if ( $scope.slidePosition === 3 ) {
				window.location = "/d/dropbox/connect";
				$scope.closeModalWindow();
			} else {
				$scope.goForward();
			}
		};
		$scope.slideHeader = slide[ 1 ].header; // default first slide header
		$scope.slideSubtitle = slide[ 1 ].subtitle;
		$scope.slidePosition = 1;
	}
} )( angular, InVision );;;
/*! bulk-invite-project-members-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.BulkInviteProjectMembersController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modelEvents, modalWindowRequest, teamInvitationService, projectService, validationService ) {
		$scope.toggleMessage = function () {
			$( '.texta-wrapper' ).slideDown( 300 );
			$( '.include-message' ).slideUp( 300 );
			$( '#p-message' ).focus();
		};
		$scope.updateTeamMembers = function () {
			var emails = $scope.emails;
			var emailArray = [];
			$scope.errorMessage = "";
			if ( !emails.length ) {
				$scope.closeModalWindow();
				return;
			} else {
				emailArray = emails.split( ',' );
				for ( var e = 0; e < emailArray.length; e++ ) {
					emailArray[ e ] = $.trim( emailArray[ e ] );
					if ( !( /^[^@]+@[^.]+\..+$/i ).test( emailArray[ e ] ) ) {
						$scope.errorMessage = "Please enter in valid email addresses.";
						return;
					}
				}
				Deferred.handlePromise(
					teamInvitationService.send( emailArray.join( ',' ), $scope.personalNote, false, projectID ),
					function ( response ) {
						var newCollabIDs = [];
						for ( var r = 0; r < response.length; r++ ) {
							newCollabIDs.push( response[ r ].id );
						}
						modelEvents.trigger( "projectInviteesAdded", projectID, newCollabIDs );
						$scope.numberOfUsersInvited = emailArray.length;
						$scope.closeModalWindow();
					},
					function ( response ) {
						if ( validationService.isOverQuota( response ) ) {
							$scope.isOverQuota = true;
						} else if ( validationService.isInvalidField( response ) ) {
							$scope.errorMessage = "Please enter in valid email addresses.";
						} else {
							$scope.openModalWindow( "error", "For some reason, we couldn't update the selected people on this project. Try refreshing your browser." );
						}
					}
				);
			}
		};
		var projectID = modalWindowRequest.getData( 0 );
		$scope.invitations = [];
		$scope.personalNote = "";
		$scope.isShowingNoteInput = false;
		$scope.errorMessage = "";
		$scope.emails = "";
	}
} )( angular, InVision );;;
/*! change-plan-billing-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.filter( 'numberFormat', function () {
		return function ( number, format ) {
			var out = "";
			var minLength = format.length;
			var leftZeroPad = format.search( /9/ ) + 2;
			var numsInFormat = ( minLength - leftZeroPad ) + 2;
			var numberAsStr = Number( number ).toString();
			if ( numberAsStr.length >= minLength ) {
				out = numberAsStr;
			} else if ( numberAsStr.length > numsInFormat ) {
				leftZeroPad = minLength - numberAsStr.length;
				out = new Array( Math.max( leftZeroPad + 1, 0 ) ).join( '0' );
				out += numberAsStr;
			} else {
				out = new Array( Math.max( leftZeroPad - 1, 0 ) ).join( '0' );
				out += numberAsStr;
			}
			return out;
		};
	} );
	app.controller( "modal.ChangePlanBillingController", Controller );
	/** @ngInject */
	function Controller(
		$scope,
		$window,
		modalWindowRequest,
		subscriptionService,
		billingService,
		sessionService,
		modelEvents,
		Deferred, _ ) {
		function loadRemoteData() {
			Deferred.handleAllPromises(
				[
					subscriptionService.getCurrentPlan(),
					billingService.getPaymentInfo()
				],
				function ( currentPlan, billingInfo ) {
					var isCurrentPlanFree = ( currentPlan.price === 0 );
					$scope.currentPlan = currentPlan;
					if ( billingInfo.lastFourDigits && billingInfo.lastFourDigits.length == 4 ) {
						$scope.creditCardNumber = "**** **** **** " + billingInfo.lastFourDigits;
						$scope.creditCardCVV = "***";
						$scope.creditCardFullName = billingInfo.name;
						$scope.creditCardExpiryMonth = billingInfo.expirationMonth;
						$scope.creditCardExpiryYear = billingInfo.expirationYear;
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				},
				true
			);
		}

		function calculateYearlySavings( selectedPlan, alternativePlan ) {
			if ( selectedPlan.termLength !== 1 ) {
				return 0;
			}
			return ( selectedPlan.price * alternativePlan.termLength ) - alternativePlan.price;
		}

		function makeRequestToChangePlan( plan ) {
			$scope.submissionInProgress = true;
			setButtonLabel();
			Deferred.handlePromise(
				subscriptionService.changePlan( plan, "", isCustomPrice ),
				function ( newPlan ) {
					$scope.submissionInProgress = false;
					setButtonLabel();
					if ( _.contains( [ PLAN_IDS.teamMonthly, PLAN_IDS.teamOneYear ], newPlan.subscriptionPlanID ) ||
						upgradeIntent === "createTeam" ) {
						$scope.openModalWindow( "changePlanConfirm", newPlan );
					} else if ( upgradeIntent === "seeOnboardingVideo" && !sessionService.user.hasSeenDashboardTour ) {
						$scope.openModalWindow( "onboardingTour" );
					} else if ( isDowngrade ) {
						$scope.openModalWindow( "downgradePlanConfirm", newPlan );
					} else {
						$scope.openModalWindow( "changePlanConfirm", newPlan, isDowngrade );
					}
				},
				function ( response ) {
					$scope.submissionInProgress = false;
					setButtonLabel();
					$scope.creditCardErrorMessage = response.message;
				}
			);
		}

		function setButtonLabel() {
			if ( $scope.submissionInProgress ) {
				$scope.buttonLabel = "Please Wait...";
			} else if ( !_.isUndefined( $scope.selectedPlan.transitionType ) &&
				$scope.selectedPlan.transitionType === "downgrade" ) {
				$scope.buttonLabel = "Choose This Plan";
			} else {
				$scope.buttonLabel = "Upgrade Your Plan";
			}
		}
		$scope.goBackToPlans = function () {
			$scope.openModalWindow( "changePlan" );
		};
		$scope.changePlan = function () {
			$scope.$broadcast( "autofillCheck.update" );
			var hasCardInfoChanged = $scope.creditCard.$dirty;
			var hasCardNameChanged = $scope.creditCard.creditCardFullName.$dirty;
			var hasAnyNonNameCardInfoChanged = (
				$scope.creditCard.creditCardNumber.$dirty ||
				$scope.creditCard.creditCardCVV.$dirty ||
				$scope.creditCard.creditCardExpiryMonth.$dirty ||
				$scope.creditCard.creditCardExpiryYear.$dirty
			);
			if ( $scope.creditCardNumber.length === 0 ) {
				$scope.creditCardErrorMessage = "Please enter a valid card number.";
				return;
			}
			if ( hasCardInfoChanged ) {
				var firstName = $scope.creditCardFullName.split( /\s/ ).splice( 0, 1 ).toString();
				var lastName = $scope.creditCardFullName.split( /\s/ ).splice( -1, 1 ).toString();
				$scope.creditCardNumber = $scope.creditCardNumber.replace( /\D/g, '' );
				var isAMEX = $scope.creditCardNumber.match( /^3[47][0-9]{13}$/ );
				if ( isAMEX && $scope.creditCardCVV.length !== 4 ) {
					$scope.creditCardErrorMessage = "The CVV must be 4 digits for American Express cards.";
					$scope.submissionInProgress = false;
					setButtonLabel();
					return;
				} else if ( ( !isAMEX ) && $scope.creditCardCVV.length !== 3 ) {
					$scope.creditCardErrorMessage = "The CVV must be 3 digits for your card.";
					$scope.submissionInProgress = false;
					setButtonLabel();
					return;
				}
				$scope.submissionInProgress = true;
				setButtonLabel();
				$scope.creditCardErrorMessage = "";
				$scope.shouldShowInternationalErrorInfo = false;
				Deferred.handlePromise(
					billingService.changeCreditCard(
						hasAnyNonNameCardInfoChanged,
						false,
						firstName,
						lastName,
						$scope.creditCardNumber,
						$scope.creditCardExpiryMonth,
						$scope.creditCardExpiryYear,
						$scope.creditCardCVV
					),
					function ( paymentInfo ) {
						try {
							if ( $window.__adroll_loaded ) {
								$window.adroll_segments = "converted-upgrade";
								__adroll.render_pixel_code( adroll_adv_id, adroll_pix_id );
							}
						} catch ( exception ) {}
						modelEvents.trigger( "billingInfo:updated", paymentInfo );
						makeRequestToChangePlan( $scope.selectedPlan );
					},
					function ( response ) {
						$scope.submissionInProgress = false;
						setButtonLabel();
						$scope.creditCardErrorMessage = response.message;
						$scope.creditCardErrorCount++;
						if ( $scope.creditCardErrorCount >= 2 ) {
							$scope.shouldShowInternationalErrorInfo = true;
						}
						modelEvents.trigger( "billingInfo:error", response );
					}
				);
			} else {
				makeRequestToChangePlan( $scope.selectedPlan );
			}
		};
		$scope.clearCardValues = function () {
			if ( $scope.creditCard.creditCardNumber.$pristine ) {
				$scope.creditCardNumber = "";
			}
			if ( $scope.creditCard.creditCardCVV.$pristine ) {
				$scope.creditCardCVV = "";
			}
			/* Don't clear theses as they'll still be sent propperly.
if( $scope.creditCard.creditCardFullName.$pristine ) {
$scope.creditCardFullName = "";
}
if( $scope.creditCard.creditCardExpiryYear.$pristine ) {
$scope.creditCardExpiryYear = "";
}
if( $scope.creditCard.creditCardExpiryMonth.$pristine ) {
$scope.creditCardExpiryMonth = "";
}
*/
		};
		$scope.swapForAlternativePlan = function () {
			var temp = null;
			temp = $scope.selectedPlan;
			$scope.selectedPlan = $scope.alternativePlan;
			$scope.alternativePlan = temp;
		};
		var PLAN_IDS = {
			freeMonthly: 1,
			freeOneYear: 16,
			freeTwoYear: 17,
			starterMonthly: 2,
			starterOneYear: 18,
			starterTwoYear: 19,
			professionalMonthly: 3,
			professionalOneYear: 8,
			professionalTwoYear: 9,
			studioMonthly: 4,
			studioOneYear: 10,
			studioTwoYear: 11,
			studioPlusMonthly: 7,
			studioPlusOneYear: 12,
			studioPlusTwoYear: 13,
			agencyMonthly: 5,
			agencyOneYear: 14,
			agencyTwoYear: 15,
			enterprise: 20,
			custom: 21,
			enterprise_tier2: 22,
			enterprise_tier3: 23,
			enterprise_trial: 24,
			premiumMonthly: 26,
			premiumOneYear: 27,
			teamMonthly: 28,
			teamOneYear: 29
		};
		modalWindowRequest.setSuppressClose( false );
		var currentDate = new Date();
		var nextDefaultExpirationDate = null;
		var isDowngrade = false;
		var isCustomPrice = false;
		$scope.monthsInForm = _.range( 1, 13 );
		$scope.yearsInForm = _.range( currentDate.getFullYear(), currentDate.getFullYear() + 10 );
		if ( currentDate.getMonth() == 11 ) {
			nextDefaultExpirationDate = new Date( currentDate.getFullYear() + 1, 0, 1 );
		} else {
			nextDefaultExpirationDate = new Date( currentDate.getFullYear(), currentDate.getMonth() + 1, 1 );
		}
		$scope.creditCardFullName = "";
		$scope.creditCardNumber = "";
		$scope.creditCardCVV = "";
		$scope.creditCardExpiryYear = nextDefaultExpirationDate.getFullYear();
		$scope.creditCardExpiryMonth = nextDefaultExpirationDate.getMonth() + 1;
		var upgradeData = modalWindowRequest.getData( 0 );
		var upgradeIntent = modalWindowRequest.getData( 1, "" );
		$scope.selectedPlan = upgradeData.selectedPlan;
		isCustomPrice = $scope.selectedPlan.isCustomPrice;
		isDowngrade = ( $scope.selectedPlan.transitionType == "downgrade" );
		$scope.hasAlternativePlan = false;
		if ( !_.isNull( upgradeData.alternativeTermOption ) ) {
			$scope.hasAlternativePlan = true;
		}
		$scope.isShowingSinglePlanVariant = upgradeData.isShowingSinglePlanVariant;
		$scope.alternativePlan = upgradeData.alternativeTermOption;
		$scope.yearlySaving = calculateYearlySavings;
		$scope.isProrated = upgradeData.isProrated;
		$scope.prorateAmount = upgradeData.prorateAmount;
		$scope.creditCardErrorMessage = "";
		$scope.creditCardErrorCount = 0;
		$scope.shouldShowInternationalErrorInfo = false;
		$scope.submissionInProgress = false;
		$scope.buttonLabel = "";
		$scope.showCoupon = false;
		$scope.carouselStartPos = 1;
		setButtonLabel();
		$scope.$on(
			"$destroy",
			function () {
				$window._kiq.push( [ 'hideSurvey' ] );
				$window.olark( 'api.box.hide' );
			}
		);
		if ( sessionService.get( 'olarkOperatorAvailable', false ) ) {
			$window.olark( 'api.box.show' );
		}
		$window._kmq.push( [ 'record', 'Billing Page Viewed' ] );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! change-plan-billing-enterprise-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ChangePlanBillingEnterpriseController", Controller );
	/** @ngInject */
	function Controller(
		$scope,
		$window,
		modalWindowRequest,
		subscriptionService,
		billingService,
		sessionService,
		modelEvents,
		Deferred, _ ) {
		function loadRemoteData() {
			Deferred.handleAllPromises(
				[
					subscriptionService.getCurrentPlan(),
					billingService.getPaymentInfo()
				],
				function ( currentPlan, billingInfo ) {
					var isCurrentPlanFree = ( currentPlan.price === 0 );
					$scope.currentPlan = currentPlan;
					setSalesRepBasedOnNote( currentPlan.notes );
					if ( billingInfo.lastFourDigits && billingInfo.lastFourDigits.length === 4 ) {
						$scope.creditCardNumber = "**** **** **** " + billingInfo.lastFourDigits;
						$scope.creditCardCVV = "***";
						$scope.creditCardFullName = billingInfo.name;
						$scope.creditCardExpiryMonth = billingInfo.expirationMonth;
						$scope.creditCardExpiryYear = billingInfo.expirationYear;
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				},
				true
			);
		}

		function setSalesRepBasedOnNote( note ) {
			var possibleRepEmail = note.match( /(\w*@invisionapp\.com)/ );
			if ( !_.isNull( possibleRepEmail ) && !_.isUndefined( SALES_REPS[ possibleRepEmail[ 0 ] ] ) ) {
				$scope.salesRep = SALES_REPS[ possibleRepEmail[ 0 ] ];
			} else {
				$scope.salesRep = SALES_REPS[ "clark@invisionapp.com" ];
			}
		}

		function makeRequestToChangePlan( plan, coupon ) {
			$scope.submissionInProgress = true;
			setButtonLabel();
			Deferred.handlePromise(
				subscriptionService.changePlan( plan, coupon, true ),
				function ( newPlan ) {
					$scope.submissionInProgress = false;
					setButtonLabel();
					$scope.openModalWindow( "changePlanConfirmEnterprise", newPlan );
				},
				function ( response ) {
					$scope.submissionInProgress = false;
					setButtonLabel();
					$scope.creditCardErrorMessage = response.message;
				}
			);
		}

		function setButtonLabel() {
			if ( $scope.submissionInProgress ) {
				$scope.buttonLabel = "Please Wait...";
			} else if ( !_.isUndefined( $scope.selectedPlan.transitionType ) &&
				$scope.selectedPlan.transitionType === "downgrade" ) {
				$scope.buttonLabel = "Choose This Plan";
			} else {
				$scope.buttonLabel = "Upgrade Your Account";
			}
		}
		$scope.changePlan = function () {
			$scope.$broadcast( "autofillCheck.update" );
			var hasCardInfoChanged = $scope.creditCard.$dirty;
			var hasCardNameChanged = $scope.creditCard.creditCardFullName.$dirty;
			var hasAnyNonNameCardInfoChanged = (
				$scope.creditCard.creditCardNumber.$dirty ||
				$scope.creditCard.creditCardCVV.$dirty ||
				$scope.creditCard.creditCardExpiryMonth.$dirty ||
				$scope.creditCard.creditCardExpiryYear.$dirty
			);
			if ( hasCardInfoChanged ) {
				var firstName = $scope.creditCardFullName.split( /\s/ ).splice( 0, 1 ).toString();
				var lastName = $scope.creditCardFullName.split( /\s/ ).splice( -1, 1 ).toString();
				var isAMEX = $scope.creditCardNumber.match( /^3[47][0-9]{13}$/ );
				if ( isAMEX && $scope.creditCardCVV.length !== 4 ) {
					$scope.creditCardErrorMessage = "The CVV must be 4 digits for American Express cards.";
					$scope.submissionInProgress = false;
					setButtonLabel();
					return;
				} else if ( ( !isAMEX ) && $scope.creditCardCVV.length !== 3 ) {
					$scope.creditCardErrorMessage = "The CVV must be 3 digits for your card.";
					$scope.submissionInProgress = false;
					setButtonLabel();
					return;
				}
				$scope.submissionInProgress = true;
				setButtonLabel();
				$scope.creditCardErrorMessage = "";
				$scope.shouldShowInternationalErrorInfo = false;
				Deferred.handlePromise(
					billingService.changeCreditCard(
						hasAnyNonNameCardInfoChanged,
						false,
						firstName,
						lastName,
						$scope.creditCardNumber,
						$scope.creditCardExpiryMonth,
						$scope.creditCardExpiryYear,
						$scope.creditCardCVV
					),
					function ( paymentInfo ) {
						modelEvents.trigger( "billingInfo:updated", paymentInfo );
						makeRequestToChangePlan( $scope.selectedPlan, $scope.coupon );
					},
					function ( response ) {
						$scope.submissionInProgress = false;
						setButtonLabel();
						$scope.creditCardErrorMessage = response.message;
						$scope.creditCardErrorCount++;
						if ( $scope.creditCardErrorCount >= 2 ) {
							$scope.shouldShowInternationalErrorInfo = true;
						}
						modelEvents.trigger( "billingInfo:error", response );
					}
				);
			} else {
				makeRequestToChangePlan( $scope.selectedPlan, $scope.coupon );
			}
		};
		$scope.clearCardValues = function () {
			if ( $scope.creditCard.creditCardNumber.$pristine ) {
				$scope.creditCardNumber = "";
			}
			if ( $scope.creditCard.creditCardCVV.$pristine ) {
				$scope.creditCardCVV = "";
			}
			/* Don't clear theses as they'll still be sent propperly.
if( $scope.creditCard.creditCardFullName.$pristine ) {
$scope.creditCardFullName = "";
}
if( $scope.creditCard.creditCardExpiryYear.$pristine ) {
$scope.creditCardExpiryYear = "";
}
if( $scope.creditCard.creditCardExpiryMonth.$pristine ) {
$scope.creditCardExpiryMonth = "";
}
*/
		};
		$scope.swapForAlternativePlan = function () {
			var temp = null;
			temp = $scope.selectedPlan;
			$scope.selectedPlan = $scope.alternativePlan;
			$scope.alternativePlan = temp;
		};
		var SALES_REPS = {
			"clark@invisionapp.com": {
				headshot: "clark-headshot.png",
				phone: "1-877-932-7111",
				email: "clark@invisionapp.com"
			},
			"ryanduffy@invisionapp.com": {
				headshot: "ryan-headshot.png",
				phone: "916-532-7020",
				email: "ryanduffy@invisionapp.com"
			},
			"ahad@invisionapp.com": {
				headshot: "ahad-headshot.png",
				phone: "214-995-3125",
				email: "ahad@invisionapp.com"
			},
			"stuart@invisionapp.com": {
				headshot: "stuart-headshot.png",
				phone: "214-995-3125",
				email: "stuart@invisionapp.com"
			}
		};
		var currentDate = new Date();
		var nextDefaultExpirationDate = null;
		$scope.monthsInForm = _.range( 1, 13 );
		$scope.yearsInForm = _.range( currentDate.getFullYear(), currentDate.getFullYear() + 10 );
		if ( currentDate.getMonth() == 11 ) {
			nextDefaultExpirationDate = new Date( currentDate.getFullYear() + 1, 0, 1 );
		} else {
			nextDefaultExpirationDate = new Date( currentDate.getFullYear(), currentDate.getMonth() + 1, 1 );
		}
		$scope.creditCardFullName = sessionService.user.name;
		$scope.creditCardNumber = "";
		$scope.creditCardCVV = "";
		$scope.creditCardExpiryYear = nextDefaultExpirationDate.getFullYear();
		$scope.creditCardExpiryMonth = nextDefaultExpirationDate.getMonth() + 1;
		var upgradeData = modalWindowRequest.getData( 0 );
		$scope.selectedPlan = upgradeData.selectedPlan;
		$scope.hasAlternativePlan = false;
		if ( !_.isNull( upgradeData.alternativeTermOption ) ) {
			$scope.hasAlternativePlan = true;
		}
		$scope.alternativePlan = upgradeData.alternativeTermOption;
		$scope.isProrated = upgradeData.isProrated;
		$scope.prorateAmount = upgradeData.prorateAmount;
		$scope.creditCardErrorMessage = "";
		$scope.creditCardErrorCount = 0;
		$scope.shouldShowInternationalErrorInfo = false;
		$scope.submissionInProgress = false;
		$scope.buttonLabel = "";
		$scope.salesRep = SALES_REPS.clark;
		$scope.price = $scope.selectedPlan.price;
		$scope.coupon = "";
		$scope.showCoupon = false;
		setButtonLabel();
		$scope.$on(
			"$destroy",
			function () {
				$window._kiq.push( [ 'hideSurvey' ] );
				if ( sessionService.subscription.price > 0 ) {
					$window.olark( 'api.box.hide' );
				}
			}
		);
		$scope.$watch(
			"coupon",
			function ( newVal, oldVal ) {
				if ( newVal === oldVal ) {
					return;
				}
				if ( newVal === "enterprise-loyalty" ) {
					$scope.price = $scope.selectedPlan.price * .8;
				} else if ( newVal === "enterprise-bonus" ) {
					$scope.price = $scope.selectedPlan.price * .5;
				} else if ( newVal === "thanks-jiffy" && $scope.selectedPlan.price === 30000 ) {
					$scope.price = $scope.selectedPlan.price - 26500;
				} else {
					$scope.price = $scope.selectedPlan.price;
				}
			} );
		$window.olark( 'api.box.show' );
		$window._kmq.push( [ 'record', 'Billing Page Viewed' ] );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! change-plan-confirm-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ChangePlanConfirmController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, sessionService, modalWindowRequest, _ ) {
		$scope.openMyInfo = function () {
			$location.path( "/team/" + sessionService.user.id + "/profile" );
			$scope.closeModalWindow();
		};
		$scope.selectedPlan = modalWindowRequest.getData( 0 );
		$scope.isDowngrade = modalWindowRequest.getData( 1, false );
		$scope.isCompany = sessionService.user.isCompany;
		$scope.carouselStartPos = 2;
		$scope.isTeamPlan = _.contains( [ 28, 29 ], $scope.selectedPlan.subscriptionPlanID );
		if ( !$scope.isDowngrade ) {
			( function () {
				var fb_param = {};
				fb_param.pixel_id = '6013101387847';
				fb_param.value = $scope.selectedPlan.price;
				fb_param.currency = 'USD';
				( function () {
					var fpw = document.createElement( 'script' );
					fpw.async = true;
					fpw.src = '//connect.facebook.net/en_US/fp.js';
					var ref = document.getElementsByTagName( 'script' )[ 0 ];
					ref.parentNode.insertBefore( fpw, ref );
				} )();
			} )();
		}
	}
} )( angular, InVision );;;
/*! change-plan-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ChangePlanController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, modalWindowRequest, changePlansPartial, subscriptionService, billingService, sessionService, Deferred, modelEvents, accountService, moment, _ ) {
		function getPlansForSinglePlan() {
			var plans = [];
			if ( $scope.isShowingSinglePlanVariant ) {
				plans = [ {
					canArchiveProjects: true,
					canArchiveScreens: true,
					description: "Professional plan, monthly",
					id: 26,
					isactive: "1",
					maxAssetByteCount: 1073741824,
					maxProjectCount: 999999,
					maxProjectMemberCount: 6,
					maxSMSCount: 10,
					maxScreenCount: 999999,
					monthlyPlanEquiv: 26,
					monthlyPrice: 25,
					name: "Professional",
					price: 25,
					termLength: 1
				}, {
					canArchiveProjects: true,
					canArchiveScreens: true,
					description: "Professional plan, 1 year",
					id: 27,
					isactive: "1",
					maxAssetByteCount: 1073741824,
					maxProjectCount: 999999,
					maxProjectMemberCount: 6,
					maxSMSCount: 10,
					maxScreenCount: 999999,
					monthlyPlanEquiv: 26,
					monthlyPrice: 22,
					name: "Professional",
					price: 264,
					termLength: 12
				} ];
			}
			return plans;
		}

		function isEligibleForSinglePlanVariant( currentPlan ) {
			var isEligible = false;
			var eligiblePlans = [ PLAN_IDS.freeMonthly, PLAN_IDS.starterMonthly, PLAN_IDS.starterOneYear, PLAN_IDS.starterTwoYear, PLAN_IDS.custom, PLAN_IDS.educationFaculty, PLAN_IDS.educationStudent ];
			isEligible = !canShowDowngrades && _.contains( eligiblePlans, currentPlan.subscriptionPlanID );
			return isEligible;
		}

		function isCustomOrPromotionalPlan( planID ) {
			var customPlanIds = [
				PLAN_IDS.custom,
				PLAN_IDS.educationFaculty,
				PLAN_IDS.educationStudent
			];
			return ( customPlanIds.indexOf( planID ) >= 0 );
		}

		function loadRemoteData() {
			Deferred.handlePromise(
				changePlansPartial.get(),
				function ( response ) {
					var currentPlan = response.currentPlan;
					var projects = response.projects;
					var plans = response.plans;
					var lastUpgradeDate = response.lastUpgradeDate;
					var user = response.user;
					var isCurrentPlanFree = isEquivalentToFreePlan( currentPlan.subscriptionPlanID );
					if ( currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_trial ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_tier2 ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_tier3
					) {
						$scope.openModalWindow( "changePlanEnterprise" );
					}
					$scope.isShowingSinglePlanVariant = (
						$scope.isShowingSinglePlanVariant ||
						isCustomOrPromotionalPlan( currentPlan.subscriptionPlanID ) ||
						_.contains(
							[ PLAN_IDS.premiumMonthly, PLAN_IDS.premiumOneYear, PLAN_IDS.freeMonthly, PLAN_IDS.starterMonthly, PLAN_IDS.starterOneYear, PLAN_IDS.starterTwoYear ],
							currentPlan.subscriptionPlanID
						)
					);
					$scope.subview = 'oneYear';
					$scope.user.projectCount = projects.length;
					$scope.user.maxProjectMembersInAnyProject = ( _.maxProperty( projects, "projectMemberCount" ) || 0 );
					$scope.rawPlans = plans.concat( getPlansForSinglePlan() );
					$scope.plans = preparePlansForDisplay( currentPlan, plans );
					$scope.currentPlan = currentPlan;
					if ( forwardToPlan !== "" ) {
						var planToJumpTo = _.find( $scope.rawPlans, function ( plan ) {
							if ( plan.id === PLAN_IDS[ forwardToPlan ] ) {
								return true;
							}
						} );
						$scope.changePlanTo( null, planToJumpTo );
					}
					setQualarooData( currentPlan, user, lastUpgradeDate, projects );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				},
				true
			);
		}

		function groupPlansByType( currentPlan, plan ) {
			if ( isCustomOrPromotionalPlan( currentPlan.subscriptionPlanID ) ||
				plan.maxProjectCount > currentPlan.maxProjectCount ) {
				return "upgrade";
			} else if ( plan.maxProjectCount === currentPlan.maxProjectCount ) {
				if ( currentPlan.subscriptionPlanID.subscriptionPlanID === plan.id ||
					isEquivalentToFreePlan( currentPlan.subscriptionPlanID ) ) {
					return "current";
				} else if ( plan.termLength < currentPlan.termLength ) {
					return "upgrade";
				} else {
					return "upgrade";
				}
			} else {
				return "aDowngrade";
			}
		}

		function setQualarooData( currentPlan, user, lastUpgradeDate, projects ) {
			var qualarooData = {};
			qualarooData[ "Signup Date" ] = moment( user.createdAt ).format( "MMM D, YYYY" );
			qualarooData.Plan = currentPlan.name;
			qualarooData[ "Project Count" ] = projects.length;
			qualarooData[ "Over-quota Project Count" ] = ( _.filterWithProperty( projects, "isOverQuota", true ).length || 0 );
			if ( _.isNumber( lastUpgradeDate ) ) {
				qualarooData[ "Last Upgrade Date" ] = moment( lastUpgradeDate ).format( "MMM D, YYYY" );
			}
			if ( _.isNumber( currentPlan.projectGracePeriodEndsAt ) ) {
				qualarooData[ "Grace Period Ended At" ] = moment( currentPlan.projectGracePeriodEndsAt ).format( "MMM D, YYYY" );
			}
			$window._kiq.push( [ 'set', qualarooData ] );
		}

		function makeBytesHumanReadable( bytes, precision ) {
			if ( isNaN( parseFloat( bytes ) ) || !isFinite( bytes ) ) {
				return '-';
			} else if ( bytes === 0 ) {
				return 0;
			}
			if ( typeof precision === 'undefined' ) {
				precision = 1;
			}
			var units = [ 'bytes', 'kB', 'MB', 'GB', 'TB', 'PB' ],
				number = Math.floor( Math.log( bytes ) / Math.log( 1024 ) );
			return ( bytes / Math.pow( 1024, Math.floor( number ) ) ).toFixed( precision ) + ' ' + units[ number ];
		}

		function preparePlansForDisplay( currentPlan, plans ) {
			var isCurrentPlanFree = isPlanFree( currentPlan );
			if ( $scope.isShowingSinglePlanVariant && isEligibleForSinglePlanVariant( currentPlan ) ) {
				var currentPlanEquivalents = [];
				if ( !isCustomOrPromotionalPlan( currentPlan.subscriptionPlanID ) ) {
					currentPlanEquivalents = _.where( plans, function ( plan ) {
						var tmpCurrentPlan = _.find( plans, function ( plan ) {
							return plan.id === currentPlan.subscriptionPlanID;
						} );
						return ( tmpCurrentPlan.monthlyPlanEquiv === plan.monthlyPlanEquiv );
					} );
				}
				if ( isCurrentPlanFree ) {
					plans = _.where( plans, function ( plan ) {
						return plan.monthlyPlanEquiv === PLAN_IDS.starterMonthly;
					} )
						.concat(
							_.where( plans, function ( plan ) {
								return ( plan.id === PLAN_IDS.teamMonthly || plan.id === PLAN_IDS.teamOneYear );
							} )
					)
						.concat( getPlansForSinglePlan() )
						.concat( currentPlanEquivalents );
				} else {
					plans = getPlansForSinglePlan()
						.concat(
							_.where( plans, function ( plan ) {
								return ( plan.id === PLAN_IDS.teamMonthly || plan.id === PLAN_IDS.teamOneYear );
							} )
					)
						.concat( currentPlanEquivalents );
				}
				plans = _.sortBy( plans, "id" );
			}
			if ( _.contains( [ PLAN_IDS.premiumMonthly, PLAN_IDS.premiumOneYear ], currentPlan.subscriptionPlanID ) ) {
				plans = getPlansForSinglePlan().concat( plans );
			}
			if ( currentPlan.subscriptionPlanID === PLAN_IDS.pause ) {
				var freePlanIDs = [ PLAN_IDS.freeMonthly, PLAN_IDS.freeOneYear, PLAN_IDS.freeTwoYear ];
				plans = _.filter( plans, function ( p ) {
					return !( _.contains( freePlanIDs, p.id ) );
				} );
			}
			var tmpPlans = {
				monthly: _.where( plans, {
					termLength: 1
				} ),
				oneYear: _.where( plans, {
					termLength: 12
				} ),
				twoYear: _.where( plans, {
					termLength: 24
				} )
			};
			var groupPlansByTypeCurried = _.curry( groupPlansByType );
			groupPlansByTypeCurried = groupPlansByTypeCurried( currentPlan );
			tmpPlans.monthly = _.groupBy( tmpPlans.monthly, groupPlansByTypeCurried );
			tmpPlans.oneYear = _.groupBy( tmpPlans.oneYear, groupPlansByTypeCurried );
			tmpPlans.twoYear = _.groupBy( tmpPlans.twoYear, groupPlansByTypeCurried );
			var planMetaMapping = {
				"free": {
					initiallyShownIds: [
						PLAN_IDS.freeMonthly,
						PLAN_IDS.starterMonthly,
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.freeOneYear,
						PLAN_IDS.starterOneYear,
						PLAN_IDS.premiumOneYear,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.premiumOneYear
					]
				},
				"pause": {
					initiallyShownIds: [
						PLAN_IDS.starterMonthly,
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.starterOneYear,
						PLAN_IDS.premiumOneYear,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.professionalMonthly,
						PLAN_IDS.professionalOneYear
					]
				},
				"starter": {
					initiallyShownIds: [
						PLAN_IDS.starterMonthly,
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.starterOneYear,
						PLAN_IDS.premiumOneYear,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.premiumOneYear
					]
				},
				"professional": {
					initiallyShownIds: [
						PLAN_IDS.professionalMonthly,
						PLAN_IDS.studioMonthly,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.professionalOneYear,
						PLAN_IDS.studioOneYear,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.studioMonthly,
						PLAN_IDS.studioOneYear,
						PLAN_IDS.studioTwoYear
					]
				},
				"studio": {
					initiallyShownIds: [
						PLAN_IDS.studioMonthly,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.studioOneYear,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					]
				},
				"studioPlus": {
					initiallyShownIds: [
						PLAN_IDS.studioPlusMonthly,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.studioPlusOneYear,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					]
				},
				"agency": {
					initiallyShownIds: [
						PLAN_IDS.agencyMonthly,
						PLAN_IDS.agencyOneYear,
						PLAN_IDS.agencyTwoYear,
						PLAN_IDS.teamOneYear,
						PLAN_IDS.teamMonthly
					],
					featuredIds: []
				},
				"custom": {
					initiallyShownIds: [
						PLAN_IDS.freeMonthly,
						PLAN_IDS.starterMonthly,
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.freeOneYear,
						PLAN_IDS.starterOneYear,
						PLAN_IDS.premiumOneYear,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.premiumOneYear
					]
				},
				"premium": {
					initiallyShownIds: [
						PLAN_IDS.premiumMonthly,
						PLAN_IDS.teamMonthly,
						PLAN_IDS.premiumOneYear,
						PLAN_IDS.teamOneYear
					],
					featuredIds: [
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear
					]
				},
				"team": {
					initiallyShownIds: [
						PLAN_IDS.teamMonthly,
						PLAN_IDS.teamOneYear,
						PLAN_IDS.enterprise
					],
					featuredIds: []
				},
				"enterprise": {
					initiallyShownIds: [
						PLAN_IDS.agencyMonthly,
						PLAN_IDS.agencyOneYear,
						PLAN_IDS.agencyTwoYear
					],
					featuredIds: []
				}
			};
			var planMapping = {};
			planMapping[ PLAN_IDS.pause ] = planMetaMapping.pause;
			planMapping[ PLAN_IDS.freeMonthly ] = planMetaMapping.free;
			planMapping[ PLAN_IDS.freeOneYear ] = planMetaMapping.free;
			planMapping[ PLAN_IDS.freeTwoYear ] = planMetaMapping.free;
			planMapping[ PLAN_IDS.starterMonthly ] = planMetaMapping.starter;
			planMapping[ PLAN_IDS.starterOneYear ] = planMetaMapping.starter;
			planMapping[ PLAN_IDS.starterTwoYear ] = planMetaMapping.starter;
			planMapping[ PLAN_IDS.professionalMonthly ] = planMetaMapping.professional;
			planMapping[ PLAN_IDS.professionalOneYear ] = planMetaMapping.professional;
			planMapping[ PLAN_IDS.professionalTwoYear ] = planMetaMapping.professional;
			planMapping[ PLAN_IDS.studioMonthly ] = planMetaMapping.studio;
			planMapping[ PLAN_IDS.studioOneYear ] = planMetaMapping.studio;
			planMapping[ PLAN_IDS.studioTwoYear ] = planMetaMapping.studio;
			planMapping[ PLAN_IDS.studioPlusMonthly ] = planMetaMapping.studioPlus;
			planMapping[ PLAN_IDS.studioPlusOneYear ] = planMetaMapping.studioPlus;
			planMapping[ PLAN_IDS.studioPlusTwoYear ] = planMetaMapping.studioPlus;
			planMapping[ PLAN_IDS.agencyMonthly ] = planMetaMapping.agency;
			planMapping[ PLAN_IDS.agencyOneYear ] = planMetaMapping.agency;
			planMapping[ PLAN_IDS.agencyTwoYear ] = planMetaMapping.agency;
			planMapping[ PLAN_IDS.enterprise ] = planMetaMapping.enterprise;
			planMapping[ PLAN_IDS.enterprise_tier2 ] = planMetaMapping.enterprise;
			planMapping[ PLAN_IDS.enterprise_tier3 ] = planMetaMapping.enterprise;
			planMapping[ PLAN_IDS.enterprise_trial ] = planMetaMapping.enterprise;
			planMapping[ PLAN_IDS.custom ] = planMetaMapping.custom;
			planMapping[ PLAN_IDS.premiumMonthly ] = planMetaMapping.premium;
			planMapping[ PLAN_IDS.premiumOneYear ] = planMetaMapping.premium;
			planMapping[ PLAN_IDS.teamMonthly ] = planMetaMapping.team;
			planMapping[ PLAN_IDS.teamOneYear ] = planMetaMapping.team;
			planMapping[ PLAN_IDS.educationFaculty ] = planMetaMapping.free;
			planMapping[ PLAN_IDS.educationStudent ] = planMetaMapping.free;
			var plansToShow = planMapping[ currentPlan.subscriptionPlanID ].initiallyShownIds;
			var plansToFeature = planMapping[ currentPlan.subscriptionPlanID ].featuredIds;
			$scope.showEnterprisePlan = ( _.contains( plansToShow, PLAN_IDS.enterprise ) );
			_.each( tmpPlans, function ( planTermGroup, key, list ) {
				_.each( planTermGroup, function ( planTransitionType, outerKey, list ) {
					_.each( planTransitionType, function ( plan, key, list ) {
						if ( isEquivalentToFreePlan( plan.id ) ) {
							plan.id = PLAN_IDS.freeMonthly;
						}
						plan.simpleClassName = plan.name.toLowerCase().replace( /\s/gi, '-' );
						plan.isShownByDefault = _.contains( plansToShow, plan.id );
						plan.isFeatured = _.contains( plansToFeature, plan.id );
						plan.isCurrent = ( plan.id === currentPlan.subscriptionPlanID );
						plan.assetAllowanceHumanReadable = makeBytesHumanReadable( plan.maxAssetByteCount, 0 );
						if ( outerKey === "aDowngrade" ) {
							plan.transitionType = "downgrade";
						} else {
							plan.transitionType = outerKey;
						}
					} );
				} );
			} );
			return tmpPlans;
		}

		function isPlanFree( plan ) {
			return plan.price === 0;
		}

		function isEquivalentToFreePlan( planID ) {
			return (
				planID === PLAN_IDS.freeMonthly ||
				planID === PLAN_IDS.freeOneYear ||
				planID === PLAN_IDS.freeTwoYear
			);
		}
		$scope.closeModalWindow = function () {
			$window.olark( 'api.box.hide' );
			$scope.closeModalWindow();
		};
		$scope.showSubview = function ( subview ) {
			$scope.subview = subview;
		};
		$scope.showAllPlans = function () {
			$scope.allPlansShown = true;
		};
		$scope.shouldShowPlanLevelType = function ( planLevelType ) {
			if ( canShowDowngrades ) {
				return true;
			} else {
				return ( planLevelType !== "aDowngrade" );
			}
		};
		$scope.getLinkLabel = function ( plan, planLevelType ) {
			if ( plan.isCurrent ) {
				return "Current Plan";
			} else if ( isCustomOrPromotionalPlan( $scope.currentPlan.subscriptionPlanID ) ||
				$scope.currentPlan.subscriptionPlanID === PLAN_IDS.enterprise ||
				planLevelType === 'upgrade' ) {
				return "Choose Plan";
			} else if ( planLevelType === 'aDowngrade' ) {
				return "Downgrade";
			} else if ( plan.name === "Free" &&
				$scope.currentPlan.subscriptionPlanID === PLAN_IDS.freeMonthly ) {
				return "Current Plan";
			}
		};
		$scope.changePlanTo = function ( $event, plan ) {
			if ( $event ) {
				$event.preventDefault();
			}
			$scope.selectedPlan = plan;
			var termForAlternativeOption = ( plan.termLength === 1 ) ? 12 : 1;
			var isZeroCost = isPlanFree( plan );
			var isOverProjectQuota = ( $scope.user.projectCount > plan.maxProjectCount );
			var isOverProjectMemberQuota = false; // = ( $scope.user.maxProjectMembersInAnyProject > plan.maxProjectMemberCount );
			var planData = {
				"isShowingSinglePlanVariant": $scope.isShowingSinglePlanVariant,
				"isProrated": false,
				"prorateAmount": 0,
				"selectedPlan": plan,
				"alternativeTermOption": _.where(
					$scope.rawPlans, {
						termLength: termForAlternativeOption,
						monthlyPlanEquiv: plan.monthlyPlanEquiv
					}
				)[ 0 ]
			};
			if ( isOverProjectQuota ) {
				return ( $scope.showOverProjectWarning = true );
			}
			if ( isOverProjectMemberQuota ) {
				return ( $scope.showOverProjectMemberWarning = true );
			}
			if ( !isZeroCost ) {
				isGoingToBillingModal = true;
				if ( !canShowDowngrades ) {
					return ( $scope.openModalWindow( "changePlanBilling", planData, upgradeIntent ) );
				} else {
					return ( $scope.openModalWindow( "downgradePlanBilling", planData ) );
				}
			}
			Deferred.handlePromise(
				subscriptionService.changePlan( $scope.selectedPlan ),
				function ( newPlan ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't change your subscription plan. Try refreshing your browser." );
				}
			);
		};
		$scope.sendUsersDetailsToSales = function () {
			$scope.enterprisePlanRequestSent = true;
			accountService.sendEnterpriseInfoRequest();
		};
		$scope.toggleProFeaturesFlyout = function () {
			$scope.isShowingProFeaturesFlyout = !$scope.isShowingProFeaturesFlyout;
		};
		$scope.toggleTeamFeaturesFlyout = function () {
			$scope.isShowingTeamFeaturesFlyout = !$scope.isShowingTeamFeaturesFlyout;
		};
		var singlePlanExperimentBucket = sessionService.get( "planListingPresentationGroup", "Multiple plans" );
		var teamPlanExperimentBucket = sessionService.get( "planListingTeamPlanVisibility", "Team Plan is hidden" );
		var canShowDowngrades = false;
		var qualarooTimer = null;
		var PLAN_IDS = {
			freeMonthly: 1,
			freeOneYear: 16,
			freeTwoYear: 17,
			starterMonthly: 2,
			starterOneYear: 18,
			starterTwoYear: 19,
			professionalMonthly: 3,
			professionalOneYear: 8,
			professionalTwoYear: 9,
			studioMonthly: 4,
			studioOneYear: 10,
			studioTwoYear: 11,
			studioPlusMonthly: 7,
			studioPlusOneYear: 12,
			studioPlusTwoYear: 13,
			agencyMonthly: 5,
			agencyOneYear: 14,
			agencyTwoYear: 15,
			enterprise: 20,
			custom: 21,
			enterprise_tier2: 22,
			enterprise_tier3: 23,
			enterprise_trial: 24,
			premiumMonthly: 26,
			premiumOneYear: 27,
			teamMonthly: 28,
			teamOneYear: 29,
			pause: 30,
			educationFaculty: 31,
			educationStudent: 32
		};
		var calledWithSubview = "";
		var isGoingToBillingModal = false;
		var modalOpenedDueTo = "";
		var forwardToPlan = "";
		var upgradeIntent = "";
		var modalData = ( modalWindowRequest.getData( 0 ) || {} );
		_.defaults( modalData, {
			showAllPlans: false,
			subview: "",
			canShowDowngrades: false,
			openedDueTo: "",
			forwardToPlan: "",
			upgradeIntent: ""
		} );
		upgradeIntent = modalData.upgradeIntent;
		forwardToPlan = modalData.forwardToPlan;
		canShowDowngrades = modalData.canShowDowngrades;
		calledWithSubview = modalData.subview;
		modalOpenedDueTo = modalData.openedDueTo;
		$scope.subview = "oneYear";
		$scope.allPlansShown = modalData.showAllPlans;
		$scope.showEnterprisePlan = false;
		$scope.plans = {
			monthly: [],
			oneYear: [],
			twoYear: []
		};
		$scope.selectedPlan = null;
		$scope.showOverProjectWarning = false;
		$scope.showOverProjectMemberWarning = false;
		$scope.user = {
			projectCount: 0,
			maxProjectMembersInAnyProject: 0
		};
		$scope.shouldShowShowAllPlansLink = true;
		$scope.enterprisePlanRequestSent = false;
		$scope.carouselStartPos = 0;
		$scope.isShowingSinglePlanVariant = ( singlePlanExperimentBucket === "Single plan" );
		$scope.isShowingTeamPlan = ( teamPlanExperimentBucket === "Team Plan is visible" );
		$scope.isShowingProFeaturesFlyout = false;
		$scope.isShowingTeamFeaturesFlyout = false;
		if ( modalOpenedDueTo === "project quota" ) {
			$scope.modalTitle = "Upgrade your account to create new projects";
		} else {
			$scope.modalTitle = "Way to go! You're ready for an upgrade!";
		}
		$scope.$on(
			"$destroy",
			function () {
				$timeout.cancel( qualarooTimer );
				if ( !isGoingToBillingModal ) {
					$window._kiq.push( [ 'hideSurvey' ] );
					$window.olark( 'api.box.hide' );
				}
			}
		);
		var isUserAtEndofUpgradePath = [ PLAN_IDS.teamMonthly, PLAN_IDS.teamOneYear, PLAN_IDS.agencyMonthly, PLAN_IDS.agencyOneYear, PLAN_IDS.agencyTwoYear ];
		if ( !canShowDowngrades &&
			_.contains( isUserAtEndofUpgradePath, sessionService.subscription.subscriptionPlanID ) ) {
			$timeout( function () {
				$scope.openModalWindow( "enterpriseContactForm" );
			}, 10 );
		}
		if ( sessionService.get( 'olarkOperatorAvailable', false ) ) {
			$window.olark( 'api.box.show' );
		}
		$window.olark( 'api.chat.onOperatorsAvailable', function () {
			$window.olark( 'api.box.show' );
			sessionService.set( 'olarkOperatorAvailable', true );
		} );
		if ( $scope.allPlansShown ) {
			$window._kiq.push( [ 'showSurvey', 110779, true ] );
		} else {
			$window._kmq.push( [ 'record', 'Upgrade modal viewed' ] );
			if ( modalOpenedDueTo !== "" ) {
				$window._kmq.push( [ 'record', 'Upgrade modal viewed via ' + modalOpenedDueTo ] );
			}
			qualarooTimer = $timeout(
				function () {
					$window._kiq.push( [ 'showSurvey', 104396, true ] );
				}, ( 8 * 1000 )
			);
		}
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! change-plan-enterprise-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ChangePlanEnterpriseController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, modalWindowRequest, changePlansPartial, subscriptionService, billingService, sessionService, Deferred, modelEvents, accountService, _, moment ) {
		function loadRemoteData() {
			Deferred.handlePromise(
				changePlansPartial.get(),
				function ( response ) {
					var currentPlan = response.currentPlan;
					var projects = response.projects;
					var plans = getEnterprisePlans();
					var assetSizeUsed = response.totalAssetFileSizeUsed;
					$scope.user.projectCount = projects.length;
					$scope.user.maxProjectMembersInAnyProject = ( _.maxProperty( projects, "projectMemberCount" ) || 0 );
					$scope.user.assetSizeUsed = assetSizeUsed;
					$scope.rawPlans = plans;
					$scope.plans = plans;
					$scope.currentPlan = currentPlan;
					setPriceStructureBasedOnNote( currentPlan.notes );
					$scope.isTrial = ( currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_trial );
					if ( $scope.isTrial ) {
						$scope.daysLeftInTrial = moment( currentPlan.expiresAt ).diff( moment(), "days" );
						if ( $scope.daysLeftInTrial < 0 ) {
							$scope.daysLeftInTrial = 0;
						}
					} else {
						$scope.openModalWindow( "contactUsEnterprise" );
						$scope.daysLeftInTrial = 0;
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				},
				true
			);
		}

		function getEnterprisePlans() {
			var plans = [ {
				subscriptionPlanID: PLAN_IDS.enterprise,
				id: PLAN_IDS.enterprise,
				name: "Tier 1",
				maxProjectCount: PSEUDO_UNLIMITED,
				maxProjectMemberCount: PSEUDO_UNLIMITED,
				maxAssetStorage: PSEUDO_UNLIMITED,
				price: 5000
			}, {
				subscriptionPlanID: PLAN_IDS.enterprise_tier2,
				id: PLAN_IDS.enterprise_tier2,
				name: "Tier 2",
				maxProjectCount: PSEUDO_UNLIMITED,
				maxProjectMemberCount: PSEUDO_UNLIMITED,
				maxAssetStorage: PSEUDO_UNLIMITED,
				price: 10000
			} ];
			return plans;
		}

		function setPriceStructureBasedOnNote( note ) {
			var possiblePriceStructure = note.match( /Price structure \( (\d+) \) \( (\d+) \)/ );
			if ( _.isNull( possiblePriceStructure ) ) {
				return;
			}
			var tier1Price = parseInt( possiblePriceStructure[ 1 ] );
			var tier2Price = parseInt( possiblePriceStructure[ 2 ] );
			if ( _.isNumber( tier1Price ) && _.isNumber( tier2Price ) ) {
				_.findWithProperty( $scope.plans, "name", "Tier 1" ).price = tier1Price;
				_.findWithProperty( $scope.plans, "name", "Tier 2" ).price = tier2Price;
			}
		}
		$scope.closeModalWindow = function () {
			$window.olark( 'api.box.hide' );
			$scope.closeModalWindow();
		};
		$scope.showSubview = function ( subview ) {
			$scope.subview = subview;
		};
		$scope.showAllPlans = function () {
			$scope.allPlansShown = true;
		};
		$scope.getLinkLabel = function ( plan, planLevelType ) {
			if ( plan.isCurrent ) {
				return "Current Plan";
			} else {
				return "Choose Plan";
			}
		};
		$scope.isUnlimitedPlan = function ( plan ) {
			return ( true );
		};
		$scope.changePlanTo = function ( $event, plan ) {
			$event.preventDefault();
			if ( plan.maxProjectCount === 0 ) {
				plan.maxProjectCount = "Unlimited";
			}
			var planData = {
				"isProrated": false,
				"prorateAmount": 0,
				"selectedPlan": plan
			};
			$scope.selectedPlan = plan;
			var isOverProjectQuota = ( $scope.user.projectCount > plan.maxProjectCount );
			var isOverProjectMemberQuota = false;
			if ( isOverProjectQuota ) {
				return ( $scope.showOverProjectWarning = true );
			}
			if ( isOverProjectMemberQuota ) {
				return ( $scope.showOverProjectMemberWarning = true );
			}
			accountService.sendEnterpriseChangePlan( $scope.selectedPlan );
			$scope.openModalWindow( "changePlanBillingEnterprise", planData );
		};
		$scope.sendUsersDetailsToSales = function () {
			$scope.enterprisePlanRequestSent = true;
			accountService.sendEnterpriseInfoRequest();
		};
		var qualarooTimer = null;
		var PSEUDO_UNLIMITED = 999999;
		var PLAN_IDS = {
			enterprise: 20,
			enterprise_tier2: 22,
			enterprise_tier3: 23,
			enterprise_trial: 24
		};
		var calledWithSubview = "";
		var isGoingToBillingModal = false;
		var modalData = ( modalWindowRequest.getData( 0 ) || {} );
		_.defaults( modalData, {
			showAllPlans: false,
			subview: ""
		} );
		calledWithSubview = modalData.subview;
		$scope.subview = "plans";
		$scope.allPlansShown = modalData.showAllPlans;
		$scope.showEnterprisePlan = false;
		$scope.plans = [];
		$scope.selectedPlan = null;
		$scope.showOverProjectWarning = false;
		$scope.showOverProjectMemberWarning = false;
		$scope.user = {
			projectCount: 0,
			maxProjectMembersInAnyProject: 0,
			email: sessionService.user.email
		};
		$scope.shouldShowShowAllPlansLink = true;
		$scope.enterprisePlanRequestSent = false;
		$scope.isTrial = false;
		$scope.daysLeftInTrial = 0;
		$scope.$on(
			"$destroy",
			function () {
				$window.olark( 'api.box.hide' );
			}
		);
		$window.olark( 'api.box.show' );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! change-project-type-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.changeProjectType", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, modalWindowRequest, projectService, _ ) {
		$scope.selectDeviceType = function ( deviceType ) {
			$scope.selectedDeviceType = deviceType;
			if ( deviceType == "desktop" ) {
				$scope.mobileDeviceID = 0;
				$scope.isMobile = 0;
			} else if ( deviceType == "phone" ) {
				$scope.mobileDeviceID = parseInt( $scope.selectedPhoneDeviceID );
				$scope.isMobile = 1;
				$scope.selectedPhoneOrientation = _.findWithProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.mobileDeviceID ).orientation;
			} else if ( deviceType == "tablet" ) {
				$scope.mobileDeviceID = parseInt( $scope.selectedTabletDeviceID );
				$scope.isMobile = 1;
				$scope.selectedTabletOrientation = _.findWithProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.mobileDeviceID ).orientation;
			}
		}
		$scope.submitForm = function ( form ) {
			if ( $scope.mobileDeviceID < 0 || $scope.isMobile < 0 ) {
				return false;
			}
			projectService.setProjectType( $scope.projectID,
				$scope.isMobile,
				$scope.mobileDeviceID
			);
			$scope.closeModalWindow();
		}
		$scope.project = modalWindowRequest.getData( 0 );
		$scope.projectID = $scope.project.id;
		$scope.deviceTemplates = modalWindowRequest.getData( 1 );
		$scope.currentDeviceTemplate = _.findWithProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID );
		$scope.defaults = [];
		$scope.defaults.iPhonePortraitDeviceID = _.where( $scope.deviceTemplates, {
			"deviceType": "phone",
			"platform": "iOS",
			"orientation": "portrait",
			"isDefaultDeviceType": true
		} )[ 0 ].mobileDeviceID;
		$scope.defaults.iPhoneLandscapeDeviceID = _.where( $scope.deviceTemplates, {
			"deviceType": "phone",
			"platform": "iOS",
			"orientation": "landscape",
			"isDefaultDeviceType": true
		} )[ 0 ].mobileDeviceID;
		$scope.defaults.AndroidPortraitDeviceID = _.where( $scope.deviceTemplates, {
			"deviceType": "phone",
			"platform": "Android",
			"orientation": "portrait",
			"isDefaultDeviceType": true
		} )[ 0 ].mobileDeviceID;
		$scope.defaults.AndroidLandscapeDeviceID = _.where( $scope.deviceTemplates, {
			"deviceType": "phone",
			"platform": "Android",
			"orientation": "landscape",
			"isDefaultDeviceType": true
		} )[ 0 ].mobileDeviceID;
		$scope.selectedDeviceType = "";
		$scope.selectedPhoneDeviceID = $scope.defaults.iPhonePortraitDeviceID;
		$scope.selectedPhoneOrientation = "portrait";
		$scope.selectedTabletDeviceID = 3;
		$scope.selectedTabletOrientation = "portrait";
		$scope.mobileDeviceID = -1;
		$scope.isMobile = -1;
		if ( $scope.project.isMobile === "" ) {
			modalWindowRequest.setSuppressClose( true );
		} else { // the project has been set up before. set some defaults for the modal to show the current settings.
			$scope.selectedDeviceType = $scope.currentDeviceTemplate.deviceType;
			$scope.selectedDeviceOrientation = $scope.currentDeviceTemplate.orientation;
			switch ( $scope.selectedDeviceType ) {
			case "desktop":
				$scope.selectedDeviceType = "desktop";
				$scope.mobileDeviceID = 0;
				$scope.isMobile = 0;
				break;
			case "phone":
				$scope.selectedDeviceType = "phone";
				$scope.selectedPhoneDeviceID = _.where( $scope.deviceTemplates, {
					"deviceType": "phone",
					"platform": $scope.currentDeviceTemplate.platform,
					"orientation": $scope.currentDeviceTemplate.orientation,
					"isDefaultDeviceType": true
				} )[ 0 ].mobileDeviceID;
				$scope.selectedPhoneOrientation = $scope.currentDeviceTemplate.orientation;
				$scope.isMobile = 1;
				$scope.mobileDeviceID = $scope.selectedPhoneDeviceID;
				break;
			case "tablet":
				$scope.selectedDeviceType = "tablet";
				$scope.selectedTabletDeviceID = _.where( $scope.deviceTemplates, {
					"deviceType": "tablet",
					"platform": $scope.currentDeviceTemplate.platform,
					"orientation": $scope.currentDeviceTemplate.orientation,
					"isDefaultDeviceType": true
				} )[ 0 ].mobileDeviceID;
				$scope.selectedTabletOrientation = $scope.currentDeviceTemplate.orientation;
				$scope.isMobile = 1;
				$scope.mobileDeviceID = $scope.selectedTabletDeviceID;
				break;
			}
		}
	}
} )( angular, InVision );;;
/*! clickable-wireframes-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ClickableWireframesController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.playPencilVideo = function () {
			$scope.openModalWindow( "video", "43985491", [ 590, 470 ] );
		};
	}
} )( angular, InVision );;;
/*! console-first-use-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ConsoleFirstUse", Controller );
	/** @ngInject */
	function Controller( $rootScope, $scope, $timeout, Deferred, requestContext, accountService, sessionService, modalWindowRequest, _ ) {
		function init( modalData ) {
			$rootScope.$broadcast( "consoleTourOpened", $scope.subview );
			$timeout( function () {
				$scope.subview = modalData;
			}, 0 );
		}

		function markConsoleIntroAsSeen() {
			Deferred.handlePromise(
				accountService.sawConsoleIntroModal( 1 ),
				function ( response ) {
					sessionService.update();
				},
				function ( response ) {}
			);
		}

		function getIndexOfSubview() {
			for ( var i = 0; i < SUBVIEWS.length; i++ ) {
				if ( SUBVIEWS[ i ] === $scope.subview ) {
					return i;
				}
			}
			return 0;
		}

		function getCurrentConsoleModeAsInt( consoleMode ) {
			if ( consoleMode === "preview" ) return 1;
			if ( consoleMode === "build" ) return 2;
			if ( consoleMode === "comments" ) return 4;
			if ( consoleMode === "history" ) return 8;
			if ( consoleMode === "config" ) return 16;
		}
		$scope.closeTour = function () {
			$scope.closeModalWindow();
		};
		$scope.backStep = function () {
			var currentIndex = getIndexOfSubview();
			if ( currentIndex > 0 ) {
				$scope.subview = SUBVIEWS[ currentIndex - 1 ];
			}
		};
		$scope.nextStep = function () {
			var currentIndex = getIndexOfSubview();
			if ( currentIndex + 1 < SUBVIEWS.length ) {
				$scope.subview = SUBVIEWS[ currentIndex + 1 ];
			}
		};
		var SUBVIEWS = [
			"preview",
			"build",
			"comments",
			"history",
			"config"
		];
		var renderContext = requestContext.getRenderContext( "console" );
		var currentConsoleMode = renderContext.getNextSection();
		var modalData = ( modalWindowRequest.getData( 0 ) || "preview" );
		$scope.subview = null;
		$scope.wantsToNotSeeTourAgain = false;
		$scope.$on(
			"$destroy",
			function () {
				if ( $scope.wantsToNotSeeTourAgain ) {
					markConsoleIntroAsSeen();
				}
				$rootScope.$broadcast( "consoleTourClosed" );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				currentConsoleMode = renderContext.getNextSection();
			}
		);
		$scope.$on(
			"closingConsole", function () {
				$scope.closeModalWindow();
			}
		);
		$scope.$on(
			"consoleSubviewChanged", function ( event, subview, forceTourClose ) {
				var forceTourClose = forceTourClose || false;
				if ( forceTourClose ) {
					$scope.closeTour();
				} else {
					$scope.subview = subview;
				}
			}
		);
		$scope.$watch(
			"subview",
			function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				$rootScope.$broadcast( 'consoleTourChangedModes', newValue );
			}
		);
		init( modalData );
	}
} )( angular, InVision );;;
/*! contact-us-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ContactUsController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, config, Deferred, accountService, sessionService, modalWindowRequest, _ ) {
		function isEnterprisePlan( subscription ) {
			var enterprisePlanIds = [ 20, 22, 23, 24 ];
			return ( _.contains( enterprisePlanIds, subscription.subscriptionPlanID ) );
		}
		$scope.submitForm = function () {
			if ( !$scope.bugOrFeature.length ) {
				$scope.errorMessage = "Please select if this is a feature request or a bug/support request.";
				return;
			}
			if ( !$scope.description.length ) {
				$scope.errorMessage = "Please enter either a question or a comment.";
				return;
			}
			Deferred.handlePromise(
				accountService.submitSupportTicket( $scope.bugOrFeature, $scope.description ),
				function ( response ) {
					$scope.errorMessage = null;
					$scope.subview = "confirmation";
				},
				function ( response ) {
					$scope.errorMessage = "We had a problem submitting your support ticket.";
				}
			);
		};
		$scope.subview = "form";
		$scope.description = "";
		$scope.bugOrFeature = "";
		$scope.replyToEmail = sessionService.user.email;
		$scope.isEnterpriseUser = isEnterprisePlan( sessionService.subscription );
		$scope.isEnterprise = config.isEnterprise;
		$scope.errorMessage = null;
		if ( $scope.isEnterprise || $scope.isEnterpriseUser ) {
			$timeout( function () {
				$scope.openModalWindow( "contactUsEnterprise" );
			}, 10 );
		}
	}
} )( angular, InVision );;;
/*! contact-us-enterprise-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ContactUsEnterpriseController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, accountService, sessionService, modalWindowRequest, _ ) {
		$scope.submitForm = function () {
			if ( !$scope.bugOrFeature.length ) {
				$scope.errorMessage = "Please select if this is a feature request or a bug/support request.";
				return;
			}
			if ( !$scope.description.length ) {
				$scope.errorMessage = "Please enter either a question or a comment.";
				return;
			}
			Deferred.handlePromise(
				accountService.submitSupportTicket( $scope.bugOrFeature, $scope.description, true ),
				function ( response ) {
					$scope.errorMessage = null;
					$scope.subview = "confirmation";
				},
				function ( response ) {
					$scope.errorMessage = "We had a problem submitting your support ticket.";
				}
			);
		};
		$scope.subview = "form";
		$scope.description = "";
		$scope.bugOrFeature = "";
		$scope.replyToEmail = sessionService.user.email;
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! convert-to-company-tour-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ConvertToCompanyTourController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modalWindowRequest, _ ) {
		$scope.nextStep = function () {
			if ( $scope.subview === 'step1' ) {
				$scope.subview = 'step2';
			} else if ( $scope.subview === 'step2' ) {
				$scope.subview = 'step3';
			} else if ( $scope.subview === 'step3' ) {
				$scope.closeModalWindow();
			}
		};
		$scope.subview = "step1";
	}
} )( angular, InVision );;;
/*! create-team-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	var TEAM_PLAN_IDS = [ 28, 29 ];
	var ENTERPRISE_PLAN_IDS = [ 20, 22, 23, 24 ];
	app.controller( "modal.CreateTeamController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, $location, Deferred, modalWindowRequest, _, sessionService, accountService, teamProfilePartial, modelEvents, teamService ) {
		function assertUserIsOnTeamPlanOrEnterprise( subscriptionPlanID ) {
			return $timeout( function () {
				return (
					_.contains( TEAM_PLAN_IDS, subscriptionPlanID ) ||
					_.contains( ENTERPRISE_PLAN_IDS, subscriptionPlanID )
				);
			}, 0 );
		}

		function applyRemoteData( response ) {
			$scope.company.canViewAllLeadProjects = response.teaminfo.canViewAllLeadProjects;
			$scope.hasTeam = response.account.isCompany;
			if ( response.teaminfo.company.length ) {
				$scope.teamName = response.teaminfo.company;
			}
			if ( response.teaminfo.companyLogoID.length ) {
				$scope.hasLogo = true;
				$scope.companyLogoPath = "/logos/" + response.teaminfo.companyLogoID;
			}
		}

		function createCompany( teamName, hasSeenTeamCreateInit ) {
			var promise = accountService.updateCompany( {
				company: teamName,
				isCompany: true,
				companyLogoIdToBeDeleted: '',
				removeOldLogoID: false
			} );
			Deferred.handlePromise(
				promise,
				function ( account ) {
					if ( !hasSeenTeamCreateInit ) {
						modelEvents.trigger( "teamCreated.forFirstTime", account );
						$scope.openModalWindow( "newTeamMember", true );
						$location.path( "team" );
					} else {
						modelEvents.trigger( "teamCreated", account );
						$location.path( "team" );
						$scope.closeModalWindow();
					}
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				teamProfilePartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}
		$scope.createTeam = function () {
			if ( $scope.companyForm.teamName.$valid ) {
				teamService.setProjectVisibility( $scope.company.canViewAllLeadProjects );
				createCompany( $scope.teamName, $scope.hasSeenTeamCreateInit );
			} else {
				$scope.companyForm.$setDirty();
				$scope.companyForm.$setValidity();
			}
		};
		var modalData = {},
			planID = null,
			assertionPromise = null;
		$scope.hasTeam = false;
		$scope.companyLogoPath = "";
		$scope.teamName = "";
		$scope.hasLogo = false;
		$scope.errorMessage = "";
		$scope.hasSeenTeamCreateInit = true;
		$scope.company = {};
		$scope.company.canViewAllLeadProjects = false;
		$scope.$on(
			"profileCompanyLogoUploader:uploaded",
			function ( event, account ) {
				$scope.hasLogo = true;
				if ( account.companyLogoID.length ) {
					$scope.companyLogoPath = "/logos/" + account.companyLogoID;
				} else {
					$scope.companyLogoPath = "";
				}
				$scope.errorMessage = null;
			}
		);
		$scope.$on(
			"profileCompanyLogoUploader:error",
			function ( event, response ) {
				$scope.errorMessage = "There was a problem uploading your company logo!";
			}
		);
		modalWindowRequest.setSuppressClose( true );
		modalData = ( modalWindowRequest.getData( 0 ) || {
			subscriptionPlanID: null
		} );
		planID = modalData.subscriptionPlanID || sessionService.subscription.subscriptionPlanID;
		$scope.hasSeenTeamCreateInit = ( modalWindowRequest.getData( 1 ) || false );
		assertionPromise = assertUserIsOnTeamPlanOrEnterprise( planID );
		assertionPromise.then(
			function ( result ) {
				if ( result ) {
					loadRemoteData();
				} else {
					$scope.openModalWindow( 'teamEnterpriseChoice' );
				}
			} );
	}
} )( angular, InVision );;;
/*! delete-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.DeleteProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, projectService, modalWindowRequest, projectMembersLastViewedPartial, userService, validationService, _ ) {
		function applyRemoteData( teamMembers ) {
			var maxLoop = teamMembers.length;
			if ( maxLoop > 4 ) {
				maxLoop = 4;
				$scope.andOthers = " and " + ( teamMembers.length - 4 ) + " others";
			}
			activity.topUsers = [];
			augmentTeamMembers( teamMembers );
			$scope.hasNames = teamMembers.length > 0;
			for ( var i = 0, length = maxLoop; i < length; i++ ) {
				activity.topUsers.push( teamMembers[ i ] );
				if ( i === 0 ) { // set the top avatarID
					$scope.topAvatar = {
						avatarURL: "/avatars/" + teamMembers[ i ].avatarID,
						initials: teamMembers[ i ].initials,
						hasSystemAvatar: teamMembers[ i ].hasSystemAvatar
					};
				}
			}
			$scope.names = _.map( activity.topUsers, "name" ).join( ", " );
		}

		function augmentTeamMembers( teamMembers ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var user = teamMembers[ i ];
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				user.initials = userService.getInitials( user.name );
			}
			return ( teamMembers );
		}

		function loadRemoteData() {
			$scope.isLoadingTeamMembers = true;
			Deferred.handlePromise(
				projectMembersLastViewedPartial.get( $scope.projectID ),
				function ( response ) {
					$scope.isLoadingTeamMembers = false;
					applyRemoteData( response.teamMembers );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your people. Try refreshing your browser." );
				}
			);
		}
		$scope.deleteProject = function () {
			if ( !( $scope.isConfirmedLinks && $scope.isConfirmedComments && $scope.isConfirmedScreens ) ) {
				$scope.errorMessage = "Please confirm that you understand the ramifications of your action.";
				return;
			}
			Deferred.handlePromise(
				projectService.deleteProject( $scope.projectID ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					if ( validationService.isForbidden( response ) ) {
						$scope.errorMessage = "The project is currently being deleted - please be patient, thanks!"
					} else {
						$scope.errorMessage = response.message;
					}
				}
			);
		};
		var activity = {
			topUsers: []
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.isLoadingTeamMembers = false;
		$scope.isConfirmed = false;
		$scope.errorMessage = null;
		$scope.teamMembers = [];
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! downgrade-plan-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.DowngradePlanController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, Deferred, _, changePlansPartial, subscriptionService, dateHelper, moment ) {
		function loadRemoteData() {
			Deferred.handlePromise(
				changePlansPartial.get(),
				function ( response ) {
					var currentPlan = response.currentPlan;
					var projects = response.projects;
					var plans = response.plans;
					var lastUpgradeDate = response.lastUpgradeDate;
					var user = response.user;
					var pausePlan = response.pauseplan;
					var isCurrentPlanFree = isEquivalentToFreePlan( currentPlan.subscriptionPlanID );
					if ( currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_trial ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_tier2 ||
						currentPlan.subscriptionPlanID === PLAN_IDS.enterprise_tier3
					) {
						$scope.openModalWindow( "changePlanEnterprise" );
					}
					$scope.user.projectCount = projects.length;
					$scope.user.maxProjectMembersInAnyProject = ( _.maxProperty( projects, "projectMemberCount" ) || 0 );
					$scope.user.currentPlan = currentPlan;
					$scope.plans = preparePlansForDisplay( currentPlan, plans );
					$scope.pausePlan = pausePlan;
					if ( isTeamPlan( currentPlan ) ) {
						$scope.downgradeDisclaimer = "I'm aware that my team will be deleted";
					}
					if ( isPausePlan( currentPlan ) || isPlanFree( currentPlan ) || !$scope.plans.hasOwnProperty( 'aDowngrade' ) ) {
						setSubView( 'cancelAll' );
					} else {
						$scope.setDowngradePlan( $scope.plans.aDowngrade[ 0 ] );
					}
					$scope.user.projects = augmentProjects( projects );
					$scope.isLoadingProjects = false;
					$scope.isLoading = false;
					setQualarooData( currentPlan, user, lastUpgradeDate, projects );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your subscription information. Try refreshing your browser." );
				}
			);
		};

		function makeBytesHumanReadable( bytes, precision ) {
			if ( isNaN( parseFloat( bytes ) ) || !isFinite( bytes ) ) {
				return '-';
			} else if ( bytes === 0 ) {
				return 0;
			}
			if ( typeof precision === 'undefined' ) {
				precision = 1;
			}
			var units = [ 'bytes', 'kB', 'MB', 'GB', 'TB', 'PB' ],
				number = Math.floor( Math.log( bytes ) / Math.log( 1024 ) );
			return ( bytes / Math.pow( 1024, Math.floor( number ) ) ).toFixed( precision ) + ' ' + units[ number ];
		};

		function preparePlansForDisplay( currentPlan, plans ) {
			var isCurrentPlanFree = isPlanFree( currentPlan );
			var tmpPlans = _.where( plans, {
				termLength: currentPlan.termLength
			} );
			tmpPlans = _.filter( tmpPlans, function ( p ) {
				if ( p.id === currentPlan.subscriptionPlanID ) {
					return false;
				}
				return true;
			} );
			tmpPlans = _.sortBy( tmpPlans, function ( obj ) {
				return obj.price;
			} );
			tmpPlans.reverse();
			var groupPlansByTypeCurried = _.curry( groupPlansByType );
			groupPlansByTypeCurried = groupPlansByTypeCurried( currentPlan );
			tmpPlans = _.groupBy( tmpPlans, groupPlansByTypeCurried );
			_.each( tmpPlans, function ( planTransitionType, outerKey, list ) {
				_.each( planTransitionType, function ( plan, key, list ) {
					if ( isEquivalentToFreePlan( plan.id ) ) {
						plan.id = PLAN_IDS.freeMonthly;
					}
					plan.className = plan.name.toLowerCase().replace( /\s/gi, '-' );
					plan.assetAllowanceHumanReadable = makeBytesHumanReadable( plan.maxAssetByteCount, 0 );
					plan.maxProjectCount = plan.maxProjectCount > 999 ? "unlimited" : plan.maxProjectCount;
					if ( outerKey === "aDowngrade" ) {
						plan.transitionType = "downgrade";
					} else {
						plan.transitionType = outerKey;
					}
				} );
			} );
			return tmpPlans;
		};

		function augmentProjects( projects ) {
			for ( var i = 0, t = projects.length; i < t; i++ ) {
				var project = projects[ i ];
				project.thumbnailUrl = project.homeScreenID ? ( "/thumbnails/" + project.homeScreenID + "/" + project.homeScreenImageVersion ) : "/assets/apps/d/img/add-screens-thumbnail.png";
				project.isChecked = false;
				project.createdAt = getDateLabel( project.lastAccessedAt );
			}
			return projects;
		};

		function getDateLabel( timestamp ) {
			var d = dateHelper.removeTime( timestamp );
			var label = {
				literal: "",
				moment: "",
				date: ""
			};
			if ( dateHelper.isToday( d ) ) {
				label.literal = "Today";
			} else if ( dateHelper.isYesterday( d ) ) {
				label.literal = "Yesterday";
			} else {
				label.literal = dateHelper.formatDate( timestamp, "ddd" );
			}
			label.moment = "about " + moment( timestamp ).fromNow();
			label.date = dateHelper.formatDate( timestamp, "mmmm d" );
			label.time = dateHelper.formatTime( timestamp, "h:mmtt" );
			return ( label );
		};

		function groupPlansByType( currentPlan, plan ) {
			if ( currentPlan.subscriptionPlanID === PLAN_IDS.custom ||
				plan.maxProjectCount > currentPlan.maxProjectCount ) {
				return "upgrade";
			} else if ( plan.maxProjectCount === currentPlan.maxProjectCount ) {
				if ( currentPlan.subscriptionPlanID.subscriptionPlanID === plan.id ||
					isEquivalentToFreePlan( currentPlan.subscriptionPlanID ) ) {
					return "current";
				} else if ( plan.termLength < currentPlan.termLength ) {
					return "upgrade";
				} else {
					return "upgrade";
				}
			} else {
				return "aDowngrade";
			}
		};

		function isPlanFree( plan ) {
			return plan.price === 0;
		};

		function isPausePlan( plan ) {
			return plan.subscriptionPlanID === PLAN_IDS.pausePlan;
		};

		function isTeamPlan( plan ) {
			return (
				plan.subscriptionPlanID === PLAN_IDS.teamMonthly ||
				plan.subscriptionPlanID === PLAN_IDS.teamOneYear
			);
		};

		function isEquivalentToFreePlan( planID ) {
			return (
				planID === PLAN_IDS.freeMonthly ||
				planID === PLAN_IDS.freeOneYear ||
				planID === PLAN_IDS.freeTwoYear
			);
		};

		function setSubView( view ) {
			$scope.subView = view;
			$scope.$emit( "resizeModal" );
		};

		function setQualarooData( currentPlan, user, lastUpgradeDate, projects ) {
			var qualarooData = {};
			qualarooData[ "Signup Date" ] = moment( user.createdAt ).format( "MMM D, YYYY" );
			qualarooData.Plan = currentPlan.name;
			qualarooData[ "Project Count" ] = projects.length;
			qualarooData[ "Over-quota Project Count" ] = ( _.filterWithProperty( projects, "isOverQuota", true ).length || 0 );
			if ( _.isNumber( lastUpgradeDate ) ) {
				qualarooData[ "Last Upgrade Date" ] = moment( lastUpgradeDate ).format( "MMM D, YYYY" );
			}
			if ( _.isNumber( currentPlan.projectGracePeriodEndsAt ) ) {
				qualarooData[ "Grace Period Ended At" ] = moment( currentPlan.projectGracePeriodEndsAt ).format( "MMM D, YYYY" );
			}
			$window._kiq.push( [ 'set', qualarooData ] );
		};

		function deleteAccount( currentSubscriptionID, rating, cancelComments, otherSoftware ) {
			$scope.isLoadingPlan = true;
			Deferred.handlePromise(
				subscriptionService.deleteUserAccount(
					currentSubscriptionID, rating, cancelComments, otherSoftware
				),
				function ( response ) {
					$scope.isLoadingPlan = false;
					setSubView( 'cancelConfirmation' );
					setTimeout( $scope.logout, 1500 );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't change your subscription plan. Try refreshing your browser." );
				}
			);
		};

		function downgradeAccount() {
			$scope.isLoadingPlan = true;
			var projectsToDelete = _.where( $scope.user.projects, {
				isChecked: false
			} );
			projectsToDelete = _.pluck( projectsToDelete, 'id' );
			Deferred.handlePromise(
				subscriptionService.changePlan( $scope.selectedPlan, '', '', projectsToDelete ),
				function ( response ) {
					$scope.isLoadingPlan = false;
					setSubView( 'downgradeConfirmation' );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't change your subscription plan. Try refreshing your browser." );
				}
			);
		};

		function pauseAccount() {
			$scope.isLoadingPlan = true;
			Deferred.handlePromise(
				subscriptionService.pauseUserAccount( PLAN_IDS.pausePlan ),
				function ( response ) {
					$scope.isLoadingPlan = false;
					setSubView( 'pauseConfirmation' );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't change your subscription plan. Try refreshing your browser." );
				}
			);
		};
		var PLAN_IDS = {
			freeMonthly: 1,
			freeOneYear: 16,
			freeTwoYear: 17,
			starterMonthly: 2,
			starterOneYear: 18,
			starterTwoYear: 19,
			professionalMonthly: 3,
			professionalOneYear: 8,
			professionalTwoYear: 9,
			studioMonthly: 4,
			studioOneYear: 10,
			studioTwoYear: 11,
			studioPlusMonthly: 7,
			studioPlusOneYear: 12,
			studioPlusTwoYear: 13,
			agencyMonthly: 5,
			agencyOneYear: 14,
			agencyTwoYear: 15,
			enterprise: 20,
			custom: 21,
			enterprise_tier2: 22,
			enterprise_tier3: 23,
			enterprise_trial: 24,
			premiumMonthly: 26,
			premiumOneYear: 27,
			teamMonthly: 28,
			teamOneYear: 29,
			pausePlan: 30
		};
		$scope.setDowngradePlan = function ( plan ) {
			$scope.selectedPlan = plan;
		};
		$scope.$watch( "inputs.downgradeOption", function ( opt ) {
			if ( opt === 1 ) {
				$scope.planType = "Downgrade";
			} else {
				$scope.planType = "Pause";
			}
		} );
		$scope.getCheckedProjectCount = function ( project ) {
			var checkedProjectCount = _.where( $scope.user.projects, {
				isChecked: true
			} ).length;
			$scope.maxProjectsSelected = ( checkedProjectCount >= $scope.selectedPlan.maxProjectCount )
			return ( !project.isChecked && $scope.maxProjectsSelected );
		};
		$scope.markProjectAsChecked = function ( project ) {
			if ( $scope.getCheckedProjectCount( project ) ) {
				return;
			}
			project.isChecked = !project.isChecked;
		};
		$scope.downgradePlan = function () {
			if ( $scope.inputs.downgradeOption === 1 ) {
				if ( $scope.selectedPlan.maxProjectCount == "unlimited" ||
					$scope.selectedPlan.maxProjectCount >= $scope.user.projectCount
				) {
					_.each( $scope.user.projects, function ( project ) {
						project.isChecked = true
					} );
					setSubView( 'downgradePlan' );
				} else {
					setSubView( 'selectProjects' );
				}
			} else {
				setSubView( 'pausePlan' );
			}
		};
		$scope.doDowngradePlan = function () {
			if ( $scope.isLoadingPlan ) {
				return;
			}
			$scope.errorMessage = "";
			if ( !$scope.inputs.downgradePlanConfirm ) {
				$scope.errorMessage = "Please confirm that you understand the ramifications of your action.";
				return;
			}
			downgradeAccount();
		};
		$scope.doPausePlan = function () {
			if ( $scope.isLoadingPlan ) {
				return;
			}
			$scope.errorMessage = "";
			if ( !$scope.inputs.pausePlanConfirm ) {
				$scope.errorMessage = "Please confirm that you understand the ramifications of your action.";
				return;
			}
			pauseAccount();
		};
		$scope.cancelPlan = function () {
			setSubView( 'cancelAll' );
		};
		$scope.cancelPlanConfirm = function () {
			$scope.errorMessage = "";
			if ( !$scope.inputs.doDeleteAllConfirm ) {
				$scope.errorMessage = "Please confirm that you understand the ramifications of your action.";
				return;
			}
			setSubView( 'whyCancel' );
		};
		$scope.doCancelPlan = function () {
			if ( $scope.isLoadingPlan ) {
				return;
			}
			var rating = "No Rating";
			var cancelComments = "No Comments";
			var otherSoftware = "No Software Comment";
			if ( $scope.inputs.rating !== 0 ) {
				rating = $scope.inputs.rating;
			}
			if ( $scope.inputs.cancelComments ) {
				cancelComments = $scope.inputs.cancelComments;
			}
			if ( $scope.inputs.cancelOther ) {
				otherSoftware = $scope.inputs.cancelOther;
			}
			deleteAccount( $scope.user.currentPlan.id, rating, cancelComments, otherSoftware );
		};
		$scope.logout = function () {
			try {
				$window.localStorage.clear();
			} catch ( error ) {}
			window.location.href = "/logout?token=" + $scope.xsrfToken;
		};
		$scope.subView = "cancelOptions";
		$scope.isLoading = true;
		$scope.isLoadingProjects = true;
		$scope.isLoadingPlan = false;
		$scope.user = {
			projectCount: 0,
			maxProjectMembersInAnyProject: 0,
			currentPlan: 0,
			projects: []
		};
		$scope.errorMessage = null;
		$scope.selectedPlan = {};
		$scope.selectedPlan.maxProjectCount = 0;
		$scope.downgradeButtonTxt = "";
		$scope.showEnterprisePlan = false;
		$scope.plans = [];
		$scope.pausePlan = {};
		$scope.ratingRange = _.range( 1, 11 );
		$scope.maxProjectsSelected = false;
		$scope.downgradeDisclaimer = "I'm aware that my other team members will be deleted";
		$scope.inputs = {};
		$scope.inputs.downgradePlanConfirm = false;
		$scope.inputs.deleteProjectsConfirm = false;
		$scope.inputs.pausePlanConfirm = false;
		$scope.inputs.doDeleteAllConfirm = false;
		$scope.inputs.cancelRecommend = null;
		$scope.inputs.downgradeOption = 1;
		$scope.inputs.rating = 0;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! duplicate-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.DuplicateProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, validationService, modalWindowRequest, _ ) {
		$scope.duplicateProject = function () {
			if ( $scope.submissionInProgress ) {
				return;
			}
			$scope.submissionInProgress = true;
			Deferred.handlePromise(
				projectService.duplicateProject( $scope.project.id ),
				function ( project ) {
					$location.path( "/projects" );
					$( window ).scrollTop( 0 );
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.submissionInProgress = false;
					if ( validationService.isAlreadyExists( response ) ) {
						$scope.errorMessage = "Your request is already being processed - please be patient. It may take a few minutes for the application to duplicate all of the screens and assets in this project.";
					} else {
						$scope.errorMessage = response.message;
					}
				}
			);
		};
		$scope.project = modalWindowRequest.getData( 0 );
		if ( !$scope.project.thumbnailUrl ) {
			$scope.project.thumbnailUrl = $scope.project.homeScreenID ? ( "/thumbnails/" + $scope.project.homeScreenID + "/" + $scope.project.homeScreenImageVersion ) : "/assets/apps/d/img/add-screens-thumbnail.png";
		}
		$scope.submissionInProgress = false;
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! enterprise-contact-form-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.EnterpriseContactFormController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modalWindowRequest, _, sessionService, accountService ) {
		$scope.submitForm = function () {
			$scope.submitted = true;
			$scope.contactForm.$setDirty();
			$scope.isCompanySizeUnselected = !$scope.contactForm.companySize.$valid;
			if ( $scope.contactForm.$valid ) {
				$scope.showConfirmationMessage = true;
				accountService.sendEnterpriseInfoRequestWithLeadInfo(
					"requestsMoreCollaborators",
					$scope.form
				);
			}
		};
		$scope.errorMessage = null;
		$scope.showConfirmationMessage = false;
		$scope.form = {
			name: sessionService.user.name,
			email: sessionService.user.email,
			phone: "",
			companyName: sessionService.user.company,
			companySize: ""
		};
		$scope.submitted = false;
	}
} )( angular, InVision );;;
/*! enterprise-user-modal-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.EntUserModalController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, companyService, enterpriseProjectsPartial, teamActivityPartial, Deferred, hashKeyCopier, _, dateHelper, config, moment, userService ) {
		/* Get user */
		/********************************************************/
		function getCompanyMember( userID ) {
			Deferred.handlePromise(
				companyService.getCompanyMember( userID, config.companySettings.companyID ),
				function ( response ) {
					if ( response.length ) {
						$scope.member = response[ 0 ];
						$scope.member.memberHasSystemAvatar = userService.isSystemAvatar( $scope.member.avatarID );
						loadProjectData();
						loadActivityStream();
					} else {
						$scope.openModalWindow( "error", "For some reason, we couldn't load this user's profile." );
					}
					$scope.isLoading = false;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load projects or activity. Try refreshing your browser." );
					$scope.isLoading = false;
				}
			);
		}
		/* Projects Tab */
		/********************************************************/
		function calculateTruncatedProjectName( name ) {
			if ( name.length <= 53 ) {
				return ( name );
			}
			return ( name.slice( 0, 50 ) + "..." );
		}

		function augmentProject( project ) {
			project.truncatedName = calculateTruncatedProjectName( project.name );
			if ( project.homeScreenID ) {
				project.thumbnailUrl = "/thumbnails/" + project.homeScreenID + "/" + project.homeScreenImageVersion;
			} else {
				project.thumbnailUrl = "/assets/apps/d/img/add-screens-thumbnail.png";
			}
			return ( project );
		}

		function augmentProjects( projects ) {
			return ( _.each( projects, augmentProject ) );
		}

		function applyRemoteData( projects ) {
			var projects = _.filterWithProperty( projects, 'isArchived', false )
			$scope.projects = hashKeyCopier.copyHashKeys( $scope.projects, augmentProjects( projects ) );
			$scope.isLoading = false;
		}

		function loadProjectData() {
			$scope.isLoading = true;
			if ( showLimitedData ) {
				var request = enterpriseProjectsPartial.getRelatedProjects( {
					id: $scope.member.userID
				} );
			} else {
				var request = enterpriseProjectsPartial.getAllProjects( {
					id: $scope.member.userID,
					checkToShowAllProjects: false
				} )
			}
			Deferred.handlePromise(
				request,
				function ( response ) {
					applyRemoteData( response.projects );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load projects or activity. Try refreshing your browser." );
					$scope.isLoading = false;
				}
			);
		}
		/* Activity Tab */
		/********************************************************/
		function addActivityToActivityPeriods( activity ) {
			for ( var i = 0; i < $scope.activityPeriods.length; i++ ) {
				var existingActivity = $scope.activityPeriods[ i ];
				if ( existingActivity.offset === activity.offset ) {
					_.extendExistingProperties(
						existingActivity,
						hashKeyCopier.copyHashKeys( existingActivity, activity )
					);
					return ( activity );
				}
			}
			$scope.activityPeriods.push( activity );
			return ( activity );
		}

		function applyActivityData( activity ) {
			if ( activity.alreadyAddedToActivityPeriods ) {
				return;
			}
			activity.alreadyAddedToActivityPeriods = true;
			if ( activity.actions.length > 0 ) {
				$scope.hasActivity = true;
			}
			activity = augmentActivity( activity );
			addActivityToActivityPeriods( activity );
			updateHasMoreActivityToLoad();
		}

		function augmentActivity( activity ) {
			var days = groupActionsByDay( activity.actions );
			days = groupActionsByProjectAndTime( days );
			days = combineAdjacentProjects( days );
			activity.days = days;
			delete activity[ "actions" ];
			return ( activity );
		}

		function combineAdjacentProjects( days ) {
			days = _.each( days, combineAdjacentProjectsForDay );
			return days;
		}

		function combineAdjacentProjectsForDay( day ) {
			var lastProject = null;
			day.projects = _.filter( day.projects, function ( project ) {
				if ( !_.isNull( lastProject ) &&
					lastProject.label.projectId == project.label.projectId ) {
					lastProject.actions = lastProject.actions.concat( project.actions );
					return false;
				}
				lastProject = project;
				return true;
			} );
			return day.projects;
		}

		function getLastKnownOffset() {
			return (
				_.last( $scope.activityPeriods ).offset
			);
		}

		function getOffsetsForCurrentWeek() {
			var offsets = [];
			var currentDay = dateHelper.today();
			if ( currentDay.getDay() === 0 ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			for ( var i = currentDay.getDay(); i >= 1; i-- ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			return ( offsets );
		}

		function groupActionsBy( arrayToGroup, options ) {
			var grouped = {};
			var defaultOptions = {
				groupByKeys: [ "id" ],
				timeBasedKeys: [],
				timeBucketInMinutes: 5
			};
			options = _.defaults( options, defaultOptions );
			grouped = _.groupBy( arrayToGroup, function ( item ) {
				var i = 0,
					key = "",
					compositeKey = "",
					isKeyTimeBased = false,
					keyDelimiter = "_",
					timeValueRounded = null;
				for ( i = 0; i < options.groupByKeys.length; i++ ) {
					key = options.groupByKeys[ i ];
					isKeyTimeBased = _.contains( options.timeBasedKeys, key );
					if ( isKeyTimeBased ) {
						if ( options.timeBucketInMinutes === 1440 ) {
							timeValueRounded = moment( item[ key ] ).format( "DDDYYYY" );
						} else {
							timeValueRounded = Math.round( moment( item[ key ] ).unix() / ( options.timeBucketInMinutes * 60 ) ) * ( options.timeBucketInMinutes * 60 );
						}
						compositeKey += ( compositeKey.length ? keyDelimiter : '' ) + timeValueRounded.toString();
					} else {
						compositeKey += ( compositeKey.length ? keyDelimiter : '' ) + item[ key ].toString();
					}
				}
				return compositeKey;
			} );
			return grouped;
		}

		function groupActionsByDay( actions ) {
			var groupingOptions = {
				groupByKeys: [ "actionOccuredAt" ],
				timeBasedKeys: [ "actionOccuredAt" ],
				timeBucketInMinutes: 1440
			};
			var groupedActions = groupActionsBy( actions, groupingOptions );
			groupedActions = _.map( groupedActions, function ( actionsOnThisDay ) {
				var firstItemDate = moment( _.first( actionsOnThisDay ).actionOccuredAt );
				var dateLabel = "";
				var todayStart = moment().startOf( "day" );
				var yesterdayStart = moment().subtract( "days", 1 ).startOf( "day" );
				if ( firstItemDate.isAfter( todayStart ) ) {
					dateLabel = "Today";
				} else if ( firstItemDate.isAfter( yesterdayStart ) ) {
					dateLabel = "Yesterday";
				} else {
					dateLabel = firstItemDate.format( "MMM D" );
				}
				return {
					label: dateLabel,
					sortOn: firstItemDate,
					items: actionsOnThisDay
				};
			} );
			groupedActions = _.sortOnProperty( groupedActions, "sortOn", "DESC" );
			return groupedActions;
		}

		function groupActionsByProjectAndTime( actionsGroupedByDay ) {
			var groupingOptions = {
				groupByKeys: [ "projectID", "actionOccuredAt" ],
				timeBasedKeys: [ "actionOccuredAt" ],
				timeBucketInMinutes: 60
			};
			_.forEach( actionsGroupedByDay, function ( day, index, fullArray ) {
				if ( day.label !== "Today" ) {
					groupingOptions.timeBucketInMinutes = 1440;
				}
				var groupedActions = groupActionsBy( day.items, groupingOptions );
				groupedActions = _.map( groupedActions, function ( actions, key ) {
					var firstItem = _.first( actions );
					var firstItemDate = firstItem.actionOccuredAt;
					var groupedActions = groupActionsBy(
						actions, {
							groupByKeys: [ "action" ],
							timeBasedKeys: [ "actionOccuredAt" ],
							timeBucketInMinutes: groupingOptions.timeBucketInMinutes
						}
					);
					return {
						label: {
							projectName: firstItem.projectName,
							projectId: firstItem.projectID,
							homeScreenID: firstItem.homeScreenID,
							time: moment( firstItem.actionOccuredAt ).format( 'h:mma' )
						},
						id: firstItem.projectID,
						isVisible: true,
						sortOn: firstItem.actionOccuredAt,
						actions: mapProjectActions( groupedActions, firstItem.projectID )
					};
				} );
				groupedActions = _.sortOnProperty( groupedActions, "sortOn", "DESC" );
				day.projects = groupedActions;
				delete day[ "items" ];
				return true;
			} );
			return actionsGroupedByDay;
		}

		function loadActivityStream() {
			$scope.isLoadingActivity = true;
			var offsets = getOffsetsForCurrentWeek();
			var promises = [];
			for ( var i = 0; i < offsets.length; i++ ) {
				promises.push(
					enterpriseProjectsPartial.getActivity( offsets[ i ], 1, $scope.member.userID, true, showLimitedData )
				);
			}
			Deferred.handleAllPromises(
				promises,
				function ( promise1, promise2, promiseN ) {
					var actionCount = 0;
					for ( var i = 0; i < arguments.length; i++ ) {
						applyActivityData( arguments[ i ].activity );
						actionCount += arguments[ i ].activity.days.length;
					}
					if ( !actionCount ) {
						$scope.loadMoreActivity();
					}
					$scope.isLoadingActivity = false;
					$scope.isRefreshingData = false;
				},
				function () {
					$scope.isLoadingActivity = false;
					$scope.openModalWindow( "error", "For some reason, we couldn't load your activity stream. Try refreshing your browser." );
				}
			);
		}

		function mapProjectActions( projectActions, projectID ) {
			return _.map( projectActions, function ( actions ) {
				var action = {},
					usersInvolved = [],
					screensInvolved = [],
					userNameOrCount = "";
				action.niceDate = moment( _.first( actions ).actionOccuredAt ).fromNow();
				action.type = _.first( actions ).action;
				action.users = _.map( actions, function ( actionGrouping ) {
					return {
						userID: actionGrouping.userID,
						name: actionGrouping.userName
					};
				} );
				action.users = _.uniq( action.users, function ( user ) {
					return user.userID;
				} );
				action.screens = _.map( actions, function ( actionGrouping, key, allActivity ) {
					var commentsOnScreen = _.filter( allActivity, function ( activity ) {
						if ( activity.screenID !== actionGrouping.screenID ) {
							return false;
						}
						return ( activity.action === "commentCreated" || activity.action === "devnoteCreated" );
					} );
					var unreadComments = _.filterWithProperty( commentsOnScreen, "isUnread", true );
					var tmpScreen = {
						id: actionGrouping.screenID,
						name: actionGrouping.screenName,
						consoleUrl: '#/console/' + projectID + '/' + actionGrouping.screenID + '/comments/',
						commentCount: unreadComments.length
					};
					if ( commentsOnScreen.length > 0 ) {
						var firstComment = _.first( commentsOnScreen );
						if ( unreadComments.length ) {
							firstComment = _.first( unreadComments );
						}
						if ( !_.isUndefined( firstComment.conversationID ) ) {
							tmpScreen.consoleUrl += firstComment.conversationID;
						}
					} else {
						tmpScreen.consoleUrl += "#/preview";
					}
					return tmpScreen;
				} );
				action.screens = _.uniq( action.screens, function ( screen ) {
					return screen.id;
				} );
				action.commentCount = _.sumProperty( action.screens, "commentCount" );
				return action;
			} );
		}

		function updateHasMoreActivityToLoad() {
			var activity = _.last( $scope.activityPeriods );
			$scope.hasMoreActivityToLoad = ( activity.offset > activity.minimumOffset );
		}
		$scope.loadMoreActivity = function () {
			if ( $scope.isLoadingPastActivity || !$scope.hasMoreActivityToLoad ) {
				return;
			}
			$scope.isLoadingPastActivity = true;
			var lastKnownOffset = getLastKnownOffset();
			var pastOffset = dateHelper.addDays( lastKnownOffset, -7 ).getTime();
			Deferred.handlePromise(
				enterpriseProjectsPartial.getActivity( pastOffset, 7, $scope.member.userID, false, showLimitedData ),
				function ( response ) {
					if ( ( !response.activity.alreadyAddedToActivityPeriods ) && response.activity.actions.length === 0 ) {
						$scope.loadMoreActivity();
					}
					applyActivityData( response.activity );
					$scope.isLoadingPastActivity = false;
				},
				function () {
					$scope.isLoadingPastActivity = false;
					$scope.openModalWindow( "error", "For some reason, we couldn't load your past activity. Try refreshing your browser." );
				}
			);
		};
		/* end of activity */
		/********************************************************/
		$scope.showSubview = function ( section ) {
			$scope.subview = section;
		};
		var showLimitedData = (
			( $scope.isContributor && !$scope.enterpriseConfig.permissions.canDesignersViewAllProjects ) || $scope.isReviewer );
		$scope.isLoadingActivity = false;
		$scope.isLoadingPastActivity = false;
		$scope.activityPeriods = [];
		$scope.hasActivity = false;
		$scope.member = {};
		$scope.hasMoreActivityToLoad = false;
		$scope.projects = [];
		$scope.subview = "activity";
		$scope.isLoading = true;
		var memberID = modalWindowRequest.getData( 0 );
		if ( typeof memberID !== 'number' ) {
			$scope.openModalWindow( "error", "For some reason, we couldn't load this user's profile." );
		}
		getCompanyMember( memberID );
	}
} )( angular, InVision );;;
/*! error-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ErrorController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.errorMessage = modalWindowRequest.getData( 0 );
	}
} )( angular, InVision );;;
/*! getting-started-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.GettingStartedController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.openContactUsModal = function () {
			$scope.openModalWindow( "contactUs" );
		};
		$scope.openMacAppModal = function () {
			$scope.openModalWindow( "macAppAdvert" );
		};
		$scope.playGettingStartedVideo = function () {
			$scope.openModalWindow( "video", "42653619", [ 720, 460 ] );
		};
		$scope.playPencilVideo = function () {
			$scope.openModalWindow( "video", "43985491", [ 590, 470 ] );
		};
		$scope.showSubview = function ( subview ) {
			$scope.subview = subview;
		};
		$scope.subview = "helpVideos";
	}
} )( angular, InVision );;;
/*! gravatar-avatar-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.GravatarAvatarController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, accountService, sessionService, validationService, modalWindowRequest, _ ) {
		function getErrorMessageForResponse( response ) {
			if ( validationService.isNotFound( response ) ) {
				return ( "We could not find a Gravatar image using that email address." );
			} else {
				return ( response.message );
			}
		}
		$scope.saveAvatar = function () {
			if ( !/^[^@]+@[^.]+\..+$/.test( $scope.email ) ) {
				$scope.errorMessage = "Please enter a valid email address.";
				return;
			}
			Deferred.handlePromise(
				accountService.importGravatarAvatar( $scope.email ),
				function ( account ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = getErrorMessageForResponse( response );
				}
			);
		};
		$scope.email = sessionService.user.email;
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! high-fidelity-prototypes-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.HighFidelityPrototypesController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {}
} )( angular, InVision );;;
/*! join-team-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.JoinTeamProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, sessionService, modalWindowRequest, modelEvents ) {
		$scope.joinProject = function () {
			Deferred.handlePromise(
				projectService.addUserToProject( $scope.projectID, $scope.user.id ),
				function ( response ) {
					$location.path( "/projects/" + $scope.projectID );
					$scope.closeModalWindow();
				},
				function ( response ) {
					console.warn( response );
				}
			);
		};
		$scope.user = sessionService.user;
		$scope.projectID = modalWindowRequest.getData( 0 );
	}
} )( angular, InVision );;;
/*! layersync-info.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.LayerSyncInfo", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.showVideo = function () {
			$scope.isShowingVideo = true;
		};
		$scope.hideVideo = function () {
			$scope.isShowingVideo = false;
		};
		$scope.showSubview = function ( section ) {
			$scope.subview = section;
		};
		$scope.isShowingVideo = true;
	}
} )( angular, InVision );;;
/*! layersync.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.LayerSync", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _, layersyncService, Deferred ) {
		$scope.toggleFiles = function () {
			$scope.isShowingFiles = !$scope.isShowingFiles;
		};
		$scope.enableLayerSync = function () {
			Deferred.handlePromise(
				layersyncService.enable( $scope.item.id ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.disableLayerSync = function () {
			Deferred.handlePromise(
				layersyncService.disable( $scope.item.id, $scope.deleteArtifacts ),
				function ( response ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.inspect = function () {
			$scope.isInspecting = true;
			Deferred.handlePromise(
				layersyncService.inspect( $scope.item.id, $scope.deleteArtifacts ),
				function ( response ) {
					$scope.info = {
						artifacts: []
					};
					_.forEach( response.screens, function ( item ) {
						$scope.info.artifacts.push( {
							type: "screen",
							name: item.imagename,
							filename: item.imagename,
							isExisting: ( item.screenID > 0 )
						} );
						$scope.counts.screen++;
					} );
					$scope.isInspecting = false;
					$scope.allowSync = ( response.screens.length || response.images.length || response.fonts.length );
				},
				function ( response ) {
					$scope.isInspecting = false;
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.isShowingFiles = false;
		$scope.deleteArtifacts = false;
		$scope.errorMessage = "";
		$scope.item = modalWindowRequest.getData( 0 );
		$scope.info = modalWindowRequest.getData( 1 );
		$scope.counts = {
			screen: 0,
			asset: 0
		};
		$scope.isEnabled = $scope.item.isLayerSync;
		$scope.isInspecting = false;
		$scope.allowSync = false;
		if ( $scope.isEnabled ) {
			$scope.counts = _.countBy( $scope.info.artifacts, function ( i ) {
				return i.type
			} );
		} else {
			$scope.inspect();
		}
	}
} )( angular, InVision );;;
/*! live-embed.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.LiveEmbed", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, modalWindowRequest, liveEmbedModalPartial, Deferred, userPreferenceService ) {
		$scope.views = {
			'intro': 'intro.htm',
			'select': 'select.htm',
			'code': 'code.htm'
		};
		var screenID = modalWindowRequest.getData( 0 );
		var shareUrl = "";
		var hasSeenLiveEmbedIntro = false;

		function loadData() {
			Deferred.handleAllPromises(
				[
					liveEmbedModalPartial.get( screenID )
				],
				function ( response ) {
					shareUrl = response.signedPublicUrl;
				},
				function ( error ) {
					$location.path( "/" );
				}
			);
		}

		function setupShareUrl( shareUrl, service ) {
			if ( service === "JIRA" ) {
				$scope.shareUrl = "!" + shareUrl + "!";
			} else if ( $.inArray( service, servicesThatRequireMarkdown ) >= 0 ) {
				$scope.shareUrl = "![InVision Live Embed](" + shareUrl + ")";
			} else {
				$scope.shareUrl = shareUrl;
			}
		}
		$scope.changeView = function ( view ) {
			$scope.subview = view;
		};
		$scope.selectService = function ( service ) {
			$scope.subview = "code";
			$scope.service = service;
			$scope.helpSteps = helpSteps[ service ];
			setupShareUrl( shareUrl, service );
		};
		$scope.toggleHelp = function () {
			$scope.isShowingHelp = !$scope.isShowingHelp;
		};
		$scope.startSuccessMessageWorkflow = function ( duration ) {
			if ( successMessageTimer ) {
				$timeout.cancel( successMessageTimer );
			}
			$scope.showSuccessMessage = true;
			successMessageTimer = $timeout(
				function () {
					$scope.showSuccessMessage = false;
				}, ( duration || 4000 )
			);
		};
		var successMessageTimer = null,
			helpSteps = {
				"Basecamp": [
					"Start a new discussion inside a Basecamp project or add a comment to an existing discussion.",
					"Paste your Live Embed Code into the message area.",
					"Your screen is now embedded live which means any changes you make inside InVision will be reflected in Basecamp too!"
				],
				"Trello": [
					"Open or create a Trello card.",
					"Paste your Live Embed Code into the card's description field."
				],
				"teamwork": [
					"When composing a message or notebook entry click the insert / edit image icon.",
					"Paste your Live Embed code into the image URL form field."
				],
				"Flow": [
					"In order for Live Embed to work, you must first configure the Flow Text Editor.  Go to User Preferences > Account Preferences > Text Editor.  Select 'Markdown editor'.",
					"Choose to create or edit an existing task.",
					"Paste your Live Embed Code into a comment."
				],
				"JIRA": [
					"Simply paste your Live Embed Code into a new or existing JIRA Issue."
				],
				"flowdock": [
					"Paste your Live Embed Code into a flow message."
				],
				"HipChat": [
					"Paste the Live Embed Code anywhere in a chat message."
				],
				"slack": [
					"Paste the Live Embed Code anywhere in a message. "
				],
				"custom": [
					"Use this link anywhere.  It will always point the latest version of the screen."
				]
			};
		var servicesThatRequireMarkdown = [
			"Trello",
			"Flow"
		];
		$scope.subview = "intro";
		$scope.service = "";
		$scope.helpSteps = [];
		$scope.isShowingHelp = false;
		$scope.shareUrl = "";
		var promise1 = userPreferenceService.getPreferenceTypeByName( "hasSeenLiveEmbedIntro", false, "boolean" );
		promise1.then( function ( response1 ) {
			var userPreferenceID = response1.data.id;
			var promise2 = userPreferenceService.getUserPreferenceById( userPreferenceID );
			promise2.then( function ( response2 ) {
				hasSeenLiveEmbedIntro = response2.data.value === "true" ? true : false;
				if ( hasSeenLiveEmbedIntro === false ) {
					userPreferenceService.setUserPreferenceById( userPreferenceID, "true" );
				} else {
					$scope.subview = "select";
				}
			} );
		} );
		loadData();
	}
} )( angular, InVision );;;
/*! liveshare-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.liveshare.LiveShareController", Controller );

	function Controller( $scope, modalWindowRequest, _, Deferred, shareService, newShareModalPartial, $window ) {
		function applyRemoteData( share, shareUrl, screens ) {
			screens = _.sortOnProperty( screens, "sort" );
			screens = _.setProperty( screens, "isHome", false );
			screens[ 0 ].name = ( screens[ 0 ].name + " ( Home )" );
			$scope.screens = screens;
			$scope.shareUrl = shareUrl;
			$scope.form.shareID = share.id;
			$scope.form.startScreen = _.findWithProperty( screens, "id", share.screenID );
			$scope.form.isCommentingAllowed = share.isCommentingAllowed;
			$scope.form.isNavigateAllowed = share.isNavigateAllowed;
			$scope.form.isResizeWindow = share.isResizeWindow;
			$scope.form.isLoadAllScreens = share.isLoadAllScreens;
			$scope.form.isUserTesting = share.isUserTesting;
			$scope.form.isAnonymousViewingAllowed = share.isAnonymousViewingAllowed;
			$scope.form.password = share.password;
			$scope.form.key = share.key;
			$scope.form.isRequireUserIdentification = true;
			$scope.startScreen = $scope.form.startScreen.id;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				newShareModalPartial.get( $scope.projectID, $scope.screenID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.share,
						response.shareUrl,
						response.screens
					);
				},
				function ( response ) {
					$scope.openModalWindow( "error", "You cannot share this project until you upload at least one screen." );
				}
			);
		}
		$scope.toggleStatus = function () {
			$scope.toggle = $scope.toggle == "off" ? "on" : "off";
		};
		$scope.updateStartScreen = function () {
			$scope.startScreen = $scope.form.startScreen.id;
		}
		$scope.launchLiveShare = function () {
			if ( $scope.form.isRequireUserIdentification ) {
				$scope.form.isAnonymousViewingAllowed = false;
			} else {
				$scope.form.isAnonymousViewingAllowed = true;
			}
			$scope.form.isNavigateAllowed = true;
			$scope.form.isLoadAllScreens = true;
			$scope.form.forceNew = true; // forces us to grab a new share
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				shareService.createShare(
					$scope.projectID,
					$scope.form.startScreen.id,
					$scope.form.isCommentingAllowed,
					$scope.form.isNavigateAllowed,
					$scope.form.isResizeWindow,
					$scope.form.isLoadAllScreens,
					$scope.form.isUserTesting,
					$scope.form.isAnonymousViewingAllowed,
					$scope.form.password,
					$scope.form.forceNew
				),
				function ( response ) {
					$scope.form.shareID = response.id;
					$scope.form.startScreen = _.findWithProperty( $scope.screens, "id", response.screenID );
					$scope.form.isCommentingAllowed = response.isCommentingAllowed;
					$scope.form.isNavigateAllowed = response.isNavigateAllowed;
					$scope.form.isResizeWindow = response.isResizeWindow;
					$scope.form.isLoadAllScreens = response.isLoadAllScreens;
					$scope.form.isUserTesting = response.isUserTesting;
					$scope.form.isAnonymousViewingAllowed = response.isAnonymousViewingAllowed;
					$scope.form.password = response.password;
					$scope.form.key = response.key;
					document.location.href = "/liveshare/" + $scope.form.key;
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't create the LiveShare. This was unexpected!" );
				}
			);
			return true;
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.screenID = modalWindowRequest.getData( 1, 0 );
		$scope.startScreen = 0;
		$scope.isLoading = false;
		$scope.screens = [];
		$scope.shareUrl = "";
		$scope.toggle = "off";
		$scope.form = {
			shareID: 0,
			startScreen: null,
			password: "",
			key: "",
			message: ""
		};
		$scope.formAction = '/liveshare/create/' + $scope.projectID + '/phone/' + $scope.toggle;
		$scope.liveshare = {};
		$scope.$watch( "toggle", function ( status ) {
			if ( status == "on" && !$scope.liveshare.conferenceId ) {
				$scope.liveshare.conferenceId = _.random( 100, 999 );
			}
			if ( $scope.projectID ) {
				$scope.formAction = '/liveshare/create/' + $scope.projectID + '/phone/' + $scope.toggle;
			}
		} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! liveshare-intro-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.liveshare.IntroController", Controller );

	function Controller( $scope, firebaseStateService, modalWindowRequest, _, config, accountService, projectService ) {
		/**
		 * Generates a GUID string, according to RFC4122 standards.
		 * @returns {String} The generated GUID.
		 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
		 * @author Slavik Meltser (slavik@meltser.info).
		 * @link http://slavik.meltser.info/?p=142
		 */
		function guid() {
			function _p8( s ) {
				var p = ( Math.random().toString( 16 ) + "000000000" ).substr( 2, 8 );
				return s ? "-" + p.substr( 0, 4 ) + "-" + p.substr( 4, 4 ) : p;
			}
			return _p8() + _p8( true ) + _p8( true ) + _p8();
		}

		function setIntroModalPreference( pref ) {
			accountService.markLiveShareIntroClosed( pref );
		}
		var slide = {
			"1": {
				header: "Present and collaborate in real-time.",
				subtitle: "Tour your team or clients through designs and prototypes.",
				button: "Ok, next..."
			},
			"2": {
				header: "Sketch together.",
				subtitle: "Group sketch over your designs or on a virtual whiteboard.",
				button: "Ok, next..."
			},
			"3": {
				header: "Get your team talking.",
				subtitle: "Toll-free conference call gets the conversation flowing.",
				button: "Start LiveShare"
			}
		};
		var fbStatusRef;
		var fbRedirectTarget;
		$scope.goBack = function () {
			$scope.slidePosition--;
		};
		$scope.goForward = function () {
			$scope.slidePosition++;
		};
		$scope.goTo = function ( pos ) {
			$scope.slidePosition = pos;
		}
		$scope.getButton = function () {
			return slide[ $scope.slidePosition ].button;
		};
		$scope.getHeader = function () {
			return slide[ $scope.slidePosition ].header;
		};
		$scope.getSubtitle = function () {
			return slide[ $scope.slidePosition ].subtitle;
		};
		$scope.gotIt = function () {
			if ( $scope.slidePosition === 3 ) {
				$scope.closeModalWindow();
				if ( $scope.liveshare.currentTarget !== null && $scope.liveshare.participants > 0 ) {
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( "nothing" );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.currentTarget, $scope.liveshare.conferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
							fbStatusRef.off( "value" );
							fbStatusRef = null;
							fbRedirectTarget.set( "" );
						}
					} );
				} else if ( $scope.liveshare.currentTarget !== null ) { // if the presenter is the only one in the LiveShare, just reuse that tab
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( "nothing" );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.currentTarget );
							fbStatusRef.off( "value" );
							fbStatusRef = null;
							fbRedirectTarget.set( "" );
						}
					} );
				} else { // if not, force a new target
					$scope.liveshare.target = "liveshare_" + guid();
					firebaseStateService.setTarget( $scope.liveshare.target );
					$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.target );
				}
			} else {
				$scope.goForward();
			}
		};
		$scope.$watch( "hideIntroduction", function ( newVal, oldVal ) {
			if ( newVal !== oldVal ) {
				setIntroModalPreference( newVal );
			}
		} );
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.liveshare = data;
		} );
		$scope.slideHeader = "Collaborate on design in real-time."; // default first slide header
		$scope.slideSubtitle = "Tour your team or clients through designs and prototypes.";
		$scope.slidePosition = 1;
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.liveshare = firebaseStateService.getState();
	}
} )( angular, InVision );;;
/*! liveshare-schedule-list-controller.js */
;;
angular.module( 'InVision' )
	.controller( "modal.liveshareSchedule.ListController", [
		'$scope', 'firebaseStateService', 'moment', 'Deferred', 'config', '$timeout', '$filter',
		function ( $scope, firebaseStateService, moment, Deferred, config, $timeout, $filter ) {
			angular.extend( $scope, {
				isSubmitted: false,
				isLoading: true,
				isSaving: false,
				view: 'list',
				item: {},
				schedule: [],
				liveshareUrl: config.liveshareUrl,
				hours: []
			} );
			$scope.$on( "firebase.stateChange", function ( event, data ) {
				load( data );
			} );
			$scope.$watch( "subview", function () {
				load();
			} );
			$scope.$watch( "project.id", function ( newID, oldID ) {
				if ( newID === oldID ) {
					return;
				}
				load();
			} );
			$scope.$watch( '$parent.isLiveShareDdOpen', function ( isOpen ) {
				if ( !isOpen && $scope.schedule.length > 0 ) {
					angular.forEach( $scope.schedule, function ( item ) {
						item.isDelete = false;
					} );
				}
			} );
			var hours = [];
			for ( var i = 0; i < 24; ++i ) {
				var hour = ( i >= 12 ) ? ( ( i - 12 ) || 12 ) : ( i || 12 ),
					amPM = i >= 12 ? 'PM' : 'AM';
				hours.push( hour + ':00 ' + amPM );
				hours.push( hour + ':30 ' + amPM );
			}
			$scope.hours = hours;
			$scope.setView = function ( view ) {
				$scope.view = view;
			};
			$scope.itemDelete = function ( item ) {
				item.isDelete = true;
			};
			$scope.itemDeleteConfirm = function ( item ) {
				item.isDeleting = true;
				firebaseStateService
					.removeLiveShare( {
						key: item.sharekey
					} )
					.then( function () {
						item.isDelete = false;
						item.isDeleting = true;
					}, function () {
						item.isDeleting = false;
						item.isDelete = false;
						alert( 'An error occurred, please try again.' );
					} );
			};
			$scope.itemDeleteCancel = function ( item ) {
				item.isDelete = false;
			};
			$scope.itemCopyLink = function ( item ) {
				item.isCopied = true;
				$timeout( function () {
					item.isCopied = false;
				}, 1500 );
			};
			$scope.itemCreate = function () {
				$scope.item = {
					isNew: true
				};
				$scope.setView( 'edit' );
			};
			$scope.itemEdit = function ( item ) {
				$scope.item = {
					id: item.id,
					date: item.rawDate,
					time: new Date( item.date ),
					description: item.description,
					sharekey: item.sharekey,
					key: item.key
				};
				$scope.view = 'edit';
			};
			$scope.itemSave = function ( isValid ) {
				$scope.isSubmitted = true;
				if ( !isValid || $scope.isSaving ) {
					return;
				}
				$scope.isSaving = true;
				var item = {
					id: $scope.item.id,
					rawDate: $scope.item.date,
					rawTime: $scope.item.time,
					date: getUtcDate( $scope.item ),
					description: $scope.item.description || '',
					projectID: $scope.project.id,
					projectName: $scope.project.name
				};
				if ( $scope.item.isNew ) {
					itemCreate( item );
				} else {
					item.key = $scope.item.key;
					item.sharekey = $scope.item.sharekey;
					itemUpdate( item );
				}
			};
			$scope.itemCancel = function () {
				$scope.isSubmitted = false;
				$scope.item = {};
				$scope.setView( 'list' );
			};

			function load( data ) {
				if ( !data ) {
					data = firebaseStateService.getState();
				}
				$scope.schedule = _.filterWithProperty(
					data.scheduledLiveShares,
					'projectID',
					$scope.project.id
				);
			}

			function getUtcDate( o ) {
				return moment( Date.parse( o.date + " " + $filter( 'date' )( o.time, 'shortTime' ) ) )
					.utc()
					.valueOf();
			}

			function itemCreate( item ) {
				firebaseStateService
					.createLiveShare( {
						projectID: $scope.project.id,
						json: true,
						scheduled: true
					} )
					.then( function ( response ) {
						angular.extend( item, {
							id: response.id,
							sharekey: response.key
						} );
						firebaseStateService.addScheduledLiveShare( item );
						$scope.schedule.push( item );
						itemSaved();
					}, function () {
						alert( 'An error occurred, please try again.' );
					} );
			}

			function itemUpdate( item ) {
				firebaseStateService.editScheduledLiveShare( item );
				itemSaved();
			}

			function itemSaved() {
				$scope.isSubmitted = false;
				$scope.isSaving = false;
				$scope.item = {};
				$scope.view = 'list';
			}
		}
	] );;;
/*! liveshare-target-prompt-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.liveshare.TargetPrompt", Controller );

	function Controller( $scope, firebaseStateService, modalWindowRequest, _, config ) {
		/**
		 * Generates a GUID string, according to RFC4122 standards.
		 * @returns {String} The generated GUID.
		 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
		 * @author Slavik Meltser (slavik@meltser.info).
		 * @link http://slavik.meltser.info/?p=142
		 */
		function guid() {
			function _p8( s ) {
				var p = ( Math.random().toString( 16 ) + "000000000" ).substr( 2, 8 );
				return s ? "-" + p.substr( 0, 4 ) + "-" + p.substr( 4, 4 ) : p;
			}
			return _p8() + _p8( true ) + _p8( true ) + _p8();
		}
		$scope.openLiveShareInTarget = function () {
			fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshareNode + "/status" );
			fbStatusRef.set( "redirecting" );
			$scope.$emit( "autosubmit", $scope.formName, $scope.liveshareTarget, $scope.liveshareConferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
			$scope.closeModalWindow();
			fbStatusRef = null;
		}
		$scope.openLiveShareNew = function () {
			var newTarget = "liveshare_" + guid();
			firebaseStateService.setKey( "" );
			fbTargetRef.set( newTarget );
			$scope.closeModalWindow();
			setTimeout( function () {
				$scope.$emit( "autosubmit", $scope.formName, newTarget );
			}, 100 );
		}
		var fbTargetRef = new Firebase( config.firebaseUrl + "/users/" + config.userID + "/target" );
		var fbKeyRef = new Firebase( config.firebaseUrl + "/users/" + config.userID + "/sharekey" );
		var fbStatusRef;
		var fbNodeRef;
		$scope.numParticipants = modalWindowRequest.getData( 0 );
		$scope.liveshareTarget = modalWindowRequest.getData( 1 );
		$scope.liveshareNode = modalWindowRequest.getData( 2 );
		$scope.liveshareConferenceId = modalWindowRequest.getData( 3 );
		$scope.formName = modalWindowRequest.getData( 4 );
	}
} )( angular, InVision );;;
/*! mac-app-advert-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.MacAppAdvertController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.playMacAppVideo = function () {
			$scope.openModalWindow( "video", "49918256", [ 590, 470 ] );
		};
	}
} )( angular, InVision );;;
/*! mobile-demos-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.MobileDemosController", Controller );
	/** @ngInject */
	function Controller( $scope, _ ) {
		$scope.showState = function ( state ) {
			$scope.state = state;
		};
		$scope.state = 1;
	}
} )( angular, InVision );;;
/*! mobile-statusbar-is-visible-warning.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.MobileStatusbarIsVisibleWarning", Controller );
	/** @ngInject */
	function Controller( $scope, _, $rootScope, modalWindowRequest ) {
		var project = modalWindowRequest.getData( 0 );
		$scope.platformLabel = project.mobileTemplate.platform;
		if ( $scope.platformLabel == "Android" ) {
			$scope.platformLabel = "Android OS";
		}
		$scope.hideFromDesktop = function () {
			$scope.closeModalWindow();
		}
		$scope.keepVisible = function () {
			$rootScope.$broadcast( "toggleMobileStatusbarIsVisible" );
			$scope.closeModalWindow();
		}
	}
} )( angular, InVision );;;
/*! mobile-tips-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.MobileTipsController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.playMobileHelpVideo = function () {
			$scope.openModalWindow( "video", "80845114" );
		};
		$scope.showSubview = function ( section ) {
			$scope.subview = section;
		};
		var startingPoints = {
			"phone iOS": "iphone5",
			"tablet iOS": "ipad",
			"phone Android": "android-720",
			"tablet Android": "nexus-10"
		};
		var mobileSizes = {
				"iphone5": [ 640, 1136, 40 ],
				"iphone": [ 640, 960, 40 ],
				"ipad": [ 1536, 2048, 40 ],
				"android-720": [ 720, 1280, 48 ],
				"android-1080": [ 1080, 1920, 48 ],
				"nexus-7": [ 1200, 1824, 50 ],
				"nexus-10": [ 1600, 2464, 50 ]
			},
			projectType = modalWindowRequest.getData( 0 ),
			startingPlatform = startingPoints[ projectType.deviceType + " " + projectType.platform ];
		$scope.subview = projectType.orientation;
		$scope.mobileOptions = startingPlatform;
		$scope.width = mobileSizes[ startingPlatform ][ 0 ];
		$scope.height = mobileSizes[ startingPlatform ][ 2 ];

		function setDimensions( check, target ) {
			var w = check === "portrait" ? 0 : 1,
				h = check === "portrait" ? 1 : 0,
				newHeight = mobileSizes[ target ][ h ];
			if ( !$scope.hasStatusBar ) {
				newHeight = newHeight - mobileSizes[ target ][ 2 ];
			}
			$scope.width = mobileSizes[ target ][ w ];
			$scope.height = newHeight;
		}
		$scope.$watch( "mobileOptions", function ( newVal, oldVal ) {
			setDimensions( $scope.subview, newVal );
		} );
		$scope.$watch( "subview", function ( newVal, oldVal ) {
			setDimensions( newVal, $scope.mobileOptions );
		} );
		$scope.$watch( "hasStatusBar", function ( newVal, oldVal ) {
			if ( newVal === oldVal ) {
				return;
			}
			setDimensions( $scope.subview, $scope.mobileOptions );
		} );
	}
} )( angular, InVision );;;
/*! move-to-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.MoveToProjectController", Controller );
	/** @ngInject */
	function Controller( $rootScope, $scope, $location, Deferred, $q, standardPartial, screenService, modalWindowRequest, _ ) {
		function applyRemoteData( projects ) {
			projects = _.sortBy( projects, 'name' );
			projects.unshift( {
				id: 0,
				name: "Create a New Project..."
			} );
			$scope.projects = projects;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				standardPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.projects );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your projects. Try refreshing your browser." );
				}
			);
		}

		function moveSelectedToProject( project ) {
			var projectID = $scope.projectID;
			if ( typeof ( project ) !== 'undefined' ) {
				projectID = project.id;
			}
			Deferred.handlePromise(
				screenService.moveScreensToProject( $scope.screenID, projectID ),
				function ( response ) {
					$scope.closeModalWindow();
				}
			);
		}
		$scope.moveToProject = function () {
			if ( $scope.projectID ) {
				moveSelectedToProject();
			} else {
				var newProjectDeferred = $q.defer();
				var newProjectPromise = newProjectDeferred.promise;
				$scope.openModalWindow( "newProject", newProjectDeferred );
				newProjectPromise.then( moveSelectedToProject );
			}
		};
		$scope.isLoading = false;
		$scope.projectID = 0;
		$scope.screenID = modalWindowRequest.getData( 0 );
		$scope.$on(
			"$destroy",
			function () {}
		);
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! new-presentation-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.NewPresentation", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _, $location ) {
		var projectID = modalWindowRequest.getData( 0 );
		$scope.setActiveSample = function ( sample ) {
			$scope.activeSample = sample;
		};
		$scope.createTour = function () {
			$scope.closeModalWindow( true );
			$location.path( "/presentations/" + projectID + "/0" );
		};
		$scope.activeSample = "tour";
	}
} )( angular, InVision );;;
/*! new-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.NewProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, accountService, sessionService, newProjectModalPartial, validationService, modalWindowRequest, modelEvents, userService, _, $timeout ) {
		function applyRemoteData( teamMembers ) {
			$scope.possibleOwners = augmentTeamMembers( teamMembers );
			_.forEach( $scope.possibleOwners, function ( owner ) {
				owner.dropName = owner.isCompany ? owner.company : owner.name;
				if ( owner.isCompany ) {
					if ( owner.companyLogoID.length ) {
						owner.dropAvatar = "<img src=\"/logos/" + owner.companyLogoID + "\" alt=\"" + owner.dropName + "\" />";
					} else {
						owner.dropAvatar = "<span class='company-logo'><div class='company-image default-company-logo-dropdown'></div></span>";
					}
				} else {
					owner.dropAvatar = owner.hasSystemAvatar ? owner.initials : "<img src=\"/avatars/" + owner.avatarID + "\" alt=\"" + owner.dropName + "\" />";
				}
			} );
			$scope.projectOwner = getDefaultProjectOwner( $scope.possibleOwners );
		}

		function augmentTeamMembers( teamMembers ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var user = teamMembers[ i ];
				user.shortName = userService.getShortName( user.name );
				user.currentPlan = user.currentPlan.replace( /\s-\sTier.*$/, '' );
				user.remainingProjectQuota = Math.max( ( user.maxProjectCount - user.projectCount ), 0 );
				user.hasUnlimitedProjects = ( user.maxProjectCount === 999999 );
				user.hasEnterprisePlan = isEnterprisePlan( user.subscriptionPlanID );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				user.initials = userService.getInitials( user.name );
			}
			return ( sortTeamMembers( teamMembers ) );
		}

		function getDefaultProjectOwner( teamMembers ) {
			$scope.projectOwnerId = teamMembers[ 0 ].id;
			return ( teamMembers[ 0 ] );
		}

		function getErrorMessageForResponse( response ) {
			if ( validationService.isMissingField( response ) ) {
				return ( "Please enter a project name." );
			} else if ( validationService.isInvalidField( response ) ) {
				return ( "Project names can only contain limited punctuation (and may not start with a period). Try removing non-alpha-numeric characters." );
			} else if ( validationService.isAlreadyExists( response ) ) {
				if ( $scope.isEnterprise ) {
					return ( "Project names must be unique to a given company. Please select a different project name." );
				} else {
					return ( "Project names must be unique to a given user. Please select a different project name." );
				}
			} else if ( validationService.isForbidden( response ) ) {
				return ( "You are no longer allowed to create projects under this user's account." );
			} else {
				return ( response.message );
			}
		}

		function isEnterprisePlan( planID ) {
			return (
				( planID === 24 ) || // Enterprise - trial.
				( planID === 20 ) || // Enterprise - Tier 1.
				( planID === 22 ) || // Enterprise - Tier 2.
				( planID === 23 ) // Enterprise - Tier 3.
			);
		}

		function isPausePlan( planID ) {
			return planID == 30;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				newProjectModalPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.teamMembers );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your people. Try refreshing your browser." );
				}
			);
		}

		function sortTeamMembers( teamMembers ) {
			var teamLead = _.findWithProperty( teamMembers, "isTeamLead", true );
			if ( teamLead && teamLead.subscriptionPlanID === 1 ) {
				teamMembers.sort( teamMemberComparisonForFreeUser );
			} else {
				teamMembers.sort( teamMemberComparisonForPaidUser );
			}
			return ( teamMembers );
		}

		function teamMemberComparisonForFreeUser( a, b ) {
			if ( a.maxProjectCount > b.maxProjectCount ) {
				return -1;
			} else if ( a.maxProjectCount < b.maxProjectCount ) {
				return 1;
			} else if ( planComparison( a.subscriptionPlanID, b.subscriptionPlanID ) ) {
				return -1;
			} else {
				return 1;
			}
		}

		function teamMemberComparisonForPaidUser( a, b ) {
			if ( a.isTeamLead ) {
				return ( -1 );
			} else if ( b.isTeamLead ) {
				return ( 1 );
			}
			return ( a.remainingProjectQuota <= b.remainingProjectQuota ? 1 : -1 );
		}

		function planComparison( a, b ) {
			var PRO_PLAN_IDS = [ 26, 27 ];
			var TEAM_PLAN_IDS = [ 28, 29 ];
			var ENT_PLAN_IDS = [ 20, 22, 23, 24 ];
			var precedence = [
				ENT_PLAN_IDS,
				TEAM_PLAN_IDS,
				PRO_PLAN_IDS
			];
			for ( var i = 0, len = precedence.length; i < len; i++ ) {
				if ( precedence[ i ].indexOf( a ) >= 0 || precedence[ i ].indexOf( b ) >= 0 ) {
					return ( precedence[ i ].indexOf( b ) < 0 );
				}
			}
			return false;
		}
		$scope.openChangePlanModal = function () {
			if ( $scope.isEnterprise || $scope.isEnterpriseUser ) {
				$scope.openModalWindow( "changePlanEnterprise" );
			} else {
				$scope.openModalWindow( "changePlan", {
					openedDueTo: "project quota"
				} );
			}
		};
		$scope.saveProject = function () {
			if ( !$scope.projectName ) {
				$scope.errorMessage = "Please enter a project name.";
				return;
			}
			if ( !$scope.projectOwnerId ) {
				$scope.errorMessage = "Please select a project owner.";
				return;
			}
			var request = projectService.save( {
				userID: $scope.projectOwnerId,
				name: $scope.projectName,
				isMobile: $scope.isMobile,
				mobileDeviceID: $scope.mobileDeviceID
			} );
			if ( !submissionInProgress ) {
				submissionInProgress = true;
				Deferred.handlePromise(
					request,
					function ( project ) {
						$scope.closeModalWindow();
						if ( _.isNull( deferred ) ) {
							$location.path( "/projects/" + project.id );
						} else {
							deferred.resolve( project );
						}
					},
					function ( response ) {
						submissionInProgress = false;
						$scope.errorMessage = getErrorMessageForResponse( response );
					}
				);
			}
		};
		$scope.selectOwner = function ( userID ) {
			$scope.projectOwnerId = userID;
		};
		$scope.openTeamSetupVideo = function () {
			$scope.openModalWindow( "video", "66614411", [ 640, 400 ] );
		};
		$scope.hideTeamSetupTip = function ( tipId ) {
			if ( tipId === 1 ) {
				$scope.shouldShowTeamSetupTip1 = false;
			}
			accountService.markTeamSetupTipClosed( tipId );
		};
		$scope.setIsMobile = function ( projectType ) {
			$scope.mobileDeviceID = projectType;
			$scope.isMobile = projectType > 0 ? 1 : 0;
		};
		var submissionInProgress = false;
		var deferred = ( modalWindowRequest.getData( 0 ) || null );
		$scope.isLoading = false;
		$scope.projectName = "";
		$scope.projectOwner = null;
		$scope.possibleOwners = [];
		$scope.errorMessage = null;
		$scope.shouldShowTeamSetupTip1 = !( sessionService.user.hasClosedTeamSetupTip1 );
		$scope.isMobile = false;
		$scope.mobileDeviceID = 0;
		$scope.projectType = 0;
		$scope.projectOwnerId = sessionService.user.id;
		$scope.initLoad = true;
		$scope.$watch(
			"mobileDeviceID",
			function ( newValue, oldValue ) {
				if ( $scope.initLoad ) {
					$scope.isMobile = false;
					$scope.initLoad = false;
				} else {
					$scope.isMobile = true;
				}
			}
		);
		$scope.$watch(
			"projectName",
			function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				$scope.projectName = $scope.projectName.replace( /[\\\/:*?\"<>|]+/g, "" );
			}
		);
		$scope.$watch(
			"isLoading",
			function ( isLoading ) {
				if ( !isLoading ) {
					$timeout( function () {
						$scope.$broadcast( "resizeModal" );
					} );
				}
			}
		);
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "accountUpdated.newProject" );
			}
		);
		modelEvents.on(
			"accountUpdated.newProject",
			function ( event, account ) {
				sessionService.update();
			} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! new-team-member-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.NewTeamMemberController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, teamService, teamProfilePartial, teamInvitationService, modalWindowRequest, validationService, _, modelEvents, sessionService, userService, hashKeyCopier ) {
		function applyRemoteData( response ) {
			teamMemberCount = 0;
			$scope.removedMemberCount = 0;
			$scope.newMemberCount = 0;
			if ( response.companyMembers.length ) {
				var companyMembers = response.companyMembers[ 0 ];
				$scope.teamBuild.teamMembers = augmentTeamMembers( companyMembers.teamMembers );
				$scope.teamBuild.teamConnectionInvitations = augmentInvitees( companyMembers.teamConnectionInvitations );
				$scope.teamBuild.teamInvitations = _.where( companyMembers.teamInvitations, {
					canCreateProjectsForLead: true
				} );
				$scope.teamBuild.teamInvitations = augmentInvitees( $scope.teamBuild.teamInvitations );
				$scope.hasMembers = ( $scope.teamBuild.teamMembers.length > 1 || $scope.teamBuild.teamInvitations.length > 0 );
			}
			$scope.teamBuild.otherConnections = augmentTeamMembers( response.iOwnACompanyOtherConnections );
			maxProjectMemberCount = response.account.maxProjectMemberCount;
		};

		function augmentTeamMembers( teamMembers, key ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var user = teamMembers[ i ];
				user.isTeamMember = user.canCreateProjectsForLead;
				user.isSelectedForTeam = user.isTeamMember;
				user.initials = userService.getInitials( user.email );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				if ( user.email == initEmail ) {
					$scope.toggleTeamMemberSelection( user, key );
				}
				if ( user.isTeamMember ) {
					teamMemberCount++;
				}
			}
			return teamMembers;
		};

		function augmentInvitees( invitees, key ) {
			for ( var i = 0, length = invitees.length; i < length; i++ ) {
				var user = invitees[ i ];
				user.isTeamMember = user.canCreateProjectsForLead;
				user.isSelectedForTeam = user.isTeamMember;
				user.showInvitationLink = true;
				user.initials = userService.getInitials( user.memberEmail );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				if ( user.memberEmail == initEmail ) {
					$scope.toggleTeamMemberSelection( user, key );
				}
				if ( user.isTeamMember ) {
					teamMemberCount++;
				}
			}
			return invitees;
		};

		function getUserIDsToAdd() {
			var newMembers = _.where(
				$scope.teamBuild.otherConnections, {
					isTeamMember: false,
					isSelectedForTeam: true
				}
			);
			return (
				_.pluck( newMembers, "id" )
			);
		};

		function getUserIDsToRemove() {
			var oldMembers = _.where(
				$scope.teamBuild.teamMembers, {
					isTeamMember: true,
					isSelectedForTeam: false
				}
			);
			return (
				_.pluck( oldMembers, "id" )
			);
		};

		function getInviteeIDsToAdd() {
			var newMembers = _.where(
				$scope.teamBuild.teamInvitations, {
					isTeamMember: false,
					isSelectedForTeam: true
				}
			);
			return (
				_.pluck( newMembers, "id" )
			);
		};

		function getInviteeIDsToRemove() {
			var oldMembers = _.where(
				$scope.teamBuild.teamInvitations, {
					isTeamMember: true,
					isSelectedForTeam: false
				}
			);
			return (
				_.pluck( oldMembers, "id" )
			);
		};

		function getConnectionInviteeIDsToRemove() {
			var oldMembers = _.where(
				$scope.teamBuild.teamConnectionInvitations, {
					isTeamMember: true,
					isSelectedForTeam: false
				}
			);
			return (
				_.pluck( oldMembers, "id" )
			);
		};

		function loadRemoteData() {
			Deferred.handlePromise(
				teamProfilePartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your team information. Try refreshing your browser." );
				},
				false
			);
		};
		var teamMemberCount = 0; // total number of team members (invited and existing)
		var submissionInProgress = false;
		var initEmail = '';
		var maxProjectMemberCount = 0;
		$scope.clearMemberSearch = function () {
			$scope.teamFilter = "";
			$scope.teamFilter.focus;
		};
		$scope.toggleTeamMemberSelection = function ( invitation ) {
			invitation.isSelectedForTeam = !invitation.isSelectedForTeam;
			if ( !invitation.isTeamMember ) {
				if ( invitation.isSelectedForTeam ) {
					$scope.newMemberCount++;
				} else {
					$scope.newMemberCount--;
				}
			} else {
				if ( !invitation.isSelectedForTeam ) {
					$scope.removedMemberCount++;
				} else {
					$scope.removedMemberCount--;
				}
			}
		};
		$scope.updateTeamMembers = function () {
			if ( submissionInProgress ) {
				return;
			}
			submissionInProgress = true;
			var promises = [];
			var addUserIDs = getUserIDsToAdd();
			var removeUserIDs = getUserIDsToRemove();
			var addInviteIDs = getInviteeIDsToAdd();
			var removeInviteIDs = getInviteeIDsToRemove();
			var removeConnectionInviteIDs = getConnectionInviteeIDsToRemove();
			var updateWithExistingUsers = ( addUserIDs.length || removeUserIDs.length );
			var updateWithInvitedUsers = ( addInviteIDs.length || removeInviteIDs.length );
			var updateWithConnectionInvites = removeConnectionInviteIDs.length;
			var updateWithUsersByEmail = $scope.newusers.email.length;
			var newInvites = updateWithUsersByEmail ? $scope.newusers.email.split( ',' ).length : 0;
			$scope.errorMessage = null;
			var finalTeamCount = ( teamMemberCount + addUserIDs.length - removeUserIDs.length + addInviteIDs.length - removeInviteIDs.length - removeConnectionInviteIDs.length + newInvites );
			if ( finalTeamCount > maxProjectMemberCount ) {
				var msgLimit = ( maxProjectMemberCount - 1 ); // Minus one because current user is on team.
				submissionInProgress = false;
				$scope.errorMessage = ( "You have more than " + msgLimit + " designers selected/invited." );
				return;
			}
			if ( !( updateWithExistingUsers || updateWithUsersByEmail || updateWithInvitedUsers || updateWithConnectionInvites ) ) {
				submissionInProgress = false;
				return ( $scope.closeModalWindow() );
			}
			if ( updateWithUsersByEmail ) {
				var emailArray = $scope.newusers.email.split( ',' );
				for ( var e = 0; e < emailArray.length; e++ ) {
					emailArray[ e ] = $.trim( emailArray[ e ] );
					if ( !( /^[^@]+@[^.]+\..+$/i ).test( emailArray[ e ] ) ) {
						$scope.errorMessage = "Please enter a valid email address.";
						return; //only breaks the loop
					}
					$scope.newusers.email = emailArray.join( ',' );
				}
				if ( $scope.errorMessage ) {
					submissionInProgress = false;
					return;
				}
				promises.push(
					teamInvitationService.send( $scope.newusers.email, "", true, "" )
				);
			}
			if ( updateWithExistingUsers ) {
				promises.push(
					teamService.changeTeamMembers( $scope.user.id, addUserIDs, removeUserIDs )
				);
			}
			if ( updateWithInvitedUsers ) {
				promises.push(
					teamService.changeInviteesOnTeam( $scope.user.id, addInviteIDs, removeInviteIDs )
				);
			}
			if ( updateWithConnectionInvites ) {
				promises.push(
					teamService.removeTeamConnectionInvitees( removeConnectionInviteIDs )
				);
			}
			Deferred.handleAllPromises(
				promises,
				function ( response ) {
					if ( updateWithUsersByEmail ) {
						modelEvents.trigger( "teamInvitationCreated.teamList" );
					}
					submissionInProgress = false;
					$scope.closeModalWindow();
				},
				function ( response ) {
					submissionInProgress = false;
					if ( validationService.isInvalidField( response ) ) {
						$scope.errorMessage = "Please enter a valid email address.";
					} else {
						$scope.openModalWindow( "error", "For some reason, we couldn't update the selected person on this project. Try refreshing your browser." );
					}
				}
			);
		};
		$scope.resendInvitation = function ( invitation ) {
			invitation.showInvitationLink = false;
			Deferred.handlePromise(
				teamInvitationService.resend( invitation.id ),
				function () {},
				function () {
					$scope.errorMessage = "There was an error sending your invitation.";
					return;
				}
			);
		};
		$scope.errorMessage = null;
		$scope.isLoading = true;
		$scope.activeTeamMembers = [];
		$scope.inActiveTeamMembers = [];
		$scope.connectionInvitations = [];
		$scope.invitedTeamMembers = [];
		$scope.teamFilter = null;
		$scope.newMemberCount = 0;
		$scope.removedMemberCount = 0;
		$scope.newusers = {};
		$scope.newusers.email = "";
		$scope.isFirstView = false;
		$scope.user = sessionService.user;
		$scope.teamBuild = {};
		$scope.hasMembers = false;
		$scope.isFirstView = ( modalWindowRequest.getData( 0 ) || false );
		initEmail = ( modalWindowRequest.getData( 1 ) || '' );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! onboarding-tour-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.OnboardingTourController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, $window, $timeout, Deferred, accountService, sessionService, modalWindowRequest, _ ) {
		function markOnboardingTourAsSeen() {
			sessionService.user.hasSeenDashboardTour = true;
			Deferred.handlePromise(
				accountService.sawOnboardingTour( true ),
				function ( response ) {},
				function ( response ) {}
			);
		}
		$scope.openProjectsPage = function () {
			$location.path( '/projects' );
			$scope.closeModalWindow();
		}
		$scope.openNewProjectModal = function () {
			modalWindowRequest.setSuppressClose( false );
			$scope.openModalWindow( "newProject" );
		}
		modalWindowRequest.setSuppressClose( true );
		$scope.$on( "$destroy", function () {
			$scope.setSecondaryBodyClass( "" );
		} );
		markOnboardingTourAsSeen();
		$scope.setSecondaryBodyClass( "tour-open" );
	}
} )( angular, InVision );;;
/*! pdf-export-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.PDFExportController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, modalWindowRequest, _ ) {
		$scope.exportPDF = function () {
			$( '#pdfExportLoadForm' ).submit(); // just doing a standard submit here
			$scope.closeModalWindow();
		};
		$scope.openChangePlanModal = function () {
			$scope.openModalWindow( "changePlan" );
		}
		$scope.downloadSample = function () {
			document.location.href = '/d/pdfexport/sample/';
		}
		var submissionInProgress = false;
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.projectInfo = projectService.getByID( $scope.projectID );
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! presentation-intro-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.presentation.IntroController", Controller );
	/** @ngInject */
	function Controller( _, $scope, accountService, sessionService ) {
		function setIntroModalPreference( pref ) {
			accountService.markPresentationTourIntroClosed( pref );
			$scope.user.hasClosedPresentationTourIntro = pref;
		}
		$scope.user = sessionService.user;
		$scope.userID = sessionService.user.id;
		$scope.hideIntroduction = $scope.user.hasClosedPresentationTourIntro;
		$scope.$watch( "hideIntroduction", function ( newVal, oldVal ) {
			if ( newVal !== oldVal ) {
				setIntroModalPreference( newVal );
			}
		} );
	}
} )( angular, InVision );;;
/*! presentation-share-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.presentation.ShareController", Controller );
	/** @ngInject */
	function Controller( $window, $location, projectDetailPartial, presentationConsolePartial, $scope, Deferred, modalWindowRequest, _, presentationService, userService, $timeout ) {
		$scope.views = {
			'url': 'url.htm',
			'email': 'email.htm',
			'embed': 'embed.htm'
		};

		function augmentUser( user ) {
			user.shortName = userService.getShortName( user.name );
			user.initials = userService.getInitials( user.name );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			return user;
		}

		function augmentUsers( users ) {
			_.each( users, augmentUser );
			return users;
		}

		function setupEmbedShareCode() {
			$scope.embedShareCode = "";
			$scope.embedShareCode = '<iframe width="' +
				$scope.projectDeviceTemplate.embedIframeWidth +
				'" height="' +
				$scope.projectDeviceTemplate.embedIframeHeight +
				'" src="' +
				$scope.shareUrl +
				$scope.presentation.key +
				'" frameborder="0" allowfullscreen></iframe>';
		}

		function hideAutoComplete() {
			$( '.ui-autocomplete' ).hide();
		}

		function loadData() {
			$scope.isLoading = true;
			Deferred.handleAllPromises(
				[
					projectDetailPartial.get( $scope.projectID ),
					presentationConsolePartial.get( $scope.projectID, $scope.presentation.id )
				],
				function ( consolePartialResponse, presentationPartialResponse ) {
					$scope.users = augmentUsers( consolePartialResponse.teamMembers );
					$scope.project = consolePartialResponse.project;
					$scope.projectOwnerSubscription = consolePartialResponse.projectOwnerSubscription;
					if ( $scope.project.isMobile ) {
						$scope.isEmbedEnabled = true;
					} else {
						$scope.isEmbedEnabled = false;
					}
					$scope.presentation = presentationPartialResponse.presentation;
					$scope.form = $scope.presentation;
					$scope.form.presentationID = $scope.form.id;
					$scope.isLoading = false;
					$scope.shareUrl = presentationPartialResponse.shareUrl;
					setupEmbedShareCode();
				},
				function ( error ) {
					$location.path( "/" );
				}
			);
		};
		$scope.switchSubView = function ( section ) {
			if ( $scope.mainTabView !== "new" ) {
				$scope.mainTabView = "new";
			};
			$scope.shareSubview = section;
		};
		$scope.switchMainTab = function ( section ) {
			$scope.mainTabView = section;
			$scope.shareSubview = section === "new" ? "url" : "";
		}
		$scope.sendEmail = function () {
			if ( !( /[^@]+@[^.]+\.\w+/i ).test( $scope.form.emails ) ) {
				$scope.errorMessage = "Please include at least one email address.";
				hideAutoComplete();
				return;
			}
			$scope.form.emails = $scope.form.emails.replace( new RegExp( "[\\s,;]+", "g" ), ", " );
			$scope.form.emails = $scope.form.emails.replace( new RegExp( ", \s*$", "g" ), "" );
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				presentationService.sendEmail( $scope.form.presentationID, $scope.form.emails, $scope.form.message ),
				function ( response ) {
					$scope.showSuccessMessage = true;
					$scope.errorMessage = null;
					hideAutoComplete();
				},
				function ( response ) {
					hideAutoComplete();
					$scope.errorMessage = "We were unable to send your email. Please double-check your email address(es).";
				}
			);
		};
		$scope.toggleEmailMessage = function () {
			$scope.showEmailMessage = !$scope.showEmailMessage;
		};
		$scope.updatePassword = function () {
			if ( !$scope.form.isUsingPassword && $scope.form.password ) {
				$scope.form.password = "";
				$scope.updateShare();
			}
		};
		$scope.updateShare = function () {
			if ( $scope.form.isRequireUserIdentification ) {
				$scope.form.isAnonymousViewingAllowed = false;
			} else {
				$scope.form.isAnonymousViewingAllowed = true;
			}
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				presentationService.updateShareConfig(
					$scope.form
				),
				function ( response ) {
					$scope.form = response;
					$scope.form.presentationID = $scope.form.id;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't create that share. This was unexpected!" );
				}
			);
		};
		$scope.startSuccessMessageWorkflow = function ( duration ) {
			if ( successMessageTimer ) {
				$timeout.cancel( successMessageTimer );
			}
			$scope.showSuccessMessage = true;
			successMessageTimer = $timeout(
				function () {
					$scope.showSuccessMessage = false;
				}, ( duration || 4000 )
			);
		};
		var successMessageTimer = null;
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.presentation = modalWindowRequest.getData( 1, 0 );
		$scope.mainTabView = modalWindowRequest.getData( 2, "new" ) || "new";
		$scope.shareSubview = $scope.mainTabView === "new" ? "url" : "";
		$scope.isExistingSharesView = $scope.mainTabView === "existing";
		$scope.modalTitle = "Share Tour";
		$scope.isEmbedEnabled = false;
		$scope.isLoading = false;
		$scope.screens = [];
		$scope.shareUrl = "";
		$scope.embedShareCode = "";
		$scope.form = {
			presentationID: $scope.presentation.id,
			projectID: $scope.projectID,
			isCommentingAllowed: $scope.presentation.isCommentingAllowed,
			isRequireUserIdentification: $scope.presentation.isRequireUserIdentification,
			isUsingPassword: $scope.presentation.isUsingPassword,
			password: $scope.presentation.password,
			key: $scope.presentation.key,
			scaleToScreen: $scope.presentation.scaleToScreen,
			displayShareLink: $scope.presentation.displayShareLink,
			emails: "",
			message: ""
		};
		$scope.showSuccessMessage = false;
		$scope.errorMessage = null;
		$scope.showEmailMessage = false;
		$scope.projectDeviceTemplate = {
			platform: ""
		};
		$scope.isShowingAdvancedOptions = false;
		$scope.$watch( "shareSubview", function ( newVal, oldVal ) {
			if ( newVal === oldVal ) {
				return;
			};
			$scope.showSuccessMessage = false;
			$scope.errorMessage = null;
		} );
		loadData();
	}
} )( angular, InVision );;;
/*! project-comments-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ProjectCommentsController", Controller );
	/** @ngInject */
	function Controller( $rootScope, $scope, modalWindowRequest, requestContext, conversationService, userService, dateHelper, Deferred, modelEvents, projectService, projectConversationsPartial, _, sessionService, moment ) {
		function applyData( conversation, user, filters, projectMembers, projectStakeholders, project ) {
			$scope.conversation = augmentConversation( conversation );
			$scope.conversationID = $scope.conversation.id;
			$scope.marker = $scope.conversation;
			$scope.user = user;
			$scope.userID = user.id;
			$scope.filters = filters;
			projectMembers = _.rejectWithProperty( projectMembers, "id", $scope.userID );
			$scope.projectMembers = _.each( projectMembers, augmentUser );
			$scope.projectStakeholders = _.each( projectStakeholders, augmentUser );
			$scope.project = project;
			$scope.projectID = project.id;
			$scope.screen = $scope.conversation.screen;
			$scope.screenLastUpdatedAt = moment( $scope.project.updatedAt ).fromNow();
			applyScreenDisplayScaleToScreen( conversation.screen );
		}

		function applyScreenDisplayScaleToScreen( screen ) {
			screen.displayScale = 1;
			if ( $scope.project.isMobile ) {
				screen.displayScale = ( $scope.project.mobileDeviceWidth / screen.width );
			}
			if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				screen.displayScale = 0.5;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				screen.displayScale = 0.3333;
			}
			return ( screen );
		}

		function augmentUser( user ) {
			user.initials = userService.getInitials( user.name );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			user.onlineStatus = userService.getOnlineStatus( user.lastRequestAt );
			return ( user );
		}

		function augmentComment( comment ) {
			comment.isShown = true;
			comment.dateLabel = dateHelper.formatRecentDate( comment.updatedAt, "MMM d" );
			comment.timeLabel = dateHelper.formatTime( comment.updatedAt, "h:mm TT" );
			comment.niceDate = moment( comment.updatedAt ).fromNow();
			comment.userInitials = userService.getInitials( comment.userName );
			comment.userHasSystemAvatar = userService.isSystemAvatar( comment.avatarID );
			comment.userOnlineStatus = userService.getOnlineStatus( comment.userLastRequestAt );
			comment.userFirstName = userService.getFirstName( comment.userName );
			comment.userNiceName = userService.getNiceUsername( comment.userName, comment.userID, sessionService.user.id );
			comment.html = conversationService.getHtmlForComment( comment.comment );
			return ( comment );
		}

		function augmentConversation( conversation ) {
			conversation.isShown = true;
			conversation.isCommentInputVisible = true;
			conversation.newComment = "";
			conversation.notifyOthers = "";
			conversation.showNotifyOthers = false;
			conversation.isNotifySettingsVisible = false;
			conversation.thumbLarge = "/screens/" + conversation.screen.id + "/0";
			conversation.isConversationPanelVisible = true;
			conversation.hiddenCommentCount = 0;
			_.each(
				conversation.comments,
				function ( comment, i ) {
					augmentComment( comment );
					if ( i === 0 || i > conversation.comments.length - 3 || comment.isUnread ) {
						comment.isShown = true;
					} else {
						comment.isShown = false;
						conversation.hiddenCommentCount++;
					}
				}
			);
			return ( conversation );
		}

		function pushPlaceholderComment( newComment ) {
			$scope.isShowingUserList = false;
			$scope.newComment = "";
			$scope.$broadcast( "invSuccessButton:success" );
			var placeholderComment = {
				userNiceName: "me",
				avatarID: $scope.user.avatarID || 0,
				userHasSystemAvatar: $scope.user.hasSystemAvatar,
				userInitials: $scope.user.initials,
				userOnlineStatus: "Online",
				niceDate: "a few seconds ago",
				html: newComment,
				numberOfLikes: 0,
				isEditing: false,
				isPlaceholder: true
			};
			$scope.conversation.comments.push( placeholderComment );
		}
		$scope.handleCommentUpdates = function ( comment, conversation ) {
			modelEvents.trigger( "commentModal.handleCommentUpdates", comment, conversation );
		};
		$scope.areConversationsDirty = function () {
			return ( hasActiveConversationWithDirtyData );
		};
		$scope.deleteComment = function ( comment, conversation, screen ) {
			conversationService.deleteComment( comment );
			conversation.comments = _.rejectWithProperty( conversation.comments, "id", comment.id );
			$scope.handleCommentUpdates( comment, conversation );
		};
		$scope.deleteConversation = function ( conversation ) {
			conversationService.deleteConversation( conversation );
			$scope.handleCommentUpdates( false, conversation );
			$scope.closeModalWindow();
		};
		$scope.loadStakeholders = function () {
			var promise = Deferred.handlePromise(
				projectService.getStakeholders( $scope.projectID ),
				function ( response ) {
					$scope.projectStakeholders = response;
				}
			);
			return ( promise );
		};
		$scope.showCommentInput = function () {
			$scope.isCommentInputVisible = true;
		};
		$scope.removeConversation = function ( screen, conversation ) {
			screen.conversations = _.without( screen.conversations, conversation );
		};
		$scope.expandComments = function ( conversation ) {
			var comments = conversation.comments;
			_.setProperty( comments, "isCollapsed", false );
		};
		$scope.markRead = function ( conversation ) {
			var comments = _.filter( conversation.comments, function ( comment ) {
				return comment.isUnread === true;
			} );
			var commentIDs = _.pluck( comments, "id" );
			_.setProperty( conversation.comments, "isUnread", false );
			if ( commentIDs.length ) {
				conversationService.markCommentsAsRead( commentIDs );
				conversation.isUnread = false;
			}
		};
		$scope.saveComment = function ( comment, conversation, screen ) {
			if ( !comment.comment ) {
				return;
			}
			if ( !comment.isEditing ) {
				pushPlaceholderComment( comment.comment );
			}
			comment.isEditing = false;
			comment.originalComment = comment.comment;
			comment.html = conversationService.getHtmlForComment( comment.comment );
			if ( comment.id ) {
				var notify = {
					members: [],
					stakeholders: [],
					others: [],
					unsubscribe: []
				};
			} else {
				var memberIDs = _.filterWithProperty( $scope.projectMembers, "isNotify", true );
				var stakeholderIDs = _.filterWithProperty( $scope.projectStakeholders, "isNotify", true );
				var notify = {
					members: _.pluck( memberIDs, "id" ),
					stakeholders: _.pluck( stakeholderIDs, "id" ),
					others: [],
					unsubscribe: []
				};
				var membersToUnsubscribe = _.filterWithProperty( $scope.projectMembers, "isNotify", false );
				var stakeholdersToUnsubscribe = _.filterWithProperty( $scope.projectStakeholders, "isNotify", false );
				notify.unsubscribe = _.pluck( membersToUnsubscribe, "id" );
				notify.unsubscribe = notify.unsubscribe.concat( _.pluck( stakeholdersToUnsubscribe, "id" ) );
				if ( conversation.notifyOthers ) {
					notify.others = conversation.notifyOthers.split( "," );
				}
			}
			comment.notify = notify;
			comment.conversationID = conversation.id;
			Deferred.handlePromise(
				conversationService.saveComment( comment ),
				function ( savedComment ) {
					if ( !comment.id ) {
						augmentComment( savedComment );
						conversation.subscribers = notify.members.concat( notify.stakeholders );
					}
					if ( notify.others.length ) {
						$scope.loadStakeholders().then(
							function ( stakeholders ) {
								var newUserIDs = [];
								_.each(
									stakeholders,
									function ( stakeholder ) {
										if (
											_.contains( notify.subscribers, stakeholder.id ) ||
											_.contains( notify.unsubscribe, stakeholder.id )
										) {
											return;
										}
										newUserIDs.push( stakeholder.id );
									}
								);
								if ( !newUserIDs.length ) {
									return;
								}
								conversation.subscribers = conversation.subscribers.concat( newUserIDs );
							}
						);
					}
					$scope.handleCommentUpdates( savedComment, conversation );
					$scope.$broadcast( "commentSaved" );
					$scope.$broadcast( "updateConversation" );
					modelEvents.trigger( "conversationUpdated" );
					$scope.notifyOthers = "";
					if ( conversation.isUnread ) {
						$scope.markRead( conversation );
					}
				}
			);
		};
		$scope.toggleLike = function ( comment ) {
			comment.hasUserLiked = !comment.hasUserLiked;
			if ( comment.hasUserLiked ) {
				comment.numberOfLikes++;
				comment.likedBy.push( {
					name: sessionService.user.name,
					email: sessionService.user.email
				} );
			} else {
				comment.numberOfLikes--;
				comment.likedBy = _.rejectWithProperty( comment.likedBy, "email", sessionService.user.email );
			}
			comment.likedByList = conversationService.formatCommentLikers( comment );
			conversationService.toggleCommentLike( comment.id, comment.conversationID );
		};
		$scope.showAllComments = function ( conversation ) {
			_.setProperty( conversation.comments, "isShown", true );
			conversation.hiddenCommentCount = 0;
		};
		$scope.saveConversation = function ( conversation ) {
			var promise = conversationService.saveConversation( conversation );
			Deferred.handlePromise(
				promise,
				null,
				function () {}
			);
		};
		$scope.getUsersToBeNotified = function () {
			var userNames = [];
			var pushUserOnStackIfNotified = function ( user ) {
				if ( user.isNotify ) {
					userNames.push( userService.getFirstName( user.name ) );
				}
			};
			_.each( $scope.projectMembers, pushUserOnStackIfNotified );
			_.each( $scope.projectStakeholders, pushUserOnStackIfNotified );
			if ( $scope.conversation.notifyOthers ) {
				var others = $scope.conversation.notifyOthers.split( "," );
				userNames = userNames.concat( others );
			}
			return userNames[ 0 ];
		};
		$scope.startSketchViewer = function ( sketch, isTemp, marker ) {
			$scope.sketchImageIsProcessing = true;
			$scope.closeModalWindow();
			$rootScope.$broadcast( "showSketchViewer", sketch, isTemp, $scope.screen, marker );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.comments", [ "projectID", "readFilter", "statusFilter", "typeFilter" ] );
		var hasActiveConversationWithDirtyData = false;
		$scope.conversation = {};
		$scope.user = {};
		applyData(
			modalWindowRequest.getData( 0 ),
			modalWindowRequest.getData( 1 ),
			modalWindowRequest.getData( 2 ),
			modalWindowRequest.getData( 3 ),
			modalWindowRequest.getData( 4 ),
			modalWindowRequest.getData( 5 )
		);
	}
} )( angular, InVision );;;
/*! project-members-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ProjectMembersController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, teamInvitationService, accountService, modelEvents, projectService, projectMembersModalPartial, modalWindowRequest, validationService, sessionService, $timeout, userService, _ ) {
		function applyRemoteData( project, teamMembers, invitations ) {
			var currentSubscription = sessionService.subscription;
			$scope.maxProjectMemberCount = ( currentSubscription.maxProjectMemberCount - 1 );
			$scope.subscriptionPlanName = currentSubscription.name.replace( "Enterprise - ", "" );
			$scope.project = project;
			$scope.teamMembers = augmentTeamMembers( teamMembers );
			$scope.invitations = augmentInvitations( invitations );
			$scope.isProjectOwner = ( sessionService.user.id === project.userID );
		}

		function augmentTeamMembers( teamMembers ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var user = teamMembers[ i ];
				user.isSelectedForProject = user.isProjectMember;
				user.initials = userService.getInitials( user.name );
				user.shortName = userService.getShortName( user.name );
				user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			}
			sortTeamMembers( teamMembers );
			return ( teamMembers );
		}

		function augmentInvitations( invitees ) {
			for ( var i = 0, length = invitees.length; i < length; i++ ) {
				var user = invitees[ i ];
				user.isSelectedForProject = user.isProjectMember;
				user.showInvitationLink = true;
			}
			return ( invitees );
		}

		function getUserIDsToAdd() {
			var newMembers = _.where(
				$scope.teamMembers, {
					isProjectMember: false,
					isSelectedForProject: true
				}
			);
			return (
				_.pluck( newMembers, "id" )
			);
		}

		function getUserIDsToRemove() {
			var oldMembers = _.where(
				$scope.teamMembers, {
					isProjectMember: true,
					isSelectedForProject: false
				}
			);
			return (
				_.pluck( oldMembers, "id" )
			);
		}

		function getInviteeIDsToAdd() {
			var newMembers = _.where(
				$scope.invitations, {
					isProjectMember: false,
					isSelectedForProject: true
				}
			);
			return (
				_.pluck( newMembers, "id" )
			);
		}

		function getInviteeIDsToRemove() {
			var oldMembers = _.where(
				$scope.invitations, {
					isProjectMember: true,
					isSelectedForProject: false
				}
			);
			return (
				_.pluck( oldMembers, "id" )
			);
		}

		function loadRemoteData() {
			$scope.isLoadingTeamMembers = true;
			Deferred.handlePromise(
				projectMembersModalPartial.get( $scope.projectID ),
				function ( response ) {
					$scope.isLoadingTeamMembers = false;
					applyRemoteData( response.project, response.teamMembers, response.invitations );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your people. Try refreshing your browser." );
				}
			);
		}

		function sortTeamMembers( teamMembers ) {
			teamMembers.sort(
				function ( a, b ) {
					if ( a.isSelectedForProject && b.isSelectedForProject ) {
						return ( a.name < b.name ? -1 : 1 );
					}
					if ( a.isSelectedForProject ) {
						return ( -1 );
					}
					if ( b.isSelectedForProject ) {
						return ( 1 );
					}
					return ( a.name < b.name ? -1 : 1 );
				}
			);
			return ( teamMembers );
		}

		function handlePromises( promises, success, error ) {
			Deferred.handleAllPromises( promises, success, error );
		}
		$scope.resendInvitation = function ( invitation ) {
			invitation.showInvitationLink = false;
			Deferred.handlePromise(
				teamInvitationService.resend( invitation.id ),
				function () {},
				function () {
					$scope.errorMessage = "There was an error sending your invitation.";
					return;
				}
			);
		};
		$scope.updateTeamMembers = function () {
			var promises = [];
			var addUserIDs = getUserIDsToAdd();
			var removeUserIDs = getUserIDsToRemove();
			var addInviteIDs = getInviteeIDsToAdd();
			var removeInviteIDs = getInviteeIDsToRemove();
			var updateWithExistingUsers = ( addUserIDs.length || removeUserIDs.length );
			var updateWithInvitedUsers = ( addInviteIDs.length || removeInviteIDs.length );
			var updateWithUsersByEmail = $scope.newusers.email.length;
			$scope.errorMessage = null;
			if ( !( updateWithExistingUsers || updateWithUsersByEmail || updateWithInvitedUsers ) ) {
				return ( $scope.closeModalWindow() );
			}
			/**
			 * First handle email invites...
			 * 	- send out the invites
			 * 	- get the ids of the newly sended invites and update the $scope.invitiations var
			 */
			/********************************************************/
			if ( updateWithUsersByEmail ) {
				var emailArray = $scope.newusers.email.split( ',' );
				for ( var e = 0; e < emailArray.length; e++ ) {
					emailArray[ e ] = $.trim( emailArray[ e ] );
					if ( !( /^[^@]+@[^.]+\..+$/i ).test( emailArray[ e ] ) ) {
						$scope.errorMessage = "Please enter a valid email address.";
						return; //only breaks the loop
					}
					$scope.newusers.email = emailArray.join( ',' );
				}
				if ( $scope.errorMessage ) {
					return;
				}
				promises.push(
					teamInvitationService.send( $scope.newusers.email, $scope.newusers.message, false, $scope.projectID )
				);
			}
			if ( updateWithExistingUsers ) {
				promises.push(
					projectService.changeUsersOnProject( $scope.projectID, addUserIDs, removeUserIDs, $scope.newusers.message )
				);
			}
			if ( updateWithInvitedUsers ) {
				promises.push(
					projectService.changeInviteesOnProject( $scope.projectID, addInviteIDs, removeInviteIDs )
				);
			}
			Deferred.handleAllPromises( promises,
				function ( response ) {
					if ( updateWithUsersByEmail ) {
						var newCollabIDs = [];
						for ( var r = 0; r < response.length; r++ ) {
							newCollabIDs.push( response[ r ].id );
						}
						modelEvents.trigger( "projectInviteesAdded", $scope.projectID, newCollabIDs );
					}
					$scope.closeModalWindow();
				},
				function ( response ) {
					if ( validationService.isOverQuota( response ) ) {
						$scope.isOverQuota = true;
					} else if ( validationService.isInvalidField( response ) ) {
						$scope.errorMessage = "Please enter a valid email address.";
					} else {
						$scope.openModalWindow( "error", "For some reason, we couldn't update the selected person on this project. Try refreshing your browser." );
					}
				}
			);
		};
		$scope.sendEnterpriseInfoRequest = function () {
			accountService.sendEnterpriseInfoRequest( "requestsMoreCollaborators" );
			$scope.extraCollabRequestSent = true;
		};
		$scope.openShareModal = function ( project ) {
			$scope.openModalWindow( "share", project.id );
		};
		$scope.toggleTeamMemberSelection = function ( teamMember ) {
			if ( $scope.project.userID === teamMember.id ) {
				return;
			}
			$scope.isOverQuota = false;
			teamMember.isSelectedForProject = !teamMember.isSelectedForProject;
			if ( teamMember.isProjectMember ) {
				if ( teamMember.isSelectedForProject ) {
					$scope.removedMemberCount--;
				} else {
					$scope.removedMemberCount++;
				}
			} else {
				if ( teamMember.isSelectedForProject ) {
					$scope.newMemberCount++;
				} else {
					$scope.newMemberCount--;
				}
			}
		};
		$scope.clearMemberSearch = function () {
			$scope.teamFilter = "";
			$scope.teamFilter.focus;
		}
		$scope.clearMemberSearch = function () {
			$scope.teamFilter = "";
			$( "#search" ).focus();
		}
		$scope.toggleMessage = function () {
			$( '.modal-viewport' ).animate( {
				height: '-=58'
			}, 300 );
			$( '.texta-wrapper' ).slideDown( 300 );
			$( '.include-message' ).slideUp( 300 );
			$( '#p-message' ).focus();
		}
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.isLoadingTeamMembers = false;
		$scope.project = null;
		$scope.teamMembers = [];
		$scope.isProjectOwner = false;
		$scope.teamFilter = null;
		$scope.newMemberCount = 0;
		$scope.removedMemberCount = 0;
		$scope.newusers = {};
		$scope.newusers.email = "";
		$scope.errorMessage = null;
		$scope.isOverQuota = false;
		$scope.extraCollabRequestSent = false;
		$scope.subscriptionPlanName = "";
		$scope.numberOfUsersInvited = 0;
		$scope.$on( "$destroy", function () {} );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! request-permission-confirmation-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.RequestPermissionConfirmationController", Controller );
	/** @ngInject */
	function Controller( $scope, sessionService, modalWindowRequest, modelEvents ) {
		$scope.user = sessionService.user;
		$scope.projectOwnerName = modalWindowRequest.getData( 0 );
	}
} )( angular, InVision );;;
/*! request-permission-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.RequestPermissionController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, modelEvents ) {
		$scope.projectID = modalWindowRequest.getData( 0 );
	}
} )( angular, InVision );;;
/*! retina-helper-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.RetinaHelperController", Controller );

	function Controller( $scope, userPreferenceService, Deferred, modalWindowRequest, modelEvents ) {
		function loadModalPreference() {
			var r = userPreferenceService.getPreferenceTypeByName( $scope.userPreferenceName, true, 'boolean' );
			r.then( function ( response ) {
				$scope.userPreferenceID = response.data.id;
			} )
		}

		function setModalPreference( pref ) {
			userPreferenceService.setUserPreferenceById( $scope.userPreferenceID, pref );
			modelEvents.trigger( "showRetinaModalHelperUpdated", pref );
		}
		$scope.$watch( "hideRetinaHelper", function ( newVal, oldVal ) {
			setModalPreference( newVal );
		} );
		$scope.userPreferenceName = "showRetinaHelperModal";
		$scope.userPreferenceID = 0;
		$scope.hideRetinaHelper = 0;
		loadModalPreference();
	}
} )( angular, InVision );;;
/*! save-project-offline-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.SaveProjectOfflineController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {}
} )( angular, InVision );;;
/*! screen-source-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ScreenSourceController", Controller );

	function Controller( $scope, userPreferenceService, Deferred, modalWindowRequest, modelEvents, _ ) {
		function loadIntroModalPreference() {
			var r = userPreferenceService.getPreferenceTypeByName( $scope.userPreferenceName, true, 'boolean' );
			r.then( function ( response ) {
				$scope.userPreferenceID = response.data.id;
			} )
		}

		function setIntroModalPreference( pref ) {
			userPreferenceService.setUserPreferenceById( $scope.userPreferenceID, pref );
			modelEvents.trigger( "showScreenSourceModalPreferenceUpdated", pref );
		}
		$scope.$watch( "hideIntroModal", function ( newVal, oldVal ) {
			var showScreenSourceIntro = ( newVal == 1 ) ? 0 : 1;
			setIntroModalPreference( showScreenSourceIntro );
		} );
		$scope.userPreferenceName = "showScreenSourceIntro";
		$scope.userPreferenceID = 0;
		$scope.hideIntroModal = 0;
		loadIntroModalPreference();
	}
} )( angular, InVision );;;
/*! screen-source-error-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ScreenSourceErrorController", Controller );

	function Controller( $scope, layersyncService, Deferred, modalWindowRequest, modelEvents, _ ) {
		$scope.tryAgain = function () {
			layersyncService.submit( $scope.assetID );
			var d = {
				projectID: $scope.projectID,
				status: "uploaded",
				info: {
					screens: [ {
						screenID: 0,
						imagename: "Retrying source..."
					} ]
				},
				asset: {
					id: $scope.assetID,
					clientFilename: $scope.fileName
				}
			};
			modelEvents.trigger( "screenSourceUploaded.projectScreens", d );
			$scope.closeModalWindow();
		};
		$scope.contactSupport = function () {
			$scope.openModalWindow( "contactUs" );
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.assetID = modalWindowRequest.getData( 1 );
		$scope.fileName = modalWindowRequest.getData( 2 );
	}
} )( angular, InVision );;;
/*! sync-download-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.sync.DownloadController", Controller );

	function Controller( $scope, modalWindowRequest, _, Deferred, sessionService, $window ) {
		$scope.openDropbox = function () {
			document.location = "/d/dropbox/connect";
		};
	}
} )( angular, InVision );;;
/*! team-enterprise-choice-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	var TEAM_PLAN_IDS = [ 28, 29 ];
	var ENTERPRISE_PLAN_IDS = [ 20, 22, 23, 24 ];
	app.controller( "modal.TeamEnterpriseChoiceController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, Deferred, modalWindowRequest, _, sessionService ) {
		var isEnterprisePlan = false;
		var isTeamPlan = false;
		$scope.isOnTeamPlan = false;
		$scope.isOnTeamPlan = isTeamPlan = _.contains( TEAM_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
		isEnterprisePlan = _.contains( ENTERPRISE_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
		if ( isEnterprisePlan ) {
			$timeout(
				function () {
					$scope.openModalWindow( 'createTeamModal' );
				},
				0
			);
		}
	}
} )( angular, InVision );;;
/*! team-invite-joined-confirmation-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TeamInviteJoinedConfirmationController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modelEvents, $location, modalWindowRequest, newTeamMemberModalPartial, sessionService, _, dateHelper, userService ) {
		function applyRemoteData( data ) {
			$scope.projects = _.withProperty( data.projects, "userID", sessionService.user.id )
			augmentProjects( $scope.projects );
			$scope.projectsSelected = 0;
		};

		function augmentProjects( projects ) {
			for ( var i = 0, t = projects.length; i < t; i++ ) {
				var project = projects[ i ];
				project.thumbnailUrl = project.homeScreenID ? ( "/thumbnails/" + project.homeScreenID + "/" + project.homeScreenImageVersion ) : "/assets/apps/d/img/add-screens-thumbnail.png";
				project.isChecked = false;
				project.createdAt = getDateLabel( project.createdAt );
			}
		};

		function getDateLabel( timestamp ) {
			var d = dateHelper.removeTime( timestamp );
			var label = {
				literal: "",
				moment: "",
				date: ""
			};
			if ( dateHelper.isToday( d ) ) {
				label.literal = "Today";
			} else if ( dateHelper.isYesterday( d ) ) {
				label.literal = "Yesterday";
			} else {
				label.literal = dateHelper.formatDate( timestamp, "ddd" );
			}
			label.moment = "about " + moment( timestamp ).fromNow();
			label.date = dateHelper.formatDate( timestamp, "mmmm d" );
			label.time = dateHelper.formatTime( timestamp, "h:mmtt" );
			return ( label );
		};

		function getSelectedProjectIDs() {
			var selectedProjects = _.withProperty( $scope.projects, "isChecked", true );
			var ids = _.pluck( selectedProjects, "id" );
			return ( ids.join( "," ) );
		};

		function loadRemoteData() {
			$scope.isLoadingProjects = true;
			Deferred.handlePromise(
				newTeamMemberModalPartial.get(),
				function ( response ) {
					$scope.isLoadingProjects = false;
					applyRemoteData( response );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your projects. Try refreshing your browser." );
				}
			);
		};
		$scope.getProjectsChecked = function () {
			$scope.projectsSelected = _.where( $scope.projects, {
				isChecked: true
			} ).length;
		}
		$scope.markProjectAsChecked = function ( project ) {
			project.isChecked = !project.isChecked;
			if ( project.isChecked ) {
				$scope.projectsSelected++;
			} else {
				$scope.projectsSelected--;
			}
		};
		$scope.transferProjects = function () {
			var selectedProjectIDs = getSelectedProjectIDs();
			if ( !selectedProjectIDs.length ) {
				$scope.closeModalWindow();
			} else {
				if ( submissionInProgress ) {
					return;
				}
				submissionInProgress = true;
				Deferred.handlePromise(
					newTeamMemberModalPartial.transferProjectOwnership( selectedProjectIDs, $scope.leadUser.email ),
					function ( response ) {
						$scope.closeModalWindow();
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we couldn't transfer your projects. Try refreshing your browser." );
					}
				);
			}
		};
		var modalData = ( modalWindowRequest.getData( 0 ) || {} );
		_.defaults( modalData, {
			leadName: "",
			leadAvatar: "",
			leadEmail: "",
			firstProjectName: "",
			projectCount: 0,
			leadCompany: "",
			leadCompanyLogoID: "",
			leadIsCompany: 0,
			canCreateProjectsForLead: 0
		} );
		var submissionInProgress = false;
		$scope.leadUser = {
			name: modalData.leadName,
			initials: userService.getInitials( modalData.leadName ),
			hasSystemAvatar: userService.isSystemAvatar( modalData.leadAvatar ),
			avatarID: modalData.leadAvatar,
			email: modalData.leadEmail,
			company: modalData.leadCompany,
			companyLogoID: modalData.leadCompanyLogoID,
			isCompany: modalData.leadIsCompany
		};
		$scope.errorMessage = null;
		$scope.isLoading = false;
		$scope.isLoadingProjects = false;
		$scope.projects = [];
		$scope.companyName = "";
		$scope.projectsSelected = 0;
		$scope.canCreateProjectsForLead = parseInt( modalData.canCreateProjectsForLead, 10 );
		if ( parseInt( modalData.canCreateProjectsForLead ) === 1 ) {
			$scope.isLoadingProjects = true;
			loadRemoteData();
		}
		$location.search( "showAcceptConfirmation", null );
		$location.search( "leadName", null );
		$location.search( "leadEmail", null );
		$location.search( "leadAvatar", null );
		$location.search( "firstProjectName", null );
		$location.search( "projectCount", null );
		$location.search( "leadCompany", null );
		$location.search( "leadCompanyLogoID", null );
		$location.search( "leadIsCompany", null );
		$location.search( "canCreateProjectsForLead", null );
		if ( $scope.leadUser.name.length == 0 ) {
			$scope.$broadcast( "closeModalWindowWithoutFade" );
		}
	}
} )( angular, InVision );;;
/*! tell-a-friend-email-preview.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TellAFriendEmailPreview", Controller );
	/** @ngInject */
	function Controller( $scope, sessionService, _ ) {
		$scope.name = sessionService.user.name;
		$scope.firstName = $scope.name.split( " " )[ 0 ];
	}
} )( angular, InVision );;;
/*! testing-selector-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TestingSelectorController", Controller );
	/** @ngInject */
	function Controller( $scope, modelEvents ) {
		$scope.openTest = function ( testId, type ) {
			if ( type !== "User Research" ) {
				if ( $scope.closeModalWindow !== undefined ) {
					$scope.closeModalWindow();
				}
				modelEvents.trigger( "testing:newTest", {
					testId: "" + testId,
					testType: type
				} );
			}
		};
		$scope.$on(
			"$destroy",
			function () {}
		);
	}
} )( angular, InVision );;;
/*! transfer-project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TransferProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, projectService, teamService, sessionService, transferProjectModalPartial, validationService, modalWindowRequest, _ ) {
		function applyRemoteData( project, currentProjectOwner, possibleOwners ) {
			$scope.project = project;
			$scope.possibleOwners = possibleOwners;
			$scope.currentProjectOwner = currentProjectOwner;
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				transferProjectModalPartial.get( $scope.projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.project,
						response.teamMembers
					);
				},
				function () {
					$scope.errorMessage = "There was a problem loading the project.";
				}
			);
		}

		function isProjectOwnersEmail( email ) {
			return (
				$scope.currentProjectOwner.email === email
			);
		}
		$scope.transferProject = function () {
			if ( !$scope.transferProjectToEmail ) {
				$scope.errorMessage = "Please enter the email address of the new project owner.";
				return;
			}
			if ( isProjectOwnersEmail( $scope.transferProjectToEmail ) ) {
				return ( $scope.closeModalWindow() );
			}
			if ( !submissionInProgress ) {
				submissionInProgress = true;
				Deferred.handlePromise(
					projectService.transferOwnership( $scope.projectID, $scope.transferProjectToEmail ),
					function ( project ) {
						$scope.closeModalWindow();
					},
					function ( response ) {
						submissionInProgress = false;
						if ( validationService.isOverQuota( response ) ) {
							$scope.errorMessage = "Due to the number of people on this project, the selected user must upgrade their account before they can take ownership of this project.";
						} else if ( validationService.isAlreadyExists( response ) ) {
							$scope.errorMessage = "The selected user already has a project with the given name. You must rename this project before you transfer it - project names must be unique for each user.";
						} else {
							$scope.errorMessage = response.message;
						}
					}
				);
			}
		};
		var submissionInProgress = false;
		$scope.isLoading = false;
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.project = null;
		$scope.currentProjectOwner = null;
		$scope.possibleOwners = [];
		$scope.transferProjectToEmail = "";
		$scope.errorMessage = null;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! transfer-projects-to-team-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TransferProjectsToTeamController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, modalWindowRequest, newTeamMemberModalPartial, sessionService, _, dateHelper ) {
		function applyRemoteData( data ) {
			$scope.companyName = data.user.company;
			$scope.projects = _.withProperty( data.projects, "userID", sessionService.user.id )
			augmentProjects( $scope.projects );
			$scope.projectsSelected = 0;
		};

		function augmentProjects( projects ) {
			for ( var i = 0, t = projects.length; i < t; i++ ) {
				var project = projects[ i ];
				project.thumbnailUrl = project.homeScreenID ? ( "/thumbnails/" + project.homeScreenID + "/" + project.homeScreenImageVersion ) : "/assets/apps/d/img/add-screens-thumbnail.png";
				project.isChecked = false;
				project.createdAt = getDateLabel( project.createdAt );
			}
		};

		function getDateLabel( timestamp ) {
			var d = dateHelper.removeTime( timestamp );
			var label = {
				literal: "",
				moment: "",
				date: ""
			};
			if ( dateHelper.isToday( d ) ) {
				label.literal = "Today";
			} else if ( dateHelper.isYesterday( d ) ) {
				label.literal = "Yesterday";
			} else {
				label.literal = dateHelper.formatDate( timestamp, "ddd" );
			}
			label.moment = "about " + moment( timestamp ).fromNow();
			label.date = dateHelper.formatDate( timestamp, "mmmm d" );
			label.time = dateHelper.formatTime( timestamp, "h:mmtt" );
			return ( label );
		};

		function getSelectedProjectIDs() {
			var selectedProjects = _.withProperty( $scope.projects, "isChecked", true );
			var ids = _.pluck( selectedProjects, "id" );
			return ( ids.join( "," ) );
		};

		function loadRemoteData() {
			$scope.isLoadingProjects = true;
			Deferred.handlePromise(
				newTeamMemberModalPartial.get(),
				function ( response ) {
					$scope.isLoadingProjects = false;
					applyRemoteData( response );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your projects. Try refreshing your browser." );
				}
			);
		};
		$scope.markProjectAsChecked = function ( project ) {
			project.isChecked = !project.isChecked;
			if ( project.isChecked ) {
				$scope.projectsSelected++;
			} else {
				$scope.projectsSelected--;
			}
		};
		$scope.transferProjects = function () {
			if ( $scope.projectsSelected === 0 ) {
				$scope.closeModalWindow();
			} else {
				if ( submissionInProgress ) {
					return;
				}
				submissionInProgress = true;
				var selectedProjectIDs = getSelectedProjectIDs();
			}
		};
		var submissionInProgress = false;
		$scope.errorMessage = null;
		$scope.isLoading = false;
		$scope.isLoadingProjects = true;
		$scope.projects = [];
		$scope.companyName = "";
		$scope.projectsSelected = 0;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! twitter-avatar-conroller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.TwitterAvatarController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, accountService, validationService, modalWindowRequest, _, sessionService ) {
		function getErrorMessageForResponse( response ) {
			if ( validationService.isNotFound( response ) ) {
				return ( "We could not find a Twitter account with the given username." );
			} else {
				return ( response.message );
			}
		}
		$scope.saveAvatar = function () {
			if ( !$scope.twitterUsername.length ) {
				$scope.errorMessage = "Please enter your twitter username.";
				return;
			}
			Deferred.handlePromise(
				accountService.importTwitterAvatar( $scope.twitterUsername ),
				function ( account ) {
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = getErrorMessageForResponse( response );
				}
			);
		};
		$scope.twitterUsername = sessionService.user.twitterUsername;
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! upload-in-progress-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.UploadInProgressController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _, $location ) {
		var targetRoute = modalWindowRequest.getData( 0 );
		$scope.cancelNavigation = function () {
			$scope.closeModalWindow();
		};
		$scope.acceptNavigation = function () {
			$scope.$emit( "screenUploadStop" );
			$location.path( targetRoute );
			$scope.closeModalWindow();
		};
	}
} )( angular, InVision );;;
/*! video-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.VideoController", Controller );
	/** @ngInject */
	function Controller( $scope, modalWindowRequest, _ ) {
		$scope.videoID = modalWindowRequest.getData( 0 );
		$scope.videoDimensions = modalWindowRequest.getData( 1 ) || [ 720, 400 ];
		$scope.videoWidth = $scope.videoDimensions[ 0 ];
		$scope.videoHeight = $scope.videoDimensions[ 1 ];
	}
} )( angular, InVision );;;
/*! workflow-status-notification-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.WorkflowStatusNotificationController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, screenService, workflowStatusNotificationModalPartial, modalWindowRequest, userService, _ ) {
		function applyRemoteData( users ) {
			$scope.users = augmentUsers( users );
		}

		function augmentUser( user ) {
			user.isSelectedForNotification = false;
			user.shortName = userService.getShortName( user.name );
			user.initials = userService.getInitials( user.name );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			return ( user );
		}

		function augmentUsers( users ) {
			_.each( users, augmentUser )
			sortUsers( users );
			return ( users );
		}

		function getSelectedUserIDs() {
			var selectedUsers = _.withProperty( $scope.users, "isSelectedForNotification", true );
			var ids = _.pluck( selectedUsers, "id" );
			return ( ids.join( "," ) );
		}

		function loadRemoteData() {
			$scope.isLoadingUsers = true;
			Deferred.handlePromise(
				workflowStatusNotificationModalPartial.get( $scope.projectID ),
				function ( response ) {
					$scope.isLoadingUsers = false;
					applyRemoteData( response.users );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your people on the project. Try refreshing your browser." );
				}
			);
		}

		function sortUsers( users ) {
			return ( _.sortOnProperty( users, "name", "asc" ) );
		}
		$scope.notifyCollaborators = function () {
			var userIDs = getSelectedUserIDs();
			if ( !userIDs ) {
				return (
					$scope.closeModalWindow()
				);
			}
			Deferred.handlePromise(
				screenService.sendWorkflowStatusNotification( $scope.screenID, userIDs ),
				function () {
					$scope.closeModalWindow();
				},
				function () {
					$scope.errorMessage = "For some reason, we couldn't notify the selected collaborators. Try refreshing your browser.";
				}
			);
		};
		$scope.toggleUserSelection = function ( user ) {
			user.isSelectedForNotification = !user.isSelectedForNotification;
			if ( user.isSelectedForNotification ) {
				$scope.selectedCount++;
			} else {
				$scope.selectedCount--;
			}
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.screenID = modalWindowRequest.getData( 1 );
		$scope.isLoadingUsers = false;
		$scope.users = [];
		$scope.selectedCount = 0;
		$scope.errorMessage = null;
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! zip-export-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.ZipExportController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectService, modalWindowRequest, _ ) {
		$scope.openChangePlanModal = function () {
			$scope.openModalWindow( "changePlan" );
		}
		$scope.errorMessage = null;
	}
} )( angular, InVision );;;
/*! existing-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.share.ExistingController", Controller );
	/** @ngInject */
	function Controller( $scope, Deferred, shareService, existingSharesModalPartial, _ ) {
		function applyRemoteData( shares, shareUrl ) {
			$scope.shares = _.withProperty( shares, "isEmbed", false );;
			$scope.shareUrl = shareUrl;
			$scope.shortShareUrl = shareUrl.replace( new RegExp( "^https?://", "i" ), "" );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				existingSharesModalPartial.get( $scope.projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.shares,
						response.shareUrl
					);
					var height = ( response.shares.length * 65 ) + 75;
					height = height > 410 ? 410 : height;
					$( '.existing_share .viewport' ).css( "height", height );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your shares." );
				}
			);
		}
		$scope.revokeAllShares = function () {
			$scope.shares = [];
			Deferred.handlePromise(
				shareService.revokeAllShares( $scope.projectID ),
				function ( response ) {},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't revoke your shares." );
				}
			);
		};
		$scope.revokeShare = function ( share ) {
			$scope.shares = _.rejectWithProperty( $scope.shares, "id", share.id );
			Deferred.handlePromise(
				shareService.revokeShare( share.id ),
				function ( response ) {},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't revoke that share." );
				}
			);
		};
		$scope.isLoading = false;
		$scope.shares = [];
		$scope.shareUrl = "";
		$scope.shortShareUrl = "";
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! new-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.share.NewController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, Deferred, shareService, newShareModalPartial, validationService, userService, sessionService, ipInfoService, dateHelper, _ ) {
		$scope.views = {
			'new': {
				view: 'new.htm'
			},
			'embed': {
				view: 'embed.htm'
			},
			'download': {
				cssClass: [ 'download' ],
				view: 'download.htm'
			},
			'existing': {
				cssClass: [ 'existing' ],
				view: 'existing.htm'
			}
		};
		$scope.viewsShareNew = {
			'url': 'url.htm',
			'email': 'email.htm',
			'sms': 'sms.htm'
		};

		function applyRemoteData( share, embedShare, shareUrl, screens, users, projectDeviceTemplate, recentShares, project ) {
			if ( !$scope.isSharingSelectedScreens ) {
				screens.unshift( {
					id: 0,
					name: "First screen in this project",
					isHome: false,
					sort: 0
				} );
			}
			screens = _.sortOnProperty( screens, "sort" );
			screens = _.setProperty( screens, "isHome", false );
			if ( !$scope.isSharingSelectedScreens ) {
				screens[ 0 ].name = ( screens[ 0 ].name + " ( Home )" );
			}
			$scope.screens = screens;
			$scope.shareUrl = shareUrl;
			$scope.users = augmentUsers( users );
			$scope.projectDeviceTemplate = projectDeviceTemplate[ 0 ];
			$scope.form.shareID = share.id;
			$scope.form.startScreen = _.findWithProperty( screens, "id", share.screenID );
			$scope.form.isCommentingAllowed = share.isCommentingAllowed;
			$scope.form.isNavigateAllowed = share.isNavigateAllowed;
			$scope.form.isResizeWindow = share.isResizeWindow;
			$scope.form.isLoadAllScreens = share.isLoadAllScreens;
			$scope.form.isUserTesting = share.isUserTesting;
			$scope.form.isAnonymousViewingAllowed = share.isAnonymousViewingAllowed;
			$scope.form.isForceAddToHomescreenOnMobile = share.isForceAddToHomescreenOnMobile;
			$scope.form.password = share.password;
			$scope.form.key = share.key;
			if ( $scope.form.isAnonymousViewingAllowed ) {
				$scope.form.isRequireUserIdentification = false;
			} else {
				$scope.form.isRequireUserIdentification = true;
			}
			$scope.embedShare = embedShare;
			setupEmbedShareCode();
			$scope.recentShares = augmentRecentShares( recentShares );
			$scope.project = project;
		}

		function setupEmbedShareCode() {
			var noProtocolShareURL = $scope.shareUrl.replace( "http:", "" ).replace( "https:", "" );
			$scope.embedShareCode = "";
			$scope.embedShareCode = '<iframe width="' +
				$scope.projectDeviceTemplate.embedIframeWidth +
				'" height="' +
				$scope.projectDeviceTemplate.embedIframeHeight +
				'" src="' +
				noProtocolShareURL +
				$scope.embedShare.key +
				'" frameborder="0" allowfullscreen></iframe>';
		}

		function augmentRecentShare( share ) {
			if ( dateHelper.isRecent( share.createdAt, 10, "n" ) ) {
				share.createdAtLabel = "just now";
			} else {
				share.createdAtLabel = dateHelper.formatDate( share.createdAt, "mmmm d, yyyy" );
			}
			if ( share.recentAccess ) {
				share.recentAccess.createdAtLabel = dateHelper.formatDate( share.recentAccess.createdAt, "mmmm d, yyyy" );
			}
		}

		function augmentRecentShares( shares ) {
			_.each( shares, augmentRecentShare );
			return ( shares );
		}

		function augmentUser( user ) {
			user.shortName = userService.getShortName( user.name );
			user.initials = userService.getInitials( user.name );
			user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
			return user;
		}

		function augmentUsers( users ) {
			_.each( users, augmentUser );
			return users;
		}

		function getSmsErrorMessage( response ) {
			if ( validationService.isForbidden( response ) ) {
				return ( "You have reached your SMS limit for the hour. Please try again shortly." );
			} else {
				return ( "We were unable to send an SMS message to that phone number." );
			}
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				ipInfoService.getGeolocationData(),
				function ( response ) {
					$scope.form.phoneCountryCode = response.country.toLowerCase();
				},
				function ( response ) {
					$scope.form.phoneCountryCode = "us";
				}
			);
			$scope.loadData()
				.then( function ( response ) {
					applyRemoteData(
						response.share,
						response.embedShare,
						response.shareUrl,
						response.screens,
						response.users,
						response.projectDeviceTemplate,
						response.recentShares,
						response.project
					);
					$scope.isLoading = false;
				} );
		}

		function hideAutoComplete() {
			$( '.ui-autocomplete' ).hide();
		}
		$scope.applyRecentShare = function ( recentShare ) {
			$scope.hideRecentShares();
			$scope.form.shareID = recentShare.id;
			$scope.form.startScreen = _.findWithProperty( $scope.screens, "id", recentShare.screenID );
			$scope.form.isCommentingAllowed = recentShare.isCommentingAllowed;
			$scope.form.isNavigateAllowed = recentShare.isNavigateAllowed;
			$scope.form.isResizeWindow = recentShare.isResizeWindow;
			$scope.form.isLoadAllScreens = recentShare.isLoadAllScreens;
			$scope.form.isUserTesting = recentShare.isUserTesting;
			$scope.form.isAnonymousViewingAllowed = recentShare.isAnonymousViewingAllowed;
			$scope.form.isForceAddToHomescreenOnMobile = recentShare.isForceAddToHomescreenOnMobile;
			$scope.form.password = recentShare.password;
			$scope.form.isUsingPassword = !!recentShare.password;
			$scope.form.key = recentShare.key;
			$scope.form.isRequireUserIdentification = !recentShare.isAnonymousViewingAllowed;
		};
		$scope.copyRecentShare = function ( recentShare ) {
			$scope.applyRecentShare( recentShare );
			$scope.startSuccessMessageWorkflow();
		};
		$scope.hideRecentShares = function () {
			$scope.isShowingRecentShares = false;
		};
		$scope.sendEmail = function () {
			if ( !( /[^@]+@[^.]+\.\w+/i ).test( $scope.form.emails ) ) {
				$scope.errorMessage = "Please include at least one email address.";
				hideAutoComplete();
				return;
			}
			$scope.form.emails = $scope.form.emails.replace( new RegExp( "[\\s,;]+", "g" ), ", " );
			$scope.form.emails = $scope.form.emails.replace( new RegExp( ", \s*$", "g" ), "" );
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				shareService.sendEmail( $scope.form.shareID, $scope.form.emails, $scope.form.message ),
				function ( response ) {
					$scope.showSuccessMessage = true;
					$scope.errorMessage = null;
					$timeout( function () {
						$scope.showSuccessMessage = false;
					}, 4000 );
					hideAutoComplete();
				},
				function ( response ) {
					hideAutoComplete();
					$scope.errorMessage = "We were unable to send your email. Please double-check your email address(es).";
				}
			);
		};
		$scope.sendSMS = function () {
			var phoneNumber = $scope.form.phoneNumber.replace( /[^\d+]+/g, "" );
			if ( phoneNumber.length < 10 ) {
				$scope.errorMessage = "Please enter a valid phone number.";
				return;
			} else if ( phoneNumber.length === 10 ) {
				$scope.errorMessage = "Please include the country code.";
				return;
			}
			$scope.showSuccessMessage = false;
			$scope.showSMSSuccessMessage = false;
			Deferred.handlePromise(
				shareService.sendSMS( $scope.form.shareID, phoneNumber ),
				function ( response ) {
					$scope.showSuccessMessage = true;
					$scope.showSMSSuccessMessage = true;
					$scope.errorMessage = null;
					$timeout( function () {
						$scope.showSuccessMessage = false;
						$scope.showSMSSuccessMessage = false;
					}, 4000 );
				},
				function ( response ) {
					$scope.errorMessage = getSmsErrorMessage( response );
				}
			);
		};
		$scope.showRecentShares = function () {
			$scope.isShowingRecentShares = true;
		};
		$scope.startSuccessMessageWorkflow = function ( duration ) {
			if ( successMessageTimer ) {
				$timeout.cancel( successMessageTimer );
			}
			$scope.showSuccessMessage = true;
			successMessageTimer = $timeout(
				function () {
					$scope.showSuccessMessage = false;
				}, ( duration || 4000 )
			);
		};
		$scope.toggleEmailMessage = function () {
			$scope.showEmailMessage = !$scope.showEmailMessage;
		};
		$scope.toggleRecentShares = function () {
			if ( $scope.isShowingRecentShares ) {
				$scope.hideRecentShares();
			} else {
				$scope.showRecentShares();
			}
		};
		$scope.updatePassword = function () {
			if ( !$scope.form.isUsingPassword && $scope.form.password ) {
				$scope.form.password = "";
				$scope.updateShare();
			}
		};
		$scope.updateShare = function () {
			if ( $scope.form.isRequireUserIdentification ) {
				$scope.form.isAnonymousViewingAllowed = false;
			} else {
				$scope.form.isAnonymousViewingAllowed = true;
			}
			var selectedScreenIDs = _.pluck( $scope.selectedScreens, 'id' );
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				shareService.createShare(
					$scope.projectID,
					$scope.form.startScreen.id,
					$scope.form.isCommentingAllowed,
					$scope.form.isNavigateAllowed,
					$scope.form.isResizeWindow,
					$scope.form.isLoadAllScreens,
					$scope.form.isUserTesting,
					$scope.form.isAnonymousViewingAllowed,
					$scope.form.isForceAddToHomescreenOnMobile,
					$scope.form.password,
					false, //forcenew
					false,
					selectedScreenIDs
				),
				function ( response ) {
					$scope.form.shareID = response.id;
					$scope.form.startScreen = _.findWithProperty( $scope.screens, "id", response.screenID );
					$scope.form.isCommentingAllowed = response.isCommentingAllowed;
					$scope.form.isNavigateAllowed = response.isNavigateAllowed;
					$scope.form.isResizeWindow = response.isResizeWindow;
					$scope.form.isLoadAllScreens = response.isLoadAllScreens;
					$scope.form.isUserTesting = response.isUserTesting;
					$scope.form.isAnonymousViewingAllowed = response.isAnonymousViewingAllowed;
					$scope.form.isForceAddToHomescreenOnMobile = response.isForceAddToHomescreenOnMobile;
					$scope.form.password = response.password;
					$scope.form.key = response.key;
					$scope.selectedScreens = response.selectedScreens;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't create that share. This was unexpected!" );
				}
			);
		};
		$scope.toggleAdvancedOptions = function () {
			$scope.isShowingAdvancedOptions = !$scope.isShowingAdvancedOptions;
		};
		$scope.toggleStandardOptions = function ( shareSubview ) {
			$scope.isShowingStandardOptions = ( shareSubview !== 'sms' );
		};
		$scope.getMailToLink = function () {
			var subject = sessionService.user.name + " Has Sent You an InVision Share Link";
			var body = "Hi,\n\nVisit the following link to install the " + $scope.project.name + " prototype on your mobile device - " + $scope.shareUrl;
			var mailto = "mailto:?subject=" + subject + "&body=" + body;
			return encodeURI( mailto );
		};
		var successMessageTimer = null;
		$scope.isLoading = true;
		$scope.screens = [];
		$scope.shareUrl = "";
		$scope.form = {
			shareID: 0,
			startScreen: null,
			isCommentingAllowed: false,
			isNavigateAllowed: false,
			isResizeWindow: false,
			isLoadAllScreens: false,
			isUserTesting: false,
			isAnonymousViewingAllowed: false,
			isForceAddToHomescreenOnMobile: true,
			isUsingPassword: false,
			password: "",
			key: "",
			phoneNumber: "",
			phoneCountryCode: "",
			emails: "",
			message: ""
		};
		$scope.showSuccessMessage = false;
		$scope.showSMSSuccessMessage = false;
		$scope.errorMessage = null;
		$scope.showEmailMessage = false;
		$scope.projectDeviceTemplate = {
			platform: ""
		};
		$scope.isShowingAdvancedOptions = false;
		$scope.isShowingStandardOptions = true;
		$scope.recentShares = [];
		$scope.isShowingRecentShares = false;
		$scope.$watch( "shareSubview", function ( newVal, oldVal ) {
			if ( newVal === oldVal ) {
				return;
			}
			$scope.showSuccessMessage = false;
			$scope.errorMessage = null;
			$scope.isShowingRecentShares = false;
			if ( newVal === 'sms' ) {
				$scope.isShowingStandardOptions = false;
			} else {
				$scope.isShowingStandardOptions = true;
			}
			if ( successMessageTimer ) {
				$timeout.cancel( successMessageTimer );
			}
		} );
		$scope.$on(
			"$destroy",
			function () {
				if ( successMessageTimer ) {
					$timeout.cancel( successMessageTimer );
				}
			}
		);
		if ( $scope.mainTabView !== "existing" ) {
			loadRemoteData();
		} else {
			$scope.isLoading = false;
		}
	}
} )( angular, InVision );;;
/*! share-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.share.ShareController", Controller );
	/** @ngInject */
	function Controller( $window, newShareModalPartial, $scope, Deferred, modalWindowRequest, $q ) {
		var _deferred;
		$scope.loadData = function () {
			if ( _deferred ) {
				return _deferred.promise;
			}
			_deferred = $q.defer();
			Deferred.handlePromise(
				newShareModalPartial.get(
					$scope.projectID,
					$scope.screenID,
					_.pluck( $scope.selectedScreens, "id" )
				),
				function ( response ) {
					$scope.project = response.project;
					$scope.projectOwnerSubscription = response.projectOwnerSubscription;
					$scope.isEmbedEnabled = response.project.isMobile;
					_deferred.resolve( response );
				},
				function ( error ) {
					$scope.openModalWindow( "error", "You cannot share this project until you upload at least one screen." );
					_deferred.reject( error );
				}
			);
			return _deferred.promise;
		};
		$scope.showExistingShares = function () {
			$scope.mainTabView = "existing";
			$scope.selectedScreens = [];
			$scope.shareSubview = "";
			$scope.isExistingSharesView = true;
			$scope.modalTitle = "Existing Shares";
		};
		$scope.switchSubView = function ( section ) {
			if ( $scope.mainTabView !== "new" ) {
				$scope.mainTabView = "new";
			}
			$scope.shareSubview = section;
		};
		$scope.switchMainTab = function ( section ) {
			$scope.mainTabView = section;
			$scope.shareSubview = section === "new" ? "url" : "";
		};
		$scope.exportZip = function () {
			$window.open( '/d/zipexport/load/projectid/' + $scope.projectID, '_blank' );
		};
		$scope.projectID = modalWindowRequest.getData( 0 );
		$scope.screenID = modalWindowRequest.getData( 1, 0 );
		$scope.selectedScreens = ( modalWindowRequest.getData( 3 ) ? modalWindowRequest.getData( 3 ) : [] );
		$scope.isSharingSelectedScreens = $scope.selectedScreens.length > 0;
		if ( $scope.selectedScreens.length === 1 ) {
			$scope.screenID = $scope.selectedScreens[ 0 ].id;
			$scope.selectedScreens = [];
		}
		$scope.mainTabView = modalWindowRequest.getData( 2, "new" ) || "new";
		$scope.shareSubview = $scope.mainTabView === "new" ? "url" : "";
		$scope.isExistingSharesView = $scope.mainTabView === "existing";
		if ( $scope.isExistingSharesView ) {
			$scope.modalTitle = "Existing Shares";
		} else if ( $scope.selectedScreens.length ) {
			$scope.modalTitle = "Share Selected Screens";
		} else {
			$scope.modalTitle = "Share Project";
		}
		$scope.isEmbedEnabled = false;
		$scope.loadData();
	}
} )( angular, InVision );;;
/*! new-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.testing.share.NewController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectTestingPartial, testingService, sessionService, _ ) {
		$scope.sendEmail = function () {
			if ( !( /[^@]+@[^.]+\.\w+/i ).test( $scope.form.emails ) ) {
				$scope.errorMessage = "Please include at least one email address.";
				return;
			}
			$scope.form.emails = $scope.form.emails.replace( new RegExp( "[\\s,;]+", "g" ), ", " );
			$scope.form.emails = $scope.form.emails.replace( new RegExp( ", \s*$", "g" ), "" );
			$scope.showSuccessMessage = false;
			Deferred.handlePromise(
				projectTestingPartial.sendTest( $scope.form.testId, $scope.form.emails ),
				function ( response ) {
					$scope.showSuccessMessage = true;
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = "We were unable to send your email. Please double-check your email address(es).";
				}
			);
		};
		$scope.getEncodedShareLink = function () {
			return encodeURIComponent( $scope.shareUrl + $scope.test.sharekey );
		};
		$scope.saveUserNotification = function () {
			Deferred.handlePromise(
				projectTestingPartial.addNotificationRequest( $scope.user.id ),
				function ( response ) {
					$scope.showNotifySuccessMessage = true;
					$scope.errorMessage = null;
					$scope.closeModalWindow();
				},
				function ( response ) {
					$scope.errorMessage = "We were unable to add your Notification Request.";
				}
			);
		};
		$scope.shareInVisionAudience = function () {
			$scope.hiredSuccessMessage = false;
			Deferred.handlePromise(
				projectTestingPartial.audienceShare( $scope.form.testId ),
				function ( response ) {
					$scope.hiredSuccessMessage = true;
					$scope.errorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = "We were unable to send your InVision Audience request.";
				}
			);
		};
		$scope.isLoading = false;
		$scope.form = {
			testId: $scope.test.testId,
			key: $scope.test.sharekey,
			emails: ""
		};
		$scope.showSuccessMessage = false;
		$scope.showNotifySuccessMessage = false;
		$scope.hiredSuccessMessage = false;
		$scope.errorMessage = null;
		$scope.showEmailMessage = false;
		$scope.user = sessionService.user;
		$scope.$watch( "shareSubview", function ( newVal, oldVal ) {
			if ( newVal === oldVal ) {
				return;
			};
			$scope.showSuccessMessage = false;
			$scope.errorMessage = null;
		} );
	}
} )( angular, InVision );;;
/*! share-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "modal.testing.share.ShareController", Controller );
	/** @ngInject */
	function Controller( $window, $location, projectTestingPartial, testingService, $scope, Deferred, modalWindowRequest, _ ) {
		$scope.views = {
			'url': {
				view: 'url.htm',
				cssClass: [ 'urlCont' ]
			},
			'email': {
				view: 'email.htm',
				cssClass: [ 'emailCont' ]
			},
			'hired': {
				view: 'hired.htm',
				cssClass: [ 'hiredCont' ]
			}
		};
		$scope.switchSubView = function ( section ) {
			$scope.shareSubview = section;
		};
		$scope.test = modalWindowRequest.getData( 0 );
		$scope.shareUrl = modalWindowRequest.getData( 1, "" );
		$scope.modalTitle = "Invite Participants";
		$scope.shareSubview = "url";
	}
} )( angular, InVision );;;
/*! new-features-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "newFeatures.newFeaturesController", Controller );
	/** @ngInject */
	function Controller( $scope, $anchorScroll, $timeout, requestContext, Deferred, _, accountService, releaseNotificationService, moment ) {
		function loadRemoteData() {
			Deferred.handlePromise(
				releaseNotificationService.getReleaseNotifications(),
				function ( announcements ) {
					var showThese = [];
					showThese = _.map( announcements, function ( announcement ) {
						return {
							id: announcement.id,
							title: announcement.title,
							createdAtDay: moment.utc( announcement.createdAt ).format( "DD" ),
							createdAtMonth: moment.utc( announcement.createdAt ).format( "MMM" ),
							content: announcement.content,
							tweetString: "https://twitter.com/intent/tweet?url=http://invisionapp.com/new-features/%23feature-" + announcement.id + "&text=I love these new features! @invisionapp",
							shareURL: "http://www.invisionapp.com/new-features/#feature-" + announcement.id
						};
					} );
					$scope.featureAnnouncements = showThese;
					$timeout(
						function () {
							$anchorScroll();
						},
						500
					);
				}
			);
		}

		function updateFeatureAnnouncementsLastViewedAt() {
			Deferred.handlePromise(
				accountService.updateFeatureAnnouncementsLastViewedAt(
					moment.utc().format( "YYYY-MM-DD HH:mm:ss" )
				),
				function ( response ) {},
				function ( response ) {}
			);
		}
		$scope.$on( "$destroy", function () {
			$scope.hideNewFeatureLink();
		} );
		$scope.$on( "newFeatureAnnounced", function () {
			loadRemoteData();
		} );
		var renderContext = requestContext.getRenderContext( "standard.new-features.default" );
		$scope.isLoading = false;
		$scope.featureAnnouncements = [];
		$scope.setSecondaryBodyClass( "new-features" );
		$scope.setWindowTitle( "New Features!" );
		updateFeatureAnnouncementsLastViewedAt();
		loadRemoteData();
		$scope.$on( '$destroy', function () {
			$scope.setSecondaryBodyClass( "" );
		} );
	}
} )( angular, InVision );;;
/*! page-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "notifications.PageController", Controller );
	/** @ngInject */
	function Controller( _, $scope, $timeout, $location, requestContext, sessionService, userService, dateHelper, conversationService, moment, firebaseStateService ) {
		function applyRemoteData() {
			$scope.user = sessionService.user;
			$scope.notifications = augmentNotifications( $scope.settings.notifications );
			$scope.setWindowTitle( "All Notifications" );
			$scope.isLoading = false;
		}

		function augmentNotifications( notifications ) {
			for ( var i in notifications ) {
				var notification = notifications[ i ];
				if ( !$scope.unreadNotificationIndex[ notification.key ] ) {
					$scope.unreadNotificationIndex[ notification.key ] = notification.unread;
				}
			}
			return notifications;
		}
		$scope.getNotificationDate = function ( date ) {
			return moment( date ).format( "h:mm A" );
		};
		$scope.markRead = function ( notification ) {
			$scope.unreadNotificationIndex[ notification.key ] = false;
			firebaseStateService.markNotificationAsRead( notification.key );
		};
		$scope.showConversationDetail = function ( notification ) {
			var members = [];
			var stakeholders = [];
			if ( notification.projectMembers ) {
				members = notification.projectMembers;
			}
			if ( notification.projectStakeholders ) {
				stakeholders = notification.projectStakeholders;
			}
			$scope.openModalWindow( "projectComments", notification.conversation, $scope.user, [], members, stakeholders, notification.project );
			$timeout(
				function () {
					$scope.markRead( notification );
				},
				5000
			);
		};
		var renderContext = requestContext.getRenderContext( "standard.notifications", [] );
		$scope.notifications = [];
		$scope.unreadNotificationIndex = {};
		$scope.isLoading = true;
		$scope.$watch( "settings.notifications", function ( notifications ) {
			if ( notifications !== null && notifications.length ) {
				applyRemoteData();
			} else {
				$scope.isLoading = false;
				$scope.setWindowTitle( "All Notifications" );
			}
		} );
		$scope.$on(
			"$destroy",
			function () {}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
			}
		);
		$scope.setWindowTitle( "Loading Notifications" );
	}
} )( angular, InVision );;;
/*! popup-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "notifications.PopupController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, $location, accountService, moment ) {
		$scope.getNotificationDate = function ( date ) {
			return moment( date ).utc().fromNow();
		};
		$scope.showConversationDetail = function ( projectID, conversationID ) {
			$location.path( "/projects/" + projectID + "/comments/showConversation/" + conversationID );
			$scope.toggleNotificationDropdown();
		};
	}
} )( angular, InVision );;;
/*! apps-controller-DISABLED.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.AppsController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, _, appsService ) {
		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				appsService.getApps(),
				function ( response ) {
					$scope.isLoading = false;
					$scope.currentApps = response;
				},
				function () {}
			);
		}
		$scope.addToNotificationList = function ( app ) {
			Deferred.handlePromise(
				appsService.addNotification( app.id ),
				function ( response ) {
					app.added = true;
				},
				function ( response ) {}
			);
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.apps", "projectID" );
		$scope.currentApps = [];
		$scope.isLoading = false;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
			}
		);
		$scope.setWindowTitle( "Project Apps" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! asset-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.AssetController", Controller );
	/** @ngInject */
	function Controller( $scope, _, requestContext, Deferred, assetFolderService, $location ) {
		$scope.views = {
			'version': 'info-versions.htm',
			'screens': 'info-layersync-screens.htm',
			'assets': 'info-layersync-assets.htm'
		};
		$scope.hideDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = false;
		};
		$scope.showDeleteConfirmation = function ( asset ) {
			$scope.hideAllOverlays();
			$scope.isShowingDeleteConfirmation = true;
			$scope.openModalWindow( "assetsDelete", asset );
		};
		$scope.showShareOverlay = function () {
			$scope.hideAllOverlays();
			$scope.isShowingShareOverlay = true;
			$scope.isShowingTools = true;
		};
		$scope.hideShareOverlay = function ( event ) {
			if ( _.isUndefined( event ) || event.target.className == "confirmation shareOverlay" ) {
				$scope.isShowingShareOverlay = false;
				$scope.isShowingTools = false;
			}
		};
		$scope.showMetaOverlay = function () {
			$scope.hideAllOverlays();
			$scope.isShowingMetaOverlay = true;
			$scope.isShowingTools = true;
		};
		$scope.hideMetaOverlay = function () {
			$scope.isShowingMetaOverlay = false;
			$scope.isShowingTools = false;
		};
		$scope.hideAllOverlays = function () {
			$scope.hideShareOverlay();
			$scope.hideDeleteConfirmation();
			$scope.hideMetaOverlay();
		};
		$scope.showMoreOptions = function () {
			$scope.isShowingMoreOptions = true;
		};
		$scope.hideMoreOptions = function () {
			$scope.isShowingMoreOptions = false;
		};
		$scope.toggleRenameField = function () {
			$scope.isShowingRenameField = !$scope.isShowingRenameField;
		};
		$scope.renameFolder = function ( folder ) {
			if ( $scope.newFolderName && $scope.newFolderName != folder.foldername ) {
				Deferred.handlePromise(
					assetFolderService.renameFolder( folder.projectID, folder.id, $scope.newFolderName ),
					function () {},
					function () {
						$scope.openModalWindow( "error", "For some reason, we couldn't rename the asset folder." );
					}
				);
			}
			$scope.toggleRenameField();
		};
		$scope.showLayerSyncInfo = function ( asset ) {
			$scope.artifacts = [];
			$scope.counts = {
				screens: 0,
				assets: 0
			};
			if ( !$scope.isShowingLayerSyncInfo ) {
				if ( asset.isLayerSync ) {
					var info = _.find( $scope.layerSyncInfo, function ( i ) {
						return i.assetid == asset.id;
					} );
					if ( info ) {
						$scope.artifacts = info.artifacts;
						$scope.artifactCounts = _.countBy( info.artifacts, function ( i ) {
							return i.type;
						} );
					}
				} else {}
			}
			$scope.isShowingLayerSyncInfo = !$scope.isShowingLayerSyncInfo;
		};
		$scope.toggleLayerSync = function ( asset ) {
			var info = {};
			if ( asset.isLayerSync ) {
				asset.isLayerSync = false;
			} else {
				asset.isLayerSync = true;
				info = _.find( $scope.layerSyncInfo, function ( i ) {
					return i.assetid == asset.id;
				} );
			}
			$scope.openModalWindow( "layerSync", asset, info );
		};
		$scope.showVersionImage = function ( version ) {
			if ( version > 0 ) {
				$scope.currentAssetImage = $scope.asset.link + "/preview?w=758&v=" + version;
			} else {
				$scope.currentAssetImage = $scope.asset.link + "/preview?w=758";
			}
		};
		$scope.downloadVersion = function ( version ) {
			if ( version > 0 ) {
				var tgt = $scope.asset.link + "/download?v=" + version;
			} else {
				var tgt = $scope.asset.link + "/download";
			}
			window.open( tgt, "_blank" );
		};
		$scope.goToAsset = function ( projectID, assetID ) {
			$location.path( "/projects/" + projectID + "/assets/" + assetID );
		};
		$scope.setPreviewFromArtifact = function ( artifact ) {
			if ( $scope.currentAssetImageID === artifact.entityid ) {
				return;
			}
			$scope.currentAssetImage = ( artifact.entitytype == "screen" ) ?
				( "/screens/" + artifact.entityid + "/" + artifact.imageVersion ) : ( artifact.link + "/preview?w=758" );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.assets", [ "projectID", "assetID" ] );
		$scope.isShowingDeleteConfirmation = false;
		$scope.isShowingShareOverlay = false;
		$scope.isShowingMetaOverlay = false;
		$scope.isShowingTools = false;
		$scope.isShowingLayerSyncInfo = false;
		$scope.isShowingMoreOptions = false;
		$scope.isShowingRenameField = false;
		$scope.artifacts = [];
		$scope.originalAssetImageID = false;
		$scope.currentAssetImageID = 0;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.assetID = requestContext.getParamAsInt( "assetID" );
			}
		);
	}
} )( angular, InVision );;;
/*! assets-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.AssetsController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, accountService, assetService, _, projectAssetsPartial, Deferred, modelEvents, sessionService, $filter, $timeout, dateHelper, userService, layersyncService, assetFolderService ) {
		$scope.views = {
			list: {
				asset: 'toolbar-list.htm',
				project: 'assets-list.htm'
			},
			detail: {
				asset: 'toolbar-info.htm',
				project: 'asset-info.htm'
			}
		};

		function loadRemoteData() {
			$scope.isLoading = true;
			$scope.isCheckProcessingAssets = false;
			$scope.checkingProcessingAssetsIDs = [];
			$scope.assetFilter = {
				value: ""
			};
			Deferred.handlePromise(
				projectAssetsPartial.get( requestContext.getParamAsInt( "projectID" ), $scope.folderID ),
				function ( response ) {
					$scope.setWindowTitle( $scope.project.name + " Assets" );
					$scope.hasValidSubscription = response.permissions[ 0 ].canUseAssets;
					applyRemoteData( response );
					updateLayerSyncInfo();
					$scope.isLoading = false;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your assets. Try refreshing your browser." );
				}
			);
		}

		function applyRemoteData( response ) {
			$scope.selectedAssetCount = 0;
			var assets = response.assets;
			assets = augmentAssets( assets );
			$scope.assets = getMergedAssetsForPerformance( $scope.assets, assets );
			$scope.folders = getMergedAssetsForPerformance( $scope.folders, response.folders );
			$scope.layerSyncInfo = response.layersync;
			$scope.shouldSeeTour = $scope.shouldSeeTour && ( $scope.assets.length + $scope.folders.length === 0 );
			applyAssets();
		}

		function getMergedAssetsForPerformance( oldAssets, newAssets ) {
			for ( var o = 0, oLength = oldAssets.length; o < oLength; o++ ) {
				var oldAsset = oldAssets[ o ];
				for ( var n = 0, nLength = newAssets.length; n < nLength; n++ ) {
					var newAsset = newAssets[ n ];
					if ( oldAsset.id === newAsset.id ) {
						newAsset.$$hashKey = oldAsset.$$hashKey;
						break;
					}
				}
			}
			return ( newAssets );
		}

		function applyAssets() {
			$scope.processingAssets = getProcessingAssets();
			if ( $scope.processingAssets.length && !$scope.isCheckProcessingAssets ) {
				thumbnailTimer = $timeout( loadRemoteData, 2000 );
				$scope.isCheckProcessingAssets = true;
			}
			if ( !$scope.assets.length && !$scope.folders.length && $scope.folderID == 0 ) {
				$scope.isShowingUploader = true;
			}
			var knownFileTypes = [ 'pdf', 'ai', 'xls', 'xlsx', 'png', 'jpg', 'jpeg', 'gif', 'key', 'graffle', 'psd', 'psb', 'sketch', 'doc', 'docx' ],
				imageTypes = [ "jpg", "jpeg", "gif", "bmp", "png", "tiff" ];
			for ( var a = 0; a < $scope.assets.length; a++ ) {
				var fileExtension = $scope.assets[ a ].clientFilename.split( '.' ).pop().toLowerCase();
				$scope.assets[ a ].fileExtension = fileExtension;
				$scope.assets[ a ].isImageFile = _.indexOf( imageTypes, $scope.assets[ a ].fileExtension ) >= 0 ? true : false;
				if ( knownFileTypes.indexOf( fileExtension ) >= 0 ) {
					$scope.assets[ a ].fileType = fileExtension;
				} else {
					$scope.assets[ a ].fileType = 'generic';
				}
			}
			for ( var a = 0; a < $scope.assets.length; a++ ) {
				$scope.assets[ a ].formattedCreatedAt = dateHelper.formatRecentDate( $scope.assets[ a ].createdAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.assets[ a ].createdAt, 'h:mmtt' );
				$scope.assets[ a ].formattedUpdatedAt = dateHelper.formatRecentDate( $scope.assets[ a ].updatedAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.assets[ a ].updatedAt, 'h:mmtt' );
			}
			for ( var a = 0; a < $scope.folders.length; a++ ) {
				$scope.folders[ a ].formattedCreatedAt = dateHelper.formatRecentDate( $scope.folders[ a ].createdAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.folders[ a ].createdAt, 'h:mmtt' );
				$scope.folders[ a ].formattedUpdatedAt = dateHelper.formatRecentDate( $scope.folders[ a ].updatedAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.folders[ a ].updatedAt, 'h:mmtt' );
				$scope.folders[ a ].formattedLastUpdatedAt = dateHelper.formatRecentDate( $scope.folders[ a ].lastUpdatedAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.folders[ a ].lastUpdatedAt, 'h:mmtt' );
			}
		}

		function augmentAsset( asset ) {
			if ( asset.createdByUserName ) {
				asset.createdByInitials = userService.getInitials( asset.createdByUserName );
				asset.createdByHasSystemAvatar = userService.isSystemAvatar( asset.createdByAvatarID );
			}
			if ( asset.updatedByUserName ) {
				asset.updatedByInitials = userService.getInitials( asset.updatedByUserName );
				asset.updatedByHasSystemAvatar = userService.isSystemAvatar( asset.updatedByAvatarID );
			}
			return ( asset );
		}

		function augmentAssets( assets ) {
			_.each( assets, augmentAsset );
			return ( assets );
		}

		function getProcessingAssets() {
			return _.withoutProperty( $scope.assets, "isProcessed", true );
		}

		function addUploadedAsset( asset ) {
			var existingAsset = _.findWithProperty( $scope.assets, "id", asset.id );
			asset = augmentAsset( asset );
			if ( existingAsset ) {
				_.extendExistingProperties( existingAsset, asset );
			} else {
				$scope.assets.push( asset );
			}
			loadRemoteData();
		}

		function updateLayerSyncInfo() {
			$scope.isShowingLayerSyncFlyout = false;
			$scope.isLayerSyncEnabled = false;
			$scope.layerSyncAssets = [];
			$scope.layerSyncPendingCount = 0;
			var assetsTemp = [];
			if ( $scope.layerSyncInfo.length ) {
				_.forEach( $scope.assets, function ( asset ) {
					if ( asset.isLayerSync ) {
						var info = _.find( $scope.layerSyncInfo, function ( i ) {
							return i.assetID == asset.id
						} );
						if ( info ) {
							var counts = _.countBy( info.artifacts, function ( i ) {
								return i.type
							} );
							assetsTemp.push( {
								asset: asset,
								info: info,
								counts: {
									screens: ( counts.screen ? counts.screen : 0 ),
									assets: ( counts.asset ? counts.asset : 0 )
								}
							} );
							asset.screenCount = counts.screen ? counts.screen : 0;
							asset.assetCount = counts.asset ? counts.asset : 0;
						}
					}
				} );
			}
			$scope.layerSyncAssets = assetsTemp
			$scope.isLayerSyncEnabled = ( $scope.layerSyncAssets.length > 0 );
			$scope.layerSyncPendingCount = _.filter( $scope.layerSyncInfo, function ( i ) {
				return i.status == "pending"
			} ).length;
		}

		function loadRemoteAssetData() {
			$scope.isLoading = true;
			$scope.assetFilter = {
				value: ""
			};
			Deferred.handlePromise(
				assetService.info( $scope.assetID ),
				function ( response ) {
					$scope.assetInfo = response;
					$scope.asset = response.asset;
					$scope.assetInfo.asset.formattedCreatedAt = dateHelper.formatRecentDate( $scope.assetInfo.asset.createdAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.assetInfo.asset.createdAt, 'h:mmtt' );
					for ( var a = 0; a < $scope.assetInfo.history.length; a++ ) {
						$scope.assetInfo.history[ a ].formattedCreatedAt = dateHelper.formatRecentDate( $scope.assetInfo.history[ a ].createdAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.assetInfo.history[ a ].createdAt, 'h:mmtt' );
					}
					if ( $scope.asset.isLayerSync ) {
						$scope.assetInfo.artifactCounts = _.countBy( response.layersync.artifacts, function ( i ) {
							return i.entitytype
						} );
					}
					$scope.currentAssetImage = $scope.asset.link + "/preview?w=758";
					$scope.isLoading = false;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your asset. Try refreshing your browser." );
				}
			);
		}
		$scope.closeTour = function () {
			$scope.shouldSeeTour = false;
			accountService.markAssetTourClosed();
			sessionService.user.hasSeenAssetTour = true;
		};
		$scope.getCountOfAssetsWithinQuota = function () {
			return _.countWithProperty( $scope.assets, "isOverQuota", false );
		};
		$scope.toggleUploader = function () {
			$scope.isShowingUploader = !$scope.isShowingUploader;
		};
		$scope.toggleNewFolder = function () {
			$scope.isShowingNewFolder = !$scope.isShowingNewFolder;
		};
		$scope.changeFolder = function ( folder ) {
			$scope.isLoading = true;
			$scope.assetFilter.value = "";
			if ( !folder ) {
				$scope.folderID = 0;
				$scope.folderStack = [];
				$scope.assetID = 0;
				$scope.assetsSubView = "list";
				$scope.asset = {};
				$scope.isScreenSourcesFolder = false;
				loadRemoteData();
				return;
			}
			if ( $scope.folderID == folder.id ) {
				loadRemoteData();
				return;
			}
			for ( var i = 0; i < $scope.folderStack.length; i++ ) {
				if ( $scope.folderStack[ i ].id == folder.id ) {
					$scope.folderID = folder.id;
					$scope.folderStack = $scope.folderStack.slice( 0, i + 1 );
					$scope.isScreenSourcesFolder = false;
					loadRemoteData();
					return;
				}
			}
			$scope.folderID = folder.id;
			$scope.folderStack.push( folder );
			$scope.isScreenSourcesFolder = ( folder.foldername == $scope.screenSourcesFolderName );
			loadRemoteData();
		}
		$scope.toggleSubscribeToAsset = function ( asset ) {
			if ( !asset.isSubscribed ) {
				Deferred.handlePromise(
					assetService.subscribeToAsset( asset.id ),
					function () {
						loadRemoteData();
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we couldn't subscribe to that asset." );
					}
				);
			} else {
				Deferred.handlePromise(
					assetService.unSubscribeToAsset( asset.id ),
					function () {
						loadRemoteData();
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we couldn't unsubscribe to that asset." );
					}
				);
			}
		};
		$scope.openAssetsVideo = function () {
			$scope.openModalWindow( "video", "64846864", [ 600, 460 ] );
		};
		$scope.isCompanyUser = function ( emailAddress ) {
			return ( emailAddress.indexOf( "@invisionapp.com" ) != -1 );
		};
		$scope.downloadAllAssets = function ( event ) {
			if ( $scope.getCountOfAssetsWithinQuota() ) {
				return true;
			} else {
				event.preventDefault();
				$scope.openModalWindow( "error", "This project currently does not have any assets that can be downloaded." );
				return false;
			}
		};
		$scope.openIntroModal = function () {
			if ( $scope.user.isSyncEnabled ) {
				document.location = "/d/dropbox/connect";
			} else {
				$scope.openModalWindow( "assetsIntro" );
			}
		};
		$scope.switchSingleAssetSubview = function ( view ) {
			$scope.singleAssetSubview = view;
		};
		$scope.toggleLinkModal = function () {
			$scope.isShowingLinkModal = !$scope.isShowingLinkModal;
		};
		$scope.toggleAssetFullView = function () {
			$scope.isShowingAssetFullView = !$scope.isShowingAssetFullView;
		};
		$scope.createNewFolder = function () {
			var folderName = angular.element( "#newFolderName" ).val();
			if ( folderName ) {
				Deferred.handlePromise(
					assetFolderService.createFolder( $scope.projectID, $scope.folderID, folderName ),
					function () {
						loadRemoteData();
					},
					function () {
						$scope.openModalWindow( "error", "For some reason, we couldn't create the asset folder." );
					}
				);
			}
			angular.element( "#newFolderName" ).val( "" );
			$scope.toggleNewFolder();
		};
		$scope.toggleLayerSyncFlyout = function () {
			$scope.isShowingLayerSyncFlyout = !$scope.isShowingLayerSyncFlyout;
		};
		$scope.isSpecialFolder = function ( folderName ) {
			var specialFolders = [ "images", "fonts" ];
			return _.indexOf( specialFolders, folderName ) >= 0 ? true : false;
		};
		$scope.isFolderEmpty = function ( numAssets, numFolders ) {
			return !( numAssets + numFolders );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.assets", [ "projectID", "assetID" ] );
		var LAST_SORT_VALUE = 999999;
		var thumbnailTimer = null;
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.assetID = requestContext.getParamAsInt( "assetID" );
		$scope.folderID = 0;
		$scope.isLoading = false;
		$scope.isShowingUploader = false;
		$scope.isShowingNewFolder = false;
		$scope.assets = [];
		$scope.processingAssets = [];
		$scope.folders = [];
		$scope.processingFolders = [];
		$scope.assetInfo = {};
		$scope.assetFilter = {
			value: ""
		};
		$scope.hasValidSubscription = false;
		$scope.shouldSeeTour = ( !sessionService.user.hasSeenAssetTour );
		$scope.singleAssetSubview = "version";
		$scope.isShowingLinkModal = false;
		$scope.isShowingAssetFullView = false;
		$scope.assetsSubView = $scope.assetID ? "detail" : "list";
		$scope.folderStack = [];
		$scope.layerSyncInfo = [];
		$scope.isShowingLayerSyncFlyout = false;
		$scope.isLayerSyncEnabled = false;
		$scope.layerSyncAssets = [];
		$scope.layerSyncPendingCount = 0;
		$scope.screenSourcesFolderName = "Source Files";
		$scope.isScreenSourcesFolder = false;
		$scope.currentAssetImage = "";
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "assetUploaded.projectAssets" );
				modelEvents.off( "assetDeleted" );
				modelEvents.off( "assetFolderDeleted" );
				modelEvents.off( "assetFolderRenamed" );
				modelEvents.off( "layerSyncEnabled" );
				modelEvents.off( "layerSyncDisabled" );
				$timeout.cancel( thumbnailTimer );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				$scope.assetID = requestContext.getParamAsInt( "assetID" );
				$scope.assetsSubView = $scope.assetID ? "detail" : "list";
				$scope.isShowingUploader = false;
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
				if ( requestContext.hasParamChanged( "assetID" ) && $scope.assetID ) {
					loadRemoteAssetData();
				}
				if ( !$scope.assetID ) {
					$scope.asset = {}
					$scope.assetInfo = {}
				}
			}
		);
		$scope.$on(
			"projectAssets:dragEnter",
			function () {
				$scope.isShowingUploader = true;
			}
		);
		modelEvents.on(
			"assetUploaded.projectAssets",
			function ( event, asset ) {
				if ( asset.projectID !== $scope.projectID ) {
					return;
				}
				addUploadedAsset( asset );
			}
		);
		modelEvents.on(
			"assetDeleted",
			function ( event, assetID ) {
				$scope.assets = _.withoutProperty( $scope.assets, "id", assetID );
			}
		);
		modelEvents.on(
			"assetFolderDeleted",
			function ( event, assetFolderID ) {
				$scope.folders = _.withoutProperty( $scope.folders, "id", assetFolderID );
			}
		);
		modelEvents.on(
			"assetFolderRenamed",
			function ( event, assetFolderID ) {
				loadRemoteData();
			}
		);
		modelEvents.on(
			"layerSyncEnabled",
			function ( event, assetID ) {
				loadRemoteData();
			}
		);
		modelEvents.on(
			"layerSyncDisabled",
			function ( event, assetID ) {
				loadRemoteData();
			}
		);
		$scope.setWindowTitle( "Loading Project Assets" );
		loadRemoteData();
		if ( $scope.assetID ) {
			loadRemoteAssetData();
		}
	}
} )( angular, InVision );;;
/*! comments-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.CommentsController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, $location, requestContext, Deferred, projectService, conversationService, projectConversationsPartial, sessionService, dateHelper, modelEvents, hashKeyCopier, userService, _ ) {
		function applyFiltersToUrl() {
			var readFilter = $scope.filters.read.value;
			var statusFilter = $scope.filters.status.value;
			var typeFilter = $scope.filters.type.value;
			var searchFilter = $scope.filters.search;
			$location.path( "/projects/" + $scope.projectID + "/comments/" + readFilter + "/" + statusFilter + "/" + typeFilter );
			if ( searchFilter ) {
				$location.search( "search", searchFilter );
			} else {
				$location.search( "search", null );
			}
		}

		function getShowingList() {
			return $scope.conversationOrderBy === "date" ? $scope.activity.listConversationsByDate : $scope.activity.listConversationsByScreen;
		}

		function applyLocalFilters() {
			clearLocalFilters();
			var screens = getShowingList();
			if ( _.isUndefined( $scope.filters.type ) ) {
				$scope.filters.type = getBestTypeFilterOption();
			}
			applyCompletedFilterToScreens( screens, $scope.isShowingCompletedView );
			applySearchFilterToScreens( screens, $scope.filters.search );
			updateAggregates();
		}

		function applyLocalFiltersWithSearchOptimization() {
			var screens = getShowingList();
			applySearchFilterToScreens( screens, $scope.filters.search );
			updateAggregates();
		}

		function applyReadFilterToConversations( conversations, isUnread ) {
			var conversationsToHide = _.withoutProperty( conversations, "isUnread", isUnread );
			_.setProperty( conversationsToHide, "isShown", false );
		}

		function applyReadFilterToScreens( screens, filterValue ) {
			if ( filterValue === "all" ) {
				return;
			}
			_.each(
				screens,
				function ( screen ) {
					if ( !screen.isShown ) {
						return;
					}
					applyReadFilterToConversations( screen.conversations, true );
					screen.isShown = _.containsWithProperty( screen.conversations, "isShown", true );
				}
			);
		}

		function applyRemoteData( project, projectMembers, projectStakeholders, activity, commentFilters ) {
			$scope.project = project;
			$scope.projectMembers = projectMembers;
			$scope.projectStakeholders = projectStakeholders;
			$scope.setWindowTitle( $scope.project.name + " Comments" );
			var currentUser = _.findWithProperty( $scope.projectMembers, "id", $scope.userID );
			$scope.projectMembers = _.rejectWithProperty( $scope.projectMembers, "id", $scope.userID );
			$scope.projectMembers.push( currentUser );
			augmentScreens( activity.screens );
			$scope.activity = hashKeyCopier.copyHashKeys( $scope.activity, activity );
			$scope.user = sessionService.user;
			var extractedConversations = ( function ( screens ) {
				var conversations = [];
				_.forEach( screens, function ( screen ) {
					var conversation = _.map( screen.conversations, function ( conversation ) {
						var firstComment = _.first( conversation.comments );
						var latestComment = conversation.comments.length > 1 ? _.last( conversation.comments ) : false;
						var commentHasSketch = false;
						_.forEach( conversation.comments, function ( comment ) {
							if ( comment.sketches.length ) {
								commentHasSketch = true;
								return; // we found one, now stop looping.
							}
						} );
						var augmentedConversation = {
							isShown: !conversation.isComplete,
							commentCount: conversation.comments.length,
							thumb: ( "/screens/" + screen.id + "/" + screen.imageVersion ),
							searchText: getConversationSearchText( conversation ),
							updatedAt: _.last( conversation.comments ).updatedAt,
							commentHasSketch: commentHasSketch,
							conversationID: conversation.id,
							screen: screen,
							firstComment: firstComment,
							latestComment: latestComment
						};
						_.merge( augmentedConversation, conversation );
						_.merge( augmentedConversation.firstComment, {
							isJustSketch: _.isEmpty( firstComment.comment ) ? true : false,
							comment: firstComment.comment || firstComment.userName + " attached a sketch",
							userName: userService.getNiceUsername( firstComment.userName, firstComment.userID, sessionService.user.id ),
							userFirstName: firstComment.userName.split( /\s/ )[ 0 ],
							initials: userService.getInitials( firstComment.userName ),
							isSystemAvatar: userService.isSystemAvatar( firstComment.avatarID ),
							dateLabel: dateHelper.formatRecentDate( firstComment.updatedAt, "mmm d" )
						} );
						if ( latestComment ) {
							_.merge( augmentedConversation.latestComment, {
								isJustSketch: _.isEmpty( latestComment.comment ) ? true : false,
								comment: latestComment.comment || latestComment.userName + " attached a sketch",
								userName: userService.getNiceUsername( latestComment.userName, latestComment.userID, sessionService.user.id ),
								userFirstName: latestComment.userName.split( /\s/ )[ 0 ],
								initials: userService.getInitials( latestComment.userName ),
								isSystemAvatar: userService.isSystemAvatar( latestComment.avatarID ),
								dateLabel: dateHelper.formatRecentDate( latestComment.updatedAt, "mmm d" )
							} );
						} else {
							augmentedConversation.latestComment = augmentedConversation.firstComment;
						}
						var viewport = {
							width: 83,
							height: 58,
							midWidth: ( 83 / 2 ),
							midHeight: ( 58 / 2 )
						};
						var composite = augmentedConversation.composite = {
							x: 0,
							y: 0,
							width: 200,
							height: 0,
							scale: 1,
							marker: {
								x: conversation.x,
								y: conversation.y
							}
						};
						composite.scale = ( composite.width / screen.width );
						composite.height = Math.floor( screen.height * composite.scale );
						composite.marker.x *= composite.scale;
						composite.marker.y *= composite.scale;
						composite.x = Math.min( ( viewport.midWidth - composite.marker.x ), 0 );
						composite.y = Math.min( ( viewport.midHeight - composite.marker.y ), 0 );
						composite.x = Math.max( composite.x, ( viewport.width - composite.width ) );
						composite.y = Math.max( composite.y, ( viewport.height - composite.height ) );
						if ( $scope.conversationID == augmentedConversation.id ) {
							$scope.showConversationDetail( augmentedConversation );
							applyFiltersToUrl();
						}
						return ( augmentedConversation );
					} );
					conversations = conversations.concat( conversation );
				} );
				return conversations;
			} )( $scope.activity.screens );
			$scope.activity.conversations = extractedConversations;
			mapConversationsToLists();
			if ( _.isUndefined( commentFilters.status ) || commentFilters.status.length === 0 ) {
				$scope.loadFiltersFromUser = false;
			}
			if ( $scope.loadFiltersFromUser ) {
				$scope.filters.read = _.findWithProperty( $scope.readFilterOptions, "value", commentFilters.read );
				$scope.filters.type = _.findWithProperty( $scope.typeFilterOptions, "value", commentFilters.type );
				$scope.filters.status = _.findWithProperty( $scope.statusFilterOptions, "value", commentFilters.status );
			}
			applyLocalFilters();
			if ( $scope.loadFiltersFromUser ) {
				applyFiltersToUrl();
			}
			$scope.loadFiltersFromUser = false;
		}

		function mapConversationsToLists() {
			$scope.activity.listConversationsByDate = mapConversationsByDate();
			$scope.activity.listConversationsByScreen = mapConversationsByScreen();
		}

		function mapConversationsByScreen() {
			var conversationsByScreen = [];
			conversationsByScreen = _.map(
				_.groupBy( $scope.activity.conversations, "screenID" ),
				function ( screenGrouping ) {
					return {
						conversations: screenGrouping,
						unreadConversationCount: _.countWithProperty( screenGrouping, "isUnread", true ),
						conversationCount: screenGrouping.length,
						isShown: true,
						name: _.first( screenGrouping ).screen.name,
						sort: _.first( screenGrouping ).screen.name,
						thumb: "/thumbnails/" + _.first( screenGrouping ).screen.id + "/0",
						screenID: _.first( screenGrouping ).screen.id
					};
				}
			);
			conversationsByScreen = _.sortOnProperty( conversationsByScreen, "sort", "desc" );
			return ( conversationsByScreen );
		}

		function mapConversationsByDate() {
			var conversationsByDate = [];
			conversationsByDate = _.map(
				_.groupBy( $scope.activity.conversations, function ( conversation ) {
					return dateHelper.removeTime( conversation.updatedAt );
				} ),
				function ( screenGrouping ) {
					return {
						conversations: screenGrouping,
						unreadConversationCount: _.countWithProperty( screenGrouping, "isUnread", true ),
						conversationCount: screenGrouping.length,
						isShown: true,
						dateLabel: dateHelper.formatRecentDate( _.first( screenGrouping ).updatedAt, "mmm dd" ),
						sort: dateHelper.removeTime( _.first( screenGrouping ).updatedAt )
					};
				}
			);
			conversationsByDate = _.sortOnProperty( conversationsByDate, "sort", "desc" );
			return ( conversationsByDate );
		}

		function applySearchFilterToConversations( conversations, substring ) {
			var conversationsToHide = _.filter(
				conversations,
				function ( conversation ) {
					return ( conversation.searchText.indexOf( substring ) === -1 );
				}
			);
			_.setProperty( conversationsToHide, "isShown", false );
		}

		function applySearchFilterToScreens( screens, filterValue ) {
			if ( !filterValue ) {
				return;
			}
			filterValue = filterValue.toLowerCase();
			_.each(
				screens,
				function ( screen ) {
					if ( !screen.isShown ) {
						return;
					}
					applySearchFilterToConversations( screen.conversations, filterValue );
					screen.isShown = _.containsWithProperty( screen.conversations, "isShown", true );
				}
			);
		}

		function applyCompletedFilterToConversations( conversations, filterValue ) {
			var conversationsToHide = _.withProperty( conversations, "isComplete", true );
			_.setProperty( conversationsToHide, "isShown", filterValue );
		}

		function applyCompletedFilterToScreens( screens, filterValue ) {
			_.each(
				screens,
				function ( screen ) {
					if ( !screen.isShown ) {
						return;
					}
					applyCompletedFilterToConversations( screen.conversations, filterValue );
					screen.isShown = _.containsWithProperty( screen.conversations, "isShown", true );
				}
			);
		}

		function augmentComment( comment ) {
			comment.isShown = true;
			comment.dateLabel = dateHelper.formatRecentDate( comment.updatedAt, "mmm d" );
			comment.timeLabel = dateHelper.formatTime( comment.updatedAt, "h:mmtt" );
			comment.userInitials = userService.getInitials( comment.userName );
			comment.userHasSystemAvatar = userService.isSystemAvatar( comment.avatarID );
			comment.html = conversationService.getHtmlForComment( comment.comment );
			return ( comment );
		}

		function augmentConversation( conversation ) {
			conversation.isShown = true;
			conversation.isCommentInputVisible = false;
			conversation.newComment = "";
			conversation.notifyOthers = "";
			conversation.showNotifyOthers = false;
			conversation.isNotifySettingsVisible = false;
			conversation.hiddenCommentCount = 0;
			_.each(
				conversation.comments,
				function ( comment, i ) {
					augmentComment( comment );
					if ( i === 0 || i > conversation.comments.length - 3 || comment.isUnread ) {
						comment.isShown = true;
					} else {
						comment.isShown = false;
						conversation.hiddenCommentCount++;
					}
				}
			);
			conversation.searchText = getConversationSearchText( conversation );
			return ( conversation );
		}

		function augmentConversations( conversations ) {
			_.each( conversations, augmentConversation );
			return ( conversations );
		}

		function augmentScreen( screen ) {
			screen.isShown = true;
			screen.dateLabel = dateHelper.formatRecentDate( screen.updatedAt, "mmm d, yyyy" );
			screen.timeLabel = dateHelper.formatTime( screen.updatedAt, "h:mmtt" );
			screen.conversationCount = 0;
			screen.commentCount = 0;
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function clearLocalFilters() {
			var screens = $scope.activity.listConversationsByDate;
			for ( var i = 0, length = screens.length; i < length; i++ ) {
				var screen = screens[ i ];
				screen.isShown = true;
				_.setProperty( screen.conversations, "isShown", true );
			}
			var screens = $scope.activity.listConversationsByScreen;
			for ( var i = 0, length = screens.length; i < length; i++ ) {
				var screen = screens[ i ];
				screen.isShown = true;
				_.setProperty( screen.conversations, "isShown", true );
			}
		}

		function getBestReadFilterOption() {
			var option = _.findWithProperty( $scope.readFilterOptions, "value", requestContext.getParam( "readFilter" ) );
			if ( !option ) {
				option = $scope.readFilterOptions[ 0 ];
			}
			return ( option );
		}

		function getBestSearchFilter() {
			if ( $location.search().search === true ) {
				return ( "" );
			}
			return ( $location.search().search || "" );
		}

		function getBestStatusFilterOption() {
			var option = _.findWithProperty( $scope.statusFilterOptions, "value", requestContext.getParam( "statusFilter" ) );
			if ( !option ) {
				option = $scope.statusFilterOptions[ 1 ];
			}
			return ( option );
		}

		function getBestTypeFilterOption() {
			var option = _.findWithProperty( $scope.typeFilterOptions, "value", requestContext.getParam( "typeFilter" ) );
			if ( !option ) {
				option = $scope.typeFilterOptions[ 0 ];
			}
			return ( option );
		}

		function getConversationById( conversationID ) {
			return _.filter( $scope.activity.conversations, function ( convo ) {
				return convo.id == conversationID;
			} )[ 0 ];
		}

		function getConversationSearchText( conversation ) {
			var commentData = _.pluck( conversation.comments, "comment" );
			var searchText = commentData.join( "~" ).toLowerCase();
			return ( searchText );
		}

		function handleProjectStakeholderRemoved( event, projectID, userID ) {
			$scope.projectStakeholders = _.rejectWithProperty( $scope.projectStakeholders, "id", userID );
		}

		function handleCommentUpdate( event, commentID, conversationID, projectID ) {
			if ( projectID !== $scope.projectID ) {
				return;
			}
			if ( commentID === false ) { // Deleting the conversation
				$scope.activity.conversations = _.withoutProperty( $scope.activity.conversations, "id", conversationID );
				mapConversationsToLists();
			} else {
				Deferred.handlePromise(
					conversationService.getComment( commentID ),
					function ( comment ) {
						if ( comment.userID !== $scope.user.id ) {
							$scope.hasOutdatedData = true;
						}
					}
				);
			}
			updateAggregates();
		}

		function loadRemoteData( callback ) {
			$scope.isLoading = true;
			$scope.activity = [];
			Deferred.handlePromise(
				projectConversationsPartial.get( $scope.projectID, "all" ),
				function ( response ) {
					if ( !renderContext.isChangeLocal() ) {
						return;
					}
					$scope.isLoading = false;
					applyRemoteData(
						response.project,
						response.projectMembers,
						response.projectStakeholders,
						response.conversations,
						response.commentFilters
					);
					if ( callback && typeof ( callback ) === "function" ) {
						callback();
					}
				},
				function () {
					$scope.openModalWindow( "error", "For some reason we couldn't load your conversations. Try refreshing your browser." );
				}
			);
		}

		function saveConversation( conversation ) {
			var promise = conversationService.saveConversation( conversation );
			Deferred.handlePromise(
				promise,
				null,
				function () {}
			);
		}

		function updateAggregates() {
			$scope.conversationCount = 0;
			_.each(
				getShowingList(),
				function ( screen ) {
					if ( !screen.isShown ) {
						return;
					}
					var visibleConversations = _.withProperty( screen.conversations, "isShown", true );
					$scope.conversationCount += visibleConversations.length;
					screen.conversationCount = visibleConversations.length;
					screen.unreadConversationCount = _.countWithProperty( visibleConversations, "isUnread", true );
					_.each(
						visibleConversations,
						function ( conversation ) {
							conversation.commentCount = conversation.comments.length;
						}
					);
				}
			);
		}

		function updateUserCommentFilters() {
			Deferred.handlePromise(
				projectConversationsPartial.updateFilters( $scope.filters ),
				function ( response ) {},
				function () {}
			);
		}

		function getConversationsToCount() {
			return $scope.activity.conversations;
		}
		$scope.setConversationOrderBy = function ( orderBy ) {
			$scope.conversationOrderBy = orderBy;
			sessionService.user.conversationOrderBy = orderBy;
			applyLocalFilters();
		};
		$scope.toggleCompletedView = function () {
			$scope.isShowingCompletedView = !$scope.isShowingCompletedView;
			applyLocalFilters();
		};
		$scope.getTotalUnreadConversationCount = function () {
			var shownConversations = _.withProperty( $scope.activity.conversations, "isShown", true );
			return ( _.countWithProperty( shownConversations, "isUnread", true ) );
		};
		$scope.getCompletedConversationCount = function () {
			var conversationsToCount = getConversationsToCount();
			return ( _.countWithProperty( conversationsToCount, "isComplete", true ) );
		};
		$scope.getOpenConversationCount = function () {
			var conversationsToCount = getConversationsToCount();
			return ( _.countWithProperty( conversationsToCount, "isComplete", false ) );
		};
		$scope.cancelEditingComment = function ( comment ) {
			comment.isEditing = false;
			if ( comment.originalComment ) {
				comment.comment = comment.originalComment;
			}
		};
		$scope.changeReadFilter = function ( newFilter ) {
			if ( $scope.filters.read === newFilter ) {
				return;
			}
			$scope.filters.read = newFilter;
			applyLocalFilters();
			applyFiltersToUrl();
			$scope.filtersChangedByUser = true;
		};
		$scope.changeStatusFilter = function ( newFilter ) {
			if ( $scope.filters.status === newFilter ) {
				return;
			}
			$scope.filters.status = newFilter;
			loadRemoteData();
			applyFiltersToUrl();
			$scope.filtersChangedByUser = true;
		};
		$scope.changeTypeFilter = function ( newFilter ) {
			if ( $scope.filters.type === newFilter ) {
				return;
			}
			$scope.filters.type = newFilter;
			applyLocalFilters();
			applyFiltersToUrl();
			$scope.filtersChangedByUser = true;
		};
		$scope.clearSearchText = function () {
			$scope.filters.search = "";
		};
		$scope.clearRefreshMsg = function () {
			$scope.hasOutdatedData = false;
		};
		$scope.closeConversationPanel = function ( conversation ) {
			conversation.newComment = "";
			conversation.notifyOthers = "";
			conversation.isCommentInputVisible = false;
			conversation.isNotifySettingsVisible = false;
		};
		$scope.conversationLabelSort = function ( conversation ) {
			return parseInt( conversation.label );
		};
		$scope.deleteComment = function ( comment, conversation, screen ) {
			conversationService.deleteComment( comment );
			conversation.comments = _.rejectWithProperty( conversation.comments, "id", comment.id );
			conversation.searchText = getConversationSearchText( conversation );
			updateAggregates();
		};
		$scope.deleteSketch = function ( sketchID, comment ) {
			conversationService.deleteSketch( sketchID );
			comment.sketches = _.rejectWithProperty( comment.sketches, "sketchID", sketchID );
		};
		$scope.deleteConversation = function ( conversation, screen ) {
			conversationService.deleteConversation( conversation );
			screen.conversations = _.withoutProperty( screen.conversations, "id", conversation.id );
			var visibleConversations = _.withProperty( screen.conversations, "isShown", true );
			if ( !visibleConversations.length ) {
				screen.isShown = false;
			}
			updateAggregates();
		};
		$scope.editComment = function ( comment, conversation ) {
			$scope.stopEditingComments( conversation );
			comment.isEditing = true;
			comment.originalComment = comment.comment;
		};
		$scope.getNotifyCount = function ( conversation ) {
			var count = 0;
			_.each( $scope.projectMembers, function ( user ) {
				if ( user.isNotify ) {
					count++;
				}
			} );
			_.each( $scope.projectStakeholders, function ( user ) {
				if ( user.isNotify ) {
					count++;
				}
			} );
			if ( conversation.notifyOthers ) {
				var others = conversation.notifyOthers.split( "," );
				count += others.length;
			}
			return count;
		};
		$scope.hideConversation = function ( screen, conversation ) {
			conversation.isShown = false;
			applyLocalFilters();
		};
		$scope.hideDeleteConfirmation = function ( conversation ) {
			conversation.isDeleting = false;
		};
		$scope.isStakeholdersShowing = function ( conversation ) {
			var isStakeholdersListEmpty = !$scope.projectStakeholders.length;
			if ( conversation.isPrivate || conversation.isForDevelopment || isStakeholdersListEmpty ) {
				return false;
			} else {
				return true;
			}
		};
		$scope.loadStakeholders = function () {
			var promise = Deferred.handlePromise(
				projectService.getStakeholders( $scope.projectID ),
				function ( response ) {
					$scope.projectStakeholders = response;
				}
			);
			return ( promise );
		};
		$scope.markCompleted = function ( conversation ) {
			var $event = arguments[ 1 ];
			if ( $event ) {
				$event.stopPropagation();
			}
			conversation.isComplete = !conversation.isComplete;
			saveConversation( conversation );
			if ( conversation.isUnread ) {
				$scope.markRead( conversation );
				conversation.isUnread = false;
				updateAggregates();
			}
		};
		$scope.markRead = function ( conversation ) {
			var comments = _.filter( conversation.comments, function ( comment ) {
				return comment.isUnread === true;
			} );
			var commentIDs = _.pluck( comments, "id" );
			_.setProperty( conversation.comments, "isUnread", false );
			if ( commentIDs.length ) {
				conversationService.markCommentsAsRead( commentIDs );
				conversation.isUnread = false;
			}
		};
		$scope.markAllAsRead = function () {
			var shownConversations = _.withProperty( $scope.activity.conversations, "isShown", true );
			_.each( shownConversations, $scope.markRead );
		};
		$scope.refreshData = function ( callback ) {
			loadRemoteData( callback );
			$scope.hasOutdatedData = false;
		};
		$scope.removeConversation = function ( screen, conversation ) {
			screen.conversations = _.without( screen.conversations, conversation );
			applyLocalFilters();
		};
		$scope.removeStakeholder = function ( stakeholder ) {
			projectService.removeStakeholderFromProject( $scope.projectID, stakeholder.id );
		};
		$scope.saveComment = function ( comment, conversation, screen ) {
			if ( !comment.comment ) {
				return;
			}
			comment.isEditing = false;
			comment.originalComment = comment.comment;
			comment.html = conversationService.getHtmlForComment( comment.comment );
			if ( comment.id ) {
				var notify = {
					members: [],
					stakeholders: [],
					others: [],
					unsubscribe: []
				};
			} else {
				var memberIDs = _.filterWithProperty( $scope.projectMembers, "isNotify", true );
				var stakeholderIDs = _.filterWithProperty( $scope.projectStakeholders, "isNotify", true );
				var notify = {
					members: _.pluck( memberIDs, "id" ),
					stakeholders: _.pluck( stakeholderIDs, "id" ),
					others: [],
					unsubscribe: []
				};
				var membersToUnsubscribe = _.filterWithProperty( $scope.projectMembers, "isNotify", false );
				var stakeholdersToUnsubscribe = _.filterWithProperty( $scope.projectStakeholders, "isNotify", false );
				notify.unsubscribe = _.pluck( membersToUnsubscribe, "id" );
				notify.unsubscribe = notify.unsubscribe.concat( _.pluck( stakeholdersToUnsubscribe, "id" ) );
				if ( conversation.notifyOthers ) {
					notify.others = conversation.notifyOthers.split( "," );
				}
			}
			comment.notify = notify;
			comment.conversationID = conversation.id;
			Deferred.handlePromise(
				conversationService.saveComment( comment ),
				function ( savedComment ) {
					if ( !comment.id ) {
						augmentComment( savedComment );
						conversation.comments.push( savedComment );
						updateAggregates();
						conversation.subscribers = notify.members.concat( notify.stakeholders );
					}
					if ( notify.others.length ) {
						$scope.loadStakeholders().then(
							function ( stakeholders ) {
								var newUserIDs = [];
								_.each(
									stakeholders,
									function ( stakeholder ) {
										if (
											_.contains( notify.subscribers, stakeholder.id ) ||
											_.contains( notify.unsubscribe, stakeholder.id )
										) {
											return;
										}
										newUserIDs.push( stakeholder.id );
									}
								);
								if ( !newUserIDs.length ) {
									return;
								}
								conversation.subscribers = conversation.subscribers.concat( newUserIDs );
							}
						);
					}
					conversation.searchText = getConversationSearchText( conversation );
					conversation.newComment = "";
					conversation.isCommentInputVisible = false;
					conversation.notifyOthers = "";
					conversation.showNotifyOthers = false;
					conversation.isNotifySettingsVisible = false;
					if ( conversation.isUnread ) {
						$scope.markRead( conversation );
					}
				}
			);
		};
		$scope.showConversationDetail = function ( conversation ) {
			$scope.openModalWindow( "projectComments", conversation, $scope.user, $scope.filters, $scope.projectMembers, $scope.projectStakeholders, $scope.project );
			$timeout(
				function () {
					$scope.markRead( conversation );
				},
				5000
			);
		};
		$scope.showCommentInput = function ( conversation ) {
			for ( var s = 0; s < $scope.activity.screens.length; s++ ) {
				for ( var c = 0; c < $scope.activity.screens[ s ].conversations.length; c++ ) {
					$scope.activity.screens[ s ].conversations[ c ].isCommentInputVisible = false;
				}
			}
			_.setProperty( $scope.projectMembers, "isNotify", false );
			_.setProperty( $scope.projectStakeholders, "isNotify", false );
			var selectedMembers = _.withPropertyRange( $scope.projectMembers, "id", conversation.subscribers );
			var selectedStakeholders = _.withPropertyRange( $scope.projectStakeholders, "id", conversation.subscribers );
			_.setProperty( selectedMembers, "isNotify", true );
			_.setProperty( selectedStakeholders, "isNotify", true );
			conversation.isCommentInputVisible = true;
		};
		$scope.showDeleteConfirmation = function ( comment, conversation, isFirstComment ) {
			if ( isFirstComment ) {
				conversation.isDeleting = true;
			} else {
				comment.isDeleting = true;
			}
		};
		$scope.stopEditingComments = function ( conversation ) {
			_.each( conversation.comments, function ( comment ) {
				$scope.cancelEditingComment( comment );
			} );
		};
		$scope.showAllComments = function ( conversation ) {
			_.setProperty( conversation.comments, "isShown", true );
			conversation.hiddenCommentCount = 0;
		};
		$scope.setSketchImageIsProcessing = function ( isProcessing ) {
			$scope.sketchImageIsProcessing = isProcessing;
		};
		$scope.closeSketchViewer = function () {
			$scope.sketchViewerSketch = {};
			$scope.sketchViewerSketchIsTemp = false;
			$scope.isShowingSketchViewer = false;
			$scope.setSketchImageIsProcessing( false );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.comments", [ "projectID", "readFilter", "statusFilter", "typeFilter", "conversationID" ] );
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.isLoading = false;
		$scope.activity = [];
		$scope.project = null;
		$scope.projectMembers = [];
		$scope.projectStakeholders = [];
		$scope.commentCount = 0;
		$scope.isShowingCompletedView = false;
		$scope.conversationID = requestContext.getParamAsInt( "conversationID" );
		$scope.user = sessionService.user;
		$scope.userID = sessionService.user.id;
		$scope.notifySettings = {
			isTeamChecked: false,
			isStakeholdersChecked: false
		};
		$scope.readFilterOptions = [ {
			label: "All Comments",
			value: "all"
		}, {
			label: "Unread",
			value: "unread"
		} ];
		$scope.statusFilterOptions = [ {
			label: "Any Status",
			value: "all"
		}, {
			label: "Open",
			value: "open"
		}, {
			label: "Completed",
			value: "completed"
		} ];
		$scope.typeFilterOptions = [ {
			label: "Comments",
			value: "comments"
		}, {
			label: "Unread Comments",
			value: "unread"
		}, {
			label: "Dev Notes",
			value: "dev-notes"
		} ];
		$scope.filters = {
			read: getBestReadFilterOption(),
			status: getBestStatusFilterOption(),
			type: getBestTypeFilterOption(),
			search: getBestSearchFilter()
		};
		$scope.loadFiltersFromUser = true;
		$scope.filtersChangedByUser = false;
		$scope.conversationOrderBy = sessionService.user.conversationOrderBy || "screen";
		$scope.hasOutdatedData = false;
		$scope.sketchImageIsProcessing = false;
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "projectStakeholderRemoved.projectComments" );
				modelEvents.off( "commentAdded.commentTab" );
				modelEvents.off( "commentUpdated.commentUpdated" );
			}
		);
		$scope.$on(
			"showSketchViewer",
			function ( event, sketch, isTemp, convoScreen, marker ) {
				$scope.screen = convoScreen;
				if ( sketch.sketchID !== undefined ) {
					sketch.id = sketch.sketchID;
				}
				$scope.sketchViewerSketch = sketch;
				$scope.sketchViewerMarker = marker;
				$scope.sketchViewerSketchIsTemp = ( sketch.tempID !== undefined ? true : false );
				$scope.isShowingSketchViewer = true;
				$scope.isBottomBarShown = false;
				$scope.sketchImageIsProcessing = false;
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				var previousReadFilter = $scope.filters.read;
				var previousStatusFilter = $scope.filters.status;
				var previousTypeFilter = $scope.filters.type;
				var previousSearchFilter = $scope.filters.search;
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				$scope.filters = {
					read: getBestReadFilterOption(),
					status: getBestStatusFilterOption(),
					type: getBestTypeFilterOption(),
					search: getBestSearchFilter()
				};
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					$scope.notifySettings.isTeamChecked = false;
					$scope.notifySettings.isStakeholdersChecked = false;
					loadRemoteData();
				} else if ( $scope.filters.status !== previousStatusFilter ) {
					loadRemoteData();
				} else if ( !$scope.isLoading &&
					(
						( $scope.filters.read !== previousReadFilter ) ||
						( $scope.filters.type !== previousTypeFilter ) ||
						( $scope.filters.search !== previousSearchFilter )
					)
				) {
					applyLocalFilters();
				}
				$scope.conversationID = requestContext.getParamAsInt( "conversationID" );
			}
		);
		$scope.$watch( "conversationID", function ( newValue ) {
			if ( newValue && $scope.activity && $scope.activity.conversations ) {
				if ( $scope.hasOutdatedData ) {
					$scope.refreshData( function cb() {
						$scope.showConversationDetail( getConversationById( newValue ) );
						applyFiltersToUrl();
					} );
				} else {
					$scope.showConversationDetail( getConversationById( newValue ) );
					applyFiltersToUrl();
				}
			}
		} );
		$scope.$watch( "notifySettings.isTeamChecked", function ( newValue, oldValue ) {
			if ( newValue !== oldValue ) {
				_.setProperty( $scope.projectMembers, "isNotify", !!newValue );
			}
		} );
		$scope.$watch( "notifySettings.isStakeholdersChecked", function ( newValue, oldValue ) {
			if ( newValue !== oldValue ) {
				_.setProperty( $scope.projectStakeholders, "isNotify", !!newValue );
			}
		} );
		$scope.$watch(
			"filters.search",
			function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				if ( newValue && ( newValue.indexOf( oldValue ) === 0 ) ) {
					applyLocalFiltersWithSearchOptimization();
				} else {
					applyLocalFilters();
				}
				applyFiltersToUrl();
			}
		);
		$scope.$watch(
			"filters",
			function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				if ( $scope.filtersChangedByUser ) {
					updateUserCommentFilters();
					$scope.filtersChangedByUser = false;
				}
			}
		);
		modelEvents.on( "projectStakeholderRemoved.commentTab", handleProjectStakeholderRemoved );
		modelEvents.on( "commentAdded.commentTab", handleCommentUpdate );
		modelEvents.on( "commentUpdated.commentTab", handleCommentUpdate );
		modelEvents.on( "commentModal.handleCommentUpdates", loadRemoteData );
		$scope.setWindowTitle( "Loading Comments" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! presentation-screen-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "presentations.PresentationScreenController", Controller );
	/** @ngInject */
	function Controller( $scope, _ ) {
		$scope.hideDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = false;
		};
		$scope.showDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = true;
		};
		$scope.isShowingDeleteConfirmation = false;
	}
} )( angular, InVision );;;
/*! presentations-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.PresentationsController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, _, presentationConsolePartial, Deferred ) {
		function loadPresentations() {
			var promise = Deferred.handlePromise(
				presentationConsolePartial.getByProjectID( $scope.project.id ),
				function ( response ) {
					$scope.presentations = _.filter( response, {
						isArchived: false
					} );
					$scope.totalPresentations = _.size( $scope.presentations );
					$scope.archivedPresentations = _.filter( response, {
						isArchived: true
					} );
					$scope.totalArchivedPresentations = _.size( $scope.archivedPresentations );
					$scope.isLoading = false;
				},
				function ( error ) {
					console.log( 'error', error );
				}
			);
			return ( promise );
		}
		$scope.activatePresentation = function ( presentation ) {
			var promise = Deferred.handlePromise(
				presentationConsolePartial.activate( presentation.projectID, presentation.id ),
				function ( response ) {
					$scope.filters.presentationFilter = "";
					$scope.presentations = _.filter( response, {
						isArchived: false
					} );
					$scope.totalPresentations = _.size( $scope.presentations );
					$scope.archivedPresentations = _.filter( response, {
						isArchived: true
					} );
					$scope.totalArchivedPresentations = _.size( $scope.archivedPresentations );
				},
				function ( error ) {
					console.log( 'error', error );
				}
			);
			return ( promise );
		};
		$scope.archivePresentation = function ( presentation ) {
			var promise = Deferred.handlePromise(
				presentationConsolePartial.archive( presentation.projectID, presentation.id ),
				function ( response ) {
					$scope.filters.presentationFilter = "";
					$scope.presentations = _.filter( response, {
						isArchived: false
					} );
					$scope.totalPresentations = _.size( $scope.presentations );
					$scope.archivedPresentations = _.filter( response, {
						isArchived: true
					} );
					$scope.totalArchivedPresentations = _.size( $scope.archivedPresentations );
				},
				function ( error ) {
					console.log( 'error', error );
				}
			);
			return ( promise );
		};
		$scope.createTour = function () {
			$location.path( "/presentations/" + $scope.project.id + "/0" );
		};
		$scope.deletePresentation = function ( presentation ) {
			var promise = Deferred.handlePromise(
				presentationConsolePartial.removePresentation( presentation.projectID, presentation.id ),
				function ( response ) {
					$scope.filters.presentationFilter = "";
					$scope.presentations = _.filter( response, {
						isArchived: false
					} );
					$scope.totalPresentations = _.size( $scope.presentations );
					$scope.archivedPresentations = _.filter( response, {
						isArchived: true
					} );
					$scope.totalArchivedPresentations = _.size( $scope.archivedPresentations );
				},
				function ( error ) {
					console.log( 'error', error );
				}
			);
			return ( promise );
		};
		$scope.duplicatePresentation = function ( presentation ) {
			var promise = Deferred.handlePromise(
				presentationConsolePartial.duplicate( presentation.projectID, presentation.id ),
				function ( response ) {
					$scope.filters.presentationFilter = "";
					$scope.presentations = _.filter( response, {
						isArchived: false
					} );
					$scope.totalPresentations = _.size( $scope.presentations );
					$scope.archivedPresentations = _.filter( response, {
						isArchived: true
					} );
					$scope.totalArchivedPresentations = _.size( $scope.archivedPresentations );
				},
				function ( error ) {
					console.log( 'error', error );
				}
			);
			return ( promise );
		};
		$scope.editTour = function ( id ) {
			$location.path( "/presentations/" + $scope.project.id + "/" + id );
		};
		$scope.filterByNameAndDescription = function ( presentation, val ) {
			if ( presentation.name.toUpperCase().indexOf( $scope.filters.presentationFilter.toUpperCase() ) > -1 || presentation.description.toUpperCase().indexOf( $scope.filters.presentationFilter.toUpperCase() ) > -1 ) {
				return true;
			} else {
				return false;
			}
		};
		$scope.openPresentationShareModal = function ( presentation ) {
			$scope.openModalWindow( "presentation-share", $scope.project.id, presentation, "new" );
		};
		$scope.updatedAtAsString = function ( date ) {
			return moment( date ).fromNow();
		};
		$scope.getThumbnail = function ( screenID, imageVersion ) {
			if ( !screenID ) {
				return '';
			}
			return '/screens/' + screenID + '/' + imageVersion;
		};
		$scope.setActiveSample = function ( sample ) {
			$scope.activeSample = sample;
		};
		$scope.toggleArchivedPresentations = function () {
			$scope.isShowingArchivedPresentations = !$scope.isShowingArchivedPresentations;
		};
		$scope.presentations = [];
		$scope.archivedPresentations = [];
		$scope.totalPresentations = 0;
		$scope.totalArchivedPresentations = 0;
		$scope.activeSample = "tour";
		$scope.isLoading = true;
		$scope.filters = {
			presentationFilter: ""
		};
		$scope.isShowingArchivedPresentations = false;
		$scope.filterMatchesNoPresentation = false;
		$scope.$watch( "filters.presentationFilter", function ( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			var matches = _.countBy( $scope.presentations, function ( presentation ) {
				if ( presentation.name.toUpperCase().indexOf( newValue.toUpperCase() ) > -1 || presentation.description.toUpperCase().indexOf( newValue.toUpperCase() ) > -1 ) {
					return "isFound";
				} else {
					return "isNotFound";
				}
			} );
			if ( matches.isFound ) {
				$scope.totalPresentations = matches.isFound;
			} else {
				$scope.totalPresentations = 0;
			}
		} );
		loadPresentations();
	}
} )( angular, InVision );;;
/*! project-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.ProjectController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, firebaseStateService, requestContext, $location, Deferred, projectService, projectDetailPartial, sessionService, modelEvents, moment, Debouncer, dateHelper, userService, validationService, _, config ) {
		$scope.views = {
			'activity': {
				view: 'overview/overview.htm'
			},
			'screens': {
				view: 'screens.htm'
			},
			'assets': {
				view: 'assets.htm'
			},
			'comments': {
				view: 'comments.htm'
			},
			'testing': {
				view: 'testing.htm'
			},
			'presentations': {
				cssClass: [ 'presentations' ],
				view: 'presentations.htm',
				autoscroll: true
			}
		};

		function applyRemoteData( project, projectStats, teamMembers, invitations, projectOwnerSubscription, userTeamSize, isUserAdminForProjectOwner, isProjectHiddenInActivity ) {
			$scope.project = project;
			$scope.projectStats = projectStats;
			$scope.canArchiveScreens = projectOwnerSubscription.canArchiveScreens;
			$scope.userTeamSize = userTeamSize;
			$scope.isProjectHiddenInActivity = isProjectHiddenInActivity;
			$scope.formAction = '/liveshare/create/' + project.id;
			if ( project.isSnap ) {
				$scope.subview = "snaps";
				$location.path( "/snaps" );
			}
			$scope.isOwnedByUser = ( $scope.project.userID === sessionService.user.id );
			$scope.isUserAdminForProjectOwner = isUserAdminForProjectOwner;
			$scope.isOverQuota = project.isOverQuota;
			$scope.isInGracePeriod = project.isInGracePeriod;
			if ( project.isInGracePeriod ) {
				var gracePeriodEndsAt = moment( projectOwnerSubscription.projectGracePeriodEndsAt );
				var daysRemaining = gracePeriodEndsAt.diff( moment(), "days" );
				var hasScreens = projectStats.screenCount > 0;
				$scope.gracePeriodDisplay.isShownInitially = !!hasScreens;
				$scope.gracePeriodDisplay.daysRemaining = daysRemaining;
			} else {
				$scope.gracePeriodDisplay.isShownInitially = false;
				$scope.gracePeriodDisplay.daysRemaining = 0;
			}
			$scope.ownersSubscription = projectOwnerSubscription;
			$scope.canArchiveProject = (
				$scope.ownersSubscription.canArchiveProjects &&
				(
					$scope.isOwnedByUser ||
					$scope.isUserAdminForProjectOwner
				)
			);
			$scope.teamMembers = augmentTeamMembers( teamMembers, project.userID );
			$scope.projectOwner = _.findWithProperty( $scope.teamMembers, "id", project.userID );
			$scope.invitations = invitations;
			updateExpirationStatus( projectOwnerSubscription.expiresAt );
			$scope.isMobile = project.isMobile;
			$scope.mobileDeviceID = project.mobileDeviceID;
			$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
			$scope.projectTypeIcon = getProjectTypeIconClass();
			$scope.projectTypeTitle = getProjectTypeTitle( $scope.deviceTemplate );
			$scope.isRecommendedSingle = getIsRecommendedSingle();
			$scope.showCollabTooltip = moment().diff( project.createdAt, "days" ) <= 5;
			$scope.updateProjectLastAccessed( $scope.project.id );
			modelEvents.trigger( "projectAccessed", {
				id: $scope.project.id,
				lastUpdatedByUserAt: moment.utc().valueOf()
			} );
		}

		function getProjectTypeIconClass() {
			if ( !$scope.deviceTemplate ) {
				return "";
			}
			return (
				$scope.deviceTemplate.deviceType.toLowerCase() + " " +
				$scope.deviceTemplate.platform.toLowerCase() + " " +
				$scope.deviceTemplate.orientation.toLowerCase()
			);
		}

		function getProjectTypeTitle( deviceTemplate ) {
			if ( !deviceTemplate ) {
				return ( "Project" );
			}
			if ( !deviceTemplate.mobileDeviceID ) {
				return "Desktop Project";
			} else if ( deviceTemplate.platform === "iOS" ) {
				return ( deviceTemplate.mobileSkin + " Project - " + _.capitalizeFirstLetter( deviceTemplate.orientation ) );
			} else {
				return ( deviceTemplate.platform + " Project - " + _.capitalizeFirstLetter( deviceTemplate.orientation ) );
			}
		}

		function getIsRecommendedSingle() {
			return _.size( $scope.recommendedSizes[ getProjectTypeIconClass() ] ) === 1 ? true : false;
		}

		function augmentTeamMembers( teamMembers, ownerUserID ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var teamMember = teamMembers[ i ];
				teamMember.isProjectOwner = ( teamMember.id === ownerUserID );
				teamMember.firstName = teamMember.name.split( /\s/ )[ 0 ];
				teamMember.tooltip = teamMember.name;
				teamMember.initials = userService.getInitials( teamMember.name );
				teamMember.hasSystemAvatar = userService.isSystemAvatar( teamMember.avatarID );
				if ( teamMember.isProjectOwner ) {
					teamMember.tooltip += " ( Owner )";
				}
				teamMember.onlineStatus = userService.getOnlineStatus( teamMember.lastRequestAt );
			}
			sortTeamMembers( teamMembers, ownerUserID );
			return ( teamMembers );
		}

		function doDataLoad( projectID ) {
			if (
				$scope.project &&
				( $scope.project.id === projectID ) &&
				!loadRemoteDataDebouncer.canProceed()
			) {
				return;
			}
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectDetailPartial.get( projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.project,
						response.projectStats,
						response.teamMembers,
						response.teamInvitations,
						response.projectOwnerSubscription,
						response.userTeamSize,
						response.isUserAdminForProjectOwner,
						response.isProjectHiddenInActivity
					);
					$timeout( function () {
						$scope.openNewProjectModalForSyncUsers( response.project );
					} );
					startTimerToRefreshRemoteData();
				},
				function ( error ) {
					if ( validationService.isMissingProjectPermission( error ) ) {
						$scope.openModalWindow( "requestPermission", $scope.projectID );
					} else if ( validationService.canJoinProject( error ) ) {
						$scope.openModalWindow( "joinTeamProject", projectID );
					} else {
						if ( validationService.isNotFound( error ) ) {
							var message = "Sorry, we could not find that project.";
						} else {
							var message = "For some reason, we can't load your project. Try refreshing your browser.";
						}
						if ( error.id ) {
							message += ( " [ID: " + error.id + "]" );
						}
						$scope.openModalWindow( "error", message );
					}
					$location.path( "/" );
					stopTimerToRefreshRemoteData();
				}
			);
		}

		function loadRemoteData() {
			if ( $scope.isSnap ) {
				$scope.projectPlaceholder = projectService.getSnapProject();
				var projectID = null;
				$scope.$watch( "projectPlaceholder", function ( newVal, oldVal ) {
					if ( newVal !== oldVal && !_.isUndefined( newVal ) && newVal !== 0 ) {
						projectID = newVal.id;
						doDataLoad( projectID );
					}
				} );
			} else {
				var projectID = requestContext.getParamAsInt( "projectID" );
				doDataLoad( projectID );
			}
		}

		function sortTeamMembers( teamMembers, ownerUserID ) {
			teamMembers.sort(
				function ( a, b ) {
					if ( a.id === ownerUserID ) {
						return ( -1 );
					} else if ( b.id === ownerUserID ) {
						return ( 1 );
					}
					return ( a.lastRequestAt < b.lastRequestAt ? 1 : -1 );
				}
			);
			return ( teamMembers );
		}

		function startTimerToRefreshRemoteData() {
			stopTimerToRefreshRemoteData();
			remoteDataTimer = $window.setInterval( loadRemoteData, ( 20 * 60 * 1000 ) );
		}

		function stopTimerToRefreshRemoteData() {
			$window.clearInterval( remoteDataTimer );
		}

		function updateExpirationStatus( expiresAt ) {
			$scope.expirationStatus.expiresAt = null;
			$scope.expirationStatus.isExpiring = false;
			$scope.expirationStatus.isExpiringSoon = false;
			$scope.expirationStatus.timeLeftInDays = 0;
			if ( expiresAt && ( parseInt( expiresAt ) > 0 ) ) {
				$scope.expirationStatus.expiresAt = new Date( expiresAt );
				$scope.expirationStatus.isExpiring = true;
				var now = new Date();
				var cutOffForDisplay = dateHelper.addDays( expiresAt, -5 );
				if ( now >= cutOffForDisplay ) {
					$scope.expirationStatus.isExpiringSoon = true;
					$scope.expirationStatus.timeLeftInDays = Math.ceil( ( expiresAt - now ) / ( 24 * 60 * 60 * 1000 ) );
				}
			}
		}

		function hideGracePeriodWarning() {
			$scope.gracePeriodDisplay.fadeOut = true;
		}
		angular.extend( $scope, {
			isLiveShareDdOpen: false
		} );
		var isIgnoreLSClick = false;
		$scope.toggleLiveShareDropdown = function () {
			if ( isIgnoreLSClick ) {
				isIgnoreLSClick = false;
				return;
			}
			$scope.isLiveShareDdOpen = !$scope.isLiveShareDdOpen;
		};
		$scope.closeCollabTooltip = function () {
			$scope.showCollabTooltip = false;
		};
		$scope.openNewProjectModalForSyncUsers = function ( project ) {
			if ( !newProjectSyncModalIsOpen && project.isMobile === "" ) {
				newProjectSyncModalIsOpen = true;
				$scope.openModalWindow( "changeProjectType", $scope.project, $scope.deviceTemplates );
			}
		};
		$scope.openChangeProjectTypeModal = function () {
			$scope.openModalWindow( "changeProjectType", $scope.project, $scope.deviceTemplates );
		};
		$scope.openAssetsIntro = function () {
			$scope.openModalWindow( "assetsIntro", $scope.project.id );
		};
		$scope.addTeamMembers = function () {
			if ( !$scope.isEnterprise ) {
				if ( $scope.userTeamSize > 1 ) {
					$scope.openModalWindow( "projectMembers", $scope.project.id );
				} else {
					$scope.openModalWindow( "bulkInviteProjectMembers", $scope.project.id );
				}
			} else if ( !$scope.isReviewer ) {
				$scope.openModalWindow( "enterpriseProjectMembers", $scope.project.id );
			}
		};
		$scope.archiveProject = function () {
			if ( $scope.canArchiveProject ) {
				$scope.openModalWindow( "archiveProject", $scope.project.id );
			} else if ( $scope.isOwnedByUser ) {
				$scope.openModalWindow( "archiveUpgrade" );
			} else if ( $scope.ownersSubscription.canArchiveProjects ) {
				$scope.openModalWindow( "error", "The project owner must give you Admin permissions before you can archive this project." );
			} else {
				$scope.openModalWindow( "error", "The project owner doesn't have the ability to archive projects." );
			}
		};
		$scope.openChangePlanModal = function ( showAllPlans ) {
			if ( showAllPlans == "undefined" ) {
				showAllPlans = false;
			}
			$scope.openModalWindow( "changePlan", {
				showAllPlans: showAllPlans,
				openedDueTo: "project quota"
			} );
		};
		$scope.openNewProjectModal = function () {
			$scope.openModalWindow( "newProject" );
		};
		$scope.deleteProject = function () {
			$scope.openModalWindow( "deleteProject", $scope.project.id );
		};
		$scope.duplicateProject = function () {
			$scope.openModalWindow( "duplicateProject", $scope.project );
		};
		$scope.exportPDF = function () {
			if ( $scope.getOwnersSubscription().canExportPDF ) {
				$scope.openModalWindow( "exportPDF", $scope.project.id );
			} else {
				$scope.openModalWindow( "exportPDF_Upgrade", $scope.project.id );
			}
		};
		$scope.getOwnersSubscription = function () {
			return $scope.ownersSubscription;
		};
		$scope.openMobileTipsModal = function ( a, b ) {
			$scope.openModalWindow( "mobileTips", $scope.deviceTemplate );
		};
		$scope.hideInActivityTimeline = function () {
			$scope.isProjectHiddenInActivity = true;
			projectService.setIsHiddenInTimeline( $scope.project.id, true );
		};
		$scope.showInActivityTimeline = function () {
			$scope.isProjectHiddenInActivity = false;
			projectService.setIsHiddenInTimeline( $scope.project.id, false );
		};
		$scope.openLiveShare = function ( isFromDropdown ) {
			if ( isFromDropdown ) {
				isIgnoreLSClick = true;
				$scope.isLiveShareDdOpen = false;
			}
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan", {
							openedDueTo: "project quota"
						} )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			} else if ( !$scope.projectStats.screenCount ) {
				return (
					$scope.openModalWindow( "error", "You can't LiveShare this project until at least one screen has been uploaded." )
				);
			}
			if ( $scope.user.hasClosedLiveshareIntro ) {
				if ( $scope.firebase.currentTarget != null && $scope.firebase.participants > 0 ) {
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.firebase.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.firebase.node + "/redirectTarget" );
					fbRedirectTarget.set( $scope.project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.firebase.currentTarget, $scope.firebase.conferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else if ( $scope.firebase.currentTarget != null ) { // if the presenter is the only one in the LiveShare, just reuse that tab
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.firebase.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.firebase.node + "/redirectTarget" );
					fbRedirectTarget.set( $scope.project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() == "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.firebase.currentTarget );
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else { // if not, force a new target
					$scope.firebase.target = "liveshare_" + firebaseStateService.guid();
					firebaseStateService.setTarget( $scope.firebase.target );
					$scope.$broadcast( "autosubmit-#liveshareProject", $scope.firebase.target );
				}
			} else {
				$scope.openModalWindow( "liveshare-intro", $scope.project.id );
			}
		};
		$scope.openShareModal = function ( subview ) {
			subview = subview || "new";
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan", {
							openedDueTo: "project quota"
						} )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			} else if ( !$scope.projectStats.screenCount ) {
				return (
					$scope.openModalWindow( "error", "You can't share this project until at least one screen has been uploaded." )
				);
			}
			$scope.openModalWindow( "share", $scope.project.id, 0, subview, $scope.selectedScreens );
		};
		$scope.openConsole = function ( projectId, screenItemId, mode ) {
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					$scope.openModalWindow( "changePlan", {
						openedDueTo: "project quota"
					} );
				} else {
					$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." );
				}
			} else {
				$location.path( "/console/" + projectId + "/" + screenItemId + "/" + mode );
			}
		};
		$scope.saveProjectOffline = function () {
			$scope.openModalWindow( "saveProjectOffline" );
		};
		$scope.showPresentationTab = function () {
			return $scope.user.email.indexOf( "@invisionapp.com" ) > -1 || $scope.user.toursBetaProgram;
		};
		$scope.transferProject = function () {
			$scope.openModalWindow( "transferProject", $scope.project.id );
		};
		$scope.leaveProject = function () {
			Deferred.handlePromise(
				projectService.removeUserFromProject( $scope.project.id, $scope.user.id ),
				function ( response ) {
					$location.path( "/" );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, you have not left your project. Try refreshing your browser." );
				}
			);
		};
		$scope.viewProject = function ( $event ) {
			if ( $scope.project.isOverQuota ) {
				$event.preventDefault();
				if ( $scope.isOwnedByUser ) {
					$scope.openModalWindow( "changePlan", {
						openedDueTo: "project quota"
					} );
				} else {
					$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." );
				}
			} else if ( !$scope.projectStats.screenCount ) {
				$event.preventDefault();
				$scope.openModalWindow( "error", "You can't view this project until at least one screen has been uploaded." );
			}
		};
		$scope.getCurrentProject = function () {
			return $scope.project;
		};
		$scope.shouldShowGracePeriodWarning = function () {
			if ( !$scope.isInGracePeriod ) {
				return false;
			}
			if ( $scope.gracePeriodDisplay.isShownInitially ) {
				return true;
			} else if ( $scope.gracePeriodDisplay.daysRemaining <= 5 ) {
				return true;
			} else {
				return ( $scope.gracePeriodDisplay.firstScreenUploaded );
			}
		};
		$scope.shouldFadeGracePeriodWarning = function () {
			return ( false );
		};
		$scope.toggleArchivedScreens = function () {
			$scope.isShowingArchivedScreens = !$scope.isShowingArchivedScreens;
		};
		$scope.openLiveEmbedModal = function ( screenID ) {
			$scope.openModalWindow( "liveEmbed", screenID );
		};
		$scope.setSelectedScreens = function ( screens ) {
			$scope.selectedScreens = screens;
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail", "projectID" );
		var remoteDataTimer = null;
		var fbStatusRef;
		var fbRedirectTarget;
		if ( $location.search().hasOwnProperty( "showAcceptConfirmation" ) ) {
			$scope.openModalWindow( "teamInviteJoinedConfirmation", $location.search() );
		}
		$scope.selectedScreens = [];
		$scope.isLoading = false;
		$scope.project = null;
		$scope.formAction = null;
		$scope.projectStats = null;
		$scope.isOwnedByUser = false;
		$scope.teamMembers = [];
		$scope.canArchiveProject = false;
		$scope.canArchiveScreens = false;
		$scope.firebase = firebaseStateService.getState();
		$scope.isInGracePeriod = false;
		$scope.isSnap = $scope.subview === "snaps" ? true : false;
		$scope.gracePeriodDisplay = {
			daysRemaining: null,
			isShownInitially: false,
			screenCount: 0,
			firstScreenUploaded: false
		};
		$scope.isOverQuota = false;
		$scope.expirationStatus = {
			expiresAt: null,
			isExpiring: false,
			isExpiringSoon: false,
			timeLeftInDays: 0
		};
		$scope.showCollabTooltip = false;
		$scope.collaboratorsInvited = 0;
		$scope.userTeamSize = 0;
		$scope.subview = ( renderContext.getNextSection() || "screens" );
		var loadRemoteDataDebouncer = new Debouncer( Debouncer.THREE_SECONDS );
		var newProjectSyncModalIsOpen = false;
		$scope.projectTypeIcon = "";
		$scope.projectTypeTitle = "";
		$scope.projectPlaceholder = null;
		$scope.recommendedSizes = {
			"phone ios portrait": {
				"iPhone 4 & 5": {
					"width": "640px",
					"height": "Any"
				}
			},
			"phone ios landscape": {
				"iPhone 5": {
					"width": "1136px",
					"height": "Any"
				},
				"iPhone 4": {
					"width": "960px",
					"height": "Any"
				}
			},
			"tablet ios portrait": {
				"iPad": {
					"width": "1536px",
					"height": "Any"
				}
			},
			"tablet ios landscape": {
				"iPad": {
					"width": "2048px",
					"height": "Any"
				}
			},
			"phone android portrait": {
				"Android 720p": {
					"width": "720px",
					"height": "Any"
				},
				"Android 1080p": {
					"width": "1080px",
					"height": "Any"
				}
			},
			"phone android landscape": {
				"Android 720p": {
					"width": "1280px",
					"height": "Any"
				},
				"Android 1080p": {
					"width": "1920px",
					"height": "Any"
				}
			}
		};
		$scope.isShowingArchivedProjects = false;
		$scope.$on(
			"$destroy",
			function () {
				stopTimerToRefreshRemoteData();
				modelEvents.off( "projectDeleted.projectDetail" );
				modelEvents.off( "projectUpdated.projectDetail" );
				modelEvents.off( "projectUserAdded.projectDetail" );
				modelEvents.off( "projectUsersAdded.projectDetail" );
				modelEvents.off( "projectUserRemoved.projectDetail" );
				modelEvents.off( "projectUsersRemoved.projectDetail" );
				modelEvents.off( "screenUploaded.projectDetail" );
				modelEvents.off( "subscriptionChanged.projectDetail" );
			}
		);
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.firebase = data;
			if ( !$scope.firebase.debug && $scope.user.email.indexOf( "@invisionapp.com" ) > -1 ) {
				$scope.firebase.featureFlags.notifications = true;
				$scope.firebase.featureFlags.scheduledLiveShare = true;
				$scope.firebase.featureFlags.userTesting = true;
			}
		} );
		$scope.$watch( "subview", function () {
			$scope.firebase = firebaseStateService.getState();
			if ( !$scope.firebase.debug && $scope.user.email.indexOf( "@invisionapp.com" ) > -1 ) {
				$scope.firebase.featureFlags.notifications = true;
				$scope.firebase.featureFlags.scheduledLiveShare = true;
				$scope.firebase.featureFlags.userTesting = true;
			}
		} );
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeLocal() ) {
					$scope.clearSecondaryBodyClass();
				}
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if (
					requestContext._previousAction === "standard.project.detail.assets" &&
					requestContext._action === "standard.project.detail.screens.list.upload" ) {
					$timeout( function () {
						$scope.$broadcast( "showProjectUploader" );
					} );
				}
				$scope.subview = ( renderContext.getNextSection() || "screens" );
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on(
			"projectDeleted.projectDetail",
			function ( event, projectID ) {
				if ( projectID !== $scope.project.id ) {
					return;
				}
				$location.path( "/" );
			}
		);
		modelEvents.on(
			"projectUpdated.projectDetail",
			function ( event, project ) {
				if ( project.id !== $scope.project.id ) {
					return;
				}
				if ( project.isArchived ) {
					return ( $location.path( "/" ) );
				}
				if ( project.userID !== $scope.project.userID ) {
					return ( loadRemoteData() );
				}
				$scope.project.name = project.name;
				$scope.project.isMobile = project.isMobile;
				$scope.project.mobileDeviceID = project.mobileDeviceID;
				$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
				$scope.projectTypeIcon = getProjectTypeIconClass();
				$scope.projectTypeTitle = getProjectTypeTitle( $scope.deviceTemplate );
				$scope.isRecommendedSingle = getIsRecommendedSingle();
			}
		);
		modelEvents.on(
			[
				"projectUserAdded.projectDetail",
				"projectUsersAdded.projectDetail",
				"projectInviteesAdded.projectDetail"
			],
			function ( event, projectID, userIDs ) {
				if ( !_.isNull( $scope.project ) &&
					projectID === $scope.project.id ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on(
			[
				"projectUserRemoved.projectDetail",
				"projectUsersRemoved.projectDetail",
				"projectInviteesRemoved.projectDetail"
			],
			function ( event, projectID, userIDs ) {
				if ( projectID === $scope.project.id ) {
					if ( !ng.isArray( userIDs ) ) {
						userIDs = [ userIDs ];
					}
					$scope.teamMembers = _.withoutPropertyRange( $scope.teamMembers, "id", userIDs );
					$scope.invitations = _.withoutPropertyRange( $scope.invitations, "id", userIDs );
				}
			}
		);
		modelEvents.on(
			"screenUploaded.projectDetail",
			function ( event, screen ) {
				if ( screen.projectID !== $scope.project.id ) {
					return;
				}
				$scope.projectStats.screenCount++;
				if ( $scope.isInGracePeriod && ( $scope.projectStats.screenCount === 1 ) ) {
					$scope.gracePeriodDisplay.firstScreenUploaded = true;
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged.projectDetail",
			function ( event, newPlan ) {
				loadRemoteData();
			}
		);
		$scope.setWindowTitle( "Loading Project" );
		$scope.setSecondaryBodyClass( "page_project" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! screen-object-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	/*
With the introduction of dividers, this controller servers multiple
purposes depending on what type of object it's controlling.  The
displayObjects array contains screens, dividers, and divider_placeholders.
This controller is used for all types.
*/
	app.controller( "project.ScreenObjectController", Controller );
	/** @ngInject */
	function Controller( $scope, _ ) {
		$scope.startEditingScreenDividerLabel = function () {
			if ( !$scope.isReviewer ) {
				$scope.isEditingDividerLabel = true;
			}
		};
		$scope.finishEditingScreenDividerLabel = function () {
			$scope.isEditingDividerLabel = false;
		};
		$scope.hideArchiveConfirmation = function () {
			$scope.isShowingArchiveConfirmation = false;
		};
		$scope.hideDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = false;
		};
		$scope.showArchiveConfirmation = function () {
			$scope.isShowingArchiveConfirmation = true;
		};
		$scope.showDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = true;
		};
		$scope.isEditingDividerLabel = false;
		$scope.isShowingDeleteConfirmation = false;
		$scope.isShowingArchiveConfirmation = false;
		if ( $scope.object && $scope.object.dividerID && isNaN( $scope.object.dividerID ) ) {
			$scope.startEditingScreenDividerLabel();
		}
		if ( $scope.object && $scope.object.parentAssetID ) {
			$scope.parentAsset = _.find( $scope.layerSyncAssets, {
				"id": $scope.object.parentAssetID
			} );
		}
	}
} )( angular, InVision );;;
/*! screens-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.ScreensController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, $timeout, $q, requestContext, Deferred, screenService, projectService, projectsProjectsPartial, projectDetailPartial, screenDividerService, projectScreensPartial, modelEvents, hashKeyCopier, dateHelper, userService, layersyncService, userPreferenceService, _, $filter, validationService ) {
		function applyFiltersToUrl() {
			var screensFilter = $scope.filters.screensFilter;
			if ( screensFilter ) {
				$location.search( "screensFilter", screensFilter );
			} else {
				$location.search( "screensFilter", null );
			}
		}

		function getBestSearchFilter() {
			return ( $location.search().screensFilter || "" );
		}

		function clearScreensFilter() {
			$scope.filters.screensFilter = "";
		}

		function addUploadedScreen( screen ) {
			var existingScreen = _.findWithProperty( $scope.screens, "id", screen.id );
			screen = augmentScreen( screen );
			if ( existingScreen ) {
				delete( screen.isSelectedForBulkAction );
				delete( screen.conversationCount );
				delete( screen.unreadConversationCount );
				_.extendExistingProperties( existingScreen, screen );
			} else {
				$scope.screens.push( screen );
			}
			if ( screen.parentAssetID ) {
				refreshLayerSyncInfo();
				var srcKey = screen.parentAssetID + ":" + screen.clientFilename;
				$scope.layerSyncTempSources = _.withoutProperty( $scope.layerSyncTempSources, "srcKey", srcKey );
			}
			if ( $scope.deferredLimit < $scope.displayObjects.length ) {
				$scope.deferredLimit = $scope.displayObjects.length;
			}
			applyScreens();
			$scope.mergeScreensAndDividers();
			$scope.removeDividerPlaceholders();
			$scope.insertDividerPlaceholders();
			setupScreenStatusFilterOptions();
		}

		function applyRemoteData( screens, dividers, layersync ) {
			if ( $scope.isSnap ) {
				$scope.isShowingRegularScreenSize = true;
				$scope.isShowingSmallScreenSize = false;
				$scope.screenSize = "regular";
			} else {
				$scope.isShowingRegularScreenSize = $scope.project.viewScreensAsThumbnails;
				$scope.isShowingSmallScreenSize = !$scope.project.viewScreensAsThumbnails;
				$scope.screenSize = $scope.isShowingRegularScreenSize ? "regular" : "small";
			}
			$scope.selectedScreenCount = 0;
			$scope.screens = augmentScreens( hashKeyCopier.copyHashKeys( $scope.screens, screens ) );
			applyScreens();
			$scope.dividers = hashKeyCopier.copyHashKeys( $scope.dividers, dividers );
			$scope.mergeScreensAndDividers();
			$scope.applyDividerScreenCounts();
			$scope.insertDividerPlaceholders();
			updateExpandedProperties();
			setupScreenStatusFilterOptions();
			$scope.filters.screensFilter = getBestSearchFilter();
			$scope.setWindowTitle( $scope.project.name + " Screens" );
			for ( var a = 0; a < layersync.length; a++ ) {
				layersync[ a ].formattedUpdatedAt = dateHelper.formatRecentDate( layersync[ a ].updatedAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( layersync[ a ].updatedAt, 'h:mmtt' );
				if ( layersync[ a ].status == "pending" ) {
					var sourceObj = {
						asset: {
							id: layersync[ a ].assetID,
							clientFilename: layersync[ a ].clientFilename
						},
						info: layersync[ a ].info,
						status: layersync[ a ].status
					};
					addUploadedSource( sourceObj );
				}
			}
			$scope.layerSyncAssets = layersync;
		}

		function updateExpandedProperties() {
			var isDividerExpanded = true;
			for ( var i = 0; i < $scope.displayObjects.length; i++ ) {
				var isDivider = $scope.displayObjects[ i ].type === "divider" ? true : false;
				if ( isDivider ) {
					isDividerExpanded = $scope.displayObjects[ i ].expanded;
				}
				if ( $scope.displayObjects[ i ].type === "screenObj" || $scope.displayObjects[ i ].type === "mobileUploadTile" || $scope.displayObjects[ i ].type === "inline_drop_zone" ) {
					$scope.displayObjects[ i ].expanded = isDividerExpanded;
				}
			}
		}

		function applyScreens() {
			$scope.activeScreens = getActiveScreens();
			$scope.archivedScreens = getArchivedScreens();
			if ( !$scope.isCheckProcessingScreens && getProcessingScreens().length ) {
				checkProcessingScreens();
			}
			$scope.screens = sortScreens( $scope.screens );
			$scope.activeScreens = sortScreens( $scope.activeScreens );
			$scope.archivedScreens = sortArchivedScreens( $scope.archivedScreens );
			if ( !$scope.activeScreens.length && !$scope.layerSyncTempSources.length ) {
				$scope.isShowingUploader = true;
			}
			$scope.updateSelectedScreenCount();
			if (
				( $scope.subview === "archive" ) &&
				!$scope.archivedScreens.length
			) {
				$location.path( "/projects/" + $scope.projectID + "/screens" );
			}
			setupScreenStatusFilterOptions();
		}

		function augmentScreen( screen ) {
			if ( !screen.hasOwnProperty( "isSelectedForBulkAction" ) ) {
				screen.isSelectedForBulkAction = false;
			}
			if ( !screen.hasOwnProperty( "conversationCount" ) ) {
				screen.conversationCount = 0;
				screen.unreadConversationCount = 0;
			}
			if ( !screen.hasOwnProperty( "expanded" ) ) {
				screen.expanded = true;
			}
			if ( /^\s+$/i.test( screen.name ) ) {
				screen.name = "[No Name]";
			}
			screen.niceUpdatedAt = dateHelper.formatRelativeWithinMonth( screen.updatedAt );
			screen.workflowStatus = "In Progress";
			screen.isCompleted = false;
			screen.isApproved = false;
			if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE ) {
				screen.workflowStatus = "Needs Review";
				screen.isCompleted = true;
				screen.isApproved = false;
			} else if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE_AND_APPROVED ) {
				screen.workflowStatus = "Approved";
				screen.isCompleted = false;
				screen.isApproved = true;
			}
			var hasUpdatedByUserInfo = ( _.has( screen, "updatedByUserName" ) || _.has( screen, "updatedByAvatarID" ) );
			if ( !hasUpdatedByUserInfo && screen.hasOwnProperty( "teamMembers" ) ) {
				var teamMember = _.findWithProperty( $scope.teamMembers, "id", screen.userID );
				screen.updatedByUserName = teamMember.name;
				screen.updatedByAvatarID = teamMember.avatarID;
			}
			if ( screen.hasOwnProperty( "updatedByUserName" ) ) {
				screen.updatedByUserInitials = userService.getInitials( screen.updatedByUserName );
			}
			if ( !_.isUndefined( screen.updatedByAvatarID ) ) {
				screen.updatedByUserHasSystemAvatar = userService.isSystemAvatar( screen.updatedByAvatarID );
			} else {
				screen.updatedByUserHasSystemAvatar = false;
			}
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			sortScreens( screens );
			return ( screens );
		}

		function checkProcessingScreens() {
			$scope.isCheckProcessingScreens = true;
			var screenCountBeforeCheck = $scope.screens.length;
			var handleSuccess = function ( processingStatus ) {
				_.setProperty( $scope.screens, "isProcessed", true );
				var pendingScreenIDs = _.pluck( processingStatus.screens, "id" );
				if ( pendingScreenIDs.length ) {
					var pendingScreens = _.withPropertyRange( $scope.screens, "id", pendingScreenIDs );
					_.setProperty( pendingScreens, "isProcessed", false );
				}
				if ( pendingScreenIDs.length || ( $scope.screens.length !== screenCountBeforeCheck ) ) {
					thumbnailTimer = $timeout( checkProcessingScreens, Math.floor( thumbnailTimerPause ) );
					thumbnailTimerPause *= 1.2;
				} else {
					$scope.isCheckProcessingScreens = false;
					thumbnailTimerPause = 2000;
				}
				applyScreens();
			};
			var handleError = function ( error ) {
				$scope.openModalWindow( "error", "For some reason, we can't check your screen status. Try refreshing your browser." );
			};
			screenService.getProcessingStatus( $scope.projectID ).then( handleSuccess, handleError );
		}

		function doDataLoad( projectID ) {
			Deferred.handlePromise(
				projectScreensPartial.get( projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.screens, response.dividers, response.layersync );
				},
				function ( response ) {
					if ( !( validationService.isMissingProjectPermission( response ) || validationService.canJoinProject( response ) ) ) {
						$scope.openModalWindow( "error", "For some reason we couldn't load your screens. Try refreshing your browser." );
					}
				}
			);
		}

		function getActiveScreens() {
			return _.withoutProperty( $scope.screens, "isArchived", true );
		}

		function getArchivedScreens() {
			return _.withProperty( $scope.screens, "isArchived", true );
		}

		function getProcessingScreens() {
			return _.withoutProperty( $scope.screens, "isProcessed", true );
		}

		function getSelectedScreens() {
			return _.filterWithProperty( $scope.screens, "isSelectedForBulkAction", true );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			$scope.state = $scope.states.READY;
			$scope.isCheckProcessingScreens = false;
			$scope.deferredLimit = 20;
			$scope.loadScreenIncrement = 40;
			$scope.isLoadingScreens = true;
			$scope.isScrolling = false;
			$scope.projectPlaceholder = null;
			resetSelectedScreens();
			$scope.isShowingUploader = false;
			if ( $scope.isSnap ) {
				$scope.projectPlaceholder = projectService.getSnapProject();
				var projectID = null;
				$scope.$watch( "projectPlaceholder", function ( newVal, oldVal ) {
					if ( newVal !== oldVal && !_.isUndefined( newVal ) && newVal !== 0 ) {
						projectID = newVal.id;
						$scope.projectID = projectID;
						doDataLoad( projectID );
					}
				} );
			} else {
				doDataLoad( requestContext.getParamAsInt( "projectID" ) );
			}
			updateShowScreenSourceModalPreference();
		}

		function setSelectionOnAllScreensInBetween( isSelected, startScreen, endScreen ) {
			var startScreenIndex = $scope.displayObjects.indexOf( startScreen ) + 1;
			var endScreenIndex = $scope.displayObjects.indexOf( endScreen );
			var startIndex = Math.min( startScreenIndex, endScreenIndex );
			var endIndex = Math.max( startScreenIndex, endScreenIndex );
			for ( var i = startIndex; i < endIndex; i++ ) {
				if ( $scope.displayObjects[ i ].type !== "divider" ) {
					$scope.displayObjects[ i ].isSelectedForBulkAction = isSelected;
				}
			}
		}

		function sortDividers( dividers ) {
			$scope.dividers.sort( function ( x, y ) {
				var n = x.position - y.position;
				if ( n !== 0 ) {
					return n;
				}
				return x.sort - y.sort;
			} );
		}

		function resortDividers( mergeScreens ) {
			mergeScreens = typeof mergeScreens !== 'undefined' ? mergeScreens : true;
			var newSort = 1;
			for ( var i = 0; i < $scope.dividers.length; i++ ) {
				$scope.dividers[ i ].sort = newSort;
				newSort++;
			}
			if ( mergeScreens ) {
				$scope.removeDividerPlaceholders();
				$scope.mergeScreensAndDividers();
				$scope.insertDividerPlaceholders();
				$scope.persistDividerPositions();
			} else {
				sortDividers();
			}
		}

		function sortScreens( screens ) {
			return _.sortOnProperty( screens, "sort" );
		}

		function sortArchivedScreens( screens ) {
			return (
				_.sortOnProperty( screens, "updatedAt", "desc" )
			);
		}

		function updateScreensSort( screenIds, screens ) {
			var sortOrder = 1;
			_.each(
				screenIds,
				function ( screenID ) {
					var screen = _.findWithProperty( screens, "id", screenID );
					screen.sort = sortOrder;
					sortOrder++;
				}
			);
		}

		function resetSelectedScreens() {
			$scope.setSelectedScreens( [] );
			$scope.selectedScreenCount = 0;
			_.setProperty( $scope.displayObjects, "isSelectedForBulkAction", false );
		}

		function updateScreenInCollection( screen ) {
			var matchingScreen = _.findWithProperty( $scope.screens, "id", screen.id );
			if ( matchingScreen ) {
				_.extendExistingProperties( matchingScreen, screen );
			}
		}

		function toggleSelectedScreensInSection( divider, selected ) {
			var screensInSection = getScreensInSection( divider );
			var customScreenStatusFilter = $filter( 'customScreenStatusFilter' )( screensInSection, $scope.filters.screenStatusFilter.activeFilter );
			var filteredScreens = $filter( 'customScreensFilter' )( customScreenStatusFilter, $scope.filters.screensFilter );
			_.setProperty( filteredScreens, "isSelectedForBulkAction", selected );
			$scope.updateSelectedScreenCount();
		}

		function getScreensInSection( object ) {
			if ( object.type !== "divider" ) {
				return [];
			}
			var screensInSection = [];
			var thisPosition = _.indexOfWithProperty( $scope.displayObjects, "dividerID", object.dividerID );
			var objects = $scope.displayObjects.slice( thisPosition + 1 );
			var nextDividerPosition = _.indexOfWithProperty( objects, "type", "divider" );
			if ( nextDividerPosition >= 0 ) {
				screensInSection = objects.slice( 0, Math.max( 0, nextDividerPosition ) );
			} else {
				screensInSection = objects;
			}
			screensInSection = _.withProperty( screensInSection, "type", "screenObj" );
			return ( screensInSection );
		}

		function getDropZonesInSection( object ) {
			if ( object.type !== "divider" ) {
				return [];
			}
			var dropZonesInSection = [];
			var thisPosition = _.indexOfWithProperty( $scope.displayObjects, "dividerID", object.dividerID );
			var objects = $scope.displayObjects.slice( thisPosition + 1 );
			var nextDividerPosition = _.indexOfWithProperty( objects, "type", "divider" );
			if ( nextDividerPosition >= 0 ) {
				dropZonesInSection = objects.slice( 0, Math.max( 0, nextDividerPosition ) );
			} else {
				dropZonesInSection = objects;
			}
			dropZonesInSection = _.withProperty( dropZonesInSection, "type", "inline_drop_zone" );
			return ( dropZonesInSection );
		}

		function getDividerPlaceholdersInSection( object ) {
			if ( object.type !== "divider" ) {
				return [];
			}
			var dividerPlaceholdersInSection = [];
			var thisPosition = _.indexOfWithProperty( $scope.displayObjects, "dividerID", object.dividerID );
			var objects = $scope.displayObjects.slice( thisPosition + 1 );
			var nextDividerPosition = _.indexOfWithProperty( objects, "type", "divider" );
			if ( nextDividerPosition >= 0 ) {
				dividerPlaceholdersInSection = objects.slice( 0, Math.max( 0, nextDividerPosition ) );
			} else {
				dividerPlaceholdersInSection = objects;
			}
			dividerPlaceholdersInSection = _.withProperty( dividerPlaceholdersInSection, "type", "divider_placeholder" );
			return ( dividerPlaceholdersInSection );
		}

		function getActiveScreensInSection( object ) {
			if ( object.type !== "divider" ) {
				return [];
			}
			var screensInSection = [];
			var startDividerIndex = _.indexOfWithProperty( $scope.dividers, "dividerID", object.dividerID );
			var endDividerIndex = startDividerIndex + 1;
			var endDivider = $scope.dividers[ endDividerIndex ];
			if ( typeof endDivider != 'undefined' ) {
				var endPosition = endDivider.position;
			} else {
				var endPosition = $scope.activeScreens.length;
			}
			for ( var i = object.position; i < endPosition; i++ ) {
				screensInSection.push( $scope.activeScreens[ i ] );
			}
			return ( screensInSection );
		}

		function markPartiallySelectedSections() {
			_.each(
				$scope.displayObjects,
				function forEachDisplayObject( object ) {
					if ( object.type === "divider" ) {
						var screensInSection = getScreensInSection( object );
						var selectedScreenCount = _.withProperty( screensInSection, "isSelectedForBulkAction", true ).length;
						var screenCount = screensInSection.length;
						if ( screenCount === 0 ) {
							object.isSelectedForBulkAction = false;
							object.isPartiallySelected = false;
						} else if ( selectedScreenCount == screenCount ) {
							object.isSelectedForBulkAction = true;
							object.isPartiallySelected = false;
						} else if ( selectedScreenCount > 0 ) {
							object.isSelectedForBulkAction = false;
							object.isPartiallySelected = true;
						} else {
							object.isSelectedForBulkAction = false;
							object.isPartiallySelected = false;
						}
					}
				}
			);
		}

		function setupScreenStatusFilterOptions() {
			if ( $scope.filters.screenStatusFilter.activeFilter.workflowStatusID === 0 && $scope.filters.screenStatusFilter.activeFilter.label == "All Screens" ) {
				$scope.filters.screenStatusFilter.activeFilter.count = $scope.activeScreens.length;
			} else if ( $scope.filters.screenStatusFilter.activeFilter.workflowStatusID === 0 && $scope.filters.screenStatusFilter.activeFilter.label == "Without Hotspots" ) {
				$scope.filters.screenStatusFilter.activeFilter.count = _.withProperty( $scope.activeScreens, "hotspotCount", 0 ).length;
			} else {
				$scope.filters.screenStatusFilter.activeFilter.count = _.withProperty( $scope.activeScreens, "workflowStatusID", $scope.filters.screenStatusFilter.activeFilter.workflowStatusID ).length;
			}
			angular.forEach( $scope.filters.screenStatusFilter.options, function ( option ) {
				if ( option.workflowStatusID === 0 && option.label == "All Screens" ) {
					option.count = $scope.activeScreens.length;
				} else if ( option.workflowStatusID === 0 && option.label == "Without Hotspots" ) {
					option.count = _.withProperty( $scope.activeScreens, "hotspotCount", 0 ).length;
				} else {
					option.count = _.withProperty( $scope.activeScreens, "workflowStatusID", option.workflowStatusID ).length;
				}
			} );
		}

		function refreshLayerSyncInfo() {
			Deferred.handlePromise(
				layersyncService.items( $scope.projectID, -1 ),
				function ( response ) {
					$scope.layerSyncAssets = response;
					for ( var a = 0; a < $scope.layerSyncAssets.length; a++ ) {
						$scope.layerSyncAssets[ a ].formattedUpdatedAt = dateHelper.formatRecentDate( $scope.layerSyncAssets[ a ].updatedAt, 'mmm dd' ) + ' at ' + dateHelper.formatTime( $scope.layerSyncAssets[ a ].updatedAt, 'h:mmtt' );
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your screen source files. Try refreshing your browser." );
				}
			);
		}

		function updateShowScreenSourceModalPreference() {
			userPreferenceService.getPreferenceTypeByName( $scope.showScreenSourceModalPrefName, true, 'boolean' ).then(
				function ( response ) {
					userPreferenceService.getUserPreferenceById( response.data.id ).then(
						function ( valueResponse ) {
							$scope.showScreenSourceModal = ( valueResponse.exists !== "true" || valueResponse.data.value == 1 );
						}
					);
				} );
		}

		function addUploadedSource( sourceObj ) {
			refreshLayerSyncInfo();
			if ( ( sourceObj.status != "pending" && sourceObj.status != "uploaded" ) || !sourceObj.info.hasOwnProperty( "screens" ) ) {
				return;
			}
			var tgtScreens = sourceObj.info.screens;
			for ( var i = 0; i < tgtScreens.length; i++ ) {
				var screenObj = _.findWithProperty( $scope.screens, "clientFilename", tgtScreens[ i ].imagename );
				if ( screenObj ) {
					if ( screenObj.parentAssetJobID != sourceObj.info.jobid ) {
						screenObj.isProcessed = false;
					}
				} else {
					var screenObj = {
						name: tgtScreens[ i ].imagename,
						niceUpdatedAt: "Now",
						clientFilename: tgtScreens[ i ].imagename,
						parentAssetID: sourceObj.asset.id,
						parentAssetName: sourceObj.asset.clientFilename,
						srcKey: sourceObj.asset.id + ":" + tgtScreens[ i ].imagename
					};
					if ( sourceObj.status == "uploaded" ) {
						screenObj.srcKey = sourceObj.asset.id;
					} else {
						$scope.layerSyncTempSources = _.withoutProperty( $scope.layerSyncTempSources, "srcKey", sourceObj.asset.id );
					}
					$scope.layerSyncTempSources = _.withoutProperty( $scope.layerSyncTempSources, "srcKey", screenObj.srcKey );
					$scope.layerSyncTempSources.push( screenObj );
				}
				applyScreens();
				$scope.mergeScreensAndDividers();
				$scope.insertDividerPlaceholders();
			}
		}
		$scope.applyDividerScreenCounts = function () {
			angular.forEach(
				$scope.displayObjects,
				function ( displayObject ) {
					if ( displayObject.type === "divider" ) {
						var objectsInSection = getScreensInSection( displayObject );
						var screenCount = 0;
						angular.forEach( objectsInSection, function ( object ) {
							if ( object.type === "screenObj" ) {
								screenCount++;
							}
						} );
						displayObject.screenCount = screenCount;
					}
				}
			);
		};
		$scope.copySelectedToNewProject = function () {
			var newProjectDeferred = $q.defer();
			var newProjectPromise = newProjectDeferred.promise;
			$scope.openModalWindow( "newProject", newProjectDeferred );
			newProjectPromise.then( $scope.copySelectedToProject );
		};
		$scope.copySelectedToProject = function ( project ) {
			var selectedScreens = getSelectedScreens();
			for ( var i = 0, len = selectedScreens.length; i < len; i++ ) {
				selectedScreens[ i ].copyingProgress = 1;
				selectedScreens[ i ].copyingTo = project.name;
				selectedScreens[ i ].isSelectedForBulkAction = false;
			}
			$scope.updateSelectedScreenCount();
			Deferred.handlePromise(
				screenService.copyScreensToProject( _.pluck( selectedScreens, "id" ).join( "," ), project.id ),
				function ( response ) {
					for ( var j = 0, len = selectedScreens.length; j < len; j++ ) {
						selectedScreens[ j ].copyingProgress = 100;
					}
					$timeout( function () {
						for ( var x = 0, len = selectedScreens.length; x < len; x++ ) {
							delete selectedScreens[ x ].copyingProgress;
							delete selectedScreens[ x ].copyingTo;
						}
					}, 600 );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't copy the selected screens. Try refreshing your browser." );
				}
			);
		};
		$scope.moveSelectedToSection = function ( divider ) {
			var selectedScreens = getSelectedScreens();
			var splicedOutScreens = [];
			_.each(
				selectedScreens,
				function ( screen ) {
					var screenIndex = $scope.displayObjects.indexOf( screen );
					var splicedOutScreen = _.first( $scope.displayObjects.splice( screenIndex, 1 ) );
					splicedOutScreens.push( screen );
				}
			);
			var screensInSection = getScreensInSection( divider );
			var lastScreenInSection = _.last( screensInSection ) ? _.last( screensInSection ) : false;
			var lastScreenIndex = 0;
			if ( lastScreenInSection ) {
				lastScreenIndex = $scope.displayObjects.indexOf( lastScreenInSection );
			} else {
				lastScreenIndex = _.indexOfWithProperty( $scope.displayObjects, "dividerID", divider.dividerID );
			}
			$scope.displayObjects.splice.apply( $scope.displayObjects, [ ( lastScreenIndex + 1 ), 0 ].concat( splicedOutScreens ) );
			resetSelectedScreens();
			$scope.$emit( "activeScreens:sortUpdate" );
			applyScreens();
			$scope.mergeScreensAndDividers();
			$scope.removeDividerPlaceholders();
			$scope.mergeScreensAndDividers();
			$scope.insertDividerPlaceholders();
			$scope.updateDividerPositions();
			$scope.persistDividerPositions();
		};

		function createNewDivider( label ) {
			var newLabel = typeof label !== 'undefined' ? label : "New Section";
			var screenPosition = $scope.screens.length;
			var sort = $scope.dividers.length + 1;
			var displayObjectsPosition = $scope.displayObjects.length;
			var newDivider = {
				dividerID: "new",
				type: "divider",
				label: newLabel,
				position: screenPosition,
				sort: sort,
				expanded: true
			};
			$scope.displayObjects.push( newDivider );
			$scope.dividers.push( newDivider );
			/*
TODO: FIX THIS
$scope.$emit( "activeScreens:sortUpdate" );
$scope.updateDividerPositions();
$scope.mergeScreensAndDividers();
$scope.persistDividerPositions();
$scope.moveSelectedToSection( newDivider );
*/
			screenDividerService.createScreenDivider( $scope.projectID, newLabel, screenPosition, sort, displayObjectsPosition );
			return ( newDivider );
		}
		$scope.moveSection = function ( divider, direction ) {
			sortDividers();
			var sortedDividers = $scope.dividers;
			if ( direction == 'down' ) {
				var dividerToMoveDown = _.findWithProperty( sortedDividers, "dividerID", divider.dividerID );
				var dividerToMoveDownIndex = _.indexOfWithProperty( sortedDividers, "dividerID", divider.dividerID );
				var dividerToMoveUpIndex = dividerToMoveDownIndex + 1;
				if ( dividerToMoveUpIndex >= sortedDividers.length ) {
					return;
				}
				var dividerToMoveUp = sortedDividers[ dividerToMoveDownIndex + 1 ];
			} else if ( direction == 'up' ) {
				var dividerToMoveUp = _.findWithProperty( sortedDividers, "dividerID", divider.dividerID );
				var dividerToMoveUpIndex = _.indexOfWithProperty( sortedDividers, "dividerID", divider.dividerID );
				if ( dividerToMoveUpIndex <= 0 ) {
					return;
				}
				var dividerToMoveDown = sortedDividers[ dividerToMoveUpIndex - 1 ];
				var dividerToMoveDownIndex = dividerToMoveUpIndex - 1;
			}
			var dividerToMoveDownSort = dividerToMoveDown.sort;
			var dividerToMoveUpSort = dividerToMoveUp.sort;
			dividerToMoveDown.sort = dividerToMoveUpSort;
			dividerToMoveUp.sort = dividerToMoveDownSort;
			var dividerToMoveDownDisplayObjectsIndex = _.indexOfWithProperty( $scope.displayObjects, "dividerID", dividerToMoveDown.dividerID );
			var dividerToMoveUpDisplayObjectsIndex = _.indexOfWithProperty( $scope.displayObjects, "dividerID", dividerToMoveUp.dividerID );
			var moveDownDividerPosition = dividerToMoveDown.position;
			var screensInSectionToMoveDown = getActiveScreensInSection( dividerToMoveDown );
			if ( screensInSectionToMoveDown.length ) {
				var firstSortLocationOfMoveDown = screensInSectionToMoveDown[ 0 ].sort;
			} else {
				var firstSortLocationOfMoveDown = moveDownDividerPosition + 1;
			}
			var screensToBeMovedUp = getActiveScreensInSection( dividerToMoveUp );
			var divDown = _.findWithProperty( $scope.dividers, "dividerID", dividerToMoveDown.dividerID );
			divDown.position = moveDownDividerPosition + screensToBeMovedUp.length;
			var divUp = _.findWithProperty( $scope.dividers, "dividerID", dividerToMoveUp.dividerID );
			divUp.position = moveDownDividerPosition;
			if ( !screensInSectionToMoveDown.length && !screensToBeMovedUp.length ) {
				$scope.removeDividerPlaceholders();
				$scope.mergeScreensAndDividers();
				$scope.insertDividerPlaceholders();
				$scope.persistDividerPositions();
				return;
			}
			var sortLocationMovingUp = firstSortLocationOfMoveDown;
			for ( var d = 0; d < screensToBeMovedUp.length; d++ ) {
				screensToBeMovedUp[ d ].sort = sortLocationMovingUp;
				sortLocationMovingUp++;
			}
			var sortLocationMovingDown = firstSortLocationOfMoveDown;
			for ( var u = 0; u < screensInSectionToMoveDown.length; u++ ) {
				screensInSectionToMoveDown[ u ].sort = sortLocationMovingDown + screensToBeMovedUp.length;
				sortLocationMovingDown++;
			}
			var screenIDsToUpdate = _.pluck( sortScreens( $scope.activeScreens ), "id" );
			screenService.updateSort( $scope.projectID, screenIDsToUpdate );
			$scope.removeDividerPlaceholders();
			$scope.mergeScreensAndDividers();
			$scope.insertDividerPlaceholders();
			$scope.persistDividerPositions();
		};
		$scope.moveSelectedToNewSection = function () {
			var newDivider = createNewDivider();
			$scope.isMovingSelectedToNewSection = true;
		};
		$scope.moveSelectedToWorkflowStatus = function ( workflowStatusID ) {
			var selectedScreens = getSelectedScreens();
			var screenIDs = _.pluck( selectedScreens, "id" ).join( "," );
			Deferred.handlePromise(
				screenService.setWorkflowStatuses( screenIDs, workflowStatusID ),
				function ( response ) {
					_.each( response, function ( screen ) {
						$scope.adjustDividerPositionsForAddOrRemove( screen, true );
					} );
					augmentScreens( $scope.screens );
					setupScreenStatusFilterOptions();
					/*if (
( workflowStatusID != 1 ) &&
$scope.projectMembers.length > 1
) {
$scope.openModalWindow( "workflowStatusNotification", $scope.screen.projectID, $scope.screen.id );
}*/
				},
				function ( resposne ) {
					$scope.openModalWindow( "error", "For some reason we couldn't update your screen status. Try refreshing your browser." );
				}
			);
			_.setProperty( selectedScreens, "isSelectedForBulkAction", false );
			_.setProperty( selectedScreens, "workflowStatusID", workflowStatusID );
			resetSelectedScreens();
		};
		$scope.expandCollapseSections = function ( divider ) {
			var expand = !divider.expanded;
			var screensInSection = getScreensInSection( divider );
			var dropZonesInSection = getDropZonesInSection( divider );
			var dividerPlaceholdersInSection = getDividerPlaceholdersInSection( divider );
			divider.expanded = expand;
			_.setProperty( screensInSection, "expanded", expand );
			_.setProperty( dropZonesInSection, "expanded", expand );
			_.setProperty( dividerPlaceholdersInSection, "expanded", expand );
			$scope.updateDividerPositions();
			$scope.persistDivider( divider.dividerID, divider.label, divider.expanded );
		};
		$scope.expandAllSections = function ( divider ) {
			_.setProperty( $scope.displayObjects, "expanded", true );
			$scope.updateDividerPositions();
		};
		$scope.mergeScreensAndDividers = function () {
			sortDividers();
			var displayObjectsTemp = [];
			for ( var s = 0; s < $scope.activeScreens.length; s++ ) {
				var dividers = _.filterWithProperty( $scope.dividers, "position", s );
				for ( var d = 0; d < dividers.length; d++ ) {
					displayObjectsTemp.push( dividers[ d ] );
				}
				if ( s === 0 && $scope.isMobile && $scope.mobileDeviceID && !$scope.isShowingSmallScreenSize ) {
					var thisDeviceData = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.mobileDeviceID )[ 0 ];
					thisDeviceData.appIconScreen = _.withProperty( $scope.screens, "clientFilename", "apple-touch-icon.png" )[ 0 ];
					thisDeviceData.loadingScreen = _.withProperty( $scope.screens, "clientFilename", "apple-touch-startup-image.png" )[ 0 ];
					thisDeviceData.type = "mobileUploadTile";
					displayObjectsTemp.push( thisDeviceData );
				}
				var screenObj = $scope.activeScreens[ s ];
				screenObj.type = "screenObj";
				displayObjectsTemp.push( screenObj );
			}
			var dividers = _.filter( $scope.dividers, function ( divider ) {
				return divider.position >= $scope.activeScreens.length;
			} );
			if ( dividers ) {
				for ( var d = 0; d < dividers.length; d++ ) {
					displayObjectsTemp.push( dividers[ d ] );
				}
			}
			for ( var s = 0; s < $scope.layerSyncTempSources.length; s++ ) {
				var sourceObj = $scope.layerSyncTempSources[ s ];
				sourceObj.type = "sourceTempObj";
				displayObjectsTemp.push( sourceObj );
			}
			$scope.displayObjects = hashKeyCopier.copyHashKeys( $scope.displayObjects, displayObjectsTemp );
		};
		$scope.insertDividerPlaceholders = function () {
			if ( $scope.isReviewer ) return;
			if ( !$scope.isShowingSmallScreenSize ) {
				var displayObjectsTemp = [];
				var placementCount = 0;
				var dividerCount = 0;
				var screenCount = 0;
				var dividerIsExpanded = true;
				var dividerID = 0;
				for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
					var isDivider = $scope.displayObjects[ d ].type === "divider" ? true : false;
					var isScreenObj = $scope.displayObjects[ d ].type === "screenObj" ? true : false;
					if ( d !== 0 && isDivider && !prevObjWasDivider ) {
						displayObjectsTemp.push( {
							type: "inline_drop_zone",
							label: "drop zone",
							position: screenCount,
							displayObjectsPosition: displayObjectsTemp.length,
							expanded: dividerIsExpanded,
							isLastDropZoneInSection: true,
							dividerID: dividerID
						} );
					}
					if ( isDivider ) {
						dividerIsExpanded = $scope.displayObjects[ d ].expanded;
						dividerID = $scope.displayObjects[ d ].dividerID;
					}
					if ( placementCount % 4 === 0 && !isDivider ) {
						if ( !prevObjWasDivider ) {
							if ( d !== 0 ) {
								displayObjectsTemp.push( {
									type: "inline_drop_zone",
									label: "drop zone",
									position: screenCount,
									displayObjectsPosition: displayObjectsTemp.length,
									expanded: dividerIsExpanded,
									isLastDropZoneInSection: false,
									dividerID: dividerID
								} );
							}
							displayObjectsTemp.push( {
								type: "divider_placeholder",
								label: "Click here to add a section.",
								position: screenCount,
								screenPosition: screenCount,
								displayObjectsPosition: displayObjectsTemp.length,
								expanded: dividerIsExpanded
							} );
						}
					}
					if ( isDivider ) {
						placementCount = 0;
						var prevObjWasDivider = true;
					} else {
						placementCount++;
						var prevObjWasDivider = false;
					}
					if ( isScreenObj ) {
						displayObjectsTemp.push( {
							type: "inline_drop_zone",
							label: "drop zone",
							position: screenCount,
							displayObjectsPosition: displayObjectsTemp.length,
							expanded: dividerIsExpanded,
							isLastDropZoneInSection: false,
							dividerID: dividerID
						} );
						$scope.displayObjects[ d ].expanded = dividerIsExpanded;
						screenCount++;
					}
					displayObjectsTemp.push( $scope.displayObjects[ d ] );
				}
				if ( $scope.activeScreens.length && _.last( displayObjectsTemp ).type != "divider" ) {
					displayObjectsTemp.push( {
						type: "inline_drop_zone",
						label: "drop zone",
						position: screenCount,
						displayObjectsPosition: displayObjectsTemp.length,
						expanded: true,
						isLastDropZoneInSection: false,
						dividerID: dividerID
					} );
					displayObjectsTemp.push( {
						type: "divider_placeholder",
						label: "Click here to add a section.",
						position: screenCount,
						displayObjectsPosition: displayObjectsTemp.length,
						expanded: true
					} );
				}
				$scope.displayObjects = hashKeyCopier.copyHashKeys( $scope.displayOjects, displayObjectsTemp );
			} else {
				var displayObjectsTemp = [];
				var dividerIsExpanded = true;
				var dividerID = 0;
				for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
					var isDivider = $scope.displayObjects[ d ].type === "divider" ? true : false;
					if ( isDivider ) {
						dividerIsExpanded = $scope.displayObjects[ d ].expanded;
						dividerID = $scope.displayObjects[ d ].dividerID;
					}
					if ( $scope.displayObjects[ d ].type == "screenObj" ) {
						$scope.displayObjects[ d ].expanded = dividerIsExpanded;
						$scope.displayObjects[ d ].isSelectedForBulkAction = false;
					}
					/*
displayObjectsTemp.push({
type: "inline_drop_zone",
label: "drop zone",
position: screenCount,
displayObjectsPosition: displayObjectsTemp.length,
expanded: dividerIsExpanded,
isLastDropZoneInSection: false,
dividerID: dividerID
});
*/
					displayObjectsTemp.push( $scope.displayObjects[ d ] );
				}
				_.setProperty( displayObjectsTemp, "isPartiallySelected", false );
				_.setProperty( displayObjectsTemp, "isSelectedForBulkAction", false );
				$scope.displayObjects = hashKeyCopier.copyHashKeys( $scope.displayOjects, displayObjectsTemp );
			}
		};
		$scope.removeDividerPlaceholders = function () {
			$scope.displayObjects = _.withoutProperty( $scope.displayObjects, "type", "divider_placeholder" );
			$scope.displayObjects = _.withoutProperty( $scope.displayObjects, "type", "inline_drop_zone" );
		};
		$scope.adjustDividerPositionsForAddOrRemove = function ( screen, isAdd ) {
			if ( isAdd ) { // is adding a screen
				var posAdjust = 1;
			} else { // is removing a screen
				var posAdjust = -1;
			}
			for ( var a = 0; a < $scope.activeScreens.length; a++ ) {
				if ( screen.id == $scope.activeScreens[ a ].id ) {
					var screenPosition = a + 1; //We want 1 based positioning for screens, not 0
					break;
				}
			}
			for ( var d = 0; d < $scope.dividers.length; d++ ) {
				if ( $scope.dividers[ d ].position >= screenPosition ) {
					$scope.dividers[ d ].position = $scope.dividers[ d ].position + posAdjust;
				}
			}
		};
		$scope.updateDividerPositions = function () {
			var dividersTemp = [];
			var screenPosition = 0;
			var lastType = "";
			var sortOrder = 1;
			for ( var p = 0; p < $scope.displayObjects.length; p++ ) {
				var objType = $scope.displayObjects[ p ].type;
				if ( objType == "screenObj" ) {
					screenPosition++;
				} else if ( objType == "divider" ) {
					dividersTemp.push( {
						dividerID: $scope.displayObjects[ p ].dividerID,
						type: $scope.displayObjects[ p ].type,
						label: $scope.displayObjects[ p ].label,
						position: screenPosition,
						sort: sortOrder,
						expanded: $scope.displayObjects[ p ].expanded
					} );
					sortOrder++;
				}
				lastType = objType;
			}
			$scope.dividers = hashKeyCopier.copyHashKeys( $scope.dividers, dividersTemp );
		};
		$scope.persistDividerPositions = function () {
			return screenDividerService.updateScreenDividerPositions( $scope.projectID, $scope.dividers );
		};
		$scope.persistDivider = function ( dividerID, label, expanded ) {
			return screenDividerService.updateScreenDivider( $scope.projectID, dividerID, label, expanded );
		};
		$scope.toggleSelection = function ( event, object ) {
			var wasShiftOn = event.shiftKey;
			var selected = !object.isSelectedForBulkAction;
			object.isSelectedForBulkAction = selected;
			if ( object.type === "divider" ) {
				toggleSelectedScreensInSection( object, selected );
				$scope.updateSelectedScreenCount();
			} else {
				if ( wasShiftOn && !_.isNull( lastScreenClickedOn ) ) {
					setSelectionOnAllScreensInBetween( selected, lastScreenClickedOn, object );
					lastScreenClickedOn = null;
				} else {
					lastScreenClickedOn = object;
				}
				$scope.updateSelectedScreenCount();
			}
		};
		$scope.toggleAllScreenSelection = function () {
			var selected = !$scope.hasAllScreensSelected;
			var allScreens = _.withProperty( $scope.displayObjects, "type", "screenObj" );
			var customScreenStatusFilter = $filter( 'customScreenStatusFilter' )( allScreens, $scope.filters.screenStatusFilter.activeFilter );
			var filteredScreens = $filter( 'customScreensFilter' )( customScreenStatusFilter, $scope.filters.screensFilter );
			_.setProperty( filteredScreens, "isSelectedForBulkAction", selected );
			$scope.updateSelectedScreenCount();
		};
		$scope.getScreensInScreenStatusFilter = function () {
			var results = [];
			if ( $scope.filters.screenStatusFilter.activeFilter.workflowStatusID === 0 && $scope.filters.screenStatusFilter.activeFilter.label === "All Screens" ) {
				results = $scope.displayObjects;
			} else if ( $scope.filters.screenStatusFilter.activeFilter.workflowStatusID === 0 && $scope.filters.screenStatusFilter.activeFilter.label === "Without Hotspots" ) {
				_.forEach( $scope.displayObjects, function ( object ) {
					if ( object.type !== undefined &&
						( object.type === "divider" ||
							( object.type === "screenObj" &&
								object.hotspotCount === 0 ) // screenObj does not have hotspots.
						)
					) {
						results.push( object );
					}
				} );
			} else {
				_.forEach( $scope.displayObjects, function ( object ) {
					if ( object.type !== undefined &&
						( object.type === "divider" ||
							( object.type === "screenObj" &&
								object.workflowStatusID === $scope.filters.screenStatusFilter.activeFilter.workflowStatusID )
						)
					) {
						results.push( object );
					}
				} );
			}
			return results;
		};
		$scope.archiveScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.archiveScreen( screen.id ),
				function ( archivedScreen ) {
					updateScreenInCollection( archivedScreen );
					clearScreensFilter();
				},
				function ( response ) {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't archive that screen." );
				}
			);
			$scope.adjustDividerPositionsForAddOrRemove( screen, false );
			screen.isArchived = true;
			screen.isSelectedForBulkAction = false;
			screen.unreadConversationCount = 0;
			applyScreens();
			$scope.mergeScreensAndDividers();
			$scope.persistDividerPositions();
			$scope.removeDividerPlaceholders();
			$scope.insertDividerPlaceholders();
		};
		$scope.archiveSelectedScreens = function () {
			var selectedScreens = getSelectedScreens();
			var screenIDs = _.pluck( selectedScreens, "id" ).join( "," );
			Deferred.handlePromise(
				screenService.archiveScreens( screenIDs ),
				function ( archivedScreens ) {
					_.each( archivedScreens, updateScreenInCollection );
					clearScreensFilter();
				},
				function ( response ) {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't archive the selected screen(s)." );
				}
			);
			_.setProperty( selectedScreens, "isArchived", true );
			_.setProperty( selectedScreens, "isSelectedForBulkAction", false );
			_.setProperty( selectedScreens, "unreadConversationCount", 0 );
			$scope.displayObjects = _.difference( $scope.displayObjects, selectedScreens );
			applyScreens();
			$scope.updateDividerPositions();
			$scope.mergeScreensAndDividers();
			$scope.persistDividerPositions();
			$scope.removeDividerPlaceholders();
			$scope.insertDividerPlaceholders();
		};
		$scope.deleteScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.deleteScreen( screen.id ),
				function () {
					$scope.$emit( "screens:deleted", screen );
					clearScreensFilter();
				},
				function () {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't delete that screen." );
				}
			);
			$scope.adjustDividerPositionsForAddOrRemove( screen, false );
			$scope.screens = _.withoutProperty( $scope.screens, "id", screen.id );
			applyScreens();
			$scope.mergeScreensAndDividers();
			$scope.persistDividerPositions();
			$scope.insertDividerPlaceholders();
		};
		$scope.deleteSelectedScreens = function () {
			var selectedScreens = _.filterWithProperty( $scope.screens, "isSelectedForBulkAction", true );
			var screenIDs = _.pluck( selectedScreens, "id" );
			Deferred.handlePromise(
				screenService.deleteScreens( screenIDs.join( "," ) ),
				function ( response ) {
					clearScreensFilter();
				},
				function ( response ) {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't delete the selected screen(s)." );
				}
			);
			$scope.screens = _.difference( $scope.screens, selectedScreens );
			$scope.displayObjects = _.difference( $scope.displayObjects, selectedScreens );
			var screenIDsToUpdate = _.pluck( $scope.screens, "id" );
			screenService.updateSort( $scope.projectID, screenIDsToUpdate );
			applyScreens();
			$scope.updateDividerPositions();
			$scope.mergeScreensAndDividers();
			$scope.persistDividerPositions();
			$scope.insertDividerPlaceholders();
		};
		$scope.duplicateScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.duplicateScreen( screen.id ),
				function ( duplicateScreen ) {
					augmentScreen( duplicateScreen );
					duplicateScreen.hotspotCount = screen.hotspotCount;
					_.defaults( duplicateScreen, screen );
					var index = $scope.screens.indexOf( screen );
					$scope.adjustDividerPositionsForAddOrRemove( screen, true );
					$scope.screens.splice( index + 1, 0, duplicateScreen );
					var screenIDsToUpdate = _.pluck( $scope.screens, "id" );
					screenService.updateSort( $scope.projectID, screenIDsToUpdate );
					updateScreensSort( screenIDsToUpdate, $scope.screens );
					applyScreens();
					$scope.persistDividerPositions();
					setupScreenStatusFilterOptions();
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't duplicate that screen." );
				}
			);
		};
		$scope.duplicateSelectedScreens = function () {
			var selectedScreens = getSelectedScreens();
			var screenIDs = _.pluck( selectedScreens, "id" ).join( "," );
			Deferred.handlePromise(
				screenService.duplicateScreens( screenIDs ),
				function ( duplicateScreens ) {
					var screenIdx = 0;
					_.each( duplicateScreens, function ( screen ) {
						$scope.adjustDividerPositionsForAddOrRemove( selectedScreens[ screenIdx ], true );
						var index = $scope.screens.indexOf( selectedScreens[ screenIdx ] );
						$scope.screens.splice( index + 1, 0, screen );
						screenIdx++;
					} );
					var screenIDsToUpdate = _.pluck( $scope.screens, "id" );
					screenService.updateSort( $scope.projectID, screenIDsToUpdate );
					updateScreensSort( screenIDsToUpdate, $scope.screens );
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.persistDividerPositions();
					setupScreenStatusFilterOptions();
				},
				function ( response ) {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't archive the selected screen(s)." );
				}
			);
			_.setProperty( selectedScreens, "isSelectedForBulkAction", false );
			_.setProperty( selectedScreens, "unreadConversationCount", 0 );
			/*$scope.removeDividerPlaceholders();
$scope.insertDividerPlaceholders();*/
		};
		$scope.openHighFidelityModal = function () {
			$scope.openModalWindow( "highFidelityPrototypes" );
		};
		$scope.openMobileModal = function () {
			$scope.openModalWindow( "mobileDemos" );
		};
		$scope.openWireframesModal = function () {
			$scope.openModalWindow( "clickableWireframes" );
		};
		$scope.shareScreen = function ( screen ) {
			$scope.openModalWindow( "share", $scope.projectID, screen.id );
		};
		$scope.showScreenSize = function ( size ) {
			$scope.screenSize = size;
			if ( size === "regular" ) {
				$scope.isShowingRegularScreenSize = true;
				$scope.isShowingSmallScreenSize = false;
			} else {
				$scope.isShowingRegularScreenSize = false;
				$scope.isShowingSmallScreenSize = true;
			}
			resetSelectedScreens();
			$scope.mergeScreensAndDividers();
			$scope.insertDividerPlaceholders();
			projectService.setViewPreference( $scope.projectID, $scope.isShowingRegularScreenSize );
			$scope.project.viewScreensAsThumbnails = $scope.isShowingRegularScreenSize;
			modelEvents.trigger( "viewChanged.projectScreens", $scope.projectID, $scope.isShowingRegularScreenSize );
		};
		$scope.toggleUploader = function () {
			$scope.isShowingUploader = !$scope.isShowingUploader;
		};
		$scope.unarchiveScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.activateScreen( screen.id ),
				function ( activatedScreen ) {
					updateScreenInCollection( activatedScreen );
				},
				function () {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't activate that screen." );
				}
			);
			$scope.createUncategorizedDividerIfNeeded();
			screen.isArchived = false;
			screen.sort = LAST_SORT_VALUE;
			screen.isSelectedForBulkAction = false;
			applyScreens();
			$scope.mergeScreensAndDividers();
			$scope.removeDividerPlaceholders();
			$scope.insertDividerPlaceholders();
		};
		$scope.updateSelectedScreenCount = function () {
			$scope.setSelectedScreens( angular.copy( _.filter( $scope.screens, "isSelectedForBulkAction" ) ) );
			$scope.selectedScreenCount = _.countWithProperty( $scope.screens, "isSelectedForBulkAction", true );
		};
		$scope.createUncategorizedDividerIfNeeded = function () {
			var lastDividerPosition = _.max( $scope.dividers, "position" ).position;
			var dividersAtLastPosition = _.withProperty( $scope.dividers, "position", lastDividerPosition );
			var lastDivider = _.last( dividersAtLastPosition );
			if ( lastDivider && lastDivider.label && lastDivider.label !== "Uncategorized" ) {
				createNewDivider( "Uncategorized" );
			}
		};
		$scope.canScreenDividerMoveUp = function ( divider ) {
			var dividerToMoveUpIndex = _.indexOfWithProperty( $scope.dividers, "dividerID", divider.dividerID );
			return ( dividerToMoveUpIndex > 0 );
		};
		$scope.canScreenDividerMoveDown = function ( divider ) {
			var dividerToMoveDownIndex = _.indexOfWithProperty( $scope.dividers, "dividerID", divider.dividerID );
			var dividerToMoveUpIndex = dividerToMoveDownIndex + 1;
			return ( dividerToMoveUpIndex < $scope.dividers.length );
		};
		$scope.loadMoreScreens = function ( i ) {
			if ( $scope.deferredLimit === i + 1 ) {
				$timeout(
					function () {
						if ( !$scope.isScrolling ) {
							$scope.deferredLimit = Math.min( ( $scope.deferredLimit + $scope.loadScreenIncrement ), $scope.displayObjects.length );
						} else {
							$scope.loadMoreScreens( i );
						}
					},
					100
				);
			}
			if ( $scope.displayObjects.length && $scope.deferredLimit >= $scope.displayObjects.length ) {
				$scope.isLoadingScreens = false;
			}
		};
		$scope.applyScreenStatusFilter = function ( option ) {
			resetSelectedScreens();
			$scope.filters.screenStatusFilter.activeFilter = option;
			$scope.isShowingScreenStatusFilterMenu = false;
		};
		$scope.setIsShowingScreenStatusFilterMenu = function ( value ) {
			$scope.isShowingScreenStatusFilterMenu = value;
		};
		$scope.toggleSourceFiles = function () {
			$scope.isShowingLayerSyncFlyout = !$scope.isShowingLayerSyncFlyout;
		};
		$scope.updateDisplayImageObjects = function () {
			$scope.displayImageObjects = _.filter( $scope.displayObjects, function ( i ) {
				return ( i.type === "screenObj" || i.type === "sourceTempObj" );
			} );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.screens", "projectID" );
		var LAST_SORT_VALUE = 999999;
		var thumbnailTimer = null;
		var thumbnailTimerPause = 2000;
		var mobileDeviceData = [ {
			mobileDeviceID: 1,
			className: "iphone-portrait",
			iconResolution: "114 x 114",
			loadScreenResolution: "640 x 1096",
			type: "mobileUploadTile"
		}, {
			mobileDeviceID: 2,
			className: "iphone-landscape",
			iconResolution: "114 x 114",
			loadScreenResolution: "1136 x 640",
			type: "mobileUploadTile"
		}, {
			mobileDeviceID: 3,
			className: "ipad-portrait",
			iconResolution: "144 x 144",
			loadScreenResolution: "1536 x 2048",
			type: "mobileUploadTile"
		}, {
			mobileDeviceID: 4,
			className: "ipad-landscape",
			iconResolution: "144 x 144",
			loadScreenResolution: "2048 x 1496",
			type: "mobileUploadTile"
		} ];
		var lastScreenClickedOn = null;
		$scope.states = {
			READY: "READY",
			SORTING: "SORTING"
		};
		$scope.state = $scope.states.READY;
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.isLoading = true;
		$scope.isCheckProcessingScreens = false;
		$scope.screens = [];
		$scope.activeScreens = [];
		$scope.archivedScreens = [];
		$scope.processingScreens = [];
		$scope.isShowingUploader = false;
		$scope.filters = {};
		$scope.filters.screensFilter = "";
		$scope.filters.screenStatusFilter = {
			activeFilter: {
				workflowStatusID: 0,
				label: "All Screens",
				count: 0,
				itemClass: "all"
			},
			options: [ {
				workflowStatusID: 0,
				label: "All Screens",
				count: 0,
				itemClass: "all"
			}, {
				workflowStatusID: 1,
				label: "In Progress",
				count: 0,
				itemClass: "in-progress"
			}, {
				workflowStatusID: 2,
				label: "For Review",
				count: 0,
				itemClass: "for-review"
			}, {
				workflowStatusID: 3,
				label: "Approved",
				count: 0,
				itemClass: "approved"
			}, {
				workflowStatusID: 0,
				label: "Without Hotspots",
				count: 0,
				itemClass: "without-hotspots"
			} ]
		};
		$scope.isShowingScreenStatusFilterMenu = false;
		$scope.moveTooltipLabel = "Move";
		$scope.selectedScreenCount = 0;
		$scope.subview = ( renderContext.getNextSection() || "list" );
		$scope.dividers = [];
		$scope.displayObjects = [];
		$scope.displayImageObjects = [];
		$scope.mobileUploadingIndicators = {};
		$scope.mobileUploadingIndicators.isUploadingIcon = false;
		$scope.mobileUploadingIndicators.isUploadingLoadingScreen = false;
		$scope.hasScreensSelected = false;
		$scope.hasAllScreensSelected = false;
		$scope.hasNotAllScreensSelected = ( $scope.hasScreensSelected && !$scope.hasAllScreensSelected );
		$scope.deferredLimit = 20;
		$scope.loadScreenIncrement = 40;
		$scope.isLoadingScreens = true;
		$scope.isScrolling = false;
		if ( $scope.project ) {
			$scope.isShowingRegularScreenSize = $scope.project.viewScreensAsThumbnails;
			$scope.isShowingSmallScreenSize = !$scope.project.viewScreensAsThumbnails;
			$scope.screenSize = $scope.isShowingRegularScreenSize ? "regular" : "small";
		}
		$scope.isMovingSelectedToNewSection = false;
		$scope.isShowingLayerSyncFlyout = false;
		$scope.layerSyncAssets = [];
		$scope.showScreenSourceModal = true;
		$scope.showScreenSourceModalPrefName = "showScreenSourceIntro";
		$scope.layerSyncTempSources = [];
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "projectScreensUploadComplete" );
				modelEvents.off( "screenUploadStop" );
				modelEvents.off( "screenDeleted.projectScreens" );
				modelEvents.off( "screenActivated.projectScreens" );
				modelEvents.off( "screenArchived.projectScreens" );
				modelEvents.off( "screenUploaded.projectScreens" );
				modelEvents.off( "subscriptionChanged.projectScreens" );
				modelEvents.off( "projectUpdated.projectScreens" );
				modelEvents.off( "dividerCreated.projectScreens" );
				modelEvents.off( "dividerDeleted.projectScreens" );
				modelEvents.off( "screenDividerUpdated.projectScreens" );
				modelEvents.off( "dividerPositionsUpdated.projectScreens" );
				modelEvents.off( "dividerUpdated.projectScreens" );
				modelEvents.off( "screenSortUpdated.projectScreens" );
				modelEvents.off( "assetDeleted" );
				modelEvents.off( "showScreenSourceModalPreferenceUpdated" );
				modelEvents.off( "screenSourceUploaded.projectScreens" );
				modelEvents.off( "screenSourceSyncUpdated.projectScreens" );
				$timeout.cancel( thumbnailTimer );
			}
		);
		$scope.$on(
			'metaKey-keydown',
			function () {
				if ( $scope.isLoadingScreens ) {
					$scope.deferredLimit = 99999;
					$scope.isLoadingScreens = false;
				}
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() &&
					( requestContext.getAction() !== "standard.project.detail" )
				) {
					return;
				}
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				$scope.subview = ( renderContext.getNextSection() || "list" );
				$scope.isShowingUploader = false;
				if (
					( $scope.subview === "list" ) &&
					!$scope.displayImageObjects.length
				) {
					$scope.isShowingUploader = true;
				}
				resetSelectedScreens();
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
			}
		);
		$scope.$on(
			"projectScreens:dragEnter",
			function () {
				if ( $scope.state !== $scope.states.READY || $scope.isReviewer ) {
					return;
				}
				$scope.isShowingUploader = true;
			}
		);
		$scope.$on(
			"activeScreens:sortStart",
			function () {
				$scope.state = $scope.states.SORTING;
				var screens = _.withProperty( $scope.displayObjects, "type", "screenObj" );
				var screenIDs = _.pluck( screens, "id" );
			}
		);
		$scope.$on(
			"activeScreens:sortStop",
			function () {
				if ( $scope.state !== $scope.states.SORTING ) {
					return;
				}
				$scope.state = $scope.states.READY;
			}
		);
		$scope.$on(
			"activeScreens:sortUpdate",
			function () {
				var screens = _.withProperty( $scope.displayObjects, "type", "screenObj" );
				var screenIDs = _.pluck( screens, "id" );
				screenService.updateSort( $scope.projectID, screenIDs );
				for ( var position = 0; position < screenIDs.length; position++ ) {
					for ( var s = 0; s < $scope.screens.length; s++ ) {
						if ( $scope.screens[ s ].id === screenIDs[ position ] ) {
							$scope.screens[ s ].sort = position;
						}
					}
				}
				applyScreens();
				$scope.removeDividerPlaceholders();
				$scope.insertDividerPlaceholders();
				$scope.updateDividerPositions();
				$scope.persistDividerPositions();
			}
		);
		$scope.$watch(
			"selectedScreenCount",
			function ( newValue, oldValue ) {
				$scope.hasScreensSelected = ( newValue > 0 );
				$scope.hasAllScreensSelected = ( newValue && newValue === _.withProperty( $scope.getScreensInScreenStatusFilter(), "type", "screenObj" ).length );
				$scope.hasNotAllScreensSelected = ( $scope.hasScreensSelected && !$scope.hasAllScreensSelected );
				markPartiallySelectedSections();
			}
		);
		$scope.$watch(
			"deferredLimit",
			function ( newValue ) {
				if ( $scope.displayObjects.length && $scope.deferredLimit >= $scope.displayObjects.length ) {
					$scope.isLoadingScreens = false;
				} else {
					$scope.isLoadingScreens = true;
				}
			}
		);
		$scope.$watch(
			"filters.screensFilter",
			function ( newVal ) {
				if ( newVal === "" ) {
					$scope.moveTooltipLabel = "Move";
					if ( !$scope.isLoadingScreens ) {
						$scope.deferredLimit = $scope.loadScreenIncrement;
						$scope.deferredLimit++;
					}
				} else {
					$scope.moveTooltipLabel = "Cannot sort while Searching.  Clear the search box first.";
					$scope.deferredLimit = $scope.displayObjects.length;
				}
				applyFiltersToUrl();
			}
		);
		$scope.$watch(
			"displayObjects",
			function ( newValue, oldValue ) {
				$scope.applyDividerScreenCounts();
				$scope.updateDisplayImageObjects();
			}
		);
		modelEvents.on(
			"screenDeleted.projectScreens",
			function ( event, screenID ) {
				if ( _.findWithProperty( $scope.screens, "id", screenID ) ) {
					$scope.screens = _.withoutProperty( $scope.screens, "id", screenID );
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.updateDividerPositions();
					$scope.insertDividerPlaceholders();
				}
			}
		);
		modelEvents.on(
			"screenActivated.projectScreens",
			function ( event, screen ) {
				if ( _.findWithProperty( $scope.screens, "id", screen.id ) ) {
					var screenIndex = _.findIndex( $scope.screens, function ( activatedScreen ) {
						return activatedScreen.id === screen.id;
					} );
					$scope.screens[ screenIndex ].isArchived = false;
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.updateDividerPositions();
					$scope.insertDividerPlaceholders();
				}
			}
		);
		modelEvents.on(
			"screenArchived.projectScreens",
			function ( event, screen ) {
				if ( _.findWithProperty( $scope.screens, "id", screen.id ) ) {
					var screenIndex = _.findIndex( $scope.screens, function ( archivedScreen ) {
						return archivedScreen.id === screen.id;
					} );
					$scope.screens[ screenIndex ].isArchived = true;
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.updateDividerPositions();
					$scope.insertDividerPlaceholders();
				}
			}
		);
		modelEvents.on(
			"screenUploaded.projectScreens",
			function handleScreenUploaded( event, screen ) {
				if ( screen.projectID !== $scope.projectID ) {
					return;
				}
				if ( screen.uploadtype === "sourceFile" ) {
					if ( $scope.showScreenSourceModal ) {
						$scope.openModalWindow( "screenSource" );
					}
					addUploadedSource( screen );
				} else {
					addUploadedScreen( screen );
				}
			}
		);
		modelEvents.on(
			"screenSourceUploaded.projectScreens",
			function handleScreenSourceUploaded( event, screenSource ) {
				if ( screenSource.projectID !== $scope.projectID ) {
					return;
				}
				addUploadedSource( screenSource );
			}
		);
		modelEvents.on(
			"screenSourceSyncUpdated.projectScreens",
			function handleScreenSourceSyncUpdated( event, assetID, status, projectID ) {
				if ( projectID !== $scope.projectID ) {
					return;
				}
				refreshLayerSyncInfo();
				switch ( status ) {
				case "failed":
					var tempSource = _.findWithProperty( $scope.layerSyncTempSources, "parentAssetID", assetID );
					if ( tempSource ) {
						$scope.openModalWindow( "screenSourceError", projectID, assetID, tempSource.parentAssetName );
						$scope.layerSyncTempSources = _.withoutProperty( $scope.layerSyncTempSources, "parentAssetID", assetID );
					}
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.insertDividerPlaceholders();
					break;
				case "complete":
					break;
				}
			}
		);
		modelEvents.on(
			"screenSortUpdated.projectScreens",
			function handleScreenSortUpdated( event, projectID, screensSorted ) {
				if ( projectID !== $scope.projectID ) {
					return;
				}
				var screens = _.withProperty( $scope.displayObjects, "type", "screenObj" );
				var localSort = _.pluck( screens, "id" );
				_.sortOnProperty( screensSorted, "sort" );
				var responseSort = _.pluck( _.withoutProperty( screensSorted, "isArchived", true ), "id" );
				var isAlreadyUpdated = _.isEqual( localSort, responseSort );
				if ( !isAlreadyUpdated ) {
					$scope.screens = augmentScreens( hashKeyCopier.copyHashKeys( $scope.screens, screensSorted ) );
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.insertDividerPlaceholders();
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged.projectScreens",
			function handleSubscriptionChanged( event, newPlan ) {
				loadRemoteData();
			}
		);
		modelEvents.on(
			"projectUpdated.projectScreens",
			function ( event, project ) {
				if ( project.id !== $scope.project.id ) {
					return;
				}
				if ( project.userID !== $scope.project.userID ) {
					return ( loadRemoteData() );
				}
				if ( $scope.isMobile !== project.isMobile || $scope.mobileDeviceID !== project.mobileDeviceID ) {
					$scope.isMobile = project.isMobile;
					$scope.mobileDeviceID = project.mobileDeviceID;
					$scope.mergeScreensAndDividers();
					$scope.insertDividerPlaceholders();
					return;
				}
			}
		);
		modelEvents.on( "screenCopyProgress.projectScreens",
			function ( event, screenID ) {
				var findScreen = _.find( $scope.screens, {
					id: screenID
				} );
				if ( findScreen && findScreen.copyingProgress ) {
					findScreen.copyingProgress += 15;
				}
			} );
		modelEvents.on(
			"dividerCreated.projectScreens",
			function ( event, response ) {
				if ( response.projectID !== $scope.project.id ) {
					return;
				}
				resortDividers( false );
				var divider = _.withProperty( $scope.dividers, "dividerID", response.dividerID );
				if ( divider && divider.length ) { // the divider was already set up properly.  No need to continue.
					return;
				}
				var tempDividerExists = false;
				var newDivider;
				for ( var d = 0; d < $scope.dividers.length; d++ ) {
					if ( $scope.dividers[ d ].dividerID === 0 || $scope.dividers[ d ].dividerID === "new" ) {
						tempDividerExists = true;
					}
				}
				if ( !tempDividerExists ) { // This event got triggered from the pusher app. So, lets see if we have a temporary divider or not.
					if ( !_.findWithProperty( $scope.dividers, "dividerID", response.dividerID ) ) {
						newDivider = {
							dividerID: response.dividerID,
							type: response.type,
							label: response.label,
							position: response.position,
							sort: response.sort,
							expanded: true
						};
						$scope.dividers.push( newDivider );
						$scope.mergeScreensAndDividers();
						$scope.insertDividerPlaceholders();
					}
				} else {
					for ( var d = 0; d < $scope.dividers.length; d++ ) {
						if ( $scope.dividers[ d ].dividerID === 0 || $scope.dividers[ d ].dividerID === "new" ) {
							newDivider = $scope.dividers[ d ];
							newDivider.dividerID = response.dividerID;
							newDivider.label = response.label;
							newDivider.position = response.position;
							newDivider.sort = response.sort;
							newDivider.expanded = true;
							break;
						}
					}
					for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
						if ( $scope.displayObjects[ d ].type != "inline_drop_zone" && ( $scope.displayObjects[ d ].dividerID === 0 || $scope.displayObjects[ d ].dividerID === "new" ) ) {
							$scope.displayObjects[ d ].dividerID = response.dividerID;
							$scope.displayObjects[ d ].label = response.label;
							$scope.displayObjects[ d ].position = response.position;
							$scope.displayObjects[ d ].sort = response.sort;
							$scope.displayObjects[ d ].expanded = true;
							break;
						}
					}
					var lastDividerID = 0;
					for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
						if ( $scope.displayObjects[ d ].type === "divider" ) {
							lastDividerID = $scope.displayObjects[ d ].dividerID;
						}
						if ( $scope.displayObjects[ d ].type === "inline_drop_zone" ) {
							$scope.displayObjects[ d ].dividerID = lastDividerID;
						}
					}
					$scope.updateDividerPositions();
				}
				if ( $scope.isMovingSelectedToNewSection && newDivider ) {
					$scope.moveSelectedToSection( newDivider );
					$scope.isMovingSelectedToNewSection = false;
					resetSelectedScreens();
				}
				$scope.applyDividerScreenCounts();
				$scope.persistDividerPositions();
			}
		);
		modelEvents.on(
			"dividerDeleted.projectScreens",
			function ( event, dividerID ) {
				if ( _.findWithProperty( $scope.dividers, "dividerID", dividerID ) ) {
					$scope.dividers = _.withoutProperty( $scope.dividers, "dividerID", dividerID );
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.insertDividerPlaceholders();
				}
				resortDividers();
			}
		);
		modelEvents.on(
			"dividerUpdated.projectScreens",
			function ( event, response ) {
				for ( var d = 0; d < $scope.dividers.length; d++ ) {
					if ( $scope.dividers[ d ].dividerID == response.dividerID ) {
						$scope.dividers[ d ].label = response.label;
						break;
					}
				}
				for ( var d = 0; d < $scope.displayObjects.length; d++ ) {
					if ( $scope.displayObjects[ d ].dividerID == response.dividerID && $scope.displayObjects[ d ].type != "inline_drop_zone" ) {
						$scope.displayObjects[ d ].label = response.label;
						break;
					}
				}
				$scope.applyDividerScreenCounts();
			}
		);
		modelEvents.on(
			"dividerPositionsUpdated.projectScreens",
			function ( event, dividers, screens ) {
				var isPositionChanged = false;
				for ( var sd = 0; sd < $scope.dividers.length; sd++ ) {
					for ( var d = 0; d < dividers.length; d++ ) {
						if ( $scope.dividers[ sd ].dividerID == dividers[ d ].dividerID &&
							$scope.dividers[ sd ].position != dividers[ d ].position
						) {
							isPositionChanged = true;
							break;
						}
					}
				}
				if ( isPositionChanged ) {
					_.setProperty( dividers, "expanded", true );
					$scope.dividers = hashKeyCopier.copyHashKeys( $scope.dividers, dividers );
					$scope.screens = augmentScreens( hashKeyCopier.copyHashKeys( $scope.screens, screens ) );
					applyScreens();
					$scope.mergeScreensAndDividers();
					$scope.insertDividerPlaceholders();
				}
			}
		);
		modelEvents.on(
			"assetDeleted",
			function ( event, assetID ) {
				$scope.layerSyncAssets = _.withoutProperty( $scope.layerSyncAssets, "id", assetID );
				$scope.screens = _.withoutProperty( $scope.screens, "parentAssetID", assetID );
				applyScreens();
				$scope.mergeScreensAndDividers();
				$scope.insertDividerPlaceholders();
			}
		);
		modelEvents.on(
			"showScreenSourceModalPreferenceUpdated",
			function ( event, pref ) {
				$scope.showScreenSourceModal = pref;
			}
		);
		modelEvents.on(
			"projectScreensUploadComplete",
			function ( event ) {
				$scope.isShowingUploader = false;
			}
		);
		$scope.setWindowTitle( "Loading Project Screens" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! testing-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.TestingController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, $location, requestContext, Deferred, projectService, projectTestingPartial, sessionService, testingService, dateHelper, modelEvents, hashKeyCopier, userService, _ ) {
		function applyRemoteData( tests, share ) {
			$scope.tests = tests;
			$scope.share = share;
			testingService.set( {
				projectID: $scope.project.id,
				mode: "list"
			} );
			$scope.setWindowTitle( $scope.project.name + " User Testing" );
			$scope.user = sessionService.user; // Passed in openModalWindow to be used in the projects-comment.htm modal window
		};

		function loadRemoteData() {
			$scope.isLoading = true;
			$scope.test = null;
			$scope.testType = null;
			Deferred.handlePromise(
				projectTestingPartial.get( $scope.projectID ),
				function ( response ) {
					if ( !renderContext.isChangeLocal() ) {
						return;
					}
					$scope.isLoading = false;
					applyRemoteData(
						response.tests,
						response.share
					);
				},
				function ( response ) {
					$scope.openModalWindow( "error", ( ( response.message != undefined ) ? response.message : "For some reason we couldn't load your User Tests. Try refreshing your browser." ) );
				}
			);
		};
		$scope.openNewTestModal = function ( subview ) {
			var subview = ( subview || "new" );
			$scope.openModalWindow( "newTest", $scope.project.id, 0, subview );
		};
		$scope.editTest = function ( test ) {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectTestingPartial.getTest( test.testId, test.testType ),
				function ( response ) {
					$scope.isLoading = false;
					$scope.test = testingService.set( response.test, false );
					$scope.testType = $scope.test.testType;
					var path = "/projects/" + $scope.projectID + "/testing/" + test.testId + "/" + ( ( test.participantCount == 0 ) ? "edit" : "view" );
					$location.path( path );
				},
				function ( response ) {
					$scope.openModalWindow( "error", ( ( response.message != undefined ) ? response.message : "For some reason we couldn't retrieve your User Test." ) );
				}
			);
		};
		$scope.duplicateTest = function ( testId ) {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectTestingPartial.duplicate( testId, $scope.userID ),
				function ( response ) {},
				function ( response ) {
					$scope.openModalWindow( "error", ( ( response.message != undefined ) ? response.message : "For some reason we couldn't duplicate this User Test." ) );
				}
			);
		};
		$scope.deleteTest = function ( test ) {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectTestingPartial.deleteTest( test.testId ),
				function ( response ) {},
				function ( response ) {
					$scope.openModalWindow( "error", ( ( response.message != undefined ) ? response.message : "For some reason we couldn't delete this User Test." ) );
				}
			);
		};
		$scope.shareTest = function ( test ) {
			$scope.openModalWindow( "testing-share", test, $scope.share );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.testing", [ "projectID", "testId" ] );
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.test = null;
		$scope.testType = null;
		$scope.isLoading = false;
		$scope.subview = renderContext.getNextSection() || "list";
		$scope.user = sessionService.user;
		$scope.userID = sessionService.user.id;
		$scope.share = "";
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "testing:partialDuplicated" );
				modelEvents.off( "testing:partialDeleted" );
				modelEvents.off( "testing:partialSaved" );
				modelEvents.off( "testing:newTest" );
				$scope.setBodyClass( "l-standard" );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function ( event ) {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				$scope.subview = renderContext.getNextSection() || "list";
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on( "testing:partialDuplicated", loadRemoteData );
		modelEvents.on( "testing:partialDeleted", loadRemoteData );
		modelEvents.on( "testing:partialSaved", loadRemoteData );
		modelEvents.on( "testing:newTest", function ( event, args ) {
			args.participantCount = 0;
			$scope.tests.push( args );
			$scope.editTest( args );
		} );
		$scope.setBodyClass( "l-standard project-testing" );
		$scope.setWindowTitle( "Loading User Tests" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! overview-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "project.overview.OverviewController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, $location, Deferred, modelEvents, dateHelper, moment, _, projectOverviewService, projectService, userService ) {
		function applyRemoteData( activity, stats, views, viewsGrouped ) {
			$scope.stats.projectViews = stats.totalViews;
			$scope.stats.numberOfPeople = stats.totalViewers;
			$scope.stats.commentCount = stats.totalComments;
			_.defaults( $scope.stats, getDefaultStats() );
			$scope.projectViewStats = viewsGrouped;
			viewStore = augmentViews( views );
			$scope.projectViews = getViewsForPagination( viewStore );
			$scope.pagination.totalResults = viewStore.length;
			applyRemoteActivityData( activity );
			$scope.setWindowTitle( $scope.project.name + " Stats" );
		}

		function applyRemoteActivityData( activity ) {
			if ( activity.alreadyAddedToActivityPeriods ) {
				return;
			}
			activity.alreadyAddedToActivityPeriods = true;
			$scope.activityStream = $scope.activityStream.concat( augmentActivity( activity ) );
			$scope.noActivity = ( $scope.activityStream.length == 0 );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectService.getByID( $scope.projectID ),
				function ( projectData ) {
					var duration = 7;
					var offset = Math.max(
						moment().utc().subtract( "days", duration ).valueOf(),
						projectData.createdAt
					);
					lastUsedOffset = offset;
					$scope.minimumOffset = Math.max(
						projectData.createdAt,
						moment( "2013-01-24" ).utc().valueOf()
					);
					Deferred.handlePromise(
						projectOverviewService.getActivityAndStats( $scope.projectID, offset, duration ),
						function ( data ) {
							if ( data.activity.length > 0 ) {
								$scope.isLoading = false;
							} else {
								$scope.loadMoreActivity();
							}
							applyRemoteData( data.activity, data.stats, data.views, data.viewsGrouped );
						}
					)
				}
			);
		}

		function augmentActivity( activity ) {
			var activityGrouped = groupActivityByTypeAndTime( activity );
			activityGrouped = groupActivityByDay( activityGrouped );
			return activityGrouped;
		}

		function augmentViews( views ) {
			var tempViews = [];
			_.forEach( views, function ( view ) {
				var duration = moment.duration( view.timeSpentInSeconds, "seconds" );
				tempViews.push( {
					avatarID: view.avatarID,
					userID: view.userID,
					userName: view.name.replace( /Anonymous User/, "Anonymous" ),
					userInitials: userService.getInitials( view.name ),
					userHasSystemAvatar: userService.isSystemAvatar( view.avatarID ),
					onlineStatus: userService.getOnlineStatus( view.lastRequestAt ),
					isAnonymous: view.isAnonymous,
					relationship: view.relationship,
					location: view.viewer_location,
					startedAtDate: dateHelper.formatRecentDate( view.startedAt, "mmm d" ),
					startedAtTime: moment( view.startedAt ).format( "h:mma" ),
					durationInHours: duration.hours(),
					durationInMins: duration.minutes(),
					durationInSecs: duration.seconds(),
					showSecs: duration.hours() == 0 && duration.seconds() > 0,
					screens: view.screenCount,
					comments: view.commentCount
				} );
			} );
			return tempViews;
		}

		function getViewsForPagination( views ) {
			var pagination = $scope.pagination;
			var startIndex = 0;
			var endIndex = 0;
			endIndex = pagination.resultsPerPage;
			$scope.pagination.hasMorePages = ( endIndex < views.length );
			return views.slice( startIndex, endIndex );
		}

		function getLastKnownOffset() {
			return lastUsedOffset;
		}

		function formatAverageTimeViewed( timeInSeconds ) {
			var timeInSeconds = timeInSeconds ? timeInSeconds : 0;
			var friendlyDuration = "";
			var duration = moment.duration( timeInSeconds, "seconds" );
			var hoursStr = duration.hours() == 0 ? "" : duration.hours().toString();
			var minutesStr = duration.minutes() == 0 ? ":" : duration.minutes().toString();
			if ( duration.seconds() < 10 ) {
				var secondsStr = duration.seconds() == 0 ? ":00" : ( ":0" + duration.seconds().toString() );
			} else {
				var secondsStr = ":" + duration.seconds().toString();
			}
			friendlyDuration = hoursStr + minutesStr + secondsStr;
			friendlyDuration = friendlyDuration.replace( /:{2,3}/, ':' );
			return ( friendlyDuration );
		}

		function getDefaultStats() {
			return ( {
				projectViews: 0,
				numberOfPeople: 0,
				commentCount: 0
			} );
		}

		function groupActivityByTypeAndTime( activity ) {
			var secondsToGroupBy = 60 * 30;
			var groupedByTime = _.groupBy( activity, function ( activityItem ) {
				var groupByTimeframeInSeconds = secondsToGroupBy;
				var timeRounded = null;
				var nearestTime = 0;
				nearestTime = Math.round( moment( activityItem.actionOccuredAt ).unix() / secondsToGroupBy ) * secondsToGroupBy;
				timeRounded = moment.unix( nearestTime );
				return timeRounded.unix() + "_" + activityItem.action;
			} );
			groupedByTime = _.map( groupedByTime, function ( activityGrouping, label ) {
				var tmpItem = {};
				var actionType = label.split( "_" )[ 1 ];
				var occuredAt = moment( _.first( activityGrouping ).actionOccuredAt );
				tmpItem.occuredAt = occuredAt.valueOf();
				tmpItem.occuredAtFormatted = occuredAt.format( "hh:mm a" );
				tmpItem.type = actionType;
				tmpItem.activity = activityGrouping;
				if ( tmpItem.type !== "projectCreated" ) {
					tmpItem.users = _.map( activityGrouping, function ( activityGrouping ) {
						return {
							userID: activityGrouping.userID,
							name: activityGrouping.userName,
							shortName: userService.getShortName( activityGrouping.userName ),
							avatarID: activityGrouping.avatarID,
							hasSystemAvatar: userService.isSystemAvatar( activityGrouping.avatarID ),
							isAnonymous: activityGrouping.isAnonymous,
							onlineStatus: userService.getOnlineStatus( activityGrouping.lastRequestAt ),
							initials: userService.getInitials( activityGrouping.userName ),
							relationship: activityGrouping.relationship
						}
					} );
					tmpItem.users = _.uniq( tmpItem.users, function ( user ) {
						return user.userID;
					} );
					if ( tmpItem.users.length == 1 ) {
						tmpItem.userNameOrCount = _.first( tmpItem.users ).name;
					} else {
						tmpItem.userNameOrCount = tmpItem.users.length + ' people';
					}
					tmpItem.screens = _.map( activityGrouping, function ( activityGrouping, key, allActivity ) {
						var activityWithUnreadComments = _.filterWithProperty(
							_.filter( allActivity, function ( activity ) {
								return ( activity.action == "commentCreated" || activity.action == "devnoteCreated" );
							} ),
							"isUnread",
							true
						);
						var tmpScreen = {
							id: activityGrouping.screenID,
							name: activityGrouping.screenName,
							imageVersion: activityGrouping.imageVersion,
							backgroundColor: activityGrouping.backgroundColor,
							consoleUrl: activityGrouping.screenID,
							commentCount: _.countWithProperty( activityWithUnreadComments, "screenID", activityGrouping.screenID )
						};
						if ( tmpScreen.commentCount > 0 ) {
							tmpScreen.consoleUrl += "/comments";
						} else {
							tmpScreen.consoleUrl += "/preview";
						}
						return tmpScreen;
					} );
					tmpItem.screens = _.uniq( tmpItem.screens, function ( screen ) {
						return screen.id;
					} );
				}
				return tmpItem;
			} );
			return groupedByTime;
		}

		function groupActivityByDay( groupedByTime ) {
			var groupedByDayAndTime = _.groupBy( groupedByTime, function ( activityGrouping ) {
				var momentObj = moment( activityGrouping.occuredAt );
				return momentObj.startOf( "day" ).unix();
			} );
			groupedByDayAndTime = _.sortOnProperty(
				_.map( groupedByDayAndTime, function ( item, label ) {
					var tmpItem = {};
					var dayOf = moment.unix( parseInt( label ) );
					tmpItem.dayOf = dayOf.unix();
					tmpItem.activities = item;
					if ( dateHelper.isToday( dayOf.toDate() ) ) {
						tmpItem.dayOfFormatted = "Today";
					} else if ( dateHelper.isYesterday( dayOf.toDate() ) ) {
						tmpItem.dayOfFormatted = "Yesterday";
					} else {
						tmpItem.dayOfFormatted = dayOf.format( "MMM D" );
					}
					return tmpItem
				} ),
				"dayOf",
				"desc"
			);
			return groupedByDayAndTime;
		}
		$scope.loadMoreActivity = function () {
			$scope.isLoadingPastActivity = true;
			var duration = 7;
			var lastKnownOffset = getLastKnownOffset();
			var pastOffset = dateHelper.addDays( lastKnownOffset, -1 * duration ).getTime();
			if ( !$scope.hasMoreActivityToLoad || pastOffset < $scope.minimumOffset ) {
				$scope.hasMoreActivityToLoad = false;
				$scope.isLoadingPastActivity = false;
				$scope.isLoading = false;
				return;
			}
			if ( dateHelper.addDays( $scope.minimumOffset, duration ).getTime() >= pastOffset ) {
				pastOffset = $scope.minimumOffset;
				$scope.hasMoreActivityToLoad = false;
			}
			lastUsedOffset = pastOffset;
			Deferred.handlePromise(
				projectOverviewService.getActivity( $scope.projectID, pastOffset, duration ),
				function ( response ) {
					var hasReturnedNoActivity = ( response.activity.length == 0 );
					if ( hasReturnedNoActivity ) {
						$scope.loadMoreActivity();
					} else {
						$scope.isLoadingPastActivity = false;
						$scope.isLoading = false;
					}
					applyRemoteActivityData( response.activity );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load the past activity. Try refreshing your browser." );
				}
			);
		};
		$scope.showMoreViewers = function () {
			$scope.pagination.resultsPerPage += 10;
			$scope.projectViews = getViewsForPagination( viewStore );
		};
		$scope.openShareModal = function ( projectID ) {
			$scope.openModalWindow( "share", projectID );
		};
		$scope.viewUser = function ( user, project ) {
			if ( user.relationship === "teamMember" ) {
				$location.path( "/team/" + user.userID + "/activity" );
			} else if ( user.relationship === "affiliate" ) {
				$scope.openModalWindow( "affiliateActivity", user.userID, project.id );
			} else {}
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.stats", "projectID" );
		var viewStore = [];
		var lastUsedOffset = 0;
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.isLoading = false;
		$scope.stats = {
			projectViews: 0,
			numberOfPeople: 0,
			commentCount: 0
		};
		$scope.pagination = {
			resultsPerPage: 10,
			hasMorePages: false,
			totalResults: 0
		}
		$scope.projectViews = [];
		$scope.projectViewStats = [];
		$scope.timespans = [];
		$scope.activityStream = [];
		$scope.noActivity = true;
		$scope.isLoadingPastActivity = false;
		$scope.hasMoreActivityToLoad = true;
		$scope.minimumOffset = 0;
		$scope.$on(
			"$destroy",
			function () {}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					$scope.stats = {
						projectViews: 0,
						numberOfPeople: 0,
						commentCount: 0
					};
					$scope.pagination = {
						resultsPerPage: 10,
						hasMorePages: false,
						totalResults: 0
					}
					loadRemoteData();
				}
			}
		);
		$scope.setWindowTitle( "Loading Project Stats" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! test-object-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	/*
With the introduction of dividers, this controller servers multiple
purposes depending on what type of object it's controlling.  The
displayObjects array contains screens, dividers, and divider_placeholders.
This controller is used for all types.
*/
	app.controller( "testing.TestObjectController", Controller );
	/** @ngInject */
	function Controller( $scope, _ ) {
		$scope.hideDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = false;
		};
		$scope.showDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = true;
		};
		$scope.isShowingDeleteConfirmation = false;
	}
} )( angular, InVision );;;
/*! thisorthat-test-form-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "testing.ThisorthatTestFormController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, requestContext, modelEvents, Deferred, projectScreensPartial, projectTestingPartial, testingService, _ ) {
		var applyRemoteData = function ( screens, dividers ) {
			$scope.screens = screens;
			$scope.dividers = dividers;
		};
		var loadData = function ( projectID, testId ) {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectScreensPartial.get( projectID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.screens, response.dividers );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your screens. Try refreshing your browser." );
				}
			);
		};
		var isNameValid = function ( name ) {
			return ( name.length > 2 );
		};
		var isQuestionValid = function ( question ) {
			return ( question.length > 3 );
		};
		var isScreenValid = function ( screen ) {
			return ( screen.id > 0 )
		};
		$scope.formIsValid = function () {
			var t = $scope.test;
			if ( !( $scope.allowSave && isNameValid( t.name ) && isQuestionValid( t.question ) && isScreenValid( t.screens.screenA ) && isScreenValid( t.screens.screenB ) ) ) {
				return false;
			}
			return true;
		};
		$scope.cancel = function () {
			if ( parseInt( $scope.test.testId, 10 ) === 0 ) {
				$scope.tests = $scope.tests.splice( $scope.tests.length - 1, 1 );
			}
			testingService.reset();
			$location.path( "/projects/" + $scope.projectID + "/testing" );
		};
		$scope.saveTest = function ( test ) {
			if ( $scope.formIsValid() ) {
				Deferred.handlePromise(
					projectTestingPartial.save( test ),
					function ( response ) {
						var test = response.test;
						test.mode = "edit";
						$scope.test = testingService.set( test );
						$scope.share = response.share;
						$scope.shareTest( $scope.test );
					},
					function ( response ) {
						$scope.openModalWindow( "error", ( ( response.message != undefined ) ? response.message : "For some reason we couldn't save your User Test." ) );
					}
				);
			}
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail.testing.edit", [ "projectID", "testId" ] );
		$scope.testId = requestContext.getParamAsInt( "testId" );
		$scope.master = angular.copy( $scope.test );
		$scope.allowEdits = $scope.test.participantCount === 0;
		$scope.allowSave = true;
		$scope.screens = [];
		$scope.$on(
			"requestContextChanged",
			function ( event ) {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.testId = requestContext.getParamAsInt( "testId" );
				if ( requestContext.hasParamChanged( "testId" ) ) {
					loadData( $scope.projectID, $scope.testId );
				}
			}
		);
		modelEvents.on( "testing:partialSaved", function () {
			$location.path( "/projects/" + $scope.projectID + "/testing" );
		} );
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "testing:partialSaved" );
				$( ".questionHelp" ).popover( "destroy" );
			}
		);
		$scope.$watch(
			"allowEdits",
			function ( newValue, oldValue ) {
				if ( !newValue ) {
					$scope.allowSave = false;
				}
			}
		);
		$scope.$watch(
			"test",
			function ( newValue, oldValue ) { // any time the full test object is updated, we need to reset the userID
				if ( newValue !== null ) {
					$scope.test.userID = $scope.userID;
					$scope.test.projectID = $scope.projectID;
				}
			}
		);
		loadData( $scope.projectID, $scope.testId );
		$( ".questionHelp" ).popover( {
			html: true,
			trigger: 'click',
			content: function () {
				return $( this ).next( ".inv-popover-content" ).clone();
			},
			template: '<div class="inv-popover question-help"><div class="popover-inner"><div class="popover-content"><p></p></div></div></div>'
		} );
	}
} )( angular, InVision );;;
/*! thisorthat-test-review-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "testing.ThisorthatTestReviewController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, Deferred, projectTestingPartial, _ ) {
		var applyData = function ( results ) {
			var totalCount = results.length,
				screenAComments = _.filterWithProperty( results, "choice", "screenA" ),
				screenAPercentage = ( screenAComments.length ) ? Math.round( screenAComments.length / totalCount * 100 ) : 0,
				screenBComments = _.filterWithProperty( results, "choice", "screenB" ),
				screenBPercentage = ( screenBComments.length ) ? Math.round( screenBComments.length / totalCount * 100 ) : 0;
			$scope.results = {
				screenA: {
					comments: screenAComments,
					percentage: screenAPercentage
				},
				screenB: {
					comments: screenBComments,
					percentage: screenBPercentage
				}
			};
		};
		var loadData = function () {
			$scope.isLoadingComments = true;
			Deferred.handlePromise(
				projectTestingPartial.getResults( $scope.test.testId ),
				function ( response ) {
					$scope.isLoadingComments = false;
					applyData(
						response.results
					);
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your comments. Try refreshing your browser." );
				}
			);
		};
		$scope.closeViewPanel = function () {
			$scope.view = {
				showFullSize: false,
				screen: {
					id: 0,
					versionId: 0,
					width: 0,
					height: 0
				}
			};
		};
		$scope.deleteTest = function () {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectTestingPartial.deleteTest( $scope.test.testId ),
				function ( response ) {
					$scope.isLoading = false;
					$location.path( "/projects/" + $scope.projectID + "/testing" );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't duplicate this test. Try refreshing your browser." );
				}
			);
		};
		$scope.duplicateTest = function () {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectTestingPartial.duplicate( $scope.test.testId, $scope.userID ),
				function ( response ) {
					$scope.isLoading = false;
					$location.path( "/projects/" + $scope.projectID + "/testing" );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't duplicate this test. Try refreshing your browser." );
				}
			);
		};
		$scope.isLoadingComments = false;
		$scope.results = {
			screenA: {
				comments: [],
				percentage: 0
			},
			screenB: {
				comments: [],
				percentage: 0
			}
		};
		$scope.view = {
			showFullSize: false,
			screen: {
				id: 0,
				versionId: 0,
				width: 0,
				height: 0
			}
		};
		loadData();
	}
} )( angular, InVision );;;
/*! list-with-groups-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "projects.ListWithGroupsController", Controller );
	/** @ngInject */
	function Controller( $scope, sessionService, modelEvents, hashKeyCopier, Deferred, projectService, projectGroupService, $filter, _ ) {
		var MY_PROJECTS_INDEX = 0,
			OTHERS_PROJECTS_INDEX = 1;
		$scope.states = {
			READY: "READY",
			SORTING: "SORTING",
			EDITING: "EDITING"
		};
		$scope.state = $scope.states.READY;
		$scope.placeholderName = 'Click to add a new section';
		$scope.placeholderClass = 'placeholder';
		$scope.newGroupName = 'New Section';
		$scope.rowLimit = 3;
		$scope.projectHeight = 334;
		$scope.projectMarginBottom = 0;
		$scope.sections = [ {
			id: "owned-by-me",
			label: "My Projects",
			groups: []
		}, {
			id: "owned-by-others",
			label: "Owned By Others",
			groups: []
		} ];
		$scope.newGroup = {
			id: 0,
			sort: 0,
			name: $scope.newGroupName,
			projects: [],
			isPlaceholder: true
		};
		$scope.$on(
			"projects:sortStart",
			function () {
				$scope.state = $scope.states.SORTING;
			}
		);
		$scope.$on(
			"projects:sortStop",
			function () {
				if ( $scope.state !== $scope.states.SORTING ) {
					return;
				}
				$scope.state = $scope.states.READY;
			}
		);
		$scope.$watch( "filters.projectFilter", function ( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			$scope.filterMatchesNoProject = ( _.countWithProperty( $scope.projects, "name", newValue ) > 0 );
			_.each( $scope.sections, function ( section ) {
				section.projectCount = _.reduce( section.groups, function ( sum, group ) {
					return sum + $filter( 'filter' )( group.projects, {
						'name': newValue
					}, true ).length;
				}, 0 );
			} );
		} );
		$scope.$on(
			"projects:sortUpdate",
			function ( event, data ) {
				var projectIDs = "";
				var movedProject = _.findWithProperty( $scope.projects, "id", data.movedProject.id );
				movedProject.projectGroupID = data.toGroup.id ? data.toGroup.id : 0;
				projectIDs = _.pluck( data.toGroup.projects, "id" );
				Deferred.handlePromise(
					projectService.updateSort( projectIDs ),
					function ( response ) {
						_.each( response, function ( updatedProject ) {
							var project = _.findWithProperty( $scope.projects, "id", updatedProject.id );
							_.extendExistingProperties( project, updatedProject );
						} );
					}
				);
				if ( data.fromGroup.id !== data.toGroup.id ) {
					if ( data.fromGroup.projects.length ) {
						projectIDs = _.pluck( data.fromGroup.projects, "id" );
						Deferred.handlePromise(
							projectService.updateSort( projectIDs ),
							function ( response ) {
								_.each( response, function ( updatedProject ) {
									var project = _.findWithProperty( $scope.projects, "id", updatedProject.id );
									_.extendExistingProperties( project, updatedProject );
								} );
							}
						);
					}
				}
				if ( !data.toGroup.isPlaceholder ) {
					projectGroupService.updateGroup( data.toGroup );
				} else {
					if ( !data.fromGroup.isPlaceholder ) {
						projectGroupService.removeProjectsFromGroups( [ data.movedProject ] );
					}
				}
			}
		);
		$scope.$watch( "activeProjects", watchActiveProjects );
		$scope.addNewGroup = addNewGroup;
		$scope.addNewPlaceholderGroup = addNewPlaceholderGroup;
		$scope.createNewGroup = createNewGroup;
		$scope.getPlaceholderOffset = getPlaceholderOffset;
		$scope.getPlaceholders = getPlaceholders;
		$scope.moveGroup = moveGroup;
		$scope.removeGroup = removeGroup;
		$scope.resetGroupName = resetGroupName;
		$scope.setGroupName = setGroupName;
		$scope.splitGroup = splitGroup;
		$scope.startEditingGroup = startEditingGroup;

		function addNewGroup( section, group, onTop ) {
			var method = onTop ? 'unshift' : 'push';
			var newGroup = ng.copy( $scope.newGroup );
			$scope.state = $scope.states.EDITING;
			section.groups[ method ]( newGroup );
			group.id = 0;
			group.isPlaceholder = false;
			group.isEditing = true;
			group.sort = getGroupPosition( group, section );
			group.isForUsersOwnProjects = ( section.id === 'owned-by-me' );
			$scope.groups.push( group );
			Deferred.handlePromise(
				projectGroupService.createGroup( group ),
				function ( response ) {
					_.extendExistingProperties( group, response );
					projectGroupService.updateGroupSort( getNonEmptyNonPlaceholderGroups( section.groups ) );
					_.each( group.projects, function ( project ) {
						var existingProject = _.findWithProperty( $scope.projects, "id", project.id );
						existingProject.projectGroupID = group.id;
					} );
				}
			);
			$scope.$broadcast( "addNewGroup", section, onTop );
		}

		function addNewPlaceholderGroup( section, onTop ) {
			var method = onTop ? 'unshift' : 'push';
			var newGroup = ng.copy( $scope.newGroup );
			newGroup.isPlaceholder = true;
			newGroup.isEditing = false;
			section.groups[ method ]( newGroup );
			$scope.$broadcast( "addNewGroup", section, onTop );
		}

		function createNewGroup( section, group, first ) {
			addNewGroup( section, group, first );
		}

		function getPlaceholderOffset( dividerIndex ) {
			var topOffset = ( dividerIndex + 1 ) * 348;
			return {
				top: topOffset + "px"
			};
		}

		function getPlaceholders( projectCount ) {
			var placeHolders = [],
				maxPlaceHolders = Math.ceil( projectCount / $scope.rowLimit ) - 1;
			for ( var i = 0; i < maxPlaceHolders; i++ ) {
				placeHolders[ i ] = i;
			};
			return placeHolders;
		}

		function moveGroup( section, group, currentIndex, newIndex ) {
			var groupToSwap = section.groups[ newIndex ];
			var isEmptyPlaceholder = ( groupToSwap.isPlaceholder && groupToSwap.projects.length == 0 );
			if ( !isEmptyPlaceholder ) {
				section.groups[ newIndex ] = group;
				section.groups[ currentIndex ] = groupToSwap;
			}
			projectGroupService.updateGroupSort( getNonEmptyNonPlaceholderGroups( section.groups ) );
		}

		function removeGroup( section, group ) {
			var groupIndex = section.groups.indexOf( group ),
				groupHeirIndex = groupIndex - 1,
				groupHeir = section.groups[ groupHeirIndex ];
			$scope.setGroups( _.rejectWithProperty( $scope.groups, "id", group.id ) );
			projectGroupService.deleteGroup( group );
			projectGroupService.updateGroupSort( getNonEmptyNonPlaceholderGroups( section.groups ) );
			if ( groupHeir ) {
				if ( groupHeirIndex < 1 ) {
					groupHeir.isUnnamedGroup = true;
					groupHeir.id = 0;
				}
				_.each( $scope.projects, function ( project ) {
					if ( project.projectGroupID == group.id ) {
						project.projectGroupID = groupHeir.id;
					}
				} );
				groupHeir.projects = ( groupIndex > groupHeirIndex ) ? groupHeir.projects.concat( group.projects ) : group.projects.concat( groupHeir.projects );
				section.groups.splice( groupIndex, 1 );
				if ( groupHeir.projects.length ) {
					Deferred.handlePromise(
						projectService.updateSort( _.pluck( groupHeir.projects, "id" ) ),
						function ( response ) {
							_.each( response, function ( updatedProject ) {
								var project = _.findWithProperty( $scope.projects, "id", updatedProject.id );
								_.extendExistingProperties( project, updatedProject );
							} );
						}
					);
				}
				if ( groupHeir.isPlaceholder ) {
					if ( groupHeir.projects.length ) {
						projectGroupService.removeProjectsFromGroups( groupHeir.projects );
					}
				} else {
					projectGroupService.updateGroup( groupHeir );
				}
			}
		}

		function resetGroupName( group ) {
			group.name = group.originalName;
			group.isEditing = false;
			$scope.state = $scope.states.READY;
		}

		function setGroupName( group, section ) {
			var newName = group.name,
				oldName = group.originalName,
				hasNameChanged = ( newName != oldName || newName == $scope.newGroupName );
			if ( hasNameChanged ) {
				group.originalName = newName;
				projectGroupService.updateGroup( group );
			}
			$scope.state = $scope.states.READY;
			group.isEditing = false;
		}

		function splitGroup( section, group, dividerIndex ) {
			var groupIndex = section.groups.indexOf( group ),
				newGroup = ng.copy( $scope.newGroup ),
				splitProjectsIndex = ( dividerIndex + 1 ) * $scope.rowLimit;
			if ( _.isUndefined( group.id ) ) {
				group.id = 0;
			}
			newGroup.isEditing = true;
			newGroup.isPlaceholder = false;
			$scope.state = $scope.states.EDITING;
			newGroup.projects = group.projects.slice( splitProjectsIndex );
			group.projects.splice( splitProjectsIndex );
			section.groups.splice( ( groupIndex + 1 ), 0, newGroup );
			newGroup.sort = getGroupPosition( newGroup, section );
			newGroup.isForUsersOwnProjects = ( section.id === 'owned-by-me' );
			if ( group.id > 0 ) {
				Deferred.handleAllPromises(
					[
						projectGroupService.createGroup( newGroup ),
						projectGroupService.updateGroup( group )
					],
					function ( createGroupResponse, updateGroupResponse ) {
						_.extendExistingProperties( newGroup, createGroupResponse );
						_.extendExistingProperties( group, updateGroupResponse );
						projectGroupService.updateGroupSort( getNonEmptyNonPlaceholderGroups( section.groups ) );
						$scope.groups.push( newGroup );
						_.each( group.projects, function ( project ) {
							var existingProject = _.findWithProperty( $scope.projects, "id", project.id );
							existingProject.projectGroupID = group.id;
						} );
						_.each( newGroup.projects, function ( project ) {
							var existingProject = _.findWithProperty( $scope.projects, "id", project.id );
							existingProject.projectGroupID = newGroup.id;
						} );
					}
				);
			} else {
				Deferred.handlePromise(
					projectGroupService.createGroup( newGroup ),
					function ( response ) {
						_.extendExistingProperties( newGroup, response );
						projectGroupService.updateGroupSort( getNonEmptyNonPlaceholderGroups( section.groups ) );
						$scope.groups.push( newGroup );
						_.each( group.projects, function ( project ) {
							var existingProject = _.findWithProperty( $scope.projects, "id", project.id );
							existingProject.projectGroupID = group.id;
						} );
						_.each( newGroup.projects, function ( project ) {
							var existingProject = _.findWithProperty( $scope.projects, "id", project.id );
							existingProject.projectGroupID = newGroup.id;
						} );
					}
				);
			}
			$scope.$broadcast( "splitGroup", section, newGroup );
		}

		function startEditingGroup( group ) {
			group.isEditing = true;
			group.originalName = group.name;
			$scope.$broadcast( "editingGroup", group );
		}

		function getGroupPosition( group, section ) {
			var position = 0,
				nonEmptyNonPlaceholderGroups = [];
			nonEmptyNonPlaceholderGroups = getNonEmptyNonPlaceholderGroups( section.groups );
			_.forEach( nonEmptyNonPlaceholderGroups, function ( aGroup, index ) {
				if ( _.isEqual( aGroup, group ) ) {
					position = ( index + 1 );
					return false;
				}
			} );
			return position;
		}

		function getNonEmptyNonPlaceholderGroups( groups ) {
			var filteredGroups = [];
			filteredGroups = _.filter( groups, function ( filteringGroup ) {
				var isPlaceholder = filteringGroup.isPlaceholder;
				var isEmpty = filteringGroup.projects.length == 0;
				return ( !( isPlaceholder && isEmpty ) );
			} );
			return filteredGroups;
		}

		function groupProjects( groups, projects ) {
			var groupsWithProjects = [],
				anonymousGroup = {};
			anonymousGroup = {
				name: $scope.placeholderName,
				projects: _.withProperty( projects, "projectGroupID", 0 ),
				isPlaceholder: true,
				sort: 0
			};
			var usedGroupIDs = _.pluck( projects, "projectGroupID" );
			var validGroupIDs = _.pluck( groups, "id" ).concat( [ 0 ] );
			var invalidGroupIDs = _.difference( usedGroupIDs, validGroupIDs );
			if ( invalidGroupIDs.length ) {
				anonymousGroup.projects = anonymousGroup.projects.concat( _.withPropertyRange( projects, "projectGroupID", invalidGroupIDs ) );
				projectGroupService.removeProjectsFromGroups( _.withPropertyRange( projects, "projectGroupID", invalidGroupIDs ) );
			}
			if ( projects.length ) {
				groupsWithProjects = _.map( groups, function ( group ) {
					group.projects = _.sortOnProperty(
						_.withProperty( projects, "projectGroupID", group.id ),
						"sort",
						"asc"
					);
					group.isPlaceholder = false;
					return group;
				} );
				if ( anonymousGroup.projects.length > 0 ) {
					groupsWithProjects.unshift( anonymousGroup );
				}
				groupsWithProjects = _.sortOnProperty( groupsWithProjects, "sort", "asc" );
			} else {
				anonymousGroup.projects = _.sortOnProperty( projects, "sort", "asc" );
				groupsWithProjects = [ anonymousGroup ];
			}
			return groupsWithProjects;
		}

		function shouldHideTitle( otherProjects ) {
			if ( $scope.isEnterprise ) {
				if ( $scope.enterpriseProjects.length ) {
					return false;
				}
				return true;
			}
			var hasNoCompanyProjects = _.isUndefined( _.find( $scope.companies, function ( c ) {
				return c.teamProjects.length > 0;
			} ) );
			var hasOtherProjects = ( otherProjects.length > 0 );
			if ( hasNoCompanyProjects && !hasOtherProjects ) return true;
			return false;
		}

		function splitProjectIntoSectionsAndGroups( activeProjects, groups ) {
			var collaboratorProjects = _.withProperty( activeProjects, "isCollaborator", true ),
				myProjects = [],
				othersProjects = [],
				groupsForMyProjects = _.withProperty( groups, "isForUsersOwnProjects", true ),
				groupsForOthersProjects = _.withProperty( groups, "isForUsersOwnProjects", false );
			if ( $scope.isEnterprise ) {
				myProjects = collaboratorProjects;
			} else {
				othersProjects = _.withoutProperty( collaboratorProjects, "userID", sessionService.user.id );
				myProjects = _.withProperty( collaboratorProjects, "userID", sessionService.user.id );
			}
			$scope.hideTitle = shouldHideTitle( othersProjects );
			$scope.sections[ MY_PROJECTS_INDEX ].groups = groupProjects( groupsForMyProjects, myProjects );
			$scope.sections[ OTHERS_PROJECTS_INDEX ].groups = groupProjects( groupsForOthersProjects, othersProjects );
			_.forEach( $scope.sections, function ( section, i ) {
				var isFirstGroupAnonymous = _.first( section.groups ).name === $scope.placeholderName;
				section.projectCount = _.reduce( section.groups, function ( sum, group ) {
					return sum + group.projects.length;
				}, 0 );
				if ( section.projectCount > 0 ) {
					if ( !isFirstGroupAnonymous ) {
						addNewPlaceholderGroup( section, true );
					}
					addNewPlaceholderGroup( section, false );
				}
			} );
		}

		function watchActiveProjects( newValue, oldValue ) {
			splitProjectIntoSectionsAndGroups( $scope.activeProjects, $scope.groups );
		}
	}
} )( angular, InVision );;;
/*! list-without-groups-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "projects.ListWithoutGroupsController", Controller );
	/** @ngInject */
	function Controller( $scope, modelEvents, _ ) {
		$scope.projectsOwnedByMe = [];
		$scope.projectsOwnedByOthers = [];
		$scope.visibleProjectsOwnedByMeCount = 0;
		$scope.visibleProjectsOwnedByOthersCount = 0;
		$scope.isShowingOnboardingTile = false;
		$scope.$watch( "activeProjects", watchActiveProjects );
		$scope.$watch( "sort", watchSortPreference );
		$scope.$watch( "filters.projectFilter", watchProjectFilter );

		function sortProjects( projects ) {
			if ( $scope.sort === "alpha" ) {
				return ( sortProjectsByName( projects ) );
			} else {
				return ( sortProjectsByActivity( projects ) );
			}
		}

		function sortProjectsByActivity( projects ) {
			return ( _.sortOnProperty( projects, "lastUpdatedByUserAt", "desc" ) );
		}

		function sortProjectsByName( projects ) {
			return ( _.sortOnPropertyUsingNaturalOrder( projects, name ) );
		}

		function updateOnboardingTileVisibility() {
			$scope.isShowingOnboardingTile = ( ( $scope.sort === "activity" ) && userOnlyOwnsSampleProjects() );
		}

		function shouldHideTitle() {
			if ( $scope.isEnterprise ) {
				if ( !$scope.enterpriseProjects.length ) return true;
			} else {
				var hasNoCompanyProjects = _.isUndefined( _.find( $scope.companies, function ( c ) {
					return c.teamProjects.length > 0;
				} ) );
				var hasOtherProjects = ( $scope.visibleProjectsOwnedByOthersCount > 0 );
				if ( hasNoCompanyProjects && !hasOtherProjects ) return true;
			}
			return false;
		}

		function updateVisibleProjectCounts() {
			if ( $scope.isEnterprise ) {
				$scope.visibleProjectsOwnedByMeCount = _.filter( $scope.activeProjects, function ( project ) {
					if ( project.isCollaborator === true && project.isHiddenByFilter === false ) {
						return true;
					}
					return false;
				} ).length;
				$scope.visibleProjectsOwnedByOthersCount = 0;
			} else {
				$scope.visibleProjectsOwnedByMeCount = _.countWithProperty( $scope.projectsOwnedByMe, "isHiddenByFilter", false );
				$scope.visibleProjectsOwnedByOthersCount = _.countWithProperty( $scope.projectsOwnedByOthers, "isHiddenByFilter", false );
			}
			$scope.hideTitle = shouldHideTitle();
		}

		function userOnlyOwnsSampleProjects() {
			return (
				_.countWithProperty( $scope.projectsOwnedByMe, "isSample", true ) &&
				!_.countWithProperty( $scope.projectsOwnedByMe, "isSample", false )
			);
		}

		function watchActiveProjects( newValue, oldValue ) {
			if ( $scope.isEnterprise ) {
				$scope.projectsOwnedByMe = sortProjects( _.withProperty( $scope.activeProjects, "isCollaborator", true ) );
				$scope.projectsOwnedByOthers = []; // enterprise doesn't have "owned by others"
				$scope.enterpriseProjects = sortProjects( $scope.enterpriseProjects );
			} else {
				$scope.projectsOwnedByMe = sortProjects( $scope.filterProjectsOwnedByMe( $scope.activeProjects ) );
				$scope.projectsOwnedByOthers = sortProjects( $scope.filterProjectsOwnedByOthers( $scope.activeProjects ) );
			}
			updateVisibleProjectCounts();
			updateOnboardingTileVisibility();
		}

		function watchProjectFilter( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			updateVisibleProjectCounts();
		}

		function watchSortPreference( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			$scope.projectsOwnedByMe = sortProjects( $scope.projectsOwnedByMe );
			$scope.projectsOwnedByOthers = sortProjects( $scope.projectsOwnedByOthers );
			$scope.enterpriseProjects = sortProjects( $scope.enterpriseProjects );
		}
	}
} )( angular, InVision );;;
/*! projects-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "projects.ProjectsController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, $route, $routeParams, $filter, Deferred, config, projectService, projectsProjectsPartial, accountService, sessionService, userService, modelEvents, dateHelper, hashKeyCopier, _, moment, firebaseStateService, colorContrastService ) {
		$scope.isLoading = false;
		$scope.projects = [];
		$scope.activeProjects = [];
		$scope.archivedProjects = [];
		$scope.enterpriseProjects = [];
		$scope.hideTitle = false;
		$scope.companies = [];
		$scope.visibleProjectCount = 0;
		$scope.visibleArchivedProjectCount = 0;
		$scope.visibleEnterpriseProjects = 0;
		$scope.noMatchingProjects = false;
		$scope.isShowingArchivedProjects = false;
		$scope.groups = [];
		$scope.subscription = null;
		$scope.sort = getSortPreference();
		$scope.canShowAllEnterpriseProjects = canShowAllEnterpriseProjects();
		$scope.filters = {
			projectFilter: ""
		};
		$scope.duplicateProject = function ( project ) {
			$scope.openModalWindow( "duplicateProject", project );
		};
		$scope.setWindowTitle( "Projects" );
		$scope.liveshare = firebaseStateService.getState();
		loadRemoteData();
		$scope.$watch( "filters.projectFilter", watchProjectFilter );
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "projectCreated.projects" );
				modelEvents.off( "projectDeleted.projects" );
				modelEvents.off( "projectUpdated.projects" );
				modelEvents.off( "projectUserAdded.projects" );
				modelEvents.off( "subscriptionChanged.projects" );
				modelEvents.off( "projectDuplicationStatusUpdated.projects" );
			}
		);
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.liveshare = data;
		} );
		modelEvents.on(
			"projectCreated.projects",
			function () {
				loadRemoteData();
			}
		);
		modelEvents.on(
			"projectDeleted.projects",
			function ( event, projectID ) {
				var projects = _.withoutProperty( $scope.projects, "id", projectID );
				applyRemoteData( projects, $scope.groups, $scope.subscription, $scope.companies );
				clearProjectFilter();
			}
		);
		modelEvents.on(
			"projectUpdated.projects",
			function ( event, project ) {
				var cachedProject = _.extendExistingProperties(
					_.findWithProperty( $scope.projects, "id", project.id ),
					project
				);
				if ( cachedProject ) {
					applyRemoteData( $scope.projects, $scope.groups, $scope.subscription, $scope.companies );
				}
				clearProjectFilter();
			}
		);
		modelEvents.on(
			"projectDuplicationStatusUpdated.projects",
			function ( event, project ) {
				var cachedProject = _.extendExistingProperties(
					_.findWithProperty( $scope.projects, "id", project.id ),
					project
				);
				clearProjectFilter();
			}
		);
		modelEvents.on(
			"projectUserAdded.projects",
			function ( event, projectID, userID ) {
				if ( userID === sessionService.user.id ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged.projects",
			function ( event, subscription ) {
				$scope.subscription = subscription;
			}
		);
		$scope.openLiveShare = function ( project ) {
			if ( project.isOverQuota ) {
				if ( project.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan", {
							openedDueTo: "project quota"
						} )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			} else if ( !project.screenCount ) {
				return (
					$scope.openModalWindow( "error", "You can't LiveShare this project until at least one screen has been uploaded." )
				);
			}
			if ( $scope.user.hasClosedLiveshareIntro ) {
				if ( $scope.liveshare.currentTarget != null && $scope.liveshare.participants > 0 ) {
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() === "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareProject", $scope.liveshare.currentTarget, $scope.liveshare.conferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else if ( $scope.liveshare.currentTarget !== null ) {
					fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
					fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
					fbRedirectTarget.set( project.name );
					fbStatusRef.set( "redirecting_prep" );
					fbStatusRef.on( "value", function ( snap ) {
						if ( snap.val() === "redirecting" ) {
							$scope.$emit( "autosubmit", "#liveshareForm-" + project.id, $scope.liveshare.currentTarget );
							fbStatusRef.off( "value" );
							fbStatusRef = null;
						}
					} );
				} else {
					$scope.liveshare.target = "liveshare_" + firebaseStateService.guid();
					firebaseStateService.setTarget( $scope.liveshare.target );
					$scope.$emit( "autosubmit", "#liveshareForm-" + project.id, $scope.liveshare.target );
				}
			} else {
				$scope.openModalWindow( "liveshare-intro", project.id );
				$scope.selectedProject = project;
			}
		};
		$scope.openShareModal = function ( project ) {
			if ( project.isOverQuota ) {
				if ( project.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan", {
							openedDueTo: "project quota"
						} )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			} else if ( !project.screenCount ) {
				return (
					$scope.openModalWindow( "error", "You can't share this project until at least one screen has been uploaded." )
				);
			}
			$scope.openModalWindow( "share", project.id, 0, "new" );
		};
		$scope.projectTileStyle = function ( project ) {
			return {
				backgroundColor: '#' + ( !project.IsProcessed ? 'fcfcfd' : project.homeScreenBackgroundColor )
			};
		};
		var fbStatusRef;
		var fbRedirectTarget;
		$scope.activateProject = activateProject;
		$scope.archiveProject = archiveProject;
		$scope.clearProjectFilter = clearProjectFilter;
		$scope.deleteProject = deleteProject;
		$scope.filterProjectsOwnedByMe = filterProjectsOwnedByMe;
		$scope.filterProjectsOwnedByOthers = filterProjectsOwnedByOthers;
		$scope.gotoProject = gotoProject;
		$scope.joinProject = joinProject;
		$scope.openNewProjectModal = openNewProjectModal;
		$scope.setGroups = setGroups;
		$scope.sortProjectsByActivity = sortProjectsByActivity;
		$scope.sortProjectsByName = sortProjectsByName;
		$scope.sortProjectsByUserSort = sortProjectsByUserSort;
		$scope.toggleArchivedProjects = toggleArchivedProjects;
		$scope.selectedProject = {};

		function applyFiltersToUrl() {
			var projectFilter = $scope.filters.projectFilter;
			if ( projectFilter ) {
				$location.search( "projectFilter", projectFilter );
			} else {
				$location.search( "projectFilter", null );
			}
		}

		function getBestSearchFilter() {
			return ( $location.search().projectFilter || "" );
		}

		function activateProject( event, project ) {
			if ( shouldIgnoreEvent( event ) ) {
				return;
			}
			if (
				( project.userID !== sessionService.user.id ) ||
				$scope.subscription.canArchiveProjects
			) {
				$scope.openModalWindow( "activateProject", project.id, project.name );
			} else if ( $scope.isAdmin || $scope.isManager || $scope.isContributor ) {
				$scope.openModalWindow( "activateProject", project.id, project.name );
			} else {
				$scope.openModalWindow( "changePlan", {
					openedDueTo: "project quota"
				} );
			}
		}

		function archiveProject( project ) {
			if ( project.canProjectOwnerArchiveProjects && ( project.isOwnedByUser || project.isUserAdminForProjectOwner ) ) {
				$scope.openModalWindow( "archiveProject", project.id );
			} else if ( $scope.isEnterprise && ( $scope.isAdmin || $scope.isManager ) ) {
				$scope.openModalWindow( "archiveProject", project.id );
			} else if ( project.isOwnedByUser ) {
				$scope.openModalWindow( "archiveUpgrade" );
			} else if ( !project.isUserAdminForProjectOwner ) {
				$scope.openModalWindow( "error", "The project owner must give you Admin permissions before you can archive this project." );
			} else {
				$scope.openModalWindow( "error", "The project owner doesn't have the ability to archive projects." );
			}
		}

		function augmentCompaniesWithProjects( companies, projects ) {
			_.each( companies, function ( company ) {
				company.teamProjects = _.withProperty( projects, "userID", company.leadUserID );
			} );
			return companies;
		}

		function clearProjectFilter() {
			$scope.filters.projectFilter = "";
		}

		function deleteProject( project ) {
			$scope.openModalWindow( "deleteProject", project.id );
		}

		function filterProjectsOwnedByMe( projects ) {
			return (
				_.withProperty(
					_.withProperty( projects, "userID", sessionService.user.id ),
					"isCollaborator", true
				)
			);
		}

		function filterCollaboratorProjects( projects, isCollaborator ) {
			return (
				_.withProperty(
					projects,
					"isCollaborator", isCollaborator
				)
			);
		}

		function canShowAllEnterpriseProjects() {
			if ( $scope.isEnterprise ) {
				if ( $scope.isContributor && !$scope.enterpriseConfig.permissions.canDesignersViewAllProjects ) {
					return false;
				}
				return true;
			}
			return false;
		}

		function filterProjectsOwnedByOthers( projects ) {
			return (
				_.withProperty(
					_.withoutProperty( projects, "userID", sessionService.user.id ),
					"isCollaborator", true
				)
			);
		}

		function gotoProject( event, project ) {
			if ( shouldIgnoreEvent( event ) ) {
				return;
			}
			$location.path( "/projects/" + project.id );
		}

		function joinProject( event, project ) {
			if ( shouldIgnoreEvent( event ) ) {
				return;
			}
			Deferred.handlePromise(
				projectService.addUserToProject( project.id, $scope.user.id ),
				function ( response ) {
					gotoProject( null, project );
				},
				function ( response ) {
					console.warn( response );
				}
			);
		}

		function openNewProjectModal() {
			if ( needsAccountUpgrade() ) {
				$scope.openModalWindow( "changePlan", {
					openedDueTo: "project quota"
				} );
			} else {
				$scope.openModalWindow( "newProject" );
			}
		}

		function needsAccountUpgrade() {
			return $scope.subscription.subscriptionPlanID === 30;
		}

		function setGroups( groups ) {
			$scope.groups = groups;
		}

		function sortProjectsByActivity() {
			clearProjectFilter();
			setSortPreference( "activity" );
		}

		function sortProjectsByName() {
			clearProjectFilter();
			setSortPreference( "alpha" );
		}

		function sortProjectsByUserSort() {
			clearProjectFilter();
			setSortPreference( "userSort" );
		}

		function toggleArchivedProjects() {
			$scope.isShowingArchivedProjects = !$scope.isShowingArchivedProjects;
		}

		function applyRemoteData( projects, projectGroups, subscription, companies, enterpriseProjects ) {
			$scope.projects = hashKeyCopier.copyHashKeys( $scope.projects, augmentProjects( projects ) );
			$scope.activeProjects = filterActiveProjects( $scope.projects );
			$scope.archivedProjects = sortArchivedProjects( filterArchivedProjects( $scope.projects ) );
			$scope.companies = augmentCompaniesWithProjects( companies, filterTeamProjects( $scope.projects ) );
			$scope.enterpriseProjects = ( $scope.isEnterprise ) ? filterCollaboratorProjects( $scope.activeProjects, false ) : [];
			$scope.visibleProjectCount = $scope.isReviewer ? $scope.activeProjects.length : $scope.projects.length;
			$scope.visibleArchivedProjectCount = $scope.archivedProjects.length;
			$scope.groups = hashKeyCopier.copyHashKeys( $scope.groups, projectGroups );
			$scope.subscription = subscription;
			checkRouteForProjectActivation();
			checkRouteForDropboxConnected();
			$scope.filters.projectFilter = getBestSearchFilter();
			applyProjectFilter();
		}

		function augmentProject( project ) {
			project.formActionLS = '/liveshare/create/' + project.id;
			project.normalizedFilterTarget = project.name.toLowerCase();
			project.truncatedName = calculateTruncatedProjectName( project.name );
			project.isOwnedByUser = ( project.userID === sessionService.user.id );
			project.canBeDeletedByUser = ( project.isOwnedByUser || $scope.isAdmin );
			project.updatedAtLabel = moment( project.mostrecentactivity.actionOccuredAt ).format( "MMM D, YYYY" );
			project.screenCountLabel = calculateScreenCountLabel( project.screenCount );
			project.isHiddenByFilter = false;
			project.thumbnailUrl = project.homeScreenID ? ( "/thumbnails/" + project.homeScreenID + "/" + project.homeScreenImageVersion ) : "/assets/apps/d/img/add-screens-thumbnail.png";
			if ( project.homeScreenBackgroundColor ) {
				project.isLightBackground = colorContrastService.isLight( project.homeScreenBackgroundColor );
				project.isDarkBackground = !project.isLightBackground;
			} else {
				project.isLightBackground = true;
				project.isDarkBackground = false;
			}
			augmentProjectCollaborators( project.collaborators );
			sortProjectCollaborators( project.userID, project.collaborators );
			project.isProcessed = project.isProcessed;
			project.projectCopyPercentage = project.projectCopyPercentage !== undefined ? parseInt( project.projectCopyPercentage ) : 0;
			return ( project );
		}

		function augmentProjectCollaborator( collaborator ) {
			collaborator.hasSystemAvatar = userService.isSystemAvatar( collaborator.avatarID );
			collaborator.initials = userService.getInitials( collaborator.name );
		}

		function augmentProjectCollaborators( collaborators ) {
			return ( _.each( collaborators, augmentProjectCollaborator ) );
		}

		function augmentProjects( projects ) {
			return ( _.each( projects, augmentProject ) );
		}

		function calculateScreenCountLabel( screenCount ) {
			if ( screenCount === 1 ) {
				return ( "1 Screen" );
			}
			return ( screenCount + " Screens" );
		}

		function calculateTruncatedProjectName( name ) {
			if ( name.length <= 53 ) {
				return ( name );
			}
			return ( name.slice( 0, 50 ) + "..." );
		}

		function checkRouteForProjectActivation() {
			if ( $route.current.action !== "standard.projects.activate" ) {
				return;
			}
			var project = getProjectByID( parseInt( $routeParams.id, 10 ) );
			$location.path( "/projects" );
			if ( !project ) {
				return;
			}
			activateProject( null, project );
		}

		function checkRouteForDropboxConnected() {
			if ( $route.current.action !== "standard.projects.dropboxConnected" ) {
				return;
			}
			$location.path( "/projects" );
			$scope.openModalWindow( "dropboxConnected" );
		}

		function filterActiveProjects( projects ) {
			return (
				_.withProperty( projects, "isArchived", false )
			);
		}

		function filterArchivedProjects( projects ) {
			if ( $scope.isEnterprise && !$scope.canShowAllEnterpriseProjects ) {
				return _.withProperty( filterCollaboratorProjects( projects, true ), "isArchived", true );
			}
			return (
				_.withProperty( projects, "isArchived", true )
			);
		}

		function filterTeamProjects( projects ) {
			return (
				_.withProperty( projects, "isCollaborator", false )
			);
		}

		function getProjectByID( id ) {
			return (
				_.findWithProperty( $scope.projects, "id", id )
			);
		}

		function getSortPreference() {
			switch ( sessionService.user.projectsSortPreference || 3 ) {
			case 1:
				return ( "userSort" );
			case 2:
				return ( "alpha" );
			default:
				return ( "activity" );
			}
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectsProjectsPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.projects, response.projectGroups, response.subscription, response.companies );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your projects. Try refreshing your browser." );
				}
			);
		}

		function setSortPreference( sortType ) {
			$scope.sort = sortType;
			var sortTypeAsInt;
			switch ( sortType ) {
			case "userSort":
				sortTypeAsInt = 1;
				break;
			case "alpha":
				sortTypeAsInt = 2;
				break;
			default:
				sortTypeAsInt = 3;
				break;
			}
			accountService.updateProjectsSortPreference( sortTypeAsInt );
			sessionService.user.projectsSortPreference = sortTypeAsInt;
		}

		function sortArchivedProjects( projects ) {
			_.sortOnPropertyUsingNaturalOrder( projects, name );
			return ( projects );
		}

		function shouldIgnoreEvent( event ) {
			var patternToNotProcess = /cancelOtherListeners/i;
			return ( event && patternToNotProcess.test( event.target.className ) );
		}

		function sortProjectCollaborators( ownerUserID, collaborators ) {
			collaborators.sort(
				function ( a, b ) {
					if ( a.id === ownerUserID ) {
						return ( -1 );
					} else if ( b.id === ownerUserID ) {
						return ( 1 );
					}
					return ( a.lastRequestAt < b.lastRequestAt ? 1 : -1 );
				}
			);
			return ( collaborators );
		}

		function updateProjectVisibility( query ) {
			var normalizedFilter = query.toLowerCase();
			for ( var i = 0, length = $scope.projects.length; i < length; i++ ) {
				var project = $scope.projects[ i ];
				project.isHiddenByFilter = ( project.normalizedFilterTarget.indexOf( normalizedFilter ) === -1 );
			}
		}

		function updateVisibleProjectCounts() {
			$scope.visibleProjectCount = ( $scope.isReviewer ? _.countWithProperty( $scope.activeProjects, "isHiddenByFilter", false ) : _.countWithProperty( $scope.projects, "isHiddenByFilter", false ) );
			$scope.visibleArchivedProjectCount = _.countWithProperty( $scope.archivedProjects, "isHiddenByFilter", false );
			$scope.visibleEnterpriseProjects = _.countWithProperty( $scope.enterpriseProjects, "isHiddenByFilter", false );
		}

		function watchProjectFilter( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			applyProjectFilter();
		}

		function applyProjectFilter() {
			updateProjectVisibility( $scope.filters.projectFilter );
			updateVisibleProjectCounts();
			$scope.noMatchingProjects = ( $scope.filters.projectFilter && !$scope.visibleProjectCount );
			applyFiltersToUrl();
		}
	}
} )( angular, InVision );;;
/*! design-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "quotes.DesignController", Controller );
	/** @ngInject */
	function Controller( $scope, designQuoteService, _ ) {
		$scope.designQuote = designQuoteService.getRandomQuote();
	}
} )( angular, InVision );;;
/*! screens-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "snaps.ScreensController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, $timeout, $q, requestContext, Deferred, screenService, projectService, projectScreensPartial, modelEvents, hashKeyCopier, dateHelper, userService, shareService, firebaseStateService, config, _ ) {
		function addUploadedScreen( screen ) {
			var existingScreen = _.findWithProperty( $scope.screens, "id", screen.id );
			screen = augmentScreen( screen );
			if ( existingScreen ) {
				delete( screen.conversationCount );
				delete( screen.unreadConversationCount );
				_.extendExistingProperties( existingScreen, screen );
			} else {
				$scope.screens.unshift( screen );
			}
			applyScreens();
			$scope.mergeScreensAndDividers();
			if ( $scope.deferredLimit < $scope.displayObjects.length ) {
				$scope.deferredLimit = $scope.displayObjects.length;
			}
		}

		function applyRemoteData( screens, dividers, hotspots, mobileDevices ) {
			$scope.selectedScreenCount = 0;
			$scope.screens = augmentScreens( hashKeyCopier.copyHashKeys( $scope.screens, screens ) );
			$.each( $scope.screens, function ( index, screen ) {
				$scope.screens[ index ].hotspotCount = _.withProperty( hotspots, "screenID", screen.id ).length;
			} );
			applyScreens();
			$scope.mergeScreensAndDividers();
			_.setProperty( $scope.displayObjects, "expanded", true );
		}

		function applyScreens() {
			$scope.activeScreens = getActiveScreens();
			$scope.processingScreens = getProcessingScreens();
			$scope.activeScreens = sortActiveScreens( $scope.activeScreens );
			if ( !$scope.activeScreens.length ) {
				$scope.isShowingUploader = true;
			}
			if (
				( $scope.subview === "archive" ) &&
				!$scope.archivedScreens.length
			) {
				$location.path( "/projects/" + $scope.projectID + "/screens" );
			}
		}

		function augmentScreen( screen ) {
			if ( !screen.hasOwnProperty( "conversationCount" ) ) {
				screen.conversationCount = 0;
				screen.unreadConversationCount = 0;
			}
			if ( /^\s+$/i.test( screen.name ) ) {
				screen.name = "[No Name]";
			}
			screen.displayFilename = screen.clientFilename.replace( "@2x@2x", "@2x" ).replace( "@print", "" );
			screen.displayDate = dateHelper.formatRelativeWithinMonth( screen.createdAt );
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function checkProcessingScreens() {
			$scope.isCheckProcessingScreens = true;
			var screenIDsToCheck = _.difference(
				_.pluck( $scope.processingScreens, "id" ),
				$scope.checkingProcessingScreenIDs
			);
			for ( var i = 0; i < screenIDsToCheck.length; i++ ) {
				$scope.checkingProcessingScreenIDs.push( screenIDsToCheck[ i ] );
				Deferred.handlePromise(
					screenService.getByID( screenIDsToCheck[ i ] ),
					function ( screen ) {
						if ( screen.isProcessed == true ) {
							updateScreenInCollection( screen );
							applyScreens();
						}
						$scope.checkingProcessingScreenIDs = _.without(
							$scope.checkingProcessingScreenIDs,
							screen.id
						);
					},
					function ( response ) {
						$scope.openModalWindow( "error", "For some reason, we can't check your screen status. Try refreshing your browser." );
						$scope.checkingProcessingScreenIDs = _.without(
							$scope.checkingProcessingScreenIDs,
							screen.id
						);
					}
				);
			}
			if ( $scope.processingScreens.length > 0 ) {
				thumbnailTimer = $timeout( checkProcessingScreens, 2000 );
			} else {
				$scope.isCheckProcessingScreens = false;
				$scope.checkingProcessingScreenIDs = [];
			}
		}

		function doDataLoad( projectID ) {
			Deferred.handlePromise(
				projectScreensPartial.get( projectID, true ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response.screens );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason we couldn't load your screens. Try refreshing your browser." );
				}
			);
		}

		function getActiveScreens() {
			return _.withoutProperty( $scope.screens, "isArchived", true );
		}

		function getProcessingScreens() {
			return _.withoutProperty( $scope.screens, "isProcessed", true );
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			$scope.state = $scope.states.READY;
			$scope.isCheckProcessingScreens = false;
			$scope.checkingProcessingScreenIDs = [];
			$scope.deferredLimit = 20;
			$scope.loadScreenIncrement = 40;
			$scope.isLoadingScreens = true;
			$scope.isScrolling = false;
			$scope.isShowingUploader = false;
			doDataLoad( $scope.projectID );
		}

		function sortActiveScreens( screens ) {
			return _.sortOnProperty( screens, "createdAt", "desc" );
		}

		function updateScreenInCollection( screen ) {
			var matchingScreen = _.findWithProperty( $scope.screens, "id", screen.id );
			if ( matchingScreen ) {
				_.extendExistingProperties( matchingScreen, screen );
			}
		}

		function updateShareLinks() {
			for ( var screen in $scope.screens ) {
				if ( $scope.screenShareIndex[ $scope.screens[ screen ].id ] ) {} else {
					shareService.createShare(
						$scope.screens[ screen ].projectID,
						$scope.screens[ screen ].id,
						true, // isCommentingAllowed
						false, // isNavigateAllowed
						false, // isResizeWindow
						false, // isLoadAllScreens
						false, // isUserTesting
						true, // isAnonymousViewingAllowed
						false, // isForceAddToHomescreenOnMobile,
						"", // password
						false, // forceNew
						false, // isEmbed
						[] // selectedScreens
					);
				}
			}
		}
		$scope.mergeScreensAndDividers = function () {
			$scope.displayObjects = $scope.activeScreens;
		};
		$scope.deleteScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.deleteScreen( screen.id ),
				function () {
					$scope.$emit( "screens:deleted", screen );
				},
				function () {
					loadRemoteData();
					$scope.openModalWindow( "error", "For some reason, we couldn't delete that screen." );
				}
			);
			$scope.screens = _.withoutProperty( $scope.screens, "id", screen.id );
			applyScreens();
			$scope.mergeScreensAndDividers();
		};
		$scope.duplicateScreen = function ( screen ) {
			Deferred.handlePromise(
				screenService.duplicateScreen( screen.id ),
				function ( duplicateScreen ) {
					_.defaults( duplicateScreen, screen );
					var index = $scope.screens.indexOf( screen );
					$scope.screens.splice( index + 1, 0, duplicateScreen );
					applyScreens();
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't duplicate that screen." );
				}
			);
		};
		$scope.openLiveShare = function ( screenID ) {
			if ( $scope.liveshare.currentTarget != null && $scope.liveshare.participants > 0 ) {
				fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
				fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
				fbRedirectTarget.set( "snaps" );
				fbStatusRef.set( "redirecting_prep" );
				fbStatusRef.on( "value", function ( snap ) {
					if ( snap.val() == "redirecting" ) {
						$scope.$emit( "autosubmit", "#liveshareForm-" + screenID, $scope.liveshare.currentTarget, $scope.liveshare.conferenceId ); // if we're redirecting, prompt the form to specify our conferenceId
						fbStatusRef.off( "value" );
						fbStatusRef = null;
					}
				} );
			} else if ( $scope.liveshare.currentTarget != null ) { // if the presenter is the only one in the LiveShare, just reuse that tab
				fbStatusRef = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/status" );
				fbRedirectTarget = new Firebase( config.firebaseUrl + $scope.liveshare.node + "/redirectTarget" );
				fbRedirectTarget.set( "snaps" );
				fbStatusRef.set( "redirecting_prep" );
				fbStatusRef.on( "value", function ( snap ) {
					if ( snap.val() == "redirecting" ) {
						$scope.$emit( "autosubmit", "#liveshareForm-" + screenID, $scope.liveshare.currentTarget );
						fbStatusRef.off( "value" );
						fbStatusRef = null;
					}
				} );
			} else { // if not, force a new target
				$scope.liveshare.target = "liveshare_" + firebaseStateService.guid();
				firebaseStateService.setTarget( $scope.liveshare.target );
				$scope.$emit( "autosubmit", "#liveshareForm-" + screenID, $scope.liveshare.target );
			}
		};
		$scope.toggleUploader = function () {
			$scope.isShowingUploader = !$scope.isShowingUploader;
		};
		$scope.loadMoreScreens = function ( i ) {
			if ( $scope.deferredLimit === i + 1 ) {
				$timeout(
					function () {
						if ( !$scope.isScrolling ) {
							$scope.deferredLimit = Math.min( ( $scope.deferredLimit + $scope.loadScreenIncrement ), $scope.displayObjects.length );
						} else {
							$scope.loadMoreScreens( i )
						}
					},
					100
				);
			}
			if ( $scope.displayObjects.length && $scope.deferredLimit >= $scope.displayObjects.length ) {
				$scope.isLoadingScreens = false;
			}
		}
		var renderContext = requestContext.getRenderContext( "standard.project.detail.screens", "projectID" );
		var thumbnailTimer = null;
		var lastScreenClickedOn = null;
		var isLoadingShareLinks = false;
		var fbStatusRef;
		var fbRedirectTarget;
		$scope.states = {
			READY: "READY",
			SORTING: "SORTING"
		};
		$scope.state = $scope.states.READY;
		$scope.isLoading = true;
		$scope.isCheckProcessingScreens = false;
		$scope.checkingProcessingScreenIDs = [];
		$scope.screens = [];
		$scope.activeScreens = [];
		$scope.processingScreens = [];
		$scope.isShowingUploader = false;
		$scope.filters = {};
		$scope.filters.screensFilter = "";
		$scope.moveTooltipLabel = "Move";
		$scope.selectedScreenCount = 0;
		$scope.subview = ( renderContext.getNextSection() || "list" );
		$scope.displayObjects = [];
		$scope.liveshare = firebaseStateService.getState();
		$scope.deferredLimit = 20;
		$scope.loadScreenIncrement = 40;
		$scope.isLoadingScreens = true;
		$scope.isScrolling = false;
		$scope.screenShareIndex = {}; // used to track Share keys for screens and cut down on unnecessary db requests
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "screenDeleted.projectScreens" );
				modelEvents.off( "screenUploaded.projectScreens" );
				modelEvents.off( "subscriptionChanged.projectScreens" );
				modelEvents.off( "projectUpdated.projectScreens" );
				modelEvents.off( "screenUploadStart.projectScreens" );
				$timeout.cancel( thumbnailTimer );
			}
		);
		$scope.$on(
			'metaKey-keydown',
			function () {
				if ( $scope.isLoadingScreens ) {
					$scope.deferredLimit = 99999;
					$scope.isLoadingScreens = false;
				}
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.projectID = requestContext.getParamAsInt( "projectID" );
				$scope.subview = ( renderContext.getNextSection() || "list" );
				$scope.isShowingUploader = false;
				if (
					( $scope.subview === "list" ) &&
					!$scope.activeScreens.length
				) {
					$scope.isShowingUploader = true;
				}
				if ( requestContext.hasParamChanged( "projectID" ) ) {
					loadRemoteData();
				}
			}
		);
		$scope.$on(
			"projectScreens:dragEnter",
			function () {
				if ( $scope.state !== $scope.states.READY ) {
					return;
				}
				$scope.isShowingUploader = true;
			}
		);
		$scope.$on( "firebase.stateChange", function ( event, data ) {
			$scope.liveshare = data;
		} );
		$scope.$watch(
			"deferredLimit",
			function ( newValue ) {
				if ( $scope.displayObjects.length && $scope.deferredLimit >= $scope.displayObjects.length ) {
					$scope.isLoadingScreens = false;
				} else {
					$scope.isLoadingScreens = true;
				}
			}
		);
		$scope.$watch(
			"processingScreens",
			function ( newValue ) {
				if ( !$scope.isCheckProcessingScreens && newValue.length > 0 ) {
					checkProcessingScreens();
				}
			}
		);
		$scope.$watch(
			"filters.screensFilter",
			function ( newVal ) {
				if ( newVal == "" ) {
					$scope.moveTooltipLabel = "Move";
					if ( !$scope.isLoadingScreens ) {
						$scope.deferredLimit = $scope.loadScreenIncrement;
						$scope.deferredLimit++;
					}
				} else {
					$scope.moveTooltipLabel = "Cannot sort while Searching.  Clear the search box first.";
					$scope.deferredLimit = $scope.displayObjects.length;
				}
			}
		);
		modelEvents.on(
			"screenDeleted.projectScreens",
			function ( event, screenID ) {
				if ( _.findWithProperty( $scope.screens, "id", screenID ) ) {
					$scope.screens = _.withoutProperty( $scope.screens, "id", screenID );
					applyScreens();
					$scope.mergeScreensAndDividers();
				}
			}
		);
		modelEvents.on( "shareCreated", function handleShareCreated( event, share ) {
			$scope.screenShareIndex[ share.screenID ] = "/share/" + share.key;
		} );
		modelEvents.on(
			"screenUploaded.projectScreens",
			function handleScreenUploaded( event, screen ) {
				if ( screen.projectID !== $scope.projectID ) {
					return;
				}
				addUploadedScreen( screen );
			}
		);
		modelEvents.on(
			"projectUpdated.projectScreens",
			function ( event, project ) {
				if ( project.id !== $scope.project.id ) {
					return;
				}
				if ( project.userID !== $scope.project.userID ) {
					return ( loadRemoteData() );
				}
				if ( $scope.isMobile != project.isMobile || $scope.mobileDeviceID != project.mobileDeviceID ) {
					$scope.isMobile = project.isMobile;
					$scope.mobileDeviceID = project.mobileDeviceID;
					$scope.mergeScreensAndDividers();
					return;
				}
			}
		);
		modelEvents.on(
			"screenUploadStart.projectScreens",
			function ( event ) {} );
		$scope.setWindowTitle( "Snaps" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! snap-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "snaps.SnapController", Controller );
	/** @ngInject */
	function Controller( $scope, $route, $window, $timeout, requestContext, $location, Deferred, projectService, projectDetailPartial, sessionService, modelEvents, moment, Debouncer, dateHelper, userService, validationService, _ ) {
		function applyRemoteData( project, projectStats, teamMembers, projectOwnerSubscription, userTeamSize, isUserAdminForProjectOwner, isProjectHiddenInActivity ) {
			$scope.project = project;
			$scope.projectStats = projectStats;
			$scope.canArchiveScreens = projectOwnerSubscription.canArchiveScreens;
			$scope.userTeamSize = userTeamSize;
			$scope.isProjectHiddenInActivity = isProjectHiddenInActivity;
			$scope.formAction = '/liveshare/create/' + project.id;
			$scope.isOwnedByUser = ( $scope.project.userID === sessionService.user.id );
			$scope.isUserAdminForProjectOwner = isUserAdminForProjectOwner;
			$scope.isOverQuota = project.isOverQuota;
			$scope.isInGracePeriod = project.isInGracePeriod;
			if ( project.isInGracePeriod ) {
				var gracePeriodEndsAt = moment( projectOwnerSubscription.projectGracePeriodEndsAt );
				var daysRemaining = gracePeriodEndsAt.diff( moment(), "days" );
				var hasScreens = projectStats.screenCount > 0;
				$scope.gracePeriodDisplay.isShownInitially = !!hasScreens;
				$scope.gracePeriodDisplay.daysRemaining = daysRemaining;
			} else {
				$scope.gracePeriodDisplay.isShownInitially = false;
				$scope.gracePeriodDisplay.daysRemaining = 0;
			}
			$scope.ownersSubscription = projectOwnerSubscription;
			$scope.canArchiveProject = (
				$scope.ownersSubscription.canArchiveProjects &&
				(
					$scope.isOwnedByUser ||
					$scope.isUserAdminForProjectOwner
				)
			);
			$scope.teamMembers = augmentTeamMembers( teamMembers, project.userID );
			$scope.projectOwner = _.findWithProperty( $scope.teamMembers, "id", project.userID );
			updateExpirationStatus( projectOwnerSubscription.expiresAt );
			$scope.isMobile = project.isMobile;
			$scope.mobileDeviceID = project.mobileDeviceID;
			$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
			$scope.projectTypeIcon = getProjectTypeIconClass();
			$scope.projectTypeTitle = getProjectTypeTitle( $scope.deviceTemplate );
			$scope.isRecommendedSingle = getIsRecommendedSingle();
			$scope.showCollabTooltip = moment().diff( project.createdAt, "days" ) <= 5;
			$scope.updateProjectLastAccessed( $scope.project.id );
			modelEvents.trigger( "projectAccessed", {
				id: $scope.project.id,
				lastUpdatedByUserAt: moment.utc().valueOf()
			} );
		}

		function getProjectTypeTitle( deviceTemplate ) {
			if ( deviceTemplate.mobileDeviceID === 0 ) {
				return "Desktop Project";
			} else if ( deviceTemplate.platform === "iOS" ) {
				return deviceTemplate.mobileSkin + " Project - " + capitaliseFirstLetter( deviceTemplate.orientation );
			} else {
				return deviceTemplate.platform + " Project - " + capitaliseFirstLetter( deviceTemplate.orientation );
			}
		}

		function capitaliseFirstLetter( string ) {
			return string.charAt( 0 ).toUpperCase() + string.slice( 1 );
		}

		function getProjectTypeIconClass() {
			if ( $scope.deviceTemplate === undefined ) {
				return "";
			}
			return (
				$scope.deviceTemplate.deviceType + " " +
				$scope.deviceTemplate.platform + " " +
				$scope.deviceTemplate.orientation
			).toLowerCase();
		}

		function getIsRecommendedSingle() {
			return _.size( $scope.recommendedSizes[ getProjectTypeIconClass() ] ) === 1 ? true : false;
		}

		function augmentTeamMembers( teamMembers, ownerUserID ) {
			for ( var i = 0, length = teamMembers.length; i < length; i++ ) {
				var teamMember = teamMembers[ i ];
				teamMember.isProjectOwner = ( teamMember.id === ownerUserID );
				teamMember.firstName = teamMember.name.split( /\s/ )[ 0 ];
				teamMember.tooltip = teamMember.name;
				teamMember.initials = userService.getInitials( teamMember.name );
				teamMember.hasSystemAvatar = userService.isSystemAvatar( teamMember.avatarID );
				if ( teamMember.isProjectOwner ) {
					teamMember.tooltip += " ( Owner )";
				}
				teamMember.onlineStatus = userService.getOnlineStatus( teamMember.lastRequestAt );
			}
			sortTeamMembers( teamMembers, ownerUserID );
			return ( teamMembers );
		}

		function doDataLoad( projectID ) {
			if (
				$scope.project &&
				( $scope.project.id === projectID ) &&
				!loadRemoteDataDebouncer.canProceed()
			) {
				return;
			}
			$scope.isLoading = true;
			Deferred.handlePromise(
				projectDetailPartial.get( projectID ),
				function ( response ) {
					applyRemoteData(
						response.project,
						response.projectStats,
						response.teamMembers,
						response.projectOwnerSubscription,
						response.userTeamSize,
						response.isUserAdminForProjectOwner,
						response.isProjectHiddenInActivity
					);
					$scope.isLoading = false;
					$timeout( function () {
						$scope.openNewProjectModalForSyncUsers( response.project );
					} );
					startTimerToRefreshRemoteData();
				},
				function ( error ) {
					var message = "";
					if ( validationService.isNotFound( error ) ) {
						message = "Sorry, you aren't a collaborator on the project you tried to access. Please inform the project owner.";
					} else {
						message = "For some reason, we can't load your project. Try refreshing your browser.";
					}
					if ( error.id ) {
						message += ( " [ID: " + error.id + "]" );
					}
					$scope.openModalWindow( "error", message );
					$location.path( "/" );
					stopTimerToRefreshRemoteData();
				}
			);
		}

		function loadRemoteData() {
			if ( $scope.isSnap && $scope.projectID === null ) {
				$scope.projectPlaceholder = projectService.getSnapProject();
				$scope.$watch( "projectPlaceholder", function ( newVal, oldVal ) {
					if ( newVal !== oldVal && !_.isUndefined( newVal ) && newVal !== 0 ) {
						$scope.projectID = newVal.id;
						doDataLoad( $scope.projectID );
					}
				} );
			} else {
				if ( $scope.projectID === null ) {
					$scope.projectID = requestContext.getParamAsInt( "projectID" );
				}
				doDataLoad( $scope.projectID );
			}
		}

		function sortTeamMembers( teamMembers, ownerUserID ) {
			teamMembers.sort(
				function ( a, b ) {
					if ( a.id === ownerUserID ) {
						return ( -1 );
					} else if ( b.id === ownerUserID ) {
						return ( 1 );
					}
					return ( a.lastRequestAt < b.lastRequestAt ? 1 : -1 );
				}
			);
			return ( teamMembers );
		}

		function startTimerToRefreshRemoteData() {
			stopTimerToRefreshRemoteData();
			remoteDataTimer = $window.setInterval( loadRemoteData, ( 20 * 60 * 1000 ) );
		}

		function stopTimerToRefreshRemoteData() {
			$window.clearInterval( remoteDataTimer );
		}

		function updateExpirationStatus( expiresAt ) {
			$scope.expirationStatus.expiresAt = null;
			$scope.expirationStatus.isExpiring = false;
			$scope.expirationStatus.isExpiringSoon = false;
			$scope.expirationStatus.timeLeftInDays = 0;
			if ( expiresAt && ( parseInt( expiresAt ) > 0 ) ) {
				$scope.expirationStatus.expiresAt = new Date( expiresAt );
				$scope.expirationStatus.isExpiring = true;
				var now = new Date();
				var cutOffForDisplay = dateHelper.addDays( expiresAt, -5 );
				if ( now >= cutOffForDisplay ) {
					$scope.expirationStatus.isExpiringSoon = true;
					$scope.expirationStatus.timeLeftInDays = Math.ceil( ( expiresAt - now ) / ( 24 * 60 * 60 * 1000 ) );
				}
			}
		}

		function hideGracePeriodWarning() {
			$scope.gracePeriodDisplay.fadeOut = true;
		}
		$scope.closeCollabTooltip = function () {
			$scope.showCollabTooltip = false;
		}
		$scope.openNewProjectModalForSyncUsers = function ( project ) {
			if ( !newProjectSyncModalIsOpen && project.isMobile === "" ) {
				newProjectSyncModalIsOpen = true;
				$scope.openModalWindow( "changeProjectType", $scope.project, $scope.deviceTemplates );
			}
		};
		$scope.openChangeProjectTypeModal = function () {
			$scope.openModalWindow( "changeProjectType", $scope.project, $scope.deviceTemplates );
		};
		$scope.addTeamMembers = function () {
			if ( $scope.userTeamSize > 1 ) {
				$scope.openModalWindow( "projectMembers", $scope.project.id );
			} else {
				$scope.openModalWindow( "bulkInviteProjectMembers", $scope.project.id );
			}
		};
		$scope.archiveProject = function () {
			if ( $scope.canArchiveProject ) {
				$scope.openModalWindow( "archiveProject", $scope.project.id );
			} else if ( $scope.isOwnedByUser ) {
				$scope.openModalWindow( "archiveUpgrade" );
			} else if ( $scope.ownersSubscription.canArchiveProjects ) {
				$scope.openModalWindow( "error", "The project owner must give you Admin permissions before you can archive this project." );
			} else {
				$scope.openModalWindow( "error", "The project owner doesn't have the ability to archive projects." );
			}
		};
		$scope.openChangePlanModal = function ( showAllPlans ) {
			if ( showAllPlans == "undefined" ) {
				showAllPlans = false;
			}
			$scope.openModalWindow( "changePlan", {
				showAllPlans: showAllPlans
			} );
		};
		$scope.openNewProjectModal = function () {
			$scope.openModalWindow( "newProject" );
		};
		$scope.deleteProject = function () {
			$scope.openModalWindow( "deleteProject", $scope.project.id );
		};
		$scope.duplicateProject = function () {
			$scope.openModalWindow( "duplicateProject", $scope.project.id );
		};
		$scope.exportPDF = function () {
			if ( $scope.getOwnersSubscription().canExportPDF ) {
				$scope.openModalWindow( "exportPDF", $scope.project.id );
			} else {
				$scope.openModalWindow( "exportPDF_Upgrade", $scope.project.id );
			}
		};
		$scope.getOwnersSubscription = function () {
			return $scope.ownersSubscription;
		};
		$scope.openMobileTipsModal = function ( a, b ) {
			$scope.openModalWindow( "mobileTips", $scope.deviceTemplate );
		};
		$scope.hideInActivityTimeline = function () {
			$scope.isProjectHiddenInActivity = true;
			projectService.setIsHiddenInTimeline( $scope.project.id, true );
		};
		$scope.showInActivityTimeline = function () {
			$scope.isProjectHiddenInActivity = false;
			projectService.setIsHiddenInTimeline( $scope.project.id, false );
		};
		$scope.openShareModal = function ( subview ) {
			var subview = ( subview || "new" );
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					return (
						$scope.openModalWindow( "changePlan" )
					);
				} else {
					return (
						$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." )
					);
				}
			} else if ( !$scope.projectStats.screenCount ) {
				return (
					$scope.openModalWindow( "error", "You can't share this project until at least one screen has been uploaded." )
				);
			}
			$scope.openModalWindow( "share", $scope.project.id, 0, subview );
		};
		$scope.openConsole = function ( projectId, screenItemId, mode ) {
			if ( $scope.project.isOverQuota ) {
				if ( $scope.isOwnedByUser ) {
					$scope.openModalWindow( "changePlan" );
				} else {
					$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." );
				}
			} else {
				$location.path( "/console/" + projectId + "/" + screenItemId + "/" + mode );
			}
		};
		$scope.saveProjectOffline = function () {
			$scope.openModalWindow( "saveProjectOffline" );
		};
		$scope.showLiveShare = function () {
			return true;
			/*	if ( $scope.user.email.indexOf("shawn@invisionapp.com") !== -1 || document.domain.indexOf("beta-projects") !== -1 ) {
return true;
} else {
return false;
} */
			if ( $scope.user.email.indexOf( "@invisionapp.com" ) !== -1 || $scope.user.email.indexOf( "@epicenterconsulting.com" ) !== -1 || $scope.user.email.indexOf( "@funsize.co" ) !== -1 || $scope.user.email.indexOf( "@shopify.com" ) !== -1 || document.domain.indexOf( "beta-projects" ) !== -1 ) {
				return true;
			} else {
				return false;
			}
		};
		$scope.transferProject = function () {
			$scope.openModalWindow( "transferProject", $scope.project.id );
		};
		$scope.viewProject = function ( $event ) {
			if ( $scope.project.isOverQuota ) {
				$event.preventDefault();
				if ( $scope.isOwnedByUser ) {
					$scope.openModalWindow( "changePlan" );
				} else {
					$scope.openModalWindow( "error", "Unfortunately, this project is over the owner's project quota." );
				}
			} else if ( !$scope.projectStats.screenCount ) {
				$event.preventDefault();
				$scope.openModalWindow( "error", "You can't view this project until at least one screen has been uploaded." );
			}
		};
		$scope.getCurrentProject = function () {
			return $scope.project;
		};
		$scope.shouldShowGracePeriodWarning = function () {
			if ( !$scope.isInGracePeriod ) {
				return false;
			}
			if ( $scope.gracePeriodDisplay.isShownInitially ) {
				return true;
			} else if ( $scope.gracePeriodDisplay.daysRemaining <= 5 ) {
				return true;
			} else {
				return ( $scope.gracePeriodDisplay.firstScreenUploaded );
			}
		};
		$scope.shouldFadeGracePeriodWarning = function () {
			return ( false );
			return ( $scope.gracePeriodDisplay.fadeOut && ( $scope.gracePeriodDisplay.daysRemaining > 5 ) );
		};
		var renderContext = requestContext.getRenderContext( "standard.project.detail", "projectID" );
		var remoteDataTimer = null;
		$scope.projectID = null;
		$scope.isLoading = true;
		$scope.project = null;
		$scope.projectStats = null;
		$scope.isOwnedByUser = false;
		$scope.teamMembers = [];
		$scope.canArchiveProject = false;
		$scope.canArchiveScreens = false;
		$scope.isInGracePeriod = false;
		$scope.isSnap = $route.current.$$route.action == "standard.snaps" ? true : false;
		$scope.gracePeriodDisplay = {
			daysRemaining: null,
			isShownInitially: false,
			screenCount: 0,
			firstScreenUploaded: false
		};
		$scope.isOverQuota = false;
		$scope.expirationStatus = {
			expiresAt: null,
			isExpiring: false,
			isExpiringSoon: false,
			timeLeftInDays: 0
		};
		$scope.showCollabTooltip = false;
		$scope.collaboratorsInvited = 0;
		$scope.userTeamSize = 0;
		$scope.subview = ( renderContext.getNextSection() || "screens" );
		var loadRemoteDataDebouncer = new Debouncer( Debouncer.THREE_SECONDS );
		var newProjectSyncModalIsOpen = false;
		$scope.projectTypeIcon = "";
		$scope.projectTypeTitle = "";
		$scope.projectPlaceholder = null;
		$scope.recommendedSizes = {
			"phone ios portrait": {
				"iPhone 4 & 5": {
					"width": "640px",
					"height": "Any"
				}
			},
			"phone ios landscape": {
				"iPhone 5": {
					"width": "1136px",
					"height": "Any"
				},
				"iPhone 4": {
					"width": "960px",
					"height": "Any"
				}
			},
			"tablet ios portrait": {
				"iPad": {
					"width": "1536px",
					"height": "Any"
				}
			},
			"tablet ios landscape": {
				"iPad": {
					"width": "2048px",
					"height": "Any"
				}
			},
			"phone android portrait": {
				"Android 720p": {
					"width": "720px",
					"height": "Any"
				},
				"Android 1080p": {
					"width": "1080px",
					"height": "Any"
				}
			},
			"phone android landscape": {
				"Android 720p": {
					"width": "1280px",
					"height": "Any"
				},
				"Android 1080p": {
					"width": "1920px",
					"height": "Any"
				}
			}
		};
		$scope.$on(
			"$destroy",
			function () {
				stopTimerToRefreshRemoteData();
				modelEvents.off( "projectDeleted.projectDetail" );
				modelEvents.off( "projectUpdated.projectDetail" );
				modelEvents.off( "projectUserAdded.projectDetail" );
				modelEvents.off( "projectUsersAdded.projectDetail" );
				modelEvents.off( "projectUserRemoved.projectDetail" );
				modelEvents.off( "projectUsersRemoved.projectDetail" );
				modelEvents.off( "screenUploaded.projectDetail" );
				modelEvents.off( "subscriptionChanged.projectDetail" );
			}
		);
		modelEvents.on(
			"projectDeleted.projectDetail",
			function ( event, projectID ) {
				if ( projectID !== $scope.project.id ) {
					return;
				}
				$location.path( "/" );
			}
		);
		modelEvents.on(
			"projectUpdated.projectDetail",
			function ( event, project ) {
				if ( project.id !== $scope.project.id ) {
					return;
				}
				if ( project.isArchived ) {
					return ( $location.path( "/" ) );
				}
				if ( project.userID !== $scope.project.userID ) {
					return ( loadRemoteData() );
				}
				$scope.project.name = project.name;
				$scope.project.isMobile = project.isMobile;
				$scope.project.mobileDeviceID = project.mobileDeviceID;
				$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
				$scope.projectTypeIcon = getProjectTypeIconClass();
				$scope.projectTypeTitle = getProjectTypeTitle( $scope.deviceTemplate );
				$scope.isRecommendedSingle = getIsRecommendedSingle();
			}
		);
		modelEvents.on(
			[
				"projectUserAdded.projectDetail",
				"projectUsersAdded.projectDetail"
			],
			function ( event, projectID, userIDs ) {
				if ( projectID === $scope.project.id ) {
					loadRemoteData();
				}
			}
		);
		modelEvents.on(
			[
				"projectUserRemoved.projectDetail",
				"projectUsersRemoved.projectDetail"
			],
			function ( event, projectID, userIDs ) {
				if ( projectID === $scope.project.id ) {
					if ( !ng.isArray( userIDs ) ) {
						userIDs = [ userIDs ];
					}
					$scope.teamMembers = _.withoutPropertyRange( $scope.teamMembers, "id", userIDs );
				}
			}
		);
		modelEvents.on(
			"screenUploaded.projectDetail",
			function ( event, screen ) {
				if ( screen.projectID !== $scope.project.id ) {
					return;
				}
				$scope.projectStats.screenCount++;
				if ( $scope.isInGracePeriod && ( $scope.projectStats.screenCount === 1 ) ) {
					$scope.gracePeriodDisplay.firstScreenUploaded = true;
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged.projectDetail",
			function ( event, newPlan ) {
				loadRemoteData();
			}
		);
		$scope.setWindowTitle( "Loading Project" );
		$scope.setSecondaryBodyClass( "snaps" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! account-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.AccountController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, billingService, subscriptionService, validationService, sessionService, modelEvents, _ ) {
		function loadRemoteData() {
			$scope.isLoadingInvoices = true;
			$scope.isLoadingPlan = true;
			$scope.isLoadingPaymentInfo = true;
			Deferred.handleAllPromises(
				[
					billingService.getCountries(),
					billingService.getPaymentInfo()
				],
				function ( countries, paymentInfo ) {
					$scope.countries = countries;
					$scope.isLoadingPaymentInfo = false;
					$scope.cardInfoName = paymentInfo.name;
					$scope.cardInfoLastFour = paymentInfo.lastFourDigits;
					$scope.account.company = paymentInfo.company;
					$scope.account.billingAddress1 = paymentInfo.street1;
					$scope.account.billingAddress2 = paymentInfo.street2;
					$scope.account.billingCity = paymentInfo.city;
					$scope.account.billingState = paymentInfo.state;
					$scope.account.billingZip = paymentInfo.zipcode;
					$scope.account.billingCountry = paymentInfo.country;
					if ( paymentInfo.name === undefined ) {
						$scope.account.billingFirstName = sessionService.user.name.split( /\s/ ).slice( 0, 1 ).toString();
						$scope.account.billingLastName = sessionService.user.name.split( /\s/ ).slice( -1 ).toString();
					} else {
						$scope.account.billingFirstName = paymentInfo.name.split( /\s/ ).slice( 0, 1 ).toString();
						$scope.account.billingLastName = paymentInfo.name.split( /\s/ ).slice( -1 ).toString();
					}
					if ( paymentInfo.city === undefined &&
						paymentInfo.state === undefined &&
						paymentInfo.country === undefined ) {
						$scope.account.billingCity = sessionService.user.city;
						$scope.account.billingState = sessionService.user.state;
						$scope.account.billingCountry = _.where( $scope.countries, {
							"name": sessionService.user.country
						} )[ 0 ];
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your billing information. Try refreshing your browser." );
				}
			);
			Deferred.handlePromise(
				subscriptionService.getCurrentPlan(),
				function ( currentPlan ) {
					$scope.isLoadingPlan = false;
					$scope.currentPlan = currentPlan;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load the current subscription. Try refreshing your browser." );
				}
			);
			loadInvoices();
		}

		function loadInvoices() {
			Deferred.handlePromise(
				billingService.getInvoices(),
				function ( invoices ) {
					$scope.isLoadingInvoices = false;
					$scope.billingHistory = invoices;
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your billing history. Try refreshing your browser." );
				}
			);
		}
		$scope.openChangePlanModal = function ( showAllPlans, canSeeDowngrades ) {
			if ( !$scope.isEnterprise && !$scope.isEnterpriseUser ) {
				if ( canSeeDowngrades ) {
					$scope.openModalWindow( "downgradePlan", {
						showAllPlans: true,
						canShowDowngrades: canSeeDowngrades
					} );
				} else {
					$scope.openModalWindow( "changePlan", {
						showAllPlans: showAllPlans,
						canShowDowngrades: canSeeDowngrades
					} );
				}
			} else {
				$scope.openModalWindow( "changePlanEnterprise" );
			}
		};
		$scope.hideCreditCardForm = function () {
			$scope.isShowingCreditCardForm = false;
		};
		$scope.showCreditCardForm = function () {
			$scope.isShowingCreditCardForm = true;
		};
		$scope.showAllInvoices = function () {
			$scope.allInvoicesShown = true;
		};
		$scope.hideSomeInvoices = function () {
			$scope.allInvoicesShown = false;
		};
		$scope.saveCreditCardForm = function () {
			if ( !$scope.isShowingCreditCardForm ) {
				return;
			}
			$scope.$broadcast( "autofillCheck.update" );
			$scope.hasCardChanged = (
				$scope.billingInformation.creditCardDigits.$dirty ||
				$scope.billingInformation.creditCardExpirationMonth.$dirty ||
				$scope.billingInformation.creditCardExpirationYear.$dirty ||
				$scope.billingInformation.creditCardCSV.$dirty
			);
			$scope.account.creditCardDigits = $scope.account.creditCardDigits.replace( /[^0-9]/gi, '' );
			var isAMEX = $scope.account.creditCardDigits.match( /^3[47][0-9]{13}$/ );
			$scope.creditCardErrorMessage = null;
			$scope.successMessage = null;
			if ( $scope.hasCardChanged ) {
				if ( isAMEX && $scope.account.creditCardCSV.length !== 4 ) {
					$scope.creditCardErrorMessage = "The CVV must be 4 digits for American Express cards.";
					return;
				} else if ( ( !isAMEX ) && $scope.account.creditCardCSV.length !== 3 ) {
					$scope.creditCardErrorMessage = "The CVV must be 3 digits for your card.";
					return;
				}
			}
			Deferred.handlePromise(
				billingService.changeCreditCard(
					$scope.hasCardChanged,
					true,
					$scope.account.billingFirstName,
					$scope.account.billingLastName,
					$scope.account.creditCardDigits,
					$scope.account.creditCardExpirationMonth,
					$scope.account.creditCardExpirationYear,
					$scope.account.creditCardCSV,
					$scope.account.company,
					$scope.account.billingAddress1,
					$scope.account.billingAddress2,
					$scope.account.billingCity,
					$scope.account.billingState,
					$scope.account.billingZip,
					$scope.account.billingCountry ),
				function ( paymentInfo ) {
					$scope.successMessage = "Your card has been saved";
					$scope.account.creditCardDigits = '';
					$scope.account.creditCardCSV = '';
					$scope.account.creditCardExpirationMonth = '';
					$scope.account.creditCardExpirationYear = '';
					$scope.hasCardChanged = false;
					$scope.hideCreditCardForm();
					$scope.successMessage = "Awesome! Now you're rocking!";
					$scope.errorMessage = null;
					$scope.creditCardErrorMessage = null;
					modelEvents.trigger( "billingInfo:updated", paymentInfo );
				},
				function ( response ) {
					$scope.creditCardErrorMessage = response.message;
					$scope.successMessage = null;
					modelEvents.trigger( "billingInfo:error", response );
				}
			);
		};
		var renderContext = requestContext.getRenderContext( "standard.team.detail.account", "userID" );
		$scope.months = _.map( _.range( 1, 13 ), function ( monthIndex ) {
			return {
				numericMonth: ( monthIndex < 10 ) ? ( "0" + monthIndex ) : monthIndex,
				display: moment( [ new Date().getFullYear(), monthIndex - 1, 1 ] ).format( "MM - MMMM" )
			};
		} );
		$scope.years = _.range( new Date().getFullYear(), new Date().getFullYear() + 10 );
		$scope.countries = null;
		$scope.userID = requestContext.getParamAsInt( "userID" );
		$scope.isLoadingPlan = false;
		$scope.isLoadingInvoices = false;
		$scope.successMessage = null;
		$scope.currentPlan = false;
		$scope.isShowingCreditCardForm = false;
		$scope.account = {
			billingFirstName: "",
			billingLastName: "",
			creditCardDigits: "",
			creditCardExpirationMonth: "",
			creditCardExpirationYear: "",
			creditCardCSV: "",
			company: "",
			billingAddress1: "",
			billingAddress2: "",
			billingCity: "",
			billingState: "",
			billingZip: "",
			billingCountry: ""
		};
		$scope.hasCardChanged = false;
		$scope.cardInfoName = "A Designer";
		$scope.cardInfoLastFour = "**** **** **** 9999";
		$scope.billingHistory = null;
		$scope.errorMessage = null;
		$scope.creditCardErrorMessage = null;
		$scope.allInvoicesShown = false;
		modelEvents.on(
			"subscriptionChanged.account",
			function ( event, newPlan ) {
				$scope.currentPlan = newPlan;
				loadInvoices();
			}
		);
		modelEvents.on(
			"billingInfo:updated",
			function ( event, billingInfo ) {
				$scope.cardInfoLastFour = billingInfo.lastFourDigits;
				$scope.cardInfoName = billingInfo.firstName + ' ' + billingInfo.lastName;
				$scope.account.creditCardDigits = "";
				$scope.account.creditCardCSV = "";
			}
		);
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "billingInfo:updated" );
				modelEvents.off( "subscriptionChanged.account" );
			}
		);
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! activity-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.ActivityController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, projectService, teamActivityPartial, dateHelper, userService, _, config ) {
		function addActivityToActivityPeriods( activity ) {
			for ( var i = 0; i < $scope.activityPeriods.length; i++ ) {
				var existingActivity = $scope.activityPeriods[ i ];
				if ( existingActivity.offset === activity.offset ) {
					_.extendExistingProperties( existingActivity, activity );
					return ( activity );
				}
			}
			$scope.activityPeriods.push( activity );
			return ( activity );
		}

		function applyDateLabels( activity ) {
			var d = dateHelper.removeTime( activity.offset );
			if ( activity.durationInDays === 1 ) {
				if ( dateHelper.isToday( d ) ) {
					activity.primaryDateLabel = "Today";
					activity.secondaryDateLabel = dateHelper.formatDate( d, "mmmm d" );
				} else if ( dateHelper.isYesterday( d ) ) {
					activity.primaryDateLabel = "Yesterday";
					activity.secondaryDateLabel = dateHelper.formatDate( d, "mmmm d" );
				} else {
					activity.primaryDateLabel = dateHelper.formatDate( d, "ddd" );
					activity.secondaryDateLabel = dateHelper.formatDate( d, "mmmm d" );
				}
			} else {
				activity.primaryDateLabel = ( "Week Of " + dateHelper.formatDate( d, "mmmm d" ) );
				activity.secondaryDateLabel = null;
			}
			return ( activity );
		}

		function applyProjectEventCount( activity ) {
			for ( var i = 0, length = activity.projects.length; i < length; i++ ) {
				var project = activity.projects[ i ];
				project.eventCount = ( project.comments.count + project.screensAdded.length + project.screensUpdated.length );
			}
			return ( activity );
		}

		function applyRemoteData( activity ) {
			if ( activity.alreadyAddedToActivityPeriods ) {
				return;
			}
			activity.alreadyAddedToActivityPeriods = true;
			activity = augmentActivity( activity );
			addActivityToActivityPeriods( activity );
			updateHasMoreActivityToLoad();
		}

		function augmentActivity( activity ) {
			activity = applyDateLabels( activity );
			activity = applyProjectEventCount( activity );
			sortActivityProjects( activity.projects );
			augmentProjects( activity.projects );
			return ( activity );
		}

		function augmentComments( comments ) {
			for ( var s = 0, sLength = comments.screens.length; s < sLength; s++ ) {
				var screen = comments.screens[ s ];
				for ( var u = 0, uLength = screen.users.length; u < uLength; u++ ) {
					var user = screen.users[ u ];
					user.shortName = userService.getShortName( user.name );
					user.initials = userService.getInitials( user.name );
					user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				}
			}
			return ( comments );
		}

		function augmentProject( project ) {
			augmentComments( project.comments );
			augmentScreens( project.screensAdded );
			augmentScreens( project.screensUpdated );
			return ( project );
		}

		function augmentProjects( projects ) {
			for ( var i = 0, length = projects.length; i < length; i++ ) {
				augmentProject( projects[ i ] );
			}
			return ( projects );
		}

		function augmentScreens( screens ) {
			for ( var i = 0, length = screens.length; i < length; i++ ) {
				var screen = screens[ i ];
				screen.shortUserName = userService.getShortName( screen.userName );
			}
			return ( screens );
		}

		function getLastKnownOffset() {
			return (
				_.last( $scope.activityPeriods ).offset
			);
		}

		function getOffsetsForCurrentWeek() {
			var offsets = [];
			var currentDay = dateHelper.today();
			if ( currentDay.getDay() === 0 ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			for ( var i = currentDay.getDay(); i >= 1; i-- ) {
				offsets.push( currentDay.getTime() );
				currentDay = dateHelper.addDays( currentDay, -1 );
			}
			return ( offsets );
		}

		function loadActivityStream() {
			$scope.isLoadingActivity = true;
			var offsets = getOffsetsForCurrentWeek();
			var promises = [];
			for ( var i = 0; i < offsets.length; i++ ) {
				promises.push(
					teamActivityPartial.get( $scope.userID, offsets[ i ], 1, config.companySettings.companyID )
				);
			}
			Deferred.handleAllPromises(
				promises,
				function ( promise1, promise2, promiseN ) {
					$scope.isLoadingActivity = false;
					var projectCount = 0;
					for ( var i = 0; i < arguments.length; i++ ) {
						applyRemoteData( arguments[ i ].activity );
						projectCount += arguments[ i ].activity.projects.length;
					}
					if ( !projectCount ) {
						$scope.loadMoreActivity();
					}
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load this person's activity stream. Try refreshing your browser." );
				}
			);
		}

		function sortActivityProjects( projects ) {
			projects.sort(
				function ( a, b ) {
					return ( a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1 );
				}
			);
			return ( projects );
		}

		function updateHasMoreActivityToLoad() {
			var activity = _.last( $scope.activityPeriods );
			$scope.hasMoreActivityToLoad = ( activity.offset > activity.minimumOffset );
		}
		$scope.loadMoreActivity = function () {
			$scope.isLoadingPastActivity = true;
			var lastKnownOffset = getLastKnownOffset();
			var pastOffset = dateHelper.addDays( lastKnownOffset, -7 ).getTime();
			Deferred.handlePromise(
				teamActivityPartial.get( $scope.userID, pastOffset, 7, config.companySettings.companyID ),
				function ( response ) {
					$scope.isLoadingPastActivity = false;
					applyRemoteData( response.activity );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load this person's past activity. Try refreshing your browser." );
				}
			);
		};
		$scope.toggleProject = function ( project ) {
			project.isMinimizedInTimeline = !project.isMinimizedInTimeline;
			Deferred.handlePromise(
				projectService.setIsMinimizedInTimeline( project.id, project.isMinimizedInTimeline ),
				function () {},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't save your activity stream setting. Try refreshing your browser." );
				}
			);
		};
		var renderContext = requestContext.getRenderContext( "standard.team.detail.activity", "userID" );
		$scope.userID = requestContext.getParamAsInt( "userID" );
		$scope.isLoadingActivity = false;
		$scope.isLoadingPastActivity = false;
		$scope.activityPeriods = [];
		$scope.hasMoreActivityToLoad = false;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( requestContext.hasParamChanged( "userID" ) ) {
					$scope.userID = requestContext.getParamAsInt( "userID" );
					$scope.activityPeriods = [];
					loadActivityStream();
				}
			}
		);
		loadActivityStream();
	}
} )( angular, InVision );;;
/*! detail-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.DetailController", Controller );
	/** @ngInject */
	function Controller( $scope, $location, requestContext, Deferred, teamService, projectService, sessionService, teamDetailPartial, modelEvents, dateHelper, validationService, userService, _ ) {
		$scope.views = {
			'activity': 'activity.htm',
			'account': 'account.htm',
			'profile': 'profile.htm',
			'notifications': 'notifications.htm'
		};

		function applyRemoteData( teamMember, projects ) {
			$scope.teamMember = teamMember;
			$scope.teamMember.initials = userService.getInitials( teamMember.name );
			$scope.teamMember.hasSystemAvatar = userService.isSystemAvatar( teamMember.avatarID );
			$scope.teamMember.onlineStatus = userService.getOnlineStatus( teamMember.lastRequestAt );
			$scope.setWindowTitle( teamMember.name );
			teamMember.lastActiveAtLabel = getLastActiveLabel( teamMember.lastRequestAt );
			$scope.projects = sortProjects( projects );
			if ( $scope.isEnterprise ) {
				$scope.enterpriseProjects = projects;
			} else {
				if ( sessionService.user.id === $scope.teamMember.id ) {
					$scope.projectsOwnedByMe = getProjectsOwnedByMe( projects );
					$scope.projectsOwnedByOthers = getProjectsOwnedByOthers( projects );
					$scope.projectsOwnedByTeamMember = [];
				} else {
					$scope.projectsOwnedByMe = getProjectsOwnedByMe( projects );
					$scope.projectsOwnedByTeamMember = getProjectsOwnedByTeamMember( projects );
					$scope.projectsOwnedByOthers = getProjectsOwnedByOthers( projects );
				}
			}
		}

		function getLastActiveLabel( offset ) {
			return (
				dateHelper.formatRecentDate( offset, "mmm d" ) +
				" at " +
				dateHelper.formatTime( offset, "h:mm tt" )
			);
		}

		function getProjectsOwnedByMe( projects ) {
			return (
				_.withProperty( projects, "userID", sessionService.user.id )
			);
		}

		function getProjectsOwnedByOthers( projects ) {
			projects = _.withoutProperty( projects, "userID", sessionService.user.id );
			if ( sessionService.user.id !== $scope.teamMember.id ) {
				projects = _.withoutProperty( projects, "userID", $scope.teamMember.id );
			}
			return ( projects );
		}

		function getProjectsOwnedByTeamMember( projects ) {
			return (
				_.withProperty( projects, "userID", $scope.teamMember.id )
			);
		}

		function loadRemoteData() {
			var userID = requestContext.getParamAsInt( "userID" );
			var maxProjectCount = sessionService.subscription.maxProjectCount;
			var currentUserID = sessionService.user.id;
			if ( maxProjectCount >= 5 || currentUserID === userID ) {
				$scope.canViewActivity = true;
			} else {
				$scope.canViewActivity = false;
			}
			$scope.isLoading = true;
			Deferred.handlePromise(
				teamDetailPartial.get( userID ),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.teamMember,
						response.projects
					);
				},
				function () {
					if ( !$scope.isEnterprise ) {
						$location.path( "/team" );
					} else {
						$location.path( "/projects" );
					}
				}
			);
		}

		function sortProjects( projects ) {
			return (
				_.sortOnProperty( projects, "sort" )
			);
		}
		$scope.inviteToProject = function ( project ) {
			var projectID = project.id;
			var userID = $scope.teamMember.id;
			project.includesTeamMember = true;
			Deferred.handlePromise(
				projectService.addUserToProject( projectID, userID ),
				null,
				function ( response ) {
					project.includesTeamMember = false;
					if ( validationService.isOverQuota( response ) ) {
						$scope.openModalWindow( "error", "The collaborator limit is maxed out. The owner of this project must upgrade their account." );
					} else {
						$scope.openModalWindow( "error", "For some reason we couldn't add this person to that project." );
					}
				}
			);
		};
		$scope.openShareModal = function ( project ) {
			$scope.openModalWindow( "share", project.id );
		};
		$scope.removeFromProject = function ( project ) {
			var projectID = project.id;
			var userID = $scope.teamMember.id;
			Deferred.handlePromise(
				projectService.removeUserFromProject( projectID, userID ),
				function ( response ) {
					project.includesTeamMember = false;
				},
				function () {
					$scope.openModalWindow( "error", "For some reason we couldn't remove this person from that project. Perhaps they own the project?" );
				}
			);
		};
		$scope.removeSelfFromProject = function ( project ) {
			var projectID = project.id;
			var userID = sessionService.user.id;
			Deferred.handlePromise(
				projectService.removeUserFromProject( projectID, userID ),
				function ( response ) {
					$scope.projects = _.withoutProperty( $scope.projects, "id", projectID );
					if ( $scope.isEnterprise ) {
						$scope.enterpriseProjects = $scope.projects;
					} else {
						$scope.projectsOwnedByTeamMember = getProjectsOwnedByTeamMember( $scope.projects );
						$scope.projectsOwnedByOthers = getProjectsOwnedByOthers( $scope.projects );
					}
				},
				function ( response ) {
					$scope.openModalWindow( "error", response.message );
				}
			);
		};
		$scope.shouldShowCreateOnBehalf = function ( teamMember ) {
			if ( teamMember.isTeamLead ) {
				return false;
			}
			if ( $scope.userCanSetAdmin ) {
				return true;
			}
			if ( teamMember.canCreateProjectsForLead ) {
				return true;
			}
			return false;
		};
		$scope.updateAdminStatus = function () {
			var userID = $scope.teamMember.id;
			var canCreateProjectsForLead = $scope.teamMember.canCreateProjectsForLead;
			Deferred.handlePromise(
				teamService.setAdminStatus( userID, canCreateProjectsForLead ),
				null,
				function ( resposne ) {
					$scope.openModalWindow( "error", "For some reason we couldn't update the admin permissions." );
				}
			);
		};
		$scope.removeAdminStatus = function () {
			$scope.teamMember.canCreateProjectsForLead = false;
			$scope.updateAdminStatus();
		}
		$scope.openTeamMemberModal = function ( email ) {
			$scope.openModalWindow( "newTeamMember", false, email );
		};
		var renderContext = requestContext.getRenderContext( "standard.team.detail", "userID" );
		$scope.userCanSetAdmin = ( !_.contains( [ 1, 2, 18, 19, 26, 27 ], sessionService.subscription.subscriptionPlanID ) );
		$scope.canViewActivity = true;
		$scope.isLoading = false;
		$scope.teamMember = null;
		$scope.teamLeadName = sessionService.user.name;
		$scope.projects = [];
		$scope.projectsOwnedByMe = [];
		$scope.projectsOwnedByTeamMember = [];
		$scope.projectsOwnedByOthers = [];
		$scope.enterpriseProjects = [];
		$scope.subview = renderContext.getNextSection();
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "accountUpdated.teamDetail" );
				modelEvents.off( "projectUserAdded.teamDetail" );
			}
		);
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( requestContext.hasParamChanged( "userID" ) ) {
					loadRemoteData();
				}
				$scope.subview = renderContext.getNextSection();
			}
		);
		modelEvents.on(
			"accountUpdated.teamDetail",
			function ( event, account ) {
				if (
					$scope.isLoading ||
					( $scope.teamMember.id !== account.id )
				) {
					return;
				}
				$scope.teamMember.name = account.name;
				$scope.teamMember.email = account.email;
				$scope.teamMember.avatarID = account.avatarID;
				$scope.teamMember.initials = userService.getInitials( account.name );
				$scope.teamMember.hasSystemAvatar = userService.isSystemAvatar( account.avatarID );
				$scope.teamMember.onlineStatus = userService.getOnlineStatus( account.lastRequestAt );
			}
		);
		modelEvents.on(
			"projectUserAdded.teamDetail",
			function ( event, projectID, userID ) {
				if ( userID === requestContext.getParamAsInt( "userID" ) ) {
					var existingProject = _.findWithProperty( $scope.projects, "id", projectID );
					if ( existingProject ) {
						existingProject.includesTeamMember = true;
					} else {
						loadRemoteData();
					}
				}
			}
		);
		modelEvents.on(
			"subscriptionChanged",
			function ( event, newPlan ) {
				var currentUserID = sessionService.user.id;
				var teamMemberID = requestContext.getParamAsInt( "userID" );
				if ( newPlan.maxProjectCount >= 5 || currentUserID === teamMemberID ) {
					$scope.canViewActivity = true;
				} else {
					$scope.canViewActivity = false;
				}
			}
		);
		$scope.setWindowTitle( "Loading person's profile..." );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! list-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.ListController", Controller );
	var TEAM_PLAN_TEAM_LIMIT = 5,
		TEAM_PLAN_IDS = [ 28, 29 ],
		ENTERPRISE_PLAN_IDS = [ 20, 22, 23, 24 ],
		OLD_FIXED_PROJECT_PLAN_IDS = [ 4, 5, 7, 10, 11, 12, 13, 14, 15 ];
	/** @ngInject */
	function Controller( $scope, $location, requestContext, Deferred, teamService, teamInvitationService, teamListPartial, modelEvents, hashKeyCopier, userService, sessionService, _, userPreferenceService ) {
		var isEnterprisePlan = _.contains( ENTERPRISE_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
		var isTeamPlan = _.contains( TEAM_PLAN_IDS, sessionService.subscription.subscriptionPlanID );

		function applyRemoteData( teamMembers, companyMembers, iOwnACompanyOtherConnections, inACompanyNotOwnOneOtherConnections, invitations, account ) {
			$scope.teamMembers = hashKeyCopier.copyHashKeys( $scope.teamMembers, augmentTeamMembers( teamMembers ) );
			$scope.activeTeamMembers = sortTeamMembers( getActiveTeamMembers( $scope.teamMembers ) );
			$scope.inactiveTeamMembers = sortTeamMembers( getInactiveTeamMembers( $scope.teamMembers ) );
			$scope.teamLead = getTeamLead( $scope.teamMembers );
			$scope.isUserCompanyOwner = isCurrentUserACompanyOwner( $scope.user, companyMembers );
			$scope.companyMembers = companyMembers;
			for ( var i = 0; i < $scope.companyMembers.length; i++ ) {
				$scope.companyMembers[ i ].teamMembers = hashKeyCopier.copyHashKeys( $scope.companyMembers, augmentTeamMembers( $scope.companyMembers[ i ].teamMembers ) );
				$scope.companyMembers[ i ].teamConnectionInvitations = augmentInvitations( $scope.companyMembers[ i ].teamConnectionInvitations );
				$scope.companyMembers[ i ].teamInvitations = augmentInvitations( $scope.companyMembers[ i ].teamInvitations );
			}
			$scope.iOwnACompanyOtherConnections = hashKeyCopier.copyHashKeys( $scope.iOwnACompanyOtherConnections, augmentTeamMembers( iOwnACompanyOtherConnections ) );
			$scope.inACompanyNotOwnACompanyOtherConnections = hashKeyCopier.copyHashKeys( $scope.inACompanyNotOwnOneOtherConnections, augmentTeamMembers( inACompanyNotOwnOneOtherConnections ) );
			$scope.invitations = hashKeyCopier.copyHashKeys( $scope.invitations, augmentInvitations( invitations ) );
			$scope.invitations = sortInvitations( $scope.invitations );
			$scope.hasTeam = account.isCompany;
		}

		function augmentInvitation( invitation ) {
			invitation.initials = userService.getInitials( invitation.memberEmail );
			invitation.hasSystemAvatar = userService.isSystemAvatar( invitation.avatarID );
			if ( invitation.hasOwnProperty( 'lastRequestAt' ) ) {
				invitation.onlineStatus = userService.getOnlineStatus( invitation.lastRequestAt );
			}
			return ( invitation );
		};

		function augmentInvitations( invitations ) {
			_.each( invitations, augmentInvitation );
			return ( invitations );
		};

		function augmentTeamMember( teamMember ) {
			teamMember.initials = userService.getInitials( teamMember.name );
			teamMember.hasSystemAvatar = userService.isSystemAvatar( teamMember.avatarID );
			teamMember.onlineStatus = userService.getOnlineStatus( teamMember.lastRequestAt );
			return ( teamMember );
		};

		function augmentTeamMembers( teamMembers ) {
			_.each( teamMembers, augmentTeamMember );
			return ( teamMembers );
		};

		function canUserAddNewTeamMember() {
			var isFixedProjectPlanBeyondProUnlimited = _.contains( OLD_FIXED_PROJECT_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
			var isUserEnterprise = _.contains( ENTERPRISE_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
			var isRoomAvailableInTeamQuota = ( getCountOfTeamMembersPlusInvitesInMyCompany() <= TEAM_PLAN_TEAM_LIMIT );
			return ( isFixedProjectPlanBeyondProUnlimited || isUserEnterprise || isRoomAvailableInTeamQuota );
		};

		function getActiveTeamMembers( teamMembers ) {
			var activeTeamMembers = _.filter(
				teamMembers,
				function ( teamMember ) {
					return ( !teamMember.isTeamLead && !!teamMember.projectCount );
				}
			);
			return ( activeTeamMembers );
		};

		function getCountOfTeamMembersPlusInvitesInMyCompany() {
			var company = ( _.findWithProperty( $scope.companyMembers, "leadUserID", $scope.user.id ) || [] );
			if ( company.length ) {
				var adminInvites = ( _.filterWithProperty( company.teamInvitations, "canCreateProjectsForLead", true ) || [] );
				return ( company.teamMembers.length + adminInvites.length );
			} else {
				return 1;
			}
		};

		function getInactiveTeamMembers( teamMembers ) {
			var inactiveTeamMembers = _.filter(
				teamMembers,
				function ( teamMember ) {
					return ( !teamMember.isTeamLead && !teamMember.projectCount );
				}
			);
			return ( inactiveTeamMembers );
		};

		function getTeamLead( teamMembers ) {
			return (
				_.findWithProperty( teamMembers, "isTeamLead", true )
			);
		};

		function isCurrentUserACompanyOwner( currentUser, companyMembers ) {
			var firstOwnedCompany = _.find( companyMembers, function ( company ) {
				return ( company.leadUserID === currentUser.id );
			} );
			return ( !_.isUndefined( firstOwnedCompany ) );
		};

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				teamListPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.teamMembers,
						response.companyMembers,
						response.iOwnACompanyOtherConnections,
						response.inACompanyNotOwnOneOtherConnections,
						response.invitations,
						response.account
					);
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your team. Try refreshing your browser." );
				}
			);
		};

		function removeTeamMember( teamMember ) {
			$scope.inactiveTeamMembers = _.withoutProperty( $scope.inactiveTeamMembers, "id", teamMember.id );
			$scope.inACompanyNotOwnACompanyOtherConnections = _.withoutProperty( $scope.inACompanyNotOwnACompanyOtherConnections, "id", teamMember.id );
			$scope.iOwnACompanyOtherConnections = _.withoutProperty( $scope.iOwnACompanyOtherConnections, "id", teamMember.id );
		};

		function sortInvitations( invitations ) {
			return (
				_.sortOnProperty( invitations, "memberEmail" )
			);
		};

		function sortTeamMembers( teamMembers ) {
			teamMembers.sort(
				function ( a, b ) {
					if ( a.onlineStatus !== b.onlineStatus ) {
						if ( a.onlineStatus === "Online" ) {
							return ( -1 );
						} else if (
							( a.onlineStatus === "Away" ) &&
							( b.onlineStatus === "Offline" )
						) {
							return ( -1 );
						} else {
							return ( 1 );
						}
					}
					if ( a.projectCount !== b.projectCount ) {
						return ( a.projectCount > b.projectCount ? -1 : 1 );
					}
					return ( a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1 );
				}
			);
			return ( teamMembers );
		};
		$scope.cancelInvitation = function ( invitation ) {
			$scope.invitations = _.withoutProperty( $scope.invitations, "id", invitation.id );
			Deferred.handlePromise(
				teamInvitationService.cancel( invitation.id, $scope.user.id ),
				null,
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't cancel that invitation." );
				}
			);
		};
		$scope.cancelCompanyInvitation = function ( invitation ) {
			for ( var i = 0; i < $scope.companyMembers.length; i++ ) {
				$scope.companyMembers[ i ].teamInvitations = _.withoutProperty( $scope.companyMembers[ i ].teamInvitations, "id", invitation.id );
				$scope.companyMembers[ i ].teamConnectionInvitations = _.withoutProperty( $scope.companyMembers[ i ].teamConnectionInvitations, "id", invitation.id );
			}
			Deferred.handlePromise(
				teamInvitationService.cancel( invitation.id, $scope.user.id ),
				null,
				function ( er ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't cancel that invitation." );
				}
			);
		};
		$scope.createTeam = function () {
			if ( isTeamPlan || isEnterprisePlan ) {
				$scope.openModalWindow( 'createTeamModal', null, $scope.hasTeam );
			} else {
				$scope.openModalWindow( 'teamEnterpriseChoice' );
			}
		};
		$scope.openNewTeamMemberModal = function ( isFirstView ) {
			if ( !canUserAddNewTeamMember() ) {
				$scope.openModalWindow( "teamEnterpriseChoice" );
			} else {
				var isFirstView = ( isFirstView || false );
				$scope.openModalWindow( "newTeamMember", isFirstView );
			}
		};
		$scope.openEditTeamModal = function ( company ) {
			if ( company.leadUserID === $scope.user.id ) {
				$scope.openModalWindow( 'createTeamModal', null, $scope.hasSeenTeamCreateInit );
			}
		};
		$scope.openMemberActivity = function ( member ) {
			$location.url( "/team/" + member.id + "/activity" );
		};
		$scope.removeMemberFromLeadsTeam = function ( member, team ) {
			$scope.companyMembers = _.rejectWithProperty( $scope.companyMembers, "leadUserID", team.leadUserID );
			Deferred.handlePromise(
				teamService.revokeAdminStatus( member.id, team.leadUserID ),
				null,
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't remove you from this team." );
				}
			);
		};
		$scope.removeTeamMember = function ( teamMember ) {
			removeTeamMember( teamMember );
			Deferred.handlePromise(
				teamService.remove( teamMember.id ),
				null,
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't remove " + teamMember.name + " from your team." );
				}
			);
		};
		$scope.resendInvitation = function ( invitation ) {
			Deferred.handlePromise(
				teamInvitationService.resend( invitation.id ),
				function () {
					$scope.openModalWindow( "alert", "Your invitation has been resent." );
				},
				function () {
					$scope.openModalWindow( "error", "For some reason, we couldn't cancel that invitation." );
				}
			);
		};
		$scope.showCreateTeamTooltip = function () {
			return ( sessionService.subscription.subscriptionPlanID !== 1 );
		};
		$scope.showTeamVideo = function () {
			var isEnterprisePlan = _.contains( ENTERPRISE_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
			var isTeamPlan = _.contains( TEAM_PLAN_IDS, sessionService.subscription.subscriptionPlanID );
			return ( isTeamPlan || isEnterprisePlan );
		};
		$scope.openTeamSetupVideo = function () {
			$scope.openModalWindow( "video", "94025254" );
		};
		$scope.setProjectVisibility = function ( company ) {
			teamService.setProjectVisibility( company.canViewAllLeadProjects );
		};
		$scope.showYouBadge = function ( leadUserID ) {
			return ( leadUserID == $scope.user.id );
		};
		$scope.isConnected = function ( userID ) {
			var teamMembers = _.filter(
				$scope.teamMembers,
				function ( teamMember ) {
					return ( teamMember.id == userID );
				}
			);
			return teamMembers.length;
		};
		var renderContext = requestContext.getRenderContext( "standard.team.list" );
		$scope.isLoading = false;
		$scope.companyMembers = [];
		$scope.teamMembers = [];
		$scope.teamLead = [];
		$scope.activeTeamMembers = [];
		$scope.inactiveTeamMembers = [];
		$scope.invitations = [];
		$scope.user = sessionService.user;
		$scope.isUserCompanyOwner = false;
		$scope.hasSeenTeamCreateInit = true;
		$scope.hasTeam = false;
		$scope.triggerAddTeamMember = false;
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "teamCreated.teamList" );
				modelEvents.off( "teamCreated.forFirstTime" );
				modelEvents.off( "teamInvitationCreated.teamList" );
				modelEvents.off( "teamInvitationDeleted.teamList" ),
				modelEvents.off( "teamMemberCreated.teamList" );
				modelEvents.off( "teamMemberUpdated.teamList" );
				modelEvents.off( "accountUpdated.teamList" );
			}
		);
		modelEvents.on(
			[
				"teamCreated.teamList",
				"teamInvitationCreated.teamList",
				"teamInvitationDeleted.teamList",
				"teamMemberCreated.teamList",
				"teamMemberUpdated.teamList",
				"accountUpdated.teamList"
			],
			function ( event, invitation ) {
				loadRemoteData();
			}
		);
		modelEvents.on( "teamCreated.forFirstTime", function ( event, accountData ) {
			$scope.hasTeam = true;
			$scope.triggerAddTeamMember = true;
		} );
		$scope.setWindowTitle( "My Team" );
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! notifications-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.NotificationsController", Controller );
	/** @ngInject */
	function Controller( $scope, moment, requestContext, Deferred, notificationsService, teamNotificationsPartial, sessionService, dateHelper, _, $timeout ) {
		function applyRemoteData( settings, projects, userPreferences ) {
			$scope.projects = projects;
			$scope.settings = settings;
			$scope.settings.wantsrealtimecomments = userPreferences.wantsRealtimeComments;
			_.sortOnProperty( $scope.projects, "name" );
			if ( $scope.settings.digestEmails.wantsDigestAtFrequencyInHours === 24 &&
				_.isNumber( $scope.settings.digestEmails.sendNextDigestAt ) &&
				moment( $scope.settings.digestEmails.sendNextDigestAt ).isValid()
			) {
				$scope.settings.digestEmails.sendNextDigestAt = moment( $scope.settings.digestEmails.sendNextDigestAt ).valueOf();
				$scope.changeDigestSendTime( {
					dateTime: $scope.settings.digestEmails.sendNextDigestAt,
					label: moment( $scope.settings.digestEmails.sendNextDigestAt ).format( "h:mma" )
				} );
				$scope.hasDigestTimeChanged = false;
			} else {
				setDigestSendAtTimeToDefault();
				$scope.hasDigestTimeChanged = true;
			}
			$scope.settings.digestEmails.enable = ( $scope.settings.digestEmails.wantsDigestAtFrequencyInHours > 0 );
			augmentProjects();
		}

		function augmentProjects() {
			var settings = $scope.settings;
			var projects = $scope.projects;
			for ( var i = 0; i < projects.length; i++ ) {
				for ( var j = 0; j < settings.projectNotifications.length; j++ ) {
					if ( projects[ i ].id === settings.projectNotifications[ j ].id ) {
						projects[ i ].notificationSettings = settings.projectNotifications[ j ];
						break;
					}
				}
			}
			$scope.form.toggleAllRealtimeNotifications = $scope.settings.wantsrealtimecomments;
			$scope.projectsOwnedByMe = getProjectsOwnedByMe();
			$scope.projectsOwnedByOthers = getProjectsOwnedByOthers();
		}

		function getProjectsOwnedByMe() {
			return (
				_.withProperty( $scope.projects, "userID", $scope.userID )
			);
		}

		function getProjectsOwnedByOthers() {
			return (
				_.withoutProperty( $scope.projects, "userID", $scope.userID )
			);
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				teamNotificationsPartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData(
						response.notificationSettings,
						response.projects,
						response.userPreferences
					);
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your notification settings. Try refreshing your browser." );
				}
			);
		}

		function setDigestSendAtTimeToDefault() {
			var defaultOpt = _.filterWithProperty( $scope.digestSendTimeOptions, "label", "8:00pm" );
			$scope.changeDigestSendTime( defaultOpt[ 0 ] );
		}

		function setupDigestSendTimes() {
			var startTime = moment().startOf( "day" );
			var endTime = moment( startTime ).add( "d", 1 );
			var timeOptionArray = [];
			for ( var timeIdx = startTime; timeIdx.isBefore( endTime ); timeIdx.add( "m", 30 ) ) {
				timeOptionArray.push( {
					dateTime: timeIdx.clone().utc().valueOf(),
					label: timeIdx.format( "h:mma" )
				} );
			}
			$scope.digestSendTimeOptions = timeOptionArray;
		}

		function turnOffAllRealtimeNotifications() {
			$scope.settings.wantsrealtimecomments = false;
			$scope.settings.digestEmails.wantsDigestAtFrequencyInHours = 24;
			_.forEach( $scope.projectsOwnedByMe, function ( project ) {
				project.notificationSettings.wantsRealtimeCommentEmails = false;
			} );
			_.forEach( $scope.projectsOwnedByOthers, function ( project ) {
				project.notificationSettings.wantsRealtimeCommentEmails = false;
			} );
		}

		function turnOnAllRealtimeNotifications() {
			$scope.settings.wantsrealtimecomments = true;
			$scope.settings.digestEmails.wantsDigestAtFrequencyInHours = 0;
			_.forEach( $scope.projectsOwnedByMe, function ( project ) {
				project.notificationSettings.wantsRealtimeCommentEmails = true;
			} );
			_.forEach( $scope.projectsOwnedByOthers, function ( project ) {
				project.notificationSettings.wantsRealtimeCommentEmails = true;
			} );
		}
		$scope.toggleAllRealtimeCommentNotifications = function () {
			if ( $scope.form.toggleAllRealtimeNotifications == true ) {
				turnOnAllRealtimeNotifications();
			} else {
				turnOffAllRealtimeNotifications();
			}
		}
		$scope.changeDigestSendTime = function ( option ) {
			var dateTime = option.dateTime;
			$scope.hasDigestTimeChanged = true;
			$scope.digestSendTime = option.label;
			if ( moment( dateTime ).isBefore( moment() ) ) {
				dateTime = moment( dateTime ).add( "d", 1 ).valueOf();
			}
			$scope.sendDigestAtSavedSuccessfully = false;
			$scope.settings.digestEmails.sendNextDigestAt = dateTime;
		};
		$scope.saveDigestSentAtTime = function () {
			var wantsDigestAtFrequencyInHours = $scope.settings.digestEmails.wantsDigestAtFrequencyInHours;
			var nextDigestAt = $scope.settings.digestEmails.sendNextDigestAt;
			if ( wantsDigestAtFrequencyInHours < 24 ) {
				nextDigestAt = moment().utc().add( "h", wantsDigestAtFrequencyInHours ).valueOf();
			}
			Deferred.handlePromise(
				notificationsService.updateSendDigestAt(
					wantsDigestAtFrequencyInHours,
					nextDigestAt
				),
				function ( response ) {
					$scope.sendDigestAtSavedSuccessfully = true;
				},
				function ( response ) {
					$scope.errorMessage = "There was a problem saving your settings.";
					$scope.successMessage = null;
					$scope.sendDigestAtSavedSuccessfully = false;
				}
			);
		};
		$scope.saveSettings = function ( projectID ) {
			$scope.lastSavedProjectID = projectID;
			Deferred.handlePromise(
				notificationsService.updateSettings( $scope.settings ),
				function ( response ) {
					$scope.errorMessage = null;
					$scope.successMessage = "Your notification settings have been saved.";
				},
				function ( response ) {
					$scope.errorMessage = "There was a problem saving your settings.";
					$scope.successMessage = null;
				}
			);
		};
		$scope.showSubview = function ( section ) {
			$scope.subview = section;
		};
		var renderContext = requestContext.getRenderContext( "standard.team.detail.notifications" );
		$scope.userID = sessionService.user.id;
		$scope.isLoading = false;
		$scope.settings = null;
		$scope.projects = [];
		$scope.projectsOwnedByMe = [];
		$scope.projectsOwnedByOthers = [];
		$scope.digestSendTime = "";
		$scope.digestSendTimeOptions = [];
		$scope.hasDigestTimeChanged = false;
		$scope.subview = "email";
		$scope.errorMessage = null;
		$scope.successMessage = null;
		$scope.sendDigestAtSavedSuccessfully = false;
		$scope.form = {
			toggleAllRealtimeNotifications: false
		};
		$scope.lastSavedProjectID = 0;
		$scope.$watch( "settings.digestEmails.wantsDigestAtFrequencyInHours", function ( newValue, oldValue ) {
			if ( oldValue !== newValue ) {
				$scope.hasDigestTimeChanged = true;
				$scope.sendDigestAtSavedSuccessfully = false;
			}
		} );
		loadRemoteData();
		setupDigestSendTimes();
	}
} )( angular, InVision );;;
/*! profile-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.ProfileController", Controller );
	/** @ngInject */
	function Controller( $scope, requestContext, Deferred, accountService, validationService, sessionService, teamProfilePartial, modelEvents, userService, _, MIN_PASSWORD_LENGTH, MAX_PASSWORD_LENGTH ) {
		function applyRemoteData( response ) {
			$scope.account = response.account;
			$scope.account.initials = userService.getInitials( response.account.name );
			$scope.account.hasSystemAvatar = userService.isSystemAvatar( response.account.avatarID );
			$scope.teamMembers = response.teamMembers;
			if ( response.account.companyLogoID.length ) {
				$scope.companyLogoPath = "/logos/" + response.account.companyLogoID;
			} else {
				$scope.companyLogoPath = "";
			}
		}

		function loadRemoteData() {
			$scope.isLoading = true;
			Deferred.handlePromise(
				teamProfilePartial.get(),
				function ( response ) {
					$scope.isLoading = false;
					applyRemoteData( response );
				},
				function ( response ) {
					$scope.openModalWindow( "error", "For some reason, we couldn't load your profile. Try refreshing your browser." );
				}
			);
		}

		function saveCompany( companyLogoIdToBeDeleted, removeOldLogoID ) {
			var companyLogoIdToBeDeleted = !_.isUndefined( companyLogoIdToBeDeleted ) ? companyLogoIdToBeDeleted : '';
			var account = $scope.account;
			var promise = accountService.updateCompany( {
				company: account.company,
				isCompany: account.isCompany,
				companyLogoIdToBeDeleted: companyLogoIdToBeDeleted,
				removeOldLogoID: removeOldLogoID
			} );
			Deferred.handlePromise(
				promise,
				function ( account ) {
					$scope.account = account;
					$scope.isShowingCompanyForm = false;
					$scope.isShowingCompanyEdit = false;
					$scope.companyErrorMessage = null;
				},
				function ( response ) {
					$scope.errorMessage = response.message;
				}
			);
		}
		$scope.showCompanyForm = function () {
			$scope.isShowingCompanyForm = true;
			$scope.originalCompanyValue = $scope.account.company;
		};
		$scope.showCompanyEditForm = function () {
			$scope.isShowingCompanyForm = false;
			$scope.isShowingCompanyEdit = true;
			$scope.originalCompanyValue = $scope.account.company;
		};
		$scope.cancelCompanyForm = function () {
			$scope.isShowingCompanyForm = false;
			$scope.isShowingCompanyEdit = false;
			$scope.companyErrorMessage = '';
			$scope.account.company = $scope.originalCompanyValue;
		};
		$scope.showConvertToCompanyTour = function () {
			$scope.openModalWindow( "convertToCompanyTour" );
		};
		$scope.openTeamSetupVideo = function () {
			$scope.openModalWindow( "video", "66614411", [ 660, 420 ] );
		};
		$scope.validateCompany = function () {
			if ( $scope.account.company.length === 0 ) {
				$scope.companyErrorMessage = "Please enter a company name.";
				return false;
			} else {
				return true;
			}
		};
		$scope.convertToCompanyAccount = function () {
			if ( $scope.validateCompany() ) {
				$scope.account.isCompany = true;
				saveCompany( '', false );
			}
		};
		$scope.convertToPersonalAccount = function () {
			var companyLogoIdToBeDeleted = $scope.account.companyLogoID;
			$scope.account.isCompany = false;
			$scope.account.company = '';
			$scope.account.companyLogoID = '';
			saveCompany( companyLogoIdToBeDeleted, true );
		};
		$scope.hidePasswordForm = function () {
			$scope.passwordErrorMessage = null;
			$scope.password.currentPassword = "";
			$scope.password.newPassword = "";
			$scope.password.confirmationPassword = "";
			$scope.isShowingPasswordForm = false;
		};
		$scope.importGravatarAvatar = function () {
			$scope.openModalWindow( "gravatarAvatar" );
		};
		$scope.importTwitterAvatar = function () {
			$scope.openModalWindow( "twitterAvatar" );
		};
		$scope.savePassword = function () {
			if ( $scope.password.currentPassword.length === 0 ) {
				$scope.passwordErrorMessage = "Please provide your current password.";
				return;
			}
			if (
				( $scope.password.newPassword.length < MIN_PASSWORD_LENGTH ) ||
				( $scope.password.newPassword.length > MAX_PASSWORD_LENGTH )
			) {
				$scope.passwordErrorMessage = "Your password must be between " + MIN_PASSWORD_LENGTH + " and " + MAX_PASSWORD_LENGTH + " characters.";
				return;
			}
			if ( $scope.password.newPassword !== $scope.password.confirmationPassword ) {
				$scope.passwordErrorMessage = "Your new password does not match your confirmation password.";
				return;
			}
			Deferred.handlePromise(
				accountService.changePassword( $scope.password.currentPassword, $scope.password.newPassword, $scope.password.confirmationPassword ),
				function ( account ) {
					$scope.hidePasswordForm();
				},
				function ( response ) {
					$scope.passwordErrorMessage = response.message;
				}
			);
		};
		$scope.saveProfile = function () {
			$scope.successMessage = null;
			var account = $scope.account;
			if ( !account.name.length ) {
				$scope.errorMessage = "Please enter your name.";
				return;
			}
			if ( !/[^@]+@[^.]+\..+/.test( account.email ) ) {
				$scope.errorMessage = "Please enter a valid email address.";
				return;
			}
			var promise = accountService.updateProfile( {
				name: account.name,
				email: account.email,
				city: account.city,
				state: account.state,
				country: account.country
			} );
			Deferred.handlePromise(
				promise,
				function ( account ) {
					if ( !$scope.isShowingCompanyForm ) {
						$scope.account = account;
					} else {
						var prevCompany = $scope.account.company;
						var prevIsCompany = $scope.account.isCompany;
						$scope.account = account;
						$scope.account.company = prevCompany;
						$scope.account.isCompany = prevIsCompany;
					}
					$scope.account.initials = userService.getInitials( account.name );
					$scope.account.hasSystemAvatar = userService.isSystemAvatar( account.avatarID );
					$scope.successMessage = "Your profile has been updated.";
					$scope.errorMessage = null;
				},
				function ( response ) {
					if ( validationService.isAlreadyExists( response ) ) {
						$scope.errorMessage = "That email address is not currently available for use.";
						return;
					}
					$scope.errorMessage = response.message;
				}
			);
		};
		$scope.showPasswordForm = function () {
			$scope.isShowingPasswordForm = true;
		};
		var renderContext = requestContext.getRenderContext( "standard.team.detail.profile", "userID" );
		$scope.userID = requestContext.getParamAsInt( "userID" );
		$scope.isLoading = true;
		$scope.account = null;
		$scope.password = {
			currentPassword: "",
			newPassword: "",
			confirmationPassword: ""
		};
		$scope.successMessage = null;
		$scope.errorMessage = null;
		$scope.passwordErrorMessage = null;
		$scope.companyErrorMessage = null;
		$scope.isShowingPasswordForm = false;
		$scope.isShowingCompanyForm = false;
		$scope.isShowingCompanyEdit = false;
		$scope.originalCompanyValue = null;
		$scope.companyLogoPath = "";
		$scope.$on(
			"$destroy",
			function () {
				modelEvents.off( "accountUpdated.teamProfile" );
			}
		);
		$scope.$on(
			"profileAvatarUploader:uploaded",
			function ( event, account ) {
				$scope.account.avatarID = account.avatarID;
				$scope.errorMessage = null;
			}
		);
		$scope.$on(
			"profileAvatarUploader:error",
			function ( event, response ) {
				$scope.errorMessage = "There was a problem uploading your avatar!";
			}
		);
		$scope.$on(
			"profileCompanyLogoUploader:uploaded",
			function ( event, account ) {
				$scope.account.companyLogoID = account.companyLogoID;
				if ( account.companyLogoID.length ) {
					$scope.companyLogoPath = "/logos/" + account.companyLogoID;
				} else {
					$scope.companyLogoPath = "";
				}
				$scope.errorMessage = null;
			}
		);
		$scope.$on(
			"profileCompanyLogoUploader:error",
			function ( event, response ) {
				$scope.errorMessage = "There was a problem uploading your company logo!";
			}
		);
		modelEvents.on(
			"accountUpdated.teamProfile",
			function ( event, account ) {
				$scope.account.avatarID = account.avatarID;
				sessionService.update();
			}
		);
		loadRemoteData();
	}
} )( angular, InVision );;;
/*! team-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "team.TeamController", Controller );
	/** @ngInject */
	function Controller( BaseController, $scope, $location, sessionService, requestContext ) {
		BaseController.call( this, $scope );
		this.requestContext = requestContext;
		this.renderContext = this.requestContext.getRenderContext( "standard.team" );
		this.scope.subview = this.renderContext.getNextSection();
		if ( $location.search().hasOwnProperty( "showAcceptConfirmation" ) ) {
			$scope.openModalWindow( "teamInviteJoinedConfirmation", $location.search() );
		}
	}
	Controller.prototype = {
		handleRequestContextChanged: function ( requestContext ) {
			if ( !this.renderContext.isChangeRelevant() ) {
				return;
			}
			this.scope.subview = this.renderContext.getNextSection();
		}
	};
} )( angular, InVision );;;
/*! popup-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "tellAFriend.PopupController", Controller );
	/** @ngInject */
	function Controller( $scope, $window, $timeout, accountService ) {
		function resetSubviewAfterTimeout() {
			var delay = ( 1 * 60 * 1000 );
			$timeout( function () {
				$scope.subview = "form";
			}, delay );
		}

		function validateEmails( emails ) {
			var emailArray = emails.split( "," );
			var badEmailCount = 0;
			for ( var i = 0; i < emailArray.length; i++ ) {
				var email = emailArray[ i ]
				if ( !( /^[^@]+@[^.]+\..+$/i ).test( email ) ) {
					badEmailCount++;
				}
			}
			return ( badEmailCount == 0 );
		}
		$scope.sendInvites = function () {
			if ( validateEmails( $scope.form.inviteEmails ) ) {
				$scope.numberOfEmails = $scope.form.inviteEmails.split( "," ).length;
				$scope.subview = "confirmation";
				$window._kmq.push( [ 'record', 'Submitted Tell-A-Friend modal' ] );
				accountService.sendInviteToSignup( $scope.form.inviteEmails );
				resetSubviewAfterTimeout();
			} else {
				$scope.errorMessage = "Please ensure all email addresses are in the proper format.";
			}
		};
		$scope.openEmailPreview = function () {
			$scope.openModalWindow( "tellAFriendEmailPreview" );
		};
		$scope.subview = "form";
		$scope.numberOfEmails = 0;
		$scope.numberOfMonthsFree = 3;
		$scope.form = {
			inviteEmails: ""
		};
		$scope.errorMessage = "";
	}
} )( angular, InVision );;;
/*! active-screens.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invActiveScreens", Directive );
	/** @ngInject */
	function Directive( $filter, _ ) {
		var linkFunction = function ( $scope, element ) {
			var $element = $( element ),
				startIndex,
				startIndices = [],
				multipleDragHelper = $element.find( ".multiple-drag-helper" ).get( 0 );
			var handleHelper = function ( event, ui ) {
				$scope.areMultipleScreensBeingDragged = ( $scope.selectedScreenCount > 1 );
				if ( $scope.areMultipleScreensBeingDragged ) {
					if ( $scope.isShowingSmallScreenSize ) {
						$( multipleDragHelper ).addClass( "dragging" );
						$element.sortable( "option", "cursorAt", {
							top: -10,
							left: -50
						} );
						return multipleDragHelper;
					} else {
						ui.find( ".link span" ).text( "Moving " + $scope.selectedScreenCount + " Screens" );
						return ui;
					}
				} else {
					return ui;
				}
			};
			var handleSortStart = function ( event, ui ) {
				if ( $scope.areMultipleScreensBeingDragged ) {
					ui.item.show();
					var selectedScreens = [];
					if ( $scope.isShowingSmallScreenSize ) {
						selectedScreens = $element.find( ".screen_row.selected" ).parent();
					} else {
						selectedScreens = $element.find( ".screen.selected" ).parent();
					}
					startIndices = _.map( selectedScreens, locateScreenItemInDOM );
				} else {
					startIndex = locateScreenItemInDOM( ui.item );
				}
				$scope.$apply(
					function () {
						$scope.$emit( "activeScreens:sortStart" );
					}
				);
			};
			var handleSortStop = function ( event, ui ) {
				if ( $scope.areMultipleScreensBeingDragged ) {
					$( multipleDragHelper ).removeClass( "dragging" );
					var $span = $( ui.item[ 0 ] ).find( ".link span" );
					$span.text( $span.data( "original-text" ) );
				}
				$scope.areMultipleScreensBeingDragged = false;
				$scope.$apply(
					function () {
						$scope.$emit( "activeScreens:sortStop" );
					}
				);
			};
			var handleSortUpdate = function ( event, ui ) {
				var endIndex = locateScreenItemInDOM( ui.item );
				var filter = $scope.filters.screensFilter;
				var allScreens = $scope.displayObjects;
				var filteredScreens = $filter( "filter" )( allScreens, {
					"name": filter
				} );
				if ( $scope.areMultipleScreensBeingDragged ) {
					var movedScreens = [];
					_.forEach( startIndices, function ( indx ) {
						movedScreens.push( filteredScreens[ indx ] );
					} );
					if ( endIndex === 0 ) {
						insertManyBefore(
							allScreens,
							movedScreens,
							filteredScreens[ endIndex ]
						);
					} else if ( endIndex > _.min( startIndices ) ) {
						insertManyAfter(
							allScreens,
							movedScreens,
							filteredScreens[ endIndex ]
						);
					} else {
						insertManyAfter(
							allScreens,
							movedScreens,
							filteredScreens[ endIndex - 1 ]
						);
					}
				} else {
					if ( endIndex === 0 ) {
						insertBefore(
							allScreens,
							filteredScreens[ startIndex ],
							filteredScreens[ endIndex ]
						);
					} else if ( endIndex > startIndex ) {
						insertAfter(
							allScreens,
							filteredScreens[ startIndex ],
							filteredScreens[ endIndex ]
						);
					} else {
						insertAfter(
							allScreens,
							filteredScreens[ startIndex ],
							filteredScreens[ endIndex - 1 ]
						);
					}
				}
				element.find( ".screenObj" ).css( {
					"display": ""
				} );
				$scope.$apply(
					function () {
						$scope.$emit( "activeScreens:sortUpdate" );
					}
				);
			};
			var insertAfter = function ( collection, movedItem, prevItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					( locateItem( collection, prevItem ) + 1 ),
					0,
					movedItem
				);
			};
			var insertBefore = function ( collection, movedItem, nextItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					locateItem( collection, nextItem ),
					0,
					movedItem
				);
			};
			var insertManyAfter = function ( collection, movedItems, prevItem ) {
				_.forEach( movedItems, function ( movedItem ) {
					collection.splice(
						locateItem( collection, movedItem ),
						1
					);
				} );
				var insertPoint = ( locateItem( collection, prevItem ) + 1 );
				collection.splice.apply( collection, [ insertPoint, 0 ].concat( movedItems ) );
			};
			var insertManyBefore = function ( collection, movedItems, nextItem ) {
				_.forEach( movedItems, function ( movedItem ) {
					collection.splice(
						locateItem( collection, movedItem ),
						1
					);
				} );
				var insertPoint = Math.max( locateItem( collection, nextItem ), 0 );
				collection.splice.apply( collection, [ insertPoint, 0 ].concat( movedItems ) );
			};
			var locateScreenItemInDOM = function ( item ) {
				return $element.children().not( ".multiple-drag-helper" ).not( ".sortablePlaceholder" ).index( item );
			};
			var locateItem = function ( collection, item ) {
				for ( var i = 0, length = collection.length; i < length; i++ ) {
					if ( collection[ i ] === item ) {
						return ( i );
					}
				}
				return ( -1 );
			};
			$scope.$watch( "filters.screensFilter", function ( newVal ) {
				if ( !$scope.isReviewer ) {
					if ( newVal === "" ) {
						$element.sortable( "option", "disabled", false );
					} else {
						$element.sortable( "option", "disabled", true );
					}
				}
			} );
			$scope.areMultipleScreensBeingDragged = false;
			if ( !$scope.isReviewer ) {
				$element.sortable( {
					cancel: ".divider",
					cursor: "move",
					distance: 10,
					items: ".screenObj, .divider",
					placeholder: "sortablePlaceholder",
					revert: 300,
					start: handleSortStart,
					stop: handleSortStop,
					tolerance: "pointer",
					helper: handleHelper,
					update: handleSortUpdate
				} );
			}
			$scope.$on( "screenRenameFocus", function () {
				$element.sortable( "option", "disabled", true );
			} );
			$scope.$on( "screenRenameBlur", function () {
				$element.sortable( "option", "disabled", false );
			} );
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! activity-stream-screen-list.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invActivityStreamScreenList", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function configureShowMore() {
				dom.screens = dom.target.children( "div.screen" );
				dom.overflowScreens = dom.screens.filter( ":gt( 3 )" );
				dom.target.css( "height", "auto" );
				dom.showMore.hide();
				if ( dom.overflowScreens.length ) {
					var rowCount = Math.ceil( dom.screens.length / 4 );
					fullHeight = ( shortHeight * rowCount );
					dom.target.css( "height", shortHeight + "px" );
					dom.showMore
						.removeClass( "more" )
						.show();
				}
			}

			function handleShowMoreClick( event ) {
				if ( dom.target.is( ":animated" ) ) {
					return;
				}
				if ( dom.showMore.is( ".more" ) ) {
					dom.showMore.removeClass( "more" );
					dom.overflowScreens.fadeOut( "slow" );
					dom.target.animate( {
							height: ( shortHeight + "px" )
						},
						"slow"
					);
				} else {
					dom.showMore.addClass( "more" );
					dom.overflowScreens.show();
					dom.target.animate( {
							height: ( fullHeight + "px" )
						},
						"slow"
					);
				}
			}
			var target = $( element );
			var dom = {
				target: target,
				showMore: target.children( "div.showMore" ),
				screens: null,
				overflowScreens: null
			};
			var shortHeight = 166;
			var fullHeight = shortHeight;
			target.on(
				"click.invActivityStreamScreenList",
				"div.showMore",
				handleShowMoreClick
			);
			$scope.$watch(
				attributes.invActivityStreamScreenList,
				function ( screenCount, oldScreenCount ) {
					configureShowMore();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "click.invActivityStreamScreenList" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! add-this.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAddThis", Directive );
	/** @ngInject */
	function Directive( _, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$timeout( function () {
				addthis.addEventListener( 'addthis.ready', addthisReady );

				function addthisReady() {
					var $element = $( element );
					_.each( $element.find( "li" ).not( ".skip" ), function ( service ) {
						var $service = $( service ),
							serviceName = $service.attr( "class" ),
							data = $element.data();
						addthis.sharecounters.getShareCounts( {
							service: serviceName,
							countUrl: data.shareUrl
						}, function ( obj ) {
							var count = obj.count || 0;
							$element.find( "." + serviceName ).find( "a" ).text( count );
						} );
					} );
				}
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! archived-projects.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invArchivedProjects", invArchivedProjects );
	/** @ngInject */
	function invArchivedProjects( $compile ) {
		function compile( tElement, tAttributes ) {
			var infoTileContents = tElement.find( "li div.info" ).children().remove();
			var transcludeInfoTileContent = $compile( infoTileContents );
			return ( link );

			function link( $scope, element, attributes ) {
				element.on(
					"mouseenter.invArchivedProjects",
					"li",
					handleMouseEnter
				);
				$scope.$on(
					"$destroy",
					function ( event ) {
						element.off( "mouseenter.invArchivedProjects" );
					}
				);

				function handleMouseEnter( event ) {
					var projectTile = $( this );
					var localScope = projectTile.scope();
					if ( localScope.isHydratedWithInfo ) {
						return;
					}
					localScope.isHydratedWithInfo = true;
					var infoTile = projectTile.find( "div.info" );
					transcludeInfoTileContent(
						localScope,
						function ( clonedContent ) {
							infoTile.append( clonedContent );
						}
					);
					localScope.$apply();
				}
			}
		}
		return ( {
			compile: compile,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! asset-full-view.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAssetFullView", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var $window = $( window ),
				$element = $( element ),
				$img = $element.find( "img" );

			function resizeWindow( offset ) {
				var offset = typeof offset === undefined ? 0 : offset;
				if ( $scope.isZoomed ) {
					$element.css( {
						height: $window.height() - offset,
						width: $window.width() - offset
					} );
				} else {
					$element.attr( "style", "" );
				}
			}
			$window.on( "resize", function () {
				var offset = $scope.isZoomed ? 15 : 0;
				resizeWindow( offset );
			} );
			$scope.isZoomed = false;
			$scope.toggleZoom = function () {
				$scope.isZoomed = !$scope.isZoomed;
			};
			$scope.$watch(
				"isZoomed",
				function ( newVal, oldVal ) {
					if ( newVal !== oldVal ) {
						resizeWindow( 15 );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! asset-share.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAssetShare", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function handleInit() {
				var clipboard = dom.copyButton.zclip( {
					path: '/assets/zeroclipboard/ZeroClipboard10.swf',
					copy: dom.shortCode.val(),
					afterCopy: function () {
						dom.copied.show().fadeIn( 'slow' ).delay( 1000 ).fadeOut( 'slow' );
						/*
setTimeout(function(){
$scope.hideShareOverlay();
$scope.$apply();
}, 1000);
*/
					}
				} );
				isInitialized = true;
			}
			var dom = {};
			dom.target = $( element );
			dom.shortCode = dom.target.find( "input.shareLink.zeroClipboardText" );
			dom.copyButton = dom.target.find( "a.zeroClipboardButton" );
			dom.copied = dom.target.find( "div.copied_successful" );
			var isInitialized = false;
			$scope.$watch(
				"isShowingShareOverlay",
				function ( isShowing ) {
					if ( isShowing && isInitialized == false ) {
						$timeout( handleInit, 500 );
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! asset-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAssetUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var maxInBytes = 524288000; // 500MB
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id == id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id ) );
			};
			var handleDragEnter = function ( event ) {
				event.stopPropagation();
				if ( dom.dropzone.is( ".hotDropzone" ) ) {
					return;
				}
				dom.dropzone.addClass( "hotDropzone" );
				$document.on( "dragenter.invAssetUploader", handleDragEnterOnDocument );
			};
			var handleDragEnterOnDocument = function ( event ) {
				dom.dropzone.removeClass( "hotDropzone" );
				$document.off( "dragenter.invAssetUploader" );
			};
			var handleMouseEnter = function ( event ) {
				dom.dropzone.addClass( "hotDropzone" );
			};
			var handleMouseLeave = function ( event ) {
				dom.dropzone.removeClass( "hotDropzone" );
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				if ( error.status == 413 || error.status == 500 ) {
					$scope.openModalWindow( "error", "The file you are uploading exceeds the maximum file size limit." );
					clearUploader();
				} else if ( error.status == 422 ) {
					$scope.openModalWindow( "error", "You have exceeded the allowed storage space for your account.  You can no longer upload additional assets." );
					clearUploader();
				} else {
					$scope.openModalWindow( "error", "An error occured during your upload.  Please try again later." );
					clearUploader();
				}
				$scope.$apply();
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				for ( var f = 0, len = files.length; f < len; f++ ) {
					if ( files[ f ].name === "Data" || files[ f ].name === "version" ) {
						isSketch = 1;
						break;
					}
				}
				if ( isSketch === 1 ) {
					$timeout( function () {
						$scope.openModalWindow( "sketchSoon" );
					} );
					clearUploader();
					for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
						uploader.removeFile( files[ i ] );
					}
					isSketch = 0;
					return;
				}
				var fileExcludedBasedOnName = null;
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						fileExcludedBasedOnName = files[ i ].name;
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
						continue; // jump to next file.
					}
					if ( files[ i ].size > maxInBytes ) { // limit the max file size, unless it's a PDF
						$scope.openModalWindow(
							"error", ( "The file, \"" + files[ i ].name + ",\" is too large to upload. ( 500MB Limit ) " ) );
						$scope.$apply(); // This helps the modal pop open right away.
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				if ( fileExcludedBasedOnName ) {
					if ( fileExcludedBasedOnName.split( '.' ).pop() === "sketch" ) {
						$timeout(
							function () {
								$scope.openModalWindow( "sketchSoon" );
							}
						);
					} else {
						$scope.openModalWindow( "error", "The file, \"" + fileExcludedBasedOnName + ",\" was skipped since it doesn't appear to be an image file." );
					}
				}
				files.sort( function ( a, b ) {
					var aName = a.name.toLowerCase();
					var bName = b.name.toLowerCase();
					return ( aName < bName ? -1 : 1 );
				} );
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size );
				}
				uploader.settings.multipart_params.numOfFiles = files.length;
				$scope.$emit( "assetUploadStart" );
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				$timeout(
					function () {
						var asset = ng.fromJson( response.response );
						modelEvents.trigger( "assetUploaded", asset );
						$scope.$emit( "assetUploader:uploaded", asset );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				$scope.isHtml5Runtime = ( uploader.runtime === "html5" );
				$scope.isFlashRuntime = ( uploader.runtime === "flash" );
				if ( $scope.isHtml5Runtime ) {
					dom.dropzone.on( "mouseenter", handleMouseEnter );
					dom.dropzone.on( "mouseleave", handleMouseLeave );
					dom.dropzone.on( "dragenter", handleDragEnter );
					dom.dropzone
						.removeClass( "flashDropzone" )
						.addClass( "html5Dropzone" );
				} else {
					dom.target.find( "div.plupload.flash" ).on( "mouseenter", handleMouseEnter );
					dom.target.find( "div.plupload.flash" ).on( "mouseleave", handleMouseLeave );
					dom.dropzone
						.removeClass( "html5Dropzone" )
						.addClass( "flashDropzone" )
				}
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply( function () {
						uploader.start();
					} );
				}
			};
			var handlePluploadUploadComplete = function ( uploader, files ) {
				$scope.$emit( "assetUploadStop" );
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply( function () {
					setFileProgress(
						file.id,
						file.uploaded,
						file.percent );
				} );
			};
			var handleWindowScroll = function ( event ) {
				if ( !dom.target.hasClass( "small" ) ) {
					return;
				}
				var uploaderOffset = dom.target.offset();
				var uploaderTop = uploaderOffset.top;
				var isAboveFold = ( uploaderTop < dom.window.scrollTop() );
				if ( isAboveFold && !dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = true;
				} else if ( !isAboveFold && dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = false;
				}
				$timeout( function () {
					$scope.$apply();
					setTimeout( refreshUploader ); // Allow pause for DOM to update before shim is refreshed.
				} );
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(app|sketch)$/i;
				return ( !pattern.test( name ) );
			};
			var refreshUploader = function () {
				uploader.refresh();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = element.find( "li[data-id='" + id + "']" );
				listItem.fadeOut(
					"slow", function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					} );
			};
			var setFileProgress = function ( id, loaded, percent ) {
				var queueItem = getQueueItemByID( id );
				queueItem.percentage = percent;
				if ( queueItem.state === $scope.fileStates.PENDING ) {
					queueItem.state = $scope.fileStates.UPLOADING;
				}
			};
			var refreshIsLargeUploader = function () {
				$scope.isLargeUploader = ( !$scope.assets.length && !$scope.folders.length && $scope.folderID == 0 );
			};
			var isSketch = 0;
			var dom = {};
			dom.target = element;
			dom.dropzone = dom.target.find( "div.dropzone" );
			dom.window = $( window );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/assets",
				multipart_params: {
					"projectID": $scope.projectID,
					"folderID": $scope.folderID
				},
				drop_element: "assetsUploaderButton",
				browse_button: "assetsUploaderButton",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				}
			} );
			$scope.isHtml5Runtime = false;
			$scope.isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOADING: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.isFixedDropzone = false;
			$scope.isLargeUploader = true;
			$scope.$watch(
				"!! assets.length", function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader );
				} );
			$scope.$watch(
				"projectID", function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				} );
			$scope.$watch(
				"folderID", function ( newValue ) {
					uploader.settings.multipart_params.folderID = newValue;
				} );
			$scope.$watch(
				"[assets.length,folders.length,folderID]", function ( newValue ) {
					refreshIsLargeUploader();
				}, true );
			$scope.$watch(
				"isShowingUploader",
				function ( newValue, oldValue ) {
					refreshIsLargeUploader();
					if ( newValue === true ) {
						if ( $scope.isLargeUploader ) {
							dom.target.show();
						} else {
							var minHeight = dom.target.css( "minHeight" );
							dom.target
								.stop( true, true )
								.css( "minHeight", 0 )
								.slideDown(
									"fast",
									function () {
										dom.target.css( "minHeight", minHeight );
										refreshUploader();
									}
							);
						}
						dom.window.on(
							"error.assetUploader",
							function ( event ) {
								if ( $scope.isFlashRuntime ) {
									return ( false );
								}
							}
						);
						dom.window.on( "scroll.assetUploader", handleWindowScroll );
						handleWindowScroll();
					} else if ( newValue === false ) {
						$scope.isFixedDropzone = false;
						var minHeight = dom.target.css( "minHeight" );
						dom.target
							.stop( true, true )
							.css( "minHeight", 0 )
							.slideUp(
								"fast",
								function () {
									dom.target.css( "minHeight", minHeight );
								}
						);
						clearUploader();
						dom.window.off( "error.assetUploader" );
						dom.window.off( "scroll.assetUploader" );
					}
				}
			);
			$scope.$on(
				"$destroy", function () {
					clearUploader();
					dom.window.off( "error.assetUploader" );
					dom.window.off( "scroll.assetUploader" );
					dom.target.remove();
				} );
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/asset-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! assets.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAssets", Directive );
	/** @ngInject */
	function Directive( $filter ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var handleSortStart = function ( event, ui ) {
				startIndex = ui.item.index();
				$scope.$apply(
					function () {
						$scope.$emit( "assets:sortStart" );
					}
				);
			};
			var handleSortStop = function ( event, ui ) {
				$scope.$apply(
					function () {
						$scope.$emit( "assets:sortStop" );
					}
				);
			};
			var handleSortUpdate = function ( event, ui ) {
				var endIndex = ui.item.index();
				var filter = $scope.assetFilter;
				var allAssets = $scope.assets;
				var filteredAssets = $filter( "filter" )( allAssets, {
					"clientFilename": filter
				} );
				if ( endIndex === 0 ) {
					insertBefore(
						allAssets,
						filteredAssets[ startIndex ],
						filteredAssets[ endIndex ]
					);
				} else if ( endIndex > startIndex ) {
					insertAfter(
						allAssets,
						filteredAssets[ startIndex ],
						filteredAssets[ endIndex ]
					);
				} else {
					insertAfter(
						allAssets,
						filteredAssets[ startIndex ],
						filteredAssets[ endIndex - 1 ]
					);
				}
				$scope.$apply(
					function () {
						$scope.$emit( "assets:sortUpdate" );
					}
				);
			};
			var insertAfter = function ( collection, movedItem, prevItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					( locateItem( collection, prevItem ) + 1 ),
					0,
					movedItem
				);
			};
			var insertBefore = function ( collection, movedItem, nextItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					locateItem( collection, nextItem ),
					0,
					movedItem
				);
			};
			var locateItem = function ( collection, item ) {
				for ( var i = 0, length = collection.length; i < length; i++ ) {
					if ( collection[ i ] === item ) {
						return ( i );
					}
				}
				return ( -1 );
			};
			$scope.setAssetsSortableDisabled = function ( value ) {}
			var startIndex = null;
			var endIndex = null;
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! autocomplete-email.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutocompleteEmail", Directive );
	/** @ngInject */
	function Directive( _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $window = $( window );

			function split( val ) {
				return val.split( /,\s*/ );
			}

			function extractLast( term ) {
				return split( term ).pop();
			}

			function escapeHtml( str ) {
				return String( str )
					.replace( /&/g, "&amp;" )
					.replace( /"/g, "&quot;" )
					.replace( /"/g, "&apos;" )
					.replace( /</g, "&lt;" )
					.replace( />/g, "&gt;" );
			}
			var _users = {},
				sortUsers = [];
			$scope.$watch( "users", function ( val ) {
				if ( !val ) {
					return;
				}
				_.forEach( val, function ( user ) {
					_users[ user.email ] = user;
				} );
				_.forEach( _users, function ( obj, key ) {
					sortUsers.push( key );
				} );
				element
					.bind( "keydown", function ( event ) {
						if ( event.keyCode === $.ui.keyCode.TAB && $( this ).data( "ui-autocomplete" ).menu.active ) {
							event.preventDefault();
						}
					} )
					.autocomplete( {
						minLength: 0,
						source: function ( request, response ) {
							response( $.ui.autocomplete.filter(
								sortUsers, extractLast( request.term ) ) );
						},
						select: function ( event, ui ) {
							var terms = split( this.value );
							terms.pop();
							terms.push( ui.item.value );
							terms.push( "" );
							$scope.$apply(
								function () {
									$scope.form.emails = terms.join( ", " );
								}
							);
							return false;
						}
					} )
					.data( "ui-autocomplete" )
					._renderItem = function ( ul, item ) {
						if ( !ul.hasClass( "share-autocomplete" ) ) {
							ul.addClass( "share-autocomplete" );
						}
						var hasSystemAvatarClass = _users[ item.label ].hasSystemAvatar ? " system-avatar" : "";
						var avatar = "<div class=\"m-avatar" + hasSystemAvatarClass + "\">" +
							"<span class=\"rendering\">" + _users[ item.label ].initials + "</span>" +
							"<img src=\"/avatars/" + _users[ item.label ].avatarID + "\" class=\"rendering\" />" +
							"<div class=\"wrap\"></div>" +
							"</div>";
						var content = "<a><span class=\"user\">" +
							"<span class=\"av\">" + avatar + "</span>" +
							"<span class=\"info\"><span class=\"title\">" + escapeHtml( _users[ item.label ].name ) + "</span>" +
							"<span class=\"email\">" + _users[ item.label ].email + "</span></span>" +
							"</span></a>";
						return $( "<li>" )
							.append( content )
							.appendTo( ul );
				};
				$window.on( "resize.autoCompleteEmail", function () {
					element.autocomplete( "close" );
				} );
			} );
			$scope.$on( "$destroy", function () {
				$window.off( "resize.autoCompleteEmail" );
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! autocomplete.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutocomplete", Directive );
	/** @ngInject */
	function Directive( $filter ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var getOptions = function () {
				var source = $scope[ attributes.invAutocomplete ];
				return angular.extend(
					DEFAULT_OPTIONS, {
						source: source
					}
				);
			};
			var initAutocompleteWidget = function () {
				var opts = getOptions();
				element.typeahead( opts );
				/* from jqui example
if (opts._renderItem) {
element.data("autocomplete")._renderItem = opts._renderItem;
}
*/
			};
			var DEFAULT_OPTIONS = {};
			$scope.$watch( getOptions, initAutocompleteWidget, true );
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! autofill-check.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutofillCheck", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			$scope.$on( "autofillCheck.update", function () {
				$scope[ attributes.ngModel ] = element.val();
			} );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			require: "?ngModel",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! autofocus.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutofocus", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			function focus() {
				setTimeout(
					function () {
						element[ 0 ].focus();
						if ( attributes.invAutofocus === "select" ) {
							element[ 0 ].select();
						}
					}
				);
			}
			var modal = element.closest( "div[ inv-modal ]" );
			if (
				( modal.length === 1 ) &&
				( modal.is( ".fade" ) && !modal.is( ".in" ) )
			) {
				modal.on(
					"shown.invAutofocus",
					function () {
						focus();
					}
				);
			} else if ( element.is( ":visible" ) ) {
				focus();
			}
			$scope.$watch(
				function () {
					return (
						element.is( ":visible" )
					);
				},
				function ( newValue, oldValue ) {
					if (
						( newValue === true ) &&
						( newValue !== oldValue )
					) {
						focus();
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					modal.off( "shown.invAutofocus" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! autosize-callout.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutosizeCallout", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element );

			function resize() {
				console.log( $element[ 0 ].scrollHeight );
				$element.height( $element[ 0 ].scrollHeight );
			}
			$element.on(
				"keyup.invAutosize",
				function ( event ) {
					resize();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$element.off( "keypress.invAutosize" );
				}
			);
		};
		return ( {
			link: linkFunction,
			priority: 2,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! autosize.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutosize", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			function getInitialDelta() {
				var content = element.val();
				element.val( "" );
				var height = element.outerHeight();
				var scrollHeight = element[ 0 ].scrollHeight;
				var delta = Math.max( 0, ( scrollHeight - height ) );
				element.val( content );
				return ( delta );
			}

			function resize() {
				var height = element.outerHeight();
				var scrollHeight = element[ 0 ].scrollHeight;
				var scrollableHeight = ( scrollHeight - height - initialDelta );
				if ( scrollableHeight <= 0 ) {
					return;
				}
				var newHeight = scrollHeight;
				element.height( newHeight );
				$scope.$emit( "autosizeResized", element, newHeight, height );
			}
			element.addClass( "autosize" );
			var initialDelta = getInitialDelta();
			element.on(
				"keyup.invAutosize",
				function ( event ) {
					if ( element.val() === "" ) {
						element.height( initialDelta );
						return;
					};
					resize();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "keypress.invAutosize" );
				}
			);
		};
		return ( {
			link: linkFunction,
			priority: 2,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! autosubmit.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invAutosubmit", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			attributes.$observe(
				"invAutosubmit",
				function ( newValue ) {
					$scope.$on( "autosubmit-" + newValue, function ( event, target ) {
						if ( target ) {
							$( newValue ).attr( "target", target );
						}
						$( newValue ).submit();
					} );
				}
			);
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! background-image-dropdown.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invBackgroundImageDropdown", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var target = $( element );
			var picker;
			var isLoaded = false;
			var $dropdownLinks;
			var $ddTarget;
			var $ddMenu;
			var $tooltipTemplate = $( '<div id="autostretch-fyi"><div class="bodytext">Auto Stretch Backgrounds will only display when viewing on modern web browsers.</div></div>' ),
				$tooltipPreview;
			$scope.$watch(
				"config.backgroundImage",
				function ( newValue, oldValue ) {
					if ( isLoaded && ( newValue === oldValue ) ) {
						return;
					}
					isLoaded = true;
					$( element ).selectpicker( "refresh" );
					picker = target
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							width: 183,
							title: "Select a background"
						} );
					$dropdownLinks = $( '#config div.image ul.dropdown-menu li[rel=1] a' );
					$ddTarget = $( '#config div.image div.bootstrap-select' );
					$ddMenu = $( '#config div.image div.bootstrap-select ul.dropdown-menu' );
					$dropdownLinks.mouseenter( function ( event ) {
						$tooltipPreview = $tooltipTemplate.clone();
						var $tooltipLoader = $( 'div', $tooltipPreview );
						$tooltipPreview
							.appendTo( $ddTarget )
							.position( {
								my: "center bottom",
								at: "center top",
								of: $ddTarget,
								collision: "none none"
							} )
							.show();
					} ).mouseleave( function () {
						$( '#autostretch-fyi' ).remove();
					} ).click( function () {
						$( '#autostretch-fyi' ).remove();
					} );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					if ( $dropdownLinks ) {
						$dropdownLinks.off( "mouseenter" )
							.off( "click" )
							.off( "mouseleave" );
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! blur.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invBlur", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var expression = attributes.invBlur;
			element.on(
				"blur.invBlur",
				function ( event ) {
					$scope.$apply( expression );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "blur.invBlur" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! build-hotspot.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invBuildHotspot", Directive );
	/** @ngInject */
	function Directive( $, _, $location, $window, templateService, Deferred, $timeout, $anchorScroll, hotspotService ) {
		return {
			restrict: "A",
			link: function ( $scope, element, attrs ) {
				var isDrawing = false;

				function drawStart( event ) {
					closeOtherHotspotForms();
					$scope.hotspot.x = $scope.mouseX;
					$scope.hotspot.y = $scope.mouseY;
					$scope.hotspot.width = 0;
					$scope.hotspot.height = 0;
					overlay.css( {
						top: $scope.hotspot.y + "px",
						left: $scope.hotspot.x + "px",
						width: $scope.hotspot.width + "px",
						height: $scope.hotspot.height + "px"
					} );
					$scope.$emit( "hideCursorTooltip" );
					isDrawing = true;
				}

				function draw( event ) {
					var top = $scope.hotspot.y;
					var left = $scope.hotspot.x;
					if ( $scope.mouseX < left ) {
						overlay.css( {
							left: $scope.mouseX + "px",
							width: Math.abs( left - $scope.mouseX ) + "px"
						} );
					}
					if ( $scope.mouseX > left ) {
						overlay.css( {
							left: left + "px",
							width: Math.abs( left - $scope.mouseX ) + "px"
						} );
					}
					if ( $scope.mouseY < top ) {
						overlay.css( {
							top: $scope.mouseY + "px",
							height: Math.abs( top - $scope.mouseY ) + "px"
						} );
					}
					if ( $scope.mouseY > top ) {
						overlay.css( {
							top: top + "px",
							height: Math.abs( top - $scope.mouseY ) + "px"
						} );
					}
				}

				function drawStop( event ) {
					var width = overlay.width();
					var height = overlay.height();
					if ( width >= 10 && height >= 10 ) {
						saveHotspotPosition();
						showHotspotForm();
					} else {
						$scope.deleteHotspot( $scope.hotspot );
					}
					image
						.off( "hotspot:draw:start" )
						.off( "hotspot:draw" )
						.off( "hotspot:draw:stop" );
					$scope.$emit( "showCursorTooltip" );
					isDrawing = false;
				}

				function resizeStart( event, ui ) {
					closeOtherHotspotForms();
					hideHotspotForm();
				}

				function resize( event, ui ) {
					if ( $scope.mouseX < ui.position.left ) {
						overlay.css( {
							left: $scope.mouseX + "px",
							width: Math.abs( ui.originalPosition.left - $scope.mouseX ) + "px"
						} );
					}
					if ( $scope.mouseY < ui.position.top ) {
						overlay.css( {
							top: $scope.mouseY + "px",
							height: Math.abs( ui.originalPosition.top - $scope.mouseY ) + "px"
						} );
					}
				}

				function resizeStop( event, ui ) {
					saveHotspotPosition();
					if ( !$scope.hotspot.isSaved ) {
						showHotspotForm();
					} else {
						$scope.saveHotspot( $scope.hotspot, $scope.screen );
					}
				}

				function dragStart( event, ui ) {
					closeOtherHotspotForms();
				}

				function drag( event, ui ) {
					var width = overlay.width();
					var height = overlay.height();
					moveHotspotForm(
						ui.position.left,
						ui.position.top,
						width,
						height
					);
				}

				function dragStop( event, ui ) {
					saveHotspotPosition();
					if ( !$scope.hotspot.isSaved ) {
						showHotspotForm();
					} else {
						$scope.saveHotspot( $scope.hotspot, $scope.screen );
					}
				}

				function toggleHotspotForm() {
					if ( $scope.hotspot.isHotspotFormVisible ) {
						hideHotspotForm();
					} else {
						showHotspotForm();
					}
				}

				function showHotspotForm() {
					$scope.isHotspotMenuOpen = true;
					closeOtherHotspotForms();
					var width = overlay.width();
					var height = overlay.height();
					moveHotspotForm(
						$scope.hotspot.x * $scope.screen.displayScale,
						$scope.hotspot.y * $scope.screen.displayScale,
						width,
						height
					);
					$scope.hotspot.isHotspotFormVisible = true;
					var $window = $( window );
					var _hotspot = {
						height: $( ".hotspotSetupContainer" ).outerHeight(),
						top: undefined,
						bottom: undefined
					};
					_hotspot.top = $scope.hotspot.y;
					_hotspot.bottom = _hotspot.top + _hotspot.height;
					var viewport = {
						top: $window.scrollTop() + 48,
						bottom: ( $window.scrollTop() + $window.innerHeight() ) - 65,
						height: $window.height(),
						width: $window.width()
					};
					if ( _hotspot.bottom < viewport.top || _hotspot.bottom > viewport.bottom ) {
						$( "body, html" ).animate( {
							scrollTop: ( _hotspot.bottom - viewport.height ) + 140
						}, 500 );
					}
				}

				function hideHotspotForm() {
					$scope.hotspot.isHotspotFormVisible = false;
					$scope.$parent.$broadcast( "closeThumbnailTray" );
					$scope.isHotspotMenuOpen = false;
					showCursorTooltip();
				}

				function getFirstAppliedTemplate() {
					return _.find( $scope.templates,
						function ( template ) {
							return $scope.isTemplateActiveForScreen( template.id, $scope.screenID );
						}
					);
				}

				function saveHotspotPosition() {
					$scope.hotspot.x = parseInt( overlay.css( "left" ), 10 ) / $scope.screen.displayScale;
					$scope.hotspot.y = parseInt( overlay.css( "top" ), 10 ) / $scope.screen.displayScale;
					$scope.hotspot.width = overlay.width() / $scope.screen.displayScale;
					$scope.hotspot.height = overlay.height() / $scope.screen.displayScale;
				}

				function moveHotspotForm( x, y, width, height ) {
					var leftPadding = 30;
					var hotspotTop = y;
					var hotspotLeft = x;
					var hotspotWidth = width;
					var hotspotHeight = height;
					var imageRight = image.width();
					var imageOffsetLeft = image.offset().left;
					var formWidth = 352;
					var maxRight = $( $window ).width();
					if ( imageRight > maxRight ) {
						maxRight = imageRight;
					}
					var newFormTop = hotspotTop + Math.round( hotspotHeight / 2 ) - 25;
					var newFormLeft = hotspotLeft + hotspotWidth + leftPadding;
					if ( newFormLeft + formWidth + imageOffsetLeft >= maxRight ) {
						newFormLeft = hotspotLeft - formWidth - leftPadding;
						if ( newFormLeft + imageOffsetLeft > 5 ) {
							$scope.hotspotFormClass = "right";
						} else {
							newFormLeft = maxRight - formWidth - imageOffsetLeft - 5;
							$scope.hotspotFormClass = "left";
						}
					} else {
						$scope.hotspotFormClass = "left";
					}
					formContainer.css( {
						"top": newFormTop + "px",
						"left": newFormLeft + "px"
					} );
				}

				function closeOtherHotspotForms() {
					_.each( $scope.hotspots, function ( hotspot ) {
						if ( $scope.hotspot !== hotspot ) {
							hotspot.isHotspotFormVisible = false;
						}
					} );
				}

				function getSelectedTargetOption() {
					if (
						( $scope.hotspot.targetTypeID === hotspotService.targetTypes.screen ) &&
						$scope.hotspot.targetScreenID
					) {
						var screenOptions = _.withProperty( $scope.targetOptions, "targetTypeID", hotspotService.targetTypes.screen );
						var screenObj = _.findWithProperty( screenOptions, "targetScreenID", $scope.hotspot.targetScreenID );
						return (
							screenObj
						);
					} else if (
						$scope.hotspot.targetTypeID &&
						( $scope.hotspot.targetTypeID !== hotspotService.targetTypes.screen )
					) {
						return (
							_.findWithProperty( $scope.targetOptions, "targetTypeID", $scope.hotspot.targetTypeID )
						);
					}
				}

				function getTargetOptions() {
					var mainGroupTitle = "";
					var options = [ {
						group: mainGroupTitle,
						targetTypeID: 6,
						targetScreenID: $scope.screenID,
						defaultMetaData: {
							scrollOffset: $scope.screenAnchorPosition,
							isSmoothScroll: false
						},
						label: "Another point on this screen"
					}, {
						group: mainGroupTitle,
						targetTypeID: 2,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Last Screen Visited"
					}, {
						group: mainGroupTitle,
						targetTypeID: 3,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Previous Screen in Series"
					}, {
						group: mainGroupTitle,
						targetTypeID: 4,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Next Screen in Series"
					}, {
						group: mainGroupTitle,
						targetTypeID: 5,
						targetScreenID: 0,
						defaultMetaData: {
							url: "http://",
							isOpenInNewWindow: true
						},
						label: "External URL"
					} ];
					if ( _.findWithProperty( $scope.displayObjects, "type", "divider" ) ) {
						var groupName = "Top Screens";
					} else {
						var groupName = "Screens";
					}
					for ( var i = 0; i < $scope.displayObjects.length; i++ ) {
						var displayObject = $scope.displayObjects[ i ];
						if ( displayObject.type === "divider" ) {
							groupName = escapeHtml( displayObject.label );
							continue;
						}
						if ( displayObject.type === "screenObj" ) {
							options.push( {
								group: groupName,
								targetTypeID: 1,
								targetScreenID: displayObject.id,
								targetScreenVersion: displayObject.imageVersion,
								targetScreenThumbnailUrl: displayObject.thumbnailUrl,
								label: $scope.getOptionLabel( displayObject )
							} );
						}
					}
					return ( options );
				}

				function escapeHtml( str ) {
					var safeContent = String( str )
						.replace( /&/g, "&amp;" )
						.replace( /"/g, "&quot;" )
						.replace( /'/g, "&apos;" )
						.replace( /</g, "&lt;" )
						.replace( />/g, "&gt;" );
					return ( safeContent );
				}

				function sortScreens( screens ) {
					screens.sort(
						function ( a, b ) {
							var nameA = a.name.toLowerCase();
							var nameB = b.name.toLowerCase();
							return ( nameA < nameB ? -1 : 1 );
						}
					);
					return ( screens );
				}

				function showCursorTooltip() {
					if ( isDrawing || $scope.isHotspotMenuOpen ) {
						return;
					}
					$scope.$emit( "showCursorTooltip" );
				}
				$scope.browseScreens = function () {
					$scope.showScreenMenu( true, $scope.hotspot.id );
				};
				$scope.getOptionLabel = function ( screen ) {
					if ( screen.id == $scope.screenID ) {
						return ( screen.name + " (this screen)" );
					} else {
						return ( screen.name );
					}
				};
				$scope.onHotspotClick = function ( event ) {
					if ( isClick ) {
						if ( event.shiftKey ) {
							$shiftTooltip.removeClass( "show" );
							if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.lastScreenVisited ) {
								$scope.navigateToPreviousScreen( "build" );
							} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.previousScreenInSort ) {
								$scope.navigateToPreviousScreenInSort();
							} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.nextScreenInSort ) {
								$scope.navigateToNextScreenInSort();
							} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.externalUrl ) {
								$scope.navigateToExternalUrl( $scope.hotspot.metaData.url, $scope.hotspot.metaData.isOpenInNewWindow );
							} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.positionOnScreen ) {
								if ( $scope.hotspot.metaData.isSmoothScroll ) {
									var animateTime = 500;
								} else {
									var animateTime = 0;
								}
								$( "body, html" ).animate( {
										scrollTop: $scope.hotspot.metaData.scrollOffset
									},
									animateTime
								);
							} else {
								$scope.navigateToScreen( $scope.hotspot.targetScreenID, "build" );
							}
							if ( !$scope.hotspot.isScrollTo ) {
								$anchorScroll();
							}
						} else {
							toggleHotspotForm();
						}
					} else {
						isClick = true;
					}
				};
				$scope.onSaveClick = function ( event ) {
					$scope.errorMessage = null;
					if ( !$scope.hotspot.targetTypeID ) {
						$scope.errorMessage = "Please select a Link target.";
						return;
					}
					if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.externalUrl ) {
						if ( !$scope.hotspot.metaData.url ||
							!( /^https?:\/\/.+/i ).test( $scope.hotspot.metaData.url )
						) {
							$scope.errorMessage = "Please enter a valid URL.";
							return;
						}
					} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.positionOnScreen ) {
						if ( $scope.hotspot.metaData.scrollOffset === 0 ) {
							$scope.errorMessage = "Please set an Anchor position";
							return;
						}
						$scope.hotspot.isScrollTo = true;
					} else if ( $scope.hotspot.targetTypeID === hotspotService.targetTypes.screen ) {
						if ( !$scope.hotspot.targetScreenID ) {
							$scope.errorMessage = "Please select a target screen.";
							return;
						}
					}
					if ( $scope.isNewTemplateFormVisible && !$scope.newTemplate.name ) {
						$scope.isNewTemplateFormVisible = false;
					}
					if ( $scope.project.isMobile && $scope.hotspot.transitionTypeID != 1 && $scope.hotspot.transitionTypeID != 8 ) {
						$scope.hotspot.isScrollTo = false;
					}
					if ( $scope.isNewTemplateFormVisible ) {
						var createTemplatePromise = $scope.createTemplate();
						createTemplatePromise.then( function handleCreateTemplatePromise() {
							$scope.hotspot.screenID = 0;
						} );
					} else {
						var createTemplatePromise = $.Deferred( function immediateResolve() {
							this.resolve();
						} );
					}
					createTemplatePromise.then( function handleCreateTemplatePromise() {
						formWasClosedByExplicitAction = true;
						hideHotspotForm();
						if ( $scope.hotspot.templateID !== hotspotBackup.templateID ) {
							if ( $scope.hotspot.templateID ) {
								$scope.addTemplateToScreen( $scope.hotspot.templateID, $scope.screenID, true );
							}
						}
						$scope.setScreenAnchorPosition( 0 );
						hotspotBackup = ng.copy( $scope.hotspot );
						var promise = $scope.saveHotspot( $scope.hotspot, $scope.screen );
						promise.then(
							function () {
								$scope.hotspot.isSaved = true;
							}
						);
						return ( promise );
					} );
					return ( createTemplatePromise );
				};
				$scope.onCancelClick = function ( event ) {
					formWasClosedByExplicitAction = true;
					hideHotspotForm();
					$scope.hideThumbnailTray();
					$scope.errorMessage = null;
					$scope.hotspot.eventTypeID = hotspotBackup.eventTypeID;
					$scope.hotspot.targetTypeID = hotspotBackup.targetTypeID;
					$scope.hotspot.transitionTypeID = hotspotBackup.transitionTypeID;
					$scope.hotspot.targetScreenID = hotspotBackup.targetScreenID;
					$scope.hotspot.metaData = hotspotBackup.metaData;
					$scope.hotspot.templateID = hotspotBackup.templateID;
					$scope.hotspot.isScrollTo = hotspotBackup.isScrollTo;
					$scope.hotspot.includeHotspotInTemplate = hotspotBackup.includeHotspotInTemplate;
					$scope.hotspot.isBottomAligned = hotspotBackup.isBottomAligned;
					if ( !$scope.hotspot.isSaved ) {
						$scope.hotspot.isHotspotVisible = false;
						$scope.deleteHotspot( $scope.hotspot );
					}
					$scope.setScreenAnchorPosition( 0 );
				};
				$scope.onDeleteClick = function ( event ) {
					formWasClosedByExplicitAction = true;
					hideHotspotForm();
					$scope.deleteHotspot( $scope.hotspot );
					$scope.hotspot.isHotspotVisible = false;
				};
				$scope.onEscapePress = function () {
					$scope.onCancelClick();
				};
				$scope.showNewTemplateForm = function () {
					$scope.newTemplate = {
						projectID: $scope.projectID,
						name: ""
					};
					$scope.isNewTemplateFormVisible = true;
				};
				$scope.createTemplate = function () {
					var template = ng.copy( $scope.newTemplate );
					var promise = $scope.saveTemplate( template, function () {
						$scope.templates.push( template );
						$scope.addTemplateToScreen( template.id, $scope.screenID, false );
						$scope.isNewTemplateFormVisible = false;
						$scope.hotspot.templateID = template.id;
					} );
					return promise;
				};
				$scope.$on(
					"hotspot.browse.screen.selected",
					function ( event, screenID, hotspotID ) {
						if (
							$scope.hotspot.isHotspotFormVisible &&
							( $scope.hotspot.id === hotspotID )
						) {
							$scope.hotspot.targetTypeID = hotspotService.targetTypes.screen;
							$scope.hotspot.targetScreenID = screenID;
							$scope.form.selectedTargetOption = getSelectedTargetOption();
						}
					} );
				$scope.$watch(
					"hotspot.screenID",
					function ( newValue, oldValue ) {
						if ( newValue ) {
							$scope.hotspot.templateID = 0;
						}
					} );
				$scope.$watch(
					"screenAnchorPosition",
					function ( newValue, oldValue ) {
						if ( !$scope.hotspot.isHotspotFormVisible ) {
							return;
						}
						if ( $scope.hotspotIDForScreenAnchorSetter == $scope.hotspot.id ) {
							$scope.hotspot.metaData.scrollOffset = $scope.screenAnchorPosition;
						}
					}
				);
				$scope.$watch( "hotspot.includeHotspotInTemplate", function ( newValue, oldValue ) {
					if ( !newValue && oldValue ) {
						$scope.hotspot.templateID = 0;
					} else if ( newValue ) {
						if ( _.isUndefined( $scope.hotspot.templateID ) || $scope.hotspot.templateID === 0 ) {
							var firstAppliedTemplate = getFirstAppliedTemplate();
							if ( !_.isUndefined( firstAppliedTemplate ) ) {
								$scope.hotspot.templateID = firstAppliedTemplate.id;
								$scope.hotspot.screenID = 0;
							}
						}
					}
				} );
				$scope.$watch( "hotspot.templateID", function ( newValue, oldValue ) {
					if ( newValue && !oldValue ) {
						$scope.hotspot.screenID = 0;
					} else if ( !newValue ) {
						$scope.hotspot.screenID = $scope.screenID;
					}
				} );
				$scope.$watch( "hotspot.isHotspotFormVisible", function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( newValue ) {
						$scope.form.selectedTargetOption = getSelectedTargetOption();
						formWasClosedByExplicitAction = false;
					} else if ( !isMoving && !isResizing && !formWasClosedByExplicitAction ) {
						var promise = $scope.onSaveClick();
						if ( $scope.errorMessage ) {
							$scope.onCancelClick();
						} else if ( promise ) {
							promise.then(
								null,
								function () {
									$scope.onCancelClick();
								}
							);
						}
					}
				} );
				$scope.$watch(
					"screens.length",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						$scope.targetOptions = getTargetOptions();
						$scope.form.selectedTargetOption = getSelectedTargetOption();
					}
				);
				$scope.$watch(
					"form.selectedTargetOption",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						if ( $scope.hotspot.eventTypeID == 8 &&
							(
								newValue.targetTypeID == 5 ||
								newValue.targetTypeID == 6
							)
						) {
							$scope.hotspot.eventTypeID = 1;
						}
						if ( $scope.hotspot.targetTypeID !== newValue.targetTypeID && $scope.hotspot.eventTypeID != 8 ) {
							$scope.hotspot.metaData = ng.copy( newValue.defaultMetaData );
						}
						$scope.hotspot.targetTypeID = newValue.targetTypeID;
						$scope.hotspot.targetScreenID = newValue.targetScreenID;
					}
				);
				var image = element.parents( ".screen" ).find( ".screenImage" );
				var overlay = element.find( ".hotspotOverlay" );
				var formContainer = element.find( ".hotspotSetupContainer" );
				var form = element.find( ".hotspotSetup" );
				var isClick = true;
				var isMoving = false;
				var isResizing = false;
				var hotspotBackup;
				var formWasClosedByExplicitAction = false;
				$scope.hotspotFormClass = "topLeft";
				$scope.hotspot.includeHotspotInTemplate = false;
				$scope.hotspot.isSaved = false;
				$scope.hotspot.isHotspotFormVisible = false;
				$scope.hotspot.isHotspotVisible = true;
				if ( $scope.hotspot.id ) {
					$scope.hotspot.isSaved = true;
				}
				$scope.hotspot.includeHotspotInTemplate = !!$scope.hotspot.templateID;
				$scope.targetOptions = getTargetOptions();
				$scope.form = {
					selectedTargetOption: getSelectedTargetOption()
				};
				$scope.errorMessage = null;
				element.on(
					"mouseup",
					"div.hotspotSetupContainer",
					function ( event ) {
						event.stopPropagation();
					}
				);
				var $shiftTooltip = element.parent().parent().find( ".tooltip" );
				overlay.on( "mouseenter", function showShiftTooltip() {
					if ( isDrawing ) {
						return;
					}
					$shiftTooltip.addClass( "show" );
				} );
				overlay.on( "mouseleave", function showShiftTooltip() {
					$shiftTooltip.removeClass( "show" );
				} );
				if ( !$scope.hotspot.eventTypeID ) {
					$scope.hotspot.eventTypeID = 1;
				}
				if ( !$scope.hotspot.transitionTypeID ) {
					$scope.hotspot.transitionTypeID = 1;
				}
				hotspotBackup = ng.copy( $scope.hotspot );
				overlay.css( {
					top: $scope.hotspot.y + "px",
					left: $scope.hotspot.x + "px",
					width: $scope.hotspot.width + "px",
					height: $scope.hotspot.height + "px"
				} );
				overlay.resizable( {
					handles: "ne, se, sw, nw",
					minWidth: 0,
					midHeight: 0,
					start: function ( event, ui ) {
						$scope.$apply( function () {
							isResizing = true;
							resizeStart( event, ui );
						} );
					},
					resize: function ( event, ui ) {
						isClick = false;
						resize( event, ui );
					},
					stop: function ( event, ui ) {
						$scope.$apply( function () {
							isResizing = false;
							resizeStop( event, ui );
						} );
					}
				} ).draggable( {
					start: function ( event, ui ) {
						$scope.$apply( function () {
							isMoving = true;
							dragStart( event, ui );
						} );
					},
					drag: function ( event, ui ) {
						isClick = false;
						drag( event, ui );
					},
					stop: function ( event, ui ) {
						$scope.$apply( function () {
							isMoving = false;
							dragStop( event, ui );
						} );
					}
				} );
				if ( !$scope.hotspot.isSaved ) {
					image
						.on( "hotspot:draw:start", function ( event ) {
							$scope.$apply( function () {
								isClick = false;
								drawStart( event );
							} );
						} )
						.on( "hotspot:draw", function ( event ) {
							draw( event );
						} )
						.on( "hotspot:draw:stop", function ( event ) {
							$scope.$apply( function () {
								drawStop( event );
							} );
						} );
				}
			}
		};
	}
} )( angular, InVision );;;
/*! build-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invBuildScreen", Directive );
	/** @ngInject */
	function Directive( $, _, $timeout, modelEvents, screenService ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				var image = element.find( ".screenImage" );
				var tooltip = element.find( ".tooltip" );
				$scope.mouseX = 0;
				$scope.mouseY = 0;
				$scope.isHotspotMenuOpen = false;

				function getMouseY( event ) {
					var mouseCurrentY = event.pageY;
					var imageY = image.offset().top;
					return mouseCurrentY - imageY;
				}

				function getMouseX( event ) {
					var mouseCurrentX = event.pageX;
					var imageX = image.offset().left;
					return mouseCurrentX - imageX;
				}
				$scope.onMousedown = function ( event ) {
					$scope.closeTimerMenu();
					if ( $( event.target ).is( image ) ) {
						$( '.dropdown.open .dropdown-toggle' ).dropdown( 'toggle' );
						$scope.hotspots.push( {
							id: 0,
							x: 0,
							y: 0,
							width: 0,
							height: 0,
							screenID: $scope.screenID,
							targetTypeID: 0, // Let this be explicitly chosen by the user.
							targetScreenID: 0,
							isScrollTo: false,
							isBottomAligned: false,
							isHotspotFormVisible: false,
							isHotspotVisible: false,
							metaData: {}
						} );
						$timeout( function () {
							image.trigger( "hotspot:draw:start" );
						} );
						event.preventDefault();
						return false;
					}
				};
				$scope.onMousemove = function ( event ) {
					$timeout( function () {
						image.trigger( "hotspot:draw" );
					} );
					$scope.mouseX = getMouseX( event );
					$scope.mouseY = getMouseY( event );
				};
				$scope.onMouseup = function ( event ) {
					$timeout( function () {
						image.trigger( "hotspot:draw:stop" );
					} );
				};
				$scope.getTooltipPosition = function () {
					return {
						"top": $scope.mouseY + 20 + "px",
						"left": $scope.mouseX - 10 + "px"
					};
				};

				function scrollScreenToAlignment( screenID, isConfigChange ) {
					var screen = _.findWithProperty( $scope.screens, "id", screenID );
					var screenAlignment = screen.alignment;
					var screenWidth = screen.width * screen.displayScale;
					var screenHeight = screen.height * screen.displayScale;
					var windowHeight = jqWindow.height();
					var windowWidth = jqWindow.width();
					var targetScrollLeft = 0
					if (
						( screenWidth <= windowWidth ) &&
						( screenHeight <= windowHeight )
					) {
						return;
					}
					if ( isConfigChange ) {
						screen = $.extend( {}, screen, $scope.config );
					}
					if ( screen.alignment === "left" ) {
						targetScrollLeft = 0;
					} else if ( screen.alignment === "right" ) {
						targetScrollLeft = ( screenWidth - windowWidth );
					} else {
						targetScrollLeft = ( ( screenWidth - windowWidth ) / 2 );
					}
					if ( screen.zoomScrollBehavior == screenService.zoomScrollBehaviors.DISABLE_HORIZONTAL_SCROLLING ) {
						if ( screenWidth > windowWidth ) {
							$( element ).css( {
								"margin-left": targetScrollLeft * -1
							} );
						} else {
							$( element ).css( {
								"margin-left": ""
							} );
						}
					} else { // All other conditions
						$( element ).css( {
							"margin-left": ""
						} );
						jqWindow.scrollLeft( targetScrollLeft );
						$timeout(
							function () {
								jqWindow.scrollLeft( targetScrollLeft );
								if ( jqWindow.scrollLeft() != targetScrollLeft ) {
									$timeout( function () {
										jqWindow.scrollLeft( targetScrollLeft );
									}, 100 );
								}
							},
							50
						);
					}
				}
				var jqWindow = $( window );
				$scope.$watch(
					"screenID",
					function ( newValue, oldValue ) {
						scrollScreenToAlignment( newValue );
					}
				);
				modelEvents.on(
					"screenConfig:changed",
					function ( event, newConfig ) {
						scrollScreenToAlignment( $scope.screen.id, true );
					} );
			}
		};
	}
} )( angular, InVision );;;
/*! callout-link.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCalloutLink", Directive );
	/** @ngInject */
	function Directive( userPreferenceService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element );

			function applyRemoteData( newUserPreferenceType, newUserPreferenceValue ) {
				if ( newUserPreferenceValue !== "1" ) {
					$element.addClass( attributes.calloutLinkClass );
					$element.on( "click", function () {
						userPreferenceService.setUserPreferenceById( newUserPreferenceType.id, 1 );
						$element.removeClass( attributes.calloutLinkClass );
					} );
				}
			}

			function loadRemoteData() {
				userPreferenceService.getPreferenceTypeByName( attributes.calloutLinkName, true, "string" ).then(
					function ( typeResponse ) {
						if ( typeResponse.exists !== "true" ) {
							return;
						}
						userPreferenceService.getUserPreferenceById( typeResponse.data.id ).then(
							function ( valueResponse ) {
								applyRemoteData(
									typeResponse.data, ( ( valueResponse.exists === "true" ) ? valueResponse.data.value : null )
								);
								typeResponse = null;
								valueResponse = null;
							}
						);
					}
				);
			}
			loadRemoteData();
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! callout.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCallout", Directive );
	/* Static */
	/********************************************************/
	var zeeIndex = 1020,
		calloutHTML = [ '<div class="invCallout">',
			'<i class="callout-close"></i>',
			'<span class="callout-message"></span>',
			'<span class="callout-carrot"></span>',
			'</div>'
		].join( '' );
	var controller = ( function () {
		var queue = [];
		var calloutNamesSeenArray = [];
		var $calloutsInDom = "";
		var calloutsInDomArray = [];
		var calloutsToBeShown = "";
		var hasCalloutAlreadyBeenSeen = false;
		var now = new Date();
		var accountCreated = null;
		return ( {
			addCallout: function ( calloutObject ) {
				queue.push( calloutObject );
			},
			showNextCallout: function () {
				if ( queue.length && !this.isNewUser() ) {
					queue[ 0 ].fadeIn();
				}
			},
			hideCallout: function () {
				if ( queue.length ) {
					queue[ 0 ].fadeOut();
				}
			},
			showCallout: function () {
				if ( queue.length && !this.isNewUser() ) {
					queue[ 0 ].fadeIn();
				}
			},
			startupCallouts: function () {
				$calloutsInDom = $( '[callout-name]' );
				calloutsInDomArray = [];
				for ( var d = 0; d < $calloutsInDom.length; d++ ) {
					calloutsInDomArray.push( $( '[callout-name]:eq(' + d + ')' ).attr( 'callout-name' ) );
				}
				calloutsToBeShown = _.difference( calloutsInDomArray, calloutNamesSeenArray );
				if ( queue.length == calloutsToBeShown.length ) {
					this.showNextCallout();
				}
			},
			removeCallout: function ( calloutObject ) {
				queue = _.without( queue, calloutObject );
			},
			removeFirstQueueItem: function () {
				queue.shift();
			},
			addCalloutSeen: function ( calloutName ) {
				hasCalloutAlreadyBeenSeen = _.contains( calloutNamesSeenArray, calloutName );
				if ( !hasCalloutAlreadyBeenSeen ) {
					calloutNamesSeenArray.push( calloutName );
				}
			},
			isActiveCallout: function ( calloutObject ) {
				if ( queue.length && queue[ 0 ].get( 0 ).id == calloutObject.get( 0 ).id ) {
					return true;
				} else {
					return false;
				}
			},
			setAccountCreated: function ( createdDate ) {
				accountCreated = createdDate;
			},
			getAccountCreated: function () {
				return accountCreated;
			},
			isNewUser: function () {
				var hoursAfterSignup = ( now - accountCreated );
				hoursAfterSignup = ( ( hoursAfterSignup / 1000 ) / 60 ) / 60;
				if ( hoursAfterSignup < 24 ) {
					return true;
				} else {
					return false;
				}
			}
		} );
	} )();
	var activeCallout = {};
	/** @ngInject */
	function Directive( $document, config, userPreferenceService, modelEvents, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $el = element,
				el_pos = $el.css( 'position' ),
				el_w,
				el_h,
				$calloutEl = $( calloutHTML ),
				callout_w,
				callout_h,
				carrot = 20,
				userPreferenceType,
				calloutPosition,
				calloutText = "",
				offsetTop = 0,
				offsetLeft = 0,
				calloutTitle = "",
				calloutName = 0,
				calloutShow = true,
				calloutZindex = 0,
				zIndex = 0,
				getPosition = {
					top: function () {
						var x = ( el_w / 2 ) - ( callout_w / 2 ) + offsetLeft;
						var y = -( callout_h ) + offsetTop - carrot;
						return {
							'top': y,
							'left': x
						};
					},
					bottom: function () {
						var x = ( el_w / 2 ) - ( callout_w / 2 ) + offsetLeft;
						var y = el_h + offsetTop + carrot;
						return {
							'top': y,
							'left': x
						};
					},
					left: function () {
						var x = -( callout_w + carrot ) + offsetLeft;
						var y = ( el_h / 2 ) - ( callout_h / 2 ) + offsetTop;
						return {
							'top': y,
							'left': x
						};
					},
					right: function () {
						var x = el_w + carrot + offsetLeft;
						var y = ( el_h / 2 ) - ( callout_h / 2 ) + offsetTop;
						return {
							'top': y,
							'left': x
						};
					}
				},
				$calloutObject = null;
			calloutPosition = ( attributes.calloutPosition || "top" ); // top, bottom, left, right
			calloutText = ( attributes.calloutText || "New!" ); // what to put in the callout
			offsetTop = ( parseInt( attributes.calloutOffsetTop ) || 0 ); // offset ability from top
			offsetLeft = ( parseInt( attributes.calloutOffsetLeft ) || 0 ); // offset ability from left
			calloutTitle = ( attributes.calloutTitle || "New" ); // highlighted title
			calloutName = ( attributes.calloutName || 0 ); // unique name for callout
			calloutZindex = ( attributes.calloutZIndex || 0 ); // z-index of the element getting the callout
			if ( $scope.user != undefined && !isNaN( $scope.user.accountCreatedAt ) ) {
				controller.setAccountCreated( $scope.user.accountCreatedAt );
			}
			if ( calloutName === 0 ) {
				alert( 'Please be sure to add a unique "calloutName" for the user preference table.' );
				return;
			}
			var pattern = new RegExp( "[^A-Za-z0-9]" );
			if ( pattern.test( calloutName ) ) {
				alert( 'Please be sure that your callout name is using only apha numeric naming convention' );
			}
			attributes.$observe( "calloutShow", function ( newValue ) {
				newValue = ( newValue || "true" );
				if ( newValue != "true" ) {
					calloutShow = false;
					$calloutEl.hide();
				} else {
					if ( controller.isActiveCallout( $calloutEl ) ) {
						$calloutEl.show();
						calloutShow = true;
						positionCallout();
					}
				}
			} );
			/* Private Functions */
			/********************************************************/
			function applyRemoteData( newUserPreferenceType, newUserPreferenceValue ) {
				userPreferenceType = newUserPreferenceType;
				if ( newUserPreferenceValue === "1" ) {
					return ( controller.addCalloutSeen( calloutName ) );
				}
				buildCallout();
				$calloutObject = $( '#callout-' + calloutName );
				var prefTypeCreatedFiveDaysAgo = ( newUserPreferenceType.createdAt + ( 5 * 24 * 60 * 60 * 1000 ) );
				var userAccountCreatedAt = controller.getAccountCreated();
				if ( userAccountCreatedAt != null && prefTypeCreatedFiveDaysAgo > userAccountCreatedAt ) {
					controller.addCallout( $calloutObject );
				}
				controller.startupCallouts();
			}

			function buildCallout() {
				if ( calloutTitle.length ) {
					calloutText = "<span>" + calloutTitle + "</span><br />" + calloutText;
				}
				if ( el_pos != 'absolute' && el_pos != 'fixed' ) {
					$el.css( {
						'position': 'relative',
						'z-index': zIndex
					} );
				}
				zeeIndex++;
				zIndex = calloutZindex === 0 ? zeeIndex : calloutZindex;
				$el.css( {
					'z-index': zIndex
				} );
				$calloutEl
					.appendTo( $el )
					.addClass( "callout-" + calloutPosition )
					.hide()
					.attr( 'id', "callout-" + calloutName )
					.find( '.callout-message' )
					.html( calloutText );
				positionCallout();
				$( 'i', $calloutEl ).on( 'click', function ( e ) {
					e.stopPropagation();
					userPreferenceService.setUserPreferenceById( userPreferenceType.id, 1 );
					$calloutEl.fadeOut( 100, destroyCallout );
					controller.addCalloutSeen( calloutName );
					controller.removeFirstQueueItem();
					controller.showNextCallout();
				} );
				$calloutEl.on( 'click', function ( e ) {
					e.stopPropagation();
				} );
			}

			function destroyCallout() {
				$document.off( 'mouseenter.' + calloutName );
				$document.off( 'mouseleave.' + calloutName );
				$calloutEl.remove();
				controller.removeCallout( $calloutObject );
			}

			function loadRemoteData( name ) {
				userPreferenceService.getPreferenceTypeByName( name, true, "string", 0 ).then(
					function ( typeResponse ) {
						if ( typeResponse.exists !== "true" ) {
							return;
						}
						userPreferenceService.getUserPreferenceById( typeResponse.data.id ).then(
							function ( valueResponse ) {
								applyRemoteData(
									typeResponse.data, ( ( valueResponse.exists === "true" ) ? valueResponse.data.value : null )
								);
								name = null;
								typeResponse = null;
								valueResponse = null;
							}
						);
					}
				);
			}

			function positionCallout() {
				el_w = $el.outerWidth();
				el_h = $el.outerHeight();
				callout_w = $calloutEl.outerWidth();
				callout_h = $calloutEl.outerHeight();
				$calloutEl
					.css( getPosition[ calloutPosition ]() )
					.animate( {
						'opacity': 1
					}, 300 );
			}
			/* Event Listeners */
			/********************************************************/
			$document.on(
				'mouseenter.' + calloutName,
				'.toggleCallouts',
				function () {
					if ( calloutShow ) {
						controller.hideCallout();
					}
				}
			)
				.on(
					'mouseleave.' + calloutName,
					'.toggleCallouts',
					function () {
						if ( calloutShow ) {
							controller.showCallout();
						}
					}
			);
			/* Scope Settings */
			/********************************************************/
			$scope.$on( "$destroy", destroyCallout );
			/* Init */
			/********************************************************/
			loadRemoteData( calloutName );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! can-use-fullescreen-api.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCanUseFullscreenApi", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			function init() {
				var targetEl = dom.target.get( 0 );
				$scope.canUseFullScreenApi = ( targetEl.requestFullScreen || targetEl.webkitRequestFullScreen || targetEl.mozRequestFullScreen ) !== undefined;
			}
			var dom = {};
			dom.target = $( element );
			var isInitialized = false;
			init();
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! capture-submit.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCaptureSubmit", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var isEnterKeyEvent = function ( event ) {
				return ( event.which === 13 );
			};
			var target = $( element );
			var submitExpression = attributes.invCaptureSubmit;
			target.on(
				"keypress.invCaptureSubmit",
				function ( event ) {
					if ( isEnterKeyEvent( event ) ) {
						event.preventDefault();
						$scope.$apply( submitExpression );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "keypress.invCaptureSubmit" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! check-color.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCheckColor", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function hexdec( hex_string ) {
				hex_string = ( hex_string + '' ).replace( /[^a-f0-9]/gi, '' );
				return parseInt( hex_string, 16 );
			}
			$timeout( function () {
				if ( attributes.hex ) {
					var hex = attributes.hex,
						$element = $( element ),
						r, g, b;
					hex = hex.replace( '#', '' );
					r = hexdec( hex.substr( 0, 2 ) );
					g = hexdec( hex.substr( 2, 2 ) );
					b = hexdec( hex.substr( 4, 2 ) );
					var diff = ( ( r * 299 ) + ( g * 587 ) + ( b * 114 ) ) / 1000;
					if ( diff > 130 ) {
						$element.addClass( "light-bg" );
					} else {
						$element.addClass( "dark-bg" );
					}
				}
			} );
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! checkbox.js */
;;
( function ( ng, app ) {
	"use strict";
	/**
	 * The @invCheckbox directive is for placing custom checkbox markers tied to model attributes
	 *
	 * You can include the necessary CSS by calling the custom mixin defined in in the inv-mixins.less
	 *
	 * .new-checkbox(@color);
	 *
	 * This will allow you to color the background of the checkbox. Keep in mind that the default checkbox
	 * is white, so you may need custom override classes if you choose a light color. Text labels are
	 * displayed by default, and show to the left of the checkbox. You may change this behavior through
	 * override class adjustments to the label container.
	 *
	 * div.m-checkbox {base checkbox directive container}
	 *     // State changes cascade down to affected elements in the DOM
	 *     &.on {checked state starts here}
	 *     &.off {unchecked state starts here}
	 *     &.disabled {disabled state starts here}
	 *
	 *     //DOM element hierarchy
	 *     > div.checkbox-field {checkbox container}
	 *         > div.check-box {actual check 'box'}
	 *             > i {check icon}
	 *     > div.checkbox-label {label container}
	 *
	 * The directive takes, at minimum, two attributes, with two additional optional attributes
	 *
	 * @param selected {Boolean} - Two-way-binding to a model var, determining selected state
	 * @param label {String} - Text defining the label of the checkbox
	 * @param disabled {*Boolean} - Optional attribute defaulted to false, this may be a straight
	 * 								Boolean value, or bound to a model var to determine state
	 * 								Bound vars may toggle selection, depending on...
	 * @param deselectOnDisable {*Boolean} - Optional attribute defaulted to false, this Boolean
	 * 								determines whether you deselect the checkbox if it becomes disabled
	 */
	app.directive( "invCheckbox", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			if ( $scope.disabled === null ) {
				$scope.disabled = false;
			}
			if ( $scope.deselectOnDisable === null ) {
				$scope.deselectOnDisable = false;
			}
			$scope.selected = !!$scope.selected;

			function toggle() {
				if ( !$scope.disabled ) {
					$scope.selected = !$scope.selected;
				}
			}
			element.on(
				"click.invCheckbox",
				function ( event ) {
					event.preventDefault();
					$scope.$apply( toggle );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "click.invCheckbox" );
				}
			);
			$scope.$watch(
				"disabled",
				function ( newValue, oldValue ) {
					if ( newValue && $scope.selected && $scope.deselectOnDisable ) {
						$scope.selected = false;
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: {
				selected: "=", // two way bound to a true|false model var, this is the value of the checkbox
				label: "@", // Straight test, this is the label of the checkbox
				disabled: "=", // two way bound to a true|false model var. Optional, defaults to false. If var becomes 'true', it will make "selected" false if...
				deselectOnDisable: "=" // Optional - defaults to false, this will deselect the option if it is disabled
			},
			restrict: "A",
			templateUrl: "/assets/apps/d/views/directives/checkbox.htm"
		} );
	}
} )( angular, InVision );;;
/*! clip.js */
;;
angular.module( 'InVision' )
	.run( function () {
		ZeroClipboard.config( {
			debug: false,
			forceHandCursor: true,
			moviePath: "/assets/zeroclipboard/ZeroClipboard.swf"
		} );
	} )
/**
 * Copy to clipboard
 * Usage: <span inv-clip="fnCallback" data-clipboard-text="my text to be copied"></span>
 */
.directive( 'invClip', function ( $timeout ) {
	return {
		restrict: 'A',
		scope: {
			text: '@invClip',
			onClick: '&ngClick'
		},
		link: function link( $scope, element, attrs ) {
			var client = new ZeroClipboard( element );
			client.on( "noflash", handleNoFlash );
			client.on( "complete", handleCopied );
			client.on( "datarequested", handleDataRequested );

			function handleDataRequested() {
				client.setText( $scope.text );
			}

			function handleNoFlash() {
				alert( 'You do not have flash installed' );
			}

			function handleCopied( client, args ) {
				$timeout( function () {
					client.reposition();
				} );
				if ( angular.isDefined( $scope.onClick ) ) {
					$scope.$apply( $scope.onClick );
				}
			}
			$scope.$on( '$destroy', function () {
				client.destroy();
			} );
		}
	}
} );;;
/*! comment-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invCommentScreen", Directive );
	/** @ngInject */
	function Directive( $, _, $timeout, $location ) {
		return {
			restrict: "A",
			link: function ( $scope, element, attrs ) {
				function getMouseY( event ) {
					var mouseCurrentY = event.pageY;
					var imageY = image.offset().top;
					return mouseCurrentY - imageY;
				}

				function getMouseX( event ) {
					var mouseCurrentX = event.pageX;
					var imageX = image.offset().left;
					return mouseCurrentX - imageX;
				}
				var image = element.find( ".screenImage" );
				image.on(
					"mousedown.invCommentScreen",
					function ( event ) {
						if ( image.is( event.target ) && $scope.isConversationActive() && !$scope.areConversationsDirty() ) {
							$scope.closeAllConversationPanels();
							$scope.$apply();
						}
					}
				);
				image.on(
					"mouseup.invCommentScreen",
					function ( event ) {
						if ( !image.is( event.target ) || $scope.isConversationActive() ) {
							return;
						}
						$location.path( "/console/" + $scope.projectID + "/" + $scope.screenID + "/comments" );
						var x = getMouseX( event ) / $scope.screen.displayScale;
						var y = getMouseY( event ) / $scope.screen.displayScale;
						var isForDevelopment = ( $scope.filters.type.value === "dev-notes" );
						$scope.startNewConversation( ( x - ( 23 / $scope.screen.displayScale ) ), ( y - ( 23 / $scope.screen.displayScale ) ), isForDevelopment );
						$scope.$apply();
					}
				);
				$scope.$on(
					"$destroy",
					function () {
						image.off( "mousedown.invCommentScreen" );
						image.off( "mouseup.invCommentScreen" );
					}
				);
			}
		};
	}
} )( angular, InVision );;;
/*! confirm-popover.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConfirmPopover", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var handleCancelClick = function ( event ) {
				event.preventDefault();
				target.popover( "destroy" );
				doc.off( "mousedown.invConfirmPopover" );
				doc.off( "click.invConfirmPopover" );
			};
			var handleConfirmClick = function ( event ) {
				event.preventDefault();
				target.popover( "destroy" );
				doc.off( "mousedown.invConfirmPopover" );
				doc.off( "click.invConfirmPopover" );
				$scope.$apply( confirmExpression );
			};
			var handleDocumentMousedown = function ( event ) {
				if ( $( event.target ).closest( "div.popover" ).length ) {
					return;
				}
				target.popover( "destroy" );
				doc.off( "mousedown.invConfirmPopover" );
				doc.off( "click.invConfirmPopover" );
			};
			var doc = $( document );
			var win = $( window );
			var target = $( element );
			var confirmExpression = attributes.onConfirm;
			target.on(
				"click.invConfirmPopover",
				function ( event ) {
					event.preventDefault();
					target.popover( {
						html: true,
						placement: function () {
							var placement = ( target.attr( "placement" ) || "top" ),
								elemPos = target.offset().top - win.scrollTop();
							if ( elemPos < 105 ) {
								placement = "bottom";
							}
							return placement;
						},
						trigger: "manual",
						title: function () {
							return ( attributes.invConfirmPopover );
						},
						content: "<a href='#' class='btn btn-primary btn-small invConfirmPopoverConfirm'>&nbsp;Yes&nbsp;</a> &nbsp; <a href='#' class='btn btn-small invConfirmPopoverCancel'>&nbsp;No&nbsp;</a> "
					} );
					target.tooltip( "hide" );
					target.popover( "show" );
					doc.on( "mousedown.invConfirmPopover", handleDocumentMousedown );
					doc.on( "click.invConfirmPopover", "a.invConfirmPopoverConfirm", handleConfirmClick );
					doc.on( "click.invConfirmPopover", "a.invConfirmPopoverCancel", handleCancelClick );
					return ( false );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "click.invConfirmPopover" );
					target.popover( "destroy" );
					doc.off( "mousedown.invConfirmPopover" );
					doc.off( "click.invConfirmPopover" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! console-build-auto-redirect-hotspot.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleBuildAutoRedirectHotspot", Directive );
	/** @ngInject */
	function Directive( $, _, $timeout, hotspotService, Deferred ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				$scope.saveAutoRedirectHotspot = function ( autoRedirectHotspot ) {
					$scope.errorMessage = "";
					if ( $scope.selectedTargetOption == undefined ) {
						$scope.errorMessage = "Please select a destination.";
						return;
					}
					if ( autoRedirectHotspot.metaData.redirectAfter == "" || isNaN( autoRedirectHotspot.metaData.redirectAfter ) || autoRedirectHotspot.metaData.redirectAfter < 1 ) {
						$scope.errorMessage = "Please enter a valid amount of time in milliseconds.";
						return;
					}
					autoRedirectHotspot.x = -10;
					autoRedirectHotspot.y = -10;
					autoRedirectHotspot.width = 0;
					autoRedirectHotspot.height = 0;
					autoRedirectHotspot.eventTypeID = 9;
					autoRedirectHotspot.targetScreenID = $scope.selectedTargetOption.targetScreenID;
					autoRedirectHotspot.targetTypeID = $scope.selectedTargetOption.targetTypeID;
					if ( !$scope.project.isMobile ) {
						autoRedirectHotspot.transitionTypeID = 1;
					}
					if ( $scope.project.isMobile && !( autoRedirectHotspot.transitionTypeID == 1 || autoRedirectHotspot.transitionTypeID == 8 ) ) {
						autoRedirectHotspot.isScrollTo = false; //Disable this feature
					}
					var promise = Deferred.handlePromise(
						hotspotService.saveHotspot( autoRedirectHotspot, autoRedirectHotspot.screenID ),
						function ( newHotspot ) {
							$scope.reloadHotspots();
						},
						function ( response ) {
							$scope.openModalWindow( "error", "For some reason we couldn't save to the server. Try refreshing your browser." );
						}
					);
					$scope.autoRedirectHotspotsBackup = autoRedirectHotspot;
					$scope.toggleIsEditingAutoRedirectHotspot();
					return ( promise );
				}
				$scope.turnOffAutoRedirectHotspot = function ( autoRedirectHotspot ) {
					var promise = Deferred.handlePromise(
						hotspotService.deleteHotspot( autoRedirectHotspot ),
						function ( response ) {},
						function ( response ) {
							$scope.openModalWindow( "error", "For some reason we couldn't save to the server. Try refreshing your browser." );
						}
					);
					var hotSpotsMinusDeleted = _.reject( $scope.hotspots, function ( h ) {
						return h.id === autoRedirectHotspot.id;
					} );
					$scope.setHotspots( hotSpotsMinusDeleted );
					$scope.autoRedirectHotspot = getDefaultRedirectHotspot();
					$scope.toggleIsEditingAutoRedirectHotspot();
					$scope.errorMessage = "";
					return ( promise );
				}
				$scope.cancelAutoRedirectHotspotChanges = function () {
					$scope.autoRedirectHotspot = ng.copy( $scope.autoRedirectHotspotsBackup );
					$scope.toggleIsEditingAutoRedirectHotspot();
					$scope.errorMessage = "";
				}
				$scope.toggleIsEditingAutoRedirectHotspot = function () {
					$scope.errorMessage = "";
					$scope.isEditingAutoRedirectHotspot = !$scope.isEditingAutoRedirectHotspot;
				}
				$scope.browseScreens = function () {
					$scope.showScreenMenu( true, $scope.autoRedirectHotspot.id );
				};
				$scope.toggleIsScrollTo = function () {
					$scope.autoRedirectHotspot.isScrollTo = !$scope.autoRedirectHotspot.isScrollTo
				}

				function getAutoRedirectHotspot( hotspots ) {
					var autoRedirectHotspot = _.findWithProperty( hotspots, "eventTypeID", 9 );
					if ( autoRedirectHotspot != undefined ) {
						$scope.autoRedirectHotspot = autoRedirectHotspot;
						$scope.autoRedirectHotspot.redirectEnabled = true;
					} else {
						$scope.autoRedirectHotspot = getDefaultRedirectHotspot();
					}
					$scope.autoRedirectHotspotsBackup = ng.copy( $scope.autoRedirectHotspot );
					$scope.targetOptions = getTargetOptions();
					$scope.selectedTargetOption = getSelectedTargetOption();
				}

				function getSelectedTargetOption() {
					if (
						( $scope.autoRedirectHotspot.targetTypeID === hotspotService.targetTypes.screen ) &&
						$scope.autoRedirectHotspot.targetScreenID
					) {
						var screenOptions = _.withProperty( $scope.targetOptions, "targetTypeID", hotspotService.targetTypes.screen );
						var screenObj = _.findWithProperty( screenOptions, "targetScreenID", $scope.autoRedirectHotspot.targetScreenID );
						return (
							screenObj
						);
					} else if (
						$scope.autoRedirectHotspot.targetTypeID &&
						( $scope.autoRedirectHotspot.targetTypeID !== hotspotService.targetTypes.screen )
					) {
						return (
							_.findWithProperty( $scope.targetOptions, "targetTypeID", $scope.autoRedirectHotspot.targetTypeID )
						);
					}
				}

				function getTargetOptions() {
					var mainGroupTitle = "";
					var options = [ {
						group: mainGroupTitle,
						targetTypeID: 2,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Last Screen Visited"
					}, {
						group: mainGroupTitle,
						targetTypeID: 3,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Previous Screen in Series"
					}, {
						group: mainGroupTitle,
						targetTypeID: 4,
						targetScreenID: 0,
						defaultMetaData: {},
						label: "Next Screen in Series"
					} ];
					if ( _.findWithProperty( $scope.displayObjects, "type", "divider" ) ) {
						var groupName = "Top Screens";
					} else {
						var groupName = "Screens";
					}
					for ( var i = 0; i < $scope.displayObjects.length; i++ ) {
						var displayObject = $scope.displayObjects[ i ];
						if ( displayObject.type === "divider" ) {
							groupName = escapeHtml( displayObject.label );
							continue;
						}
						if ( displayObject.type === "screenObj" && displayObject.id != $scope.screenID ) {
							options.push( {
								group: groupName,
								targetTypeID: 1,
								targetScreenID: displayObject.id,
								targetScreenVersion: displayObject.imageVersion,
								targetScreenThumbnailUrl: displayObject.thumbnailUrl,
								label: getOptionLabel( displayObject )
							} );
						}
					}
					return ( options );
				}

				function escapeHtml( str ) {
					var safeContent = String( str )
						.replace( /&/g, "&amp;" )
						.replace( /"/g, "&quot;" )
						.replace( /'/g, "&apos;" )
						.replace( /</g, "&lt;" )
						.replace( />/g, "&gt;" );
					return ( safeContent );
				}

				function getOptionLabel( screen ) {
					if ( screen.id == $scope.screenID ) {
						return ( screen.name + " (this screen)" );
					} else {
						return ( screen.name );
					}
				};

				function getDefaultRedirectHotspot() {
					return ( {
						id: 0,
						x: -10,
						y: -10,
						width: 0,
						height: 0,
						screenID: $scope.screen.id,
						targetTypeID: 0, // Let this be explicitly chosen by the user.
						targetScreenID: 0,
						transitionTypeID: 1,
						eventTypeID: 9, // autoRedirect
						isScrollTo: false,
						isBottomAligned: false,
						isHotspotFormVisible: false,
						isHotspotVisible: false,
						metaData: {
							redirectAfter: 800
						},
						redirectEnabled: false
					} );
				}
				$scope.autoRedirectHotspot = getDefaultRedirectHotspot();
				$scope.autoRedirectHotspotsBackup = $scope.autoRedirectHotspot;
				$scope.isEditingAutoRedirectHotspot = false;
				$scope.targetOptions = getTargetOptions();
				$scope.selectedTargetOption = getSelectedTargetOption();
				$scope.errorMessage = "";
				$scope.$watch(
					"hotspots",
					function hotspotsChangedFunction( newHotspots, oldHotspots ) {
						getAutoRedirectHotspot( newHotspots );
					}
				);
				$scope.$on(
					"hotspot.browse.screen.selected",
					function ( event, screenID, hotspotID ) {
						if (
							( $scope.autoRedirectHotspot.id === hotspotID )
						) {
							$scope.autoRedirectHotspot.targetTypeID = hotspotService.targetTypes.screen;
							$scope.autoRedirectHotspot.targetScreenID = screenID;
							$scope.selectedTargetOption = getSelectedTargetOption();
						}
					} );
				$scope.$on(
					"build.closeTimerMenu",
					function () {
						$scope.isEditingAutoRedirectHotspot = false;
					}
				);
			}
		};
	}
} )( angular, InVision );;;
/*! console-build-footer-slider.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invConsoleBuildFooterSlider",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				if ( parseInt( $scope.screen.fixedFooterHeight ) ) {
					$scope.fixedFooterHeight = parseInt( $scope.screen.fixedFooterHeight );
				} else {
					$scope.fixedFooterHeight = 0;
				}
				var maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedFooterMaximumPercentage );
				$timeout( function () {
					setupSlider( maxValue, false );
				} );

				function setupSlider( maxValue, rebuild ) {
					$( element ).parent().css( {
						height: maxValue + "px"
					} );
					$( element ).css( {
						height: maxValue + "px"
					} );
					$( element ).addClass( "noUiSlider" );
					if ( rebuild == true ) {
						$( element ).noUiSlider( {
							range: [ 0, maxValue ]
						}, true );
					} else {
						$( element ).noUiSlider( {
							range: [ 0, maxValue ],
							start: ( $scope.fixedFooterHeight * $scope.screen.displayScale ),
							handles: 1,
							orientation: "vertical",
							direction: "rtl",
							step: 1,
							slide: function () {
								$scope.screen.fixedFooterHeight = parseInt( $( this ).val() / $scope.screen.displayScale );
								$scope.$apply();
							}
						}, false );
					}
					setupEventListeners();
				}

				function setupEventListeners() {
					$( element ).find( ".noUi-handle" ).off( "mousedown.consoleFooterSlider" ).on( "mousedown.consoleFooterSlider", function () {
						var startingValue = $scope.screen.fixedFooterHeight;
						$scope.setIsEditingFixedFooterHeight( true );
						$( document ).on( "mouseup.consoleFooterSlider", function () {
							if ( startingValue != $scope.screen.fixedFooterHeight ) {
								$scope.saveFixedFooterHeight( $scope.screen );
								$scope.setIsFixedFooterInEditMode( false );
							} else {
								$scope.setIsFixedFooterInEditMode( true );
							}
							$scope.setIsEditingFixedFooterHeight( false );
							$scope.setFixedAreasMaximumPercentage();
							$( document ).off( "mouseup.consoleFooterSlider" );
						} );
					} );
				}
				$scope.$watch(
					"screen.fixedFooterHeight",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							if ( isNaN( $scope.screen.fixedFooterHeight ) ) {
								$scope.screen.fixedFooterHeight = newValue.replace( /\D/g, "" );
							}
							if ( ( $scope.screen.fixedFooterHeight * $scope.screen.displayScale ) > maxValue ) {
								$scope.screen.fixedFooterHeight = parseInt( maxValue / $scope.screen.displayScale );
							}
							if ( $scope.screen.fixedFooterHeight == "" || $scope.screen.fixedFooterHeight < 0 ) {
								$scope.screen.fixedFooterHeight = 0;
							}
							$( element ).val( $scope.screen.fixedFooterHeight * $scope.screen.displayScale );
							if ( !$scope.isEditingfixedFooterHeight ) {
								$scope.setFixedAreasMaximumPercentage();
							}
						}
					} );
				$scope.$watch(
					"isFixedFooterInEditMode",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							if ( newValue == true ) {
								$timeout( function () {
									$( "#fixedFooterInput" ).focus();
								}, 10 );
							}
						}
					} );
				$scope.$watch(
					"fixedFooterMaximumPercentage",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedFooterMaximumPercentage );
							setupSlider( maxValue, true );
						}
					} );
				$scope.$on(
					"$destroy",
					function () {
						$( element ).find( ".noUi-handle" ).off( "mousedown.consoleFooterSlider" );
						$( document ).off( "mouseup.consoleFooterSlider" );
						$( element ).remove();
					}
				);
			}
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! console-build-header-desktop-slider.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invConsoleBuildHeaderDesktopSlider",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var $window = $( window ),
					$element = $( element ),
					isDragging = false,
					topPadding = 51,
					maxValue = 300,
					draggerOffset = 9;
				if ( $scope.project.isMobile ) {
					maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedHeaderMaximumPercentage );
				}
				$timeout( function () {
					setupSlider( maxValue, false );
				}, 10 );

				function setupSlider( maxValue ) {
					var _maxValue = maxValue + 18;
					var initialTop = ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) + topPadding;
					if ( $scope.config.backgroundImage.id === "frame" ) {
						initialTop = initialTop + 35;
					}
					$element.parent().css( {
						height: _maxValue + "px"
					} );
					$element.css( {
						height: _maxValue + "px"
					} );
					$( "#fixed-drag" ).draggable( {
						axis: "y",
						containment: $element.parent(),
						drag: function ( event, ui ) {
							var top = ui.offset.top - topPadding;
							if ( $scope.config.backgroundImage.id === "frame" ) {
								top = top - 35;
							}
							$scope.screen.fixedHeaderHeight = parseInt( top / $scope.screen.displayScale );
							$scope.$apply();
							isDragging = true;
						},
						stop: function () {
							$scope.saveFixedHeaderHeight( $scope.screen );
							$scope.setFixedAreasMaximumPercentage();
							isDragging = false;
						}
					} )
						.css( {
							top: initialTop,
							marginTop: "-" + ( $window.scrollTop() + draggerOffset ) + "px"
						} );
				}

				function positionSlider() {
					if ( isDragging ) {
						return;
					}
					var top = ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) + topPadding;
					top = top - $window.scrollTop();
					$( "#fixed-drag" ).css( {
						top: top
					} );
				}
				$scope.$watch(
					"screen.fixedHeaderHeight",
					function ( newValue ) {
						if ( isNaN( $scope.screen.fixedHeaderHeight ) ) {
							$scope.screen.fixedHeaderHeight = newValue.replace( /\D/g, "" );
						}
						if ( ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) > maxValue ) {
							$scope.screen.fixedHeaderHeight = parseInt( maxValue / $scope.screen.displayScale );
						}
						if ( $scope.screen.fixedHeaderHeight === "" || $scope.screen.fixedHeaderHeight < 0 ) {
							$scope.screen.fixedHeaderHeight = 0;
						}
						$scope.screen.fixedHeaderHeight = parseInt( $scope.screen.fixedHeaderHeight );
						$element.val( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale );
						positionSlider();
					} );
				$scope.$watch(
					"fixedHeaderMaximumPercentage",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							if ( $scope.project.isMobile ) {
								maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedHeaderMaximumPercentage );
							} else {
								maxValue = 300;
							}
							setupSlider( maxValue, true );
						}
					} );
				$window.on( "scroll", function () {
					$( "#fixed-drag" ).css( {
						marginTop: "-" + ( $( this ).scrollTop() + draggerOffset ) + "px"
					} );
				} );
				$scope.$on(
					"$destroy",
					function () {
						$element.remove();
					}
				);
			};
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! console-build-header-slider.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invConsoleBuildHeaderSlider",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				if ( parseInt( $scope.screen.fixedHeaderHeight ) ) {
					$scope.fixedHeaderHeight = parseInt( $scope.screen.fixedHeaderHeight );
				} else {
					$scope.fixedHeaderHeight = 0;
				}
				var maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedHeaderMaximumPercentage );
				setupSlider( maxValue, false );

				function setupSlider( maxValue, rebuild ) {
					$( element ).parent().css( {
						height: maxValue + "px"
					} );
					$( element ).css( {
						height: maxValue + "px"
					} );
					$( element ).addClass( "noUiSlider" );
					if ( rebuild == true ) {
						$( element ).noUiSlider( {
							range: [ 0, maxValue ]
						}, true );
					} else {
						$( element ).noUiSlider( {
							range: [ 0, maxValue ],
							start: ( $scope.fixedHeaderHeight * $scope.screen.displayScale ),
							handles: 1,
							orientation: "vertical",
							slide: function () {
								$scope.screen.fixedHeaderHeight = parseInt( $( this ).val() / $scope.screen.displayScale );
								$scope.$apply();
							}
						}, false );
					}
					setupEventListeners();
				}

				function setupEventListeners() {
					$( element ).find( ".noUi-handle" ).off( "mousedown.consoleHeaderSlider" ).on( "mousedown.consoleHeaderSlider", function () {
						var startingValue = $scope.screen.fixedHeaderHeight;
						$scope.setIsEditingFixedHeaderHeight( true );
						$( document ).on( "mouseup.consoleHeaderSlider", function () {
							if ( startingValue != $scope.screen.fixedHeaderHeight ) {
								$scope.saveFixedHeaderHeight( $scope.screen );
								$scope.setIsFixedHeaderInEditMode( false );
							} else {
								$scope.setIsFixedHeaderInEditMode( true );
							}
							$scope.setIsEditingFixedHeaderHeight( false );
							$scope.setFixedAreasMaximumPercentage();
							$( document ).off( "mouseup.consoleHeaderSlider" );
						} );
					} );
				}
				$scope.$watch(
					"screen.fixedHeaderHeight",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							if ( isNaN( $scope.screen.fixedHeaderHeight ) ) {
								$scope.screen.fixedHeaderHeight = newValue.replace( /\D/g, "" );
							}
							if ( ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) > maxValue ) {
								$scope.screen.fixedHeaderHeight = parseInt( maxValue / $scope.screen.displayScale );
							}
							if ( $scope.screen.fixedHeaderHeight == "" || $scope.screen.fixedHeaderHeight < 0 ) {
								$scope.screen.fixedHeaderHeight = 0;
							}
							$( element ).val( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale );
							if ( !$scope.isEditingFixedHeaderHeight ) {
								$scope.setFixedAreasMaximumPercentage();
							}
						}
					} );
				$scope.$watch(
					"isFixedHeaderInEditMode",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							if ( newValue == true ) {
								$timeout( function () {
									$( "#fixedHeaderInput" ).focus();
								}, 10 );
							}
						}
					} );
				$scope.$watch(
					"fixedHeaderMaximumPercentage",
					function ( newValue, oldValue ) {
						if ( newValue != oldValue ) {
							maxValue = parseInt( $scope.project.mobileTemplate.viewportHeight * $scope.fixedHeaderMaximumPercentage );
							setupSlider( maxValue, true );
						}
					} );
				$scope.$on(
					"$destroy",
					function () {
						$( element ).find( ".noUi-handle" ).off( "mousedown.consoleHeaderSlider" );
						$( document ).off( "mouseup.consoleHeaderSlider" );
						$( element ).remove();
					}
				);
			}
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! console-catchup-toolbar-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleCatchupToolbarHelper", Directive );
	/** @ngInject */
	function Directive( $window, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function updateMarkerCapacity() {
				var markerWidth = 35;
				var calloutWidth = 150;
				var hiddenCalloutWidth = 65;
				var filterWidth = 400;
				var windowWidth = win.width();
				var wiggleRoom = 100;
				var minMarkerCount = 10;
				var availableWidth = ( windowWidth - calloutWidth - hiddenCalloutWidth - filterWidth - wiggleRoom );
				var markerCapacity = Math.floor( availableWidth / markerWidth );
				$scope.updateUnreadConversationCapacity(
					Math.max( markerCapacity, minMarkerCount )
				);
			}
			var win = $( $window ).on(
				"resize.invConsoleCatchupToolbarHelper",
				function ( event ) {
					$scope.$apply(
						function () {
							updateMarkerCapacity();
						}
					);
				}
			);
			element.on(
				"click.invConsoleCatchupToolbarHelper",
				"a.marker",
				function ( event ) {
					if ( $scope.areConversationsDirty() ) {
						event.preventDefault();
						event.stopPropagation();
						alert( "Oops, you haven't saved your comment!" );
					}
				}
			);
			$timeout( updateMarkerCapacity );
			$scope.$on(
				"$destroy",
				function () {
					win.off( "resize.invConsoleCatchupToolbarHelper" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! console-config-menu.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleConfigMenu", Directive );
	/** @ngInject */
	function Directive( $, $window, modelEvents, $timeout ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				$timeout( function () {
					element.find( ".btn" ).click( function () {
						if ( $( this ).parent().is( '.save' ) ) {
							return;
						}
						var group = $( this ).closest( ".btn-group" );
						$( group ).find( ".btn" ).removeClass( "enable" );
						$( this ).addClass( "enable" );
					} );
					element.find( ".swatches > div" ).each( function () {
						var color = $( this ).html();
						$( this ).css( "background-color", color );
					} );
					element.find( ".swatches > div" ).click( function () {
						element.find( "#background-color" ).trigger( "change" );
					} );
					element.find( "#background-color" ).change( function () {
						var newBackgroundColorDefault = $scope.config.backgroundColor;
						var newBackgroundColor = "";
						newBackgroundColor = $( this ).val().replace( /[^a-z0-9]/gi, "" ).substr( 0, 6 );
						if ( newBackgroundColor.length == 3 ) {
							var userGaveUsThisColor = newBackgroundColor;
							newBackgroundColor = userGaveUsThisColor[ 0 ] + userGaveUsThisColor[ 0 ];
							newBackgroundColor += userGaveUsThisColor[ 1 ] + userGaveUsThisColor[ 1 ];
							newBackgroundColor += userGaveUsThisColor[ 2 ] + userGaveUsThisColor[ 2 ];
						} else if ( newBackgroundColor.length < 6 ) {
							newBackgroundColor = $scope.config.backgroundColor;
						}
						$( this ).val( newBackgroundColor );
						$scope.config.backgroundColor = newBackgroundColor;
					} );
				}, 5 );
				$scope.getMobilePlatformLabel = function ( deviceTemplate ) {
					if ( deviceTemplate.platform == "iOS" && deviceTemplate.deviceType == "phone" ) {
						return "iPhone";
					} else if ( deviceTemplate.platform == "iOS" && deviceTemplate.deviceType == "tablet" ) {
						return "iPad";
					} else {
						return "Android";
					}
				}
				$scope.$on(
					"projectBackgroundUploader:uploaded",
					function ( event, background ) {
						var existingIndex = null;
						_.forEach( $scope.backgroundImages,
							function ( value, index ) {
								if ( value.id == background.id ) {
									existingIndex = index;
									return false;
								}
							}
						);
						if ( _.isNull( existingIndex ) ) {
							$scope.backgroundImages.push( background );
						} else {
							$scope.backgroundImages[ existingIndex ] = background;
						}
						$scope.config.backgroundImage = background;
						modelEvents.trigger( "screenConfig:changed", $scope.config );
					}
				);
			}
		};
	}
} )( angular, InVision );;;
/*! console-key-bindings.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleKeyBindings", Directive );
	/** @ngInject */
	function Directive( $window, $, _, $location ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$( $window ).on( "keydown", function ( event ) {
				var key = event.which;
				var target = event.target;
				var keyActionMapping = {
					37: {
						"description": "left-arrow",
						"type": "screen-change",
						"action": "previous"
					},
					39: {
						"description": "right-arrow",
						"type": "screen-change",
						"action": "next"
					},
					38: {
						"description": "up-arrow",
						"type": "version-change",
						"action": "previous"
					},
					40: {
						"description": "down-arrow",
						"type": "version-change",
						"action": "next"
					},
					66: {
						"description": "B",
						"type": "mode-change",
						"action": "build"
					},
					80: {
						"description": "P",
						"type": "mode-change",
						"action": "preview"
					},
					67: {
						"description": "C",
						"type": "mode-change",
						"action": "comments"
					},
					72: {
						"description": "H",
						"type": "mode-change",
						"action": "history"
					},
					27: {
						"description": "close-mode",
						"type": "close",
						"action": "preview"
					},
					84: {
						"description": "T",
						"type": "toggle-tray",
						"action": "preview"
					}
				};
				if ( $scope.isReviewer ) {
					delete keyActionMapping[ "66" ];
				}
				if ( event.metaKey || event.ctrlKey ) {
					return;
				}
				if ( !keyActionMapping[ key ] ) {
					return;
				}
				if (
					( keyActionMapping[ key ].action === "comments" ) &&
					( keyActionMapping[ key ].action === $scope.subview ) &&
					$( "div.comment-thread:visible" ).length
				) {
					return;
				}
				$scope.$apply( function () {
					if ( !( ( $( target ).is( ":input" ) || $( target ).is( "div.type_tool" ) || $scope.isShowingSketchBuilder || $scope.isShowingSketchViewer ) && $( target ).is( ":visible" ) ) ) {
						if ( !_.isUndefined( keyActionMapping[ key ] ) ) {
							if ( keyActionMapping[ key ].type == "toggle-tray" ) {
								$scope.toggleThumbnailTray();
							}
							if ( keyActionMapping[ key ].type == "mode-change" ) {
								if ( keyActionMapping[ key ].action !== $scope.subview ) {
									$scope.navigateToScreen( $scope.screenID, keyActionMapping[ key ].action );
								} else {
									$scope.navigateToScreen( $scope.screenID, "preview" );
								}
							} else if ( keyActionMapping[ key ].type == "screen-change" ) {
								if ( keyActionMapping[ key ].action === "previous" ) {
									$scope.navigateToPreviousScreenInSort();
									$scope.showScreenPosition();
								} else {
									$scope.navigateToNextScreenInSort();
									$scope.showScreenPosition();
								}
							} else if ( keyActionMapping[ key ].type === "version-change" && $scope.subview === "history" ) {
								if ( keyActionMapping[ key ].action === "previous" ) {
									$scope.previousVersion();
								} else {
									$scope.nextVersion();
								}
							} else if ( keyActionMapping[ key ].type === "close" ) {
								if ( $scope.subview === "comments" ) {
									if ( $scope.commentID ) {
										$scope.navigateToScreen( $scope.screenID, "comments" );
									} else {
										$scope.navigateToScreen( $scope.screenID, "preview" );
									}
								} else if ( $scope.subview === "build" ) {
									var hasOpenHotspots = _.findWithProperty( $scope.hotspots, "isHotspotFormVisible", true );
									if ( hasOpenHotspots ) {
										element.find( "div.hotspotSetup:visible" ).scope().onEscapePress();
									} else {
										$scope.navigateToScreen( $scope.screenID, "preview" );
									}
								} else if ( $scope.subview === "history" ) {
									$scope.closeExpandedView();
								}
							}
							event.preventDefault();
							return false;
						}
					}
				} );
			} );
			$scope.$on(
				"$destroy",
				function () {
					$( $window ).off( "keydown" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! console-loader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleLoader", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			if ( $scope.isLoading ) {
				NProgress.start();
			}
			$scope.$watch(
				"isLoading",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( newValue ) {
						NProgress.start();
					} else {
						NProgress.done();
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					NProgress.done();
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! console-preview-auto-redirect-listener.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsolePreviewAutoRedirectListener", Directive );
	/** @ngInject */
	function Directive( $, _, $timeout, hotspotService, Deferred ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				var timer;

				function getAutoRedirectHotspot( hotspots ) {
					var autoRedirectHotspot = _.findWithProperty( hotspots, "eventTypeID", 9 );
					if ( autoRedirectHotspot != undefined ) {
						$timeout.cancel( timer );
						timer = $timeout(
							function () {
								$scope.applyHotspotNavigation( autoRedirectHotspot, "click" );
							},
							autoRedirectHotspot.metaData.redirectAfter
						);
					} else {
						$timeout.cancel( timer );
					}
				}
				$scope.$watch(
					"hotspots",
					function hotspotsChangedFunction( newHotspots, oldHotspots ) {
						if ( $( "#thumbnail_tray" ).hasClass( "open" ) ) {
							return;
						}
						getAutoRedirectHotspot( newHotspots );
					}
				);
				$scope.$on(
					"$destroy",
					function ( event ) {
						$timeout.cancel( timer );
					}
				);
			}
		};
	}
} )( angular, InVision );;;
/*! console-project-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleProjectUploader", Directive );
	var helperNotice = {
		beenChecked: false,
		beenSeen: false,
		prefID: 0
	};
	var retinaNotice = {
		beenChecked: false,
		beenSeen: false,
		prefID: 0,
		hasRetinaSize: false
	};
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents, Deferred, projectService, userPreferenceService ) {
		var maxInBytes = 10485760;
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
				$scope.$emit( "screenUploadStop" );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id === id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handleDragEnter = function ( event ) {
				event.stopPropagation();
				if ( dom.dropzone.parent().is( ".hotDropzone" ) ) {
					return;
				}
				$( ".hotDropzone" ).removeClass( "hotDropzone" );
				dom.dropzone.parent().addClass( "hotDropzone" );
				$scope.isDraggingOverHotspot = true;
				$document.on( "dragenter.invProjectUploader", handleDragEnterOnDocument );
			};
			var handleDragEnterOnDocument = function ( event ) {
				dom.dropzone.parent().removeClass( "hotDropzone" );
				$scope.isDraggingOverHotspot = false;
				$document.off( "dragenter.invProjectUploader" );
			};
			var handlePluploadError = function ( uploader, error ) {
				$( ".hotDropzone" ).removeClass( "hotDropzone" );
				if ( !error.file ) {
					return;
				}
				$timeout(
					function () {
						var file = error.file;
						uploader.removeFile( file );
						removeFileFromQueue( file.id );
						if ( error.code === plupload.FILE_SIZE_ERROR ) {
							$scope.openModalWindow(
								"error", ( "The file, \"" + file.name + ",\" is too large. Are you sure that it's not a mislabeled file?" )
							);
						} else {
							$scope.openModalWindow(
								"error", ( "We could not process the image, \"" + file.name + "\". This often happens when people accidentally give an HTML file a \".jpg\" file extension." )
							);
						}
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				dom.dropzone.parent().removeClass( "hotDropzone" );
				var fileExcludedBasedOnName = null;
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						fileExcludedBasedOnName = files[ i ].name;
						files.splice( i, 1 );
					} else if ( files[ i ].size > maxInBytes && !isPDF( files[ i ].name ) && !isSourceFile( files[ i ].name ) ) { // limit the max file size, unless it's a PDF or a screen source file
						$scope.openModalWindow(
							"error", ( "The file, \"" + files[ i ].name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
						);
						files.splice( i, 1 );
					}
				}
				if ( fileExcludedBasedOnName ) {
					if ( fileExcludedBasedOnName.split( "." ).pop() === "sketch" ) {
						$scope.openModalWindow( "sketchSoon" );
					} else {
						$scope.openModalWindow( "error", "The file, \"" + fileExcludedBasedOnName + ",\" was skipped since it doesn't appear to be an image file." );
					}
				}
				files = _.sortOnPropertyUsingNaturalOrder( files, "name" );
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size
					);
				}
				if ( files.length ) {
					modelEvents.trigger( "createLoadingScreens", files );
					$scope.$emit( "screenUploadStart" );
					modelEvents.trigger( "screenUploadStart" );
					$scope.$emit( "scrollToUploadedScreen", false );
					$scope.$emit( "hideDropZones" );
				}
				$scope.$apply();
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				if ( !retinaNotice.beenSeen && !retinaNotice.hasRetinaSize ) {
					var imgInfo = ng.fromJson( response.response );
					if ( imgInfo.hasOwnProperty( "width" ) && imgInfo.width >= 2000 ) {
						retinaNotice.hasRetinaSize = true;
					}
				}
				$timeout(
					function () {
						var apiResponse = ng.fromJson( response.response );
						modelEvents.trigger( "rebuildAfterUpload", apiResponse );
						modelEvents.trigger( "scrollConsoleThumbTray", apiResponse.uploadedScreen );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				$scope.isHtml5Runtime = ( uploader.runtime === "html5" );
				$scope.isFlashRuntime = ( uploader.runtime === "flash" );
				$timeout( angular.noop );
				if ( $scope.isHtml5Runtime ) {
					dom.dropzone.on( "dragenter", handleDragEnter );
					if ( isIE() ) {
						dom.dropzone.on( "mousemove", ieHackHandleMouseMove );
						dom.container.on( "dragover", "div.plupload", ieHackHandleDragOver );
					}
					$( window ).draghover( {
						namespace: "invConsoleProjectUploaderDrag"
					} ).on( {
						"draghoverstart": function ( e ) {},
						"draghoverend": function ( e, dragEvent ) {
							if ( !!dragEvent.originalEvent ) {
								var pageX = dragEvent.originalEvent.pageX,
									pageY = dragEvent.originalEvent.pageY;
								if ( !$scope.isDraggingOverHotspot || (
									pageX === 0 ||
									pageX <= $( window ).scrollLeft() ||
									pageX >= $( window ).width() + $( window ).scrollLeft() ||
									pageY === 0 ||
									pageY <= $( window ).scrollTop() ||
									pageY >= $( window ).height() + $( window ).scrollTop()
								) ) {
									$timeout( function () {
										$scope.$emit( "hideDropZones" );
										$scope.$emit( "hideReplaceScreen" );
									} );
								}
							} else {
								if ( !$scope.isDraggingOverHotspot ) {
									$timeout( function () {
										$scope.$emit( "hideDropZones" );
										$scope.$emit( "hideReplaceScreen" );
									} );
								}
							}
						}
					} );
				}
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadComplete = function ( uploader, files ) {
				if ( retinaNotice.hasRetinaSize && !retinaNotice.beenSeen ) {
					$scope.openModalWindow( "retinaHelper" );
				}
				retinaNotice.hasRetinaSize = false;
				$scope.isDraggingOverHotspot = false;
				$scope.$emit( "screenUploadStop" );
				$scope.$emit( "hideReplaceScreen" );
				$timeout( function () {
					$scope.$emit( "setShouldScrollToScreen", true );
				}, 2000 );
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						setFileProgress(
							file.id,
							file.loaded,
							file.percent
						);
					}
				);
			};
			var handleWindowScroll = function ( event ) {
				var uploaderOffset = dom.target.offset();
				var uploaderTop = uploaderOffset.top;
				var isAboveFold = ( uploaderTop < dom.window.scrollTop() );
				if ( !$scope.displayImageObjects.length ) {
					$scope.isFixedDropzone = false;
				} else if ( isAboveFold && !dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = true;
				} else if ( !isAboveFold && dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = false;
				}
				$timeout(
					function () {
						$scope.$apply();
						setTimeout( refreshUploader ); // Allow pause for DOM to update before shim is refreshed.
					}
				);
			};
			var ieHackHandleDragOver = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
					if ( dom.dynamicPluploadWidget.css( "zIndex" ) === 99999 ) {
						dom.target.addClass( "highZIndex" );
					}
				}
				dom.dynamicPluploadWidget.hide();
			};
			var ieHackHandleMouseMove = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
					if ( dom.dynamicPluploadWidget.css( "zIndex" ) === 99999 ) {
						dom.target.addClass( "highZIndex" );
					}
				}
				if ( !dom.dynamicPluploadWidget.is( ":visible" ) &&
					!ieHackHandleMouseMove.timer
				) {
					ieHackHandleMouseMove.timer = setTimeout(
						function () {
							dom.dynamicPluploadWidget.show();
							ieHackHandleMouseMove.timer = null;
						},
						150
					);
				}
			};
			var isIE = function () {
				return ( /\bmsie\b/i.test( $window.navigator.userAgent ) );
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isPDF = function ( name ) {
				var pattern = /\.(pdf)$/i;
				return (
					pattern.test( name )
				);
			};
			var isSourceFile = function ( name ) {
				var pattern = /\.(psd|ai)$/i;
				return (
					pattern.test( name )
				);
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(gif|jpe?g|png|pdf|psd|ai)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
				setupDropZones();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				if ( !listItem.length ) {
					return ( deleteFileFromQueue( id ) );
				}
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var setFileProgress = function ( id, loaded, percent ) {
				var queueItem = getQueueItemByID( id );
				if ( !queueItem ) {
					return;
				}
				queueItem.percentage = percent;
				modelEvents.trigger( "updateLoadingScreenProgress", queueItem );
				if ( queueItem.state === $scope.fileStates.PENDING ) {
					queueItem.state = $scope.fileStates.UPLOADING;
				}
			};
			var checkHelperNotification = function () {
				if ( !helperNotice.beenChecked ) {
					checkUserPreference( 'uploadHelperNotification', helperNotice, $scope.showUploadHelper );
				} else {
					$scope.showUploadHelper = !helperNotice.beenSeen;
				}
			};
			var checkRetinaModalNotification = function () {
				if ( !retinaNotice.beenChecked ) {
					retinaNotice.beenSeen = checkUserPreference( 'showRetinaHelperModal', retinaNotice, $scope.showRetinaModal );
				} else {
					$scope.showRetinaModal = !helperNotice.beenSeen;
				}
			};
			var checkUserPreference = function ( prefName, prefStruct, scopeFlag ) {
				prefStruct.beenChecked = true;
				userPreferenceService.getPreferenceTypeByName( prefName, true, "boolean" ).then(
					function ( typeResponse ) {
						prefStruct.prefID = typeResponse.data.id;
						userPreferenceService.getUserPreferenceById( typeResponse.data.id ).then(
							function ( valueResponse ) {
								if ( valueResponse.exists === "true" && valueResponse.data.value === "1" ) {
									prefStruct.beenSeen = true;
								} else {
									prefStruct.beenSeen = false;
								}
								scopeFlag = !prefStruct.beenSeen;
								typeResponse = null;
								valueResponse = null;
							}
						);
					}
				);
			};
			var handleInlineDropZoneDragEnter = function ( event ) {
				event.stopPropagation();
				$scope.isDraggingOverHotspot = true;
				if ( $( this ).is( ".hotDropzone" ) ) {
					return;
				}
				$( ".hotDropzone" ).removeClass( "hotDropzone" );
				$( this ).addClass( "hotDropzone" );
				$document.on( "dragenter.inlinedropzone", handleInlineDragEnterOnDocument );
			};
			var handleInlineDragEnterOnDocument = function ( event ) {
				$( ".hotDropzone" ).removeClass( "hotDropzone" );
				$scope.isDraggingOverHotspot = false;
				$document.off( "dragenter.inlinedropzone" );
			};
			var setupDropZones = function () {
				$( ".inlineDropZone" ).each( function () {
					var thisInlineDropZone = $( this );
					if ( thisInlineDropZone.is( ".dropzone" ) ) {
						return;
					}
					thisInlineDropZone.addClass( "dropzone" );
					var dropzone = new mOxie.FileDrop( {
						drop_zone: this
					} );
					thisInlineDropZone.on( "dragenter", handleInlineDropZoneDragEnter );
					dropzone.ondrop = function ( event ) {
						var dividerID = parseInt( thisInlineDropZone.attr( "data-divider-id" ) || 0 );
						var position = parseInt( thisInlineDropZone.attr( "data-position" ) || 9999 );
						$scope.$emit( "setShouldScrollToScreen", false );
						for ( var i = 0, len = dropzone.files.length; i < len; i++ ) {
							dropzone.files[ i ].suggestedSort = position + i;
							dropzone.files[ i ].dividerID = dividerID;
						}
						$( ".hotDropzone" ).removeClass( "hotDropzone" );
						uploader.addFile( dropzone.files );
					};
					dropzone.init();
				} );
			};
			var dom = {};
			dom.target = element;
			dom.container = dom.target.find( "div.positioned-container" );
			dom.dropzone = dom.target.find( "div.dropzone" );
			dom.files = dom.target.find( "ol.queue" );
			dom.html5Instructions = dom.target.find( ".html5Instructions" );
			dom.window = $( $window );
			dom.dynamicPluploadWidget = null;
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID,
					"returnAllScreens": true // This will alter our response such that we get all the screens and the newly uploaded screen.
				},
				drop_element: "consoleProjectUploaderDropzone",
				container: "consoleProjectUploaderDropzone",
				browse_button: "consoleProjectUploaderButton",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png,pdf,psd,ai"
				} ]
			} );
			$scope.isHtml5Runtime = false;
			$scope.isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.bind( "BeforeUpload", function ( uploader, file ) {
				if ( file.getSource().suggestedSort >= 0 ) {
					uploader.settings.multipart_params.suggestedSort = file.getSource().suggestedSort;
					uploader.settings.multipart_params.dividerID = file.getSource().dividerID;
				} else {
					uploader.settings.multipart_params.suggestedSort = -1;
					uploader.settings.multipart_params.dividerID = 0;
				}
			} );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOAIND: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.isFixedDropzone = false;
			$scope.showUploadHelper = false;
			$scope.showRetinaModal = false;
			$scope.isDraggingOverHotspot = false;
			$scope.isShowingUploader = true;
			var isLocalDragEvent = false;
			$document.on(
				"mousedown.invConsoleProjectUploader",
				function ( event ) {
					isLocalDragEvent = true;
				}
			);
			$document.on(
				[
					"mouseup.invConsoleProjectUploader",
					"dragend.invConsoleProjectUploader"
				].join( " " ),
				function ( event ) {
					isLocalDragEvent = false;
				}
			);
			$( $window ).on(
				"dragenter.invConsoleProjectUploader",
				function ( event ) {
					if ( isLocalDragEvent ) {
						return;
					}
					if ( !$scope.isFilteringScreens ) {
						$scope.$emit( "showDropZones" );
					}
				}
			);
			$scope.$watch(
				"!! displayImageObjects.length",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				}
			);
			$scope.$watch(
				"displayObjects",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				}
			);
			$scope.$watch(
				"isFixedDropzone",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				}
			);
			$scope.$watch(
				"projectID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				}
			);
			$scope.$on(
				"showProjectUploader",
				function () {
					$scope.isShowingUploader = true;
				}
			);
			$scope.closeUploaderHelper = function () {
				$scope.showUploadHelper = false;
				helperNotice.beenSeen = true;
				userPreferenceService.setUserPreferenceById( helperNotice.prefID, 1 );
			};
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					uploader.unbindAll();
					uploader.destroy();
					$( window )
						.off( "error.projectUploader" )
						.off( "dragenter.invConsoleProjectUploader" );
					$( window )
						.draghover()
						.off( "draghoverstart" )
						.off( "draghoverend" );
					$document
						.off( "mousedown.invConsoleProjectUploader" )
						.off( "mouseup.invConsoleProjectUploader" )
						.off( "dragend.invConsoleProjectUploader" );
					$document.off( "dragenter.invConsoleProjectUploader" );
					dom.window.off( "error.projectUploader" );
					dom.window.off( "scroll.projectUploader" );
					dom.target.remove();
				}
			);
			modelEvents.on( "showRetinaModalHelperUpdated", function ( event, pref ) {
				retinaNotice.beenSeen = pref;
			} );
			checkHelperNotification();
			checkRetinaModalNotification();
		};
		return ( {
			link: linkFunction,
			scope: true
		} );
	}
} )( angular, InVision );;;
/*! console-replace-screen-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleReplaceScreenUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, $rootScope, sessionService, userService, modelEvents, config ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
			};
			var deleteFileFromQueue = function ( id ) {
				$scope.$apply( function () {
					for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
						if ( uploadQueue[ i ].id === id ) {
							uploadQueue.splice( i, 1 );
							return;
						}
					}
				} );
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handleMouseOut = function ( event ) {
				if ( isMouseEventRelevant( event, dom.dropzone ) ) {
					dom.dropzone.removeClass( "hotDropzone" );
				}
			};
			var handleMouseOver = function ( event ) {
				if ( isMouseEventRelevant( event, dom.dropzone ) ) {
					dom.dropzone.addClass( "hotDropzone" );
				}
			};
			var handlePluploadComplete = function ( uploader, files ) {
				$scope.$apply( function () {
					$scope.isShowingUploader = false;
				} );
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				if ( error.status === 422 ) {
					var parentScreens = $scope.$parent.screens;
					var currentScreenId = $scope.screenID;
					var matchingScreens = _.rejectWithProperty(
						_.findWithProperty( parentScreens, "clientFilename", error.file.name ),
						"id", currentScreenId
					);
					if ( matchingScreens.length > 0 ) {
						$scope.$parent.openModalWindow( "error", "There is another screen with that same name in this project." );
					} else {
						$scope.$parent.openModalWindow( "error", "There was an error uploading your file." );
					}
				}
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				$scope.$apply( function () {
					for ( var i = 0; i < files.length; i++ ) {
						addFileToQueue(
							files[ i ].id,
							files[ i ].name,
							files[ i ].size
						);
					}
				} );
				if ( files.length ) {
					$scope.$emit( "hideDropZones" );
				}
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.$apply( function () {
					uploader.removeFile( file );
					removeFileFromQueue( file.id );
					var apiResponse = ng.fromJson( response.response );
					modelEvents.trigger( "rebuildAfterUpload", apiResponse );
				} );
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
				$scope.runtime = uploader.runtime;
				if ( isHtml5Runtime ) {
					dom.dropzone.on( "mouseover dragenter", handleMouseOver );
					dom.dropzone.on( "mouseout dragleave", handleMouseOut );
				} else {
					dom.target.find( "div.plupload.flash" ).on( "mouseover", handleMouseOver );
					dom.target.find( "div.plupload.flash" ).on( "mouseout", handleMouseOut );
				}
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply( function () {
						uploader.start();
					} );
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						setFileProgress(
							file.id,
							file.uploaded,
							file.percent
						);
					}
				);
			};
			var isMouseEventRelevant = function ( event, element ) {
				var relatedTarget = event.relatedTarget;
				var target = element;
				if ( !relatedTarget ) {
					return ( true );
				}
				if ( target.is( relatedTarget ) ) {
					return ( false );
				}
				if ( !$.contains( target[ 0 ], relatedTarget ) ) {
					return ( true );
				}
				return ( false );
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(bmp|gif|jpe?g|pict|png|tiff|pdf)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var setFileProgress = function ( id, loaded, percent ) {
				var queueItem = getQueueItemByID( id );
				queueItem.percentage = percent;
				if ( queueItem.state === $scope.fileStates.PENDING ) {
					queueItem.state = $scope.fileStates.UPLOADING;
				}
			};
			var dom = {};
			dom.target = element;
			dom.dropzone = dom.target.find( "div.dropzone" );
			dom.queue = dom.target.find( "div.queue" );
			dom.files = dom.queue.find( "ol.files" );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID,
					"screenID": $scope.screenID,
					"returnAllScreens": true // This will alter our response such that we get all the screens and the newly uploaded screen.
				},
				drop_element: "console_dropzone",
				browse_button: "console_dropzone",
				container: "console_replace_screen_uploader",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,pict,png,tiff,pdf"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "PostInit", function () {
				var $inputs = $( '#consoleDragDropArea' ).find( 'input' );
				$inputs.on( 'click', function ( e ) {
					e.stopPropagation();
				} );
			} );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadComplete );
			uploader.bind( "BeforeUpload", function ( uploader, file ) {
				if ( file.getSource().suggestedSort >= 0 ) {
					uploader.settings.multipart_params.suggestedSort = file.getSource().suggestedSort;
					uploader.settings.multipart_params.dividerID = file.getSource().dividerID;
				} else {
					uploader.settings.multipart_params.suggestedSort = -1;
					uploader.settings.multipart_params.dividerID = 0;
				}
			} );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOAIND: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.isShowingUploader = false;
			$scope.runtime = "html5";
			var isLocalDragEvent = false;
			var isReviewer = config.companySettings.isEnterprise &&
				sessionService.user.companyMembership.roleID === userService.ROLES.REVIEWER;
			if ( !isReviewer ) {
				$document.on(
					"mousedown.invConsoleReplaceScreenUploader",
					function ( event ) {
						isLocalDragEvent = true;
					}
				);
				$document.on(
					[
						"mouseup.invConsoleReplaceScreenUploader",
						"dragend.invConsoleReplaceScreenUploader"
					].join( " " ),
					function ( event ) {
						isLocalDragEvent = false;
					}
				);
				$( $window ).on(
					"dragenter.invConsoleReplaceScreenUploader",
					function ( event ) {
						if ( isLocalDragEvent ) {
							return;
						}
						$scope.$apply( function () {
							$scope.isShowingUploader = true;
						} );
					}
				);
			}
			$scope.$watch(
				"screenID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = $scope.projectID;
					uploader.settings.multipart_params.screenID = $scope.screenID;
				}
			);
			$scope.$watch(
				"isShowingUploader",
				function ( newValue, oldValue ) {
					$scope.$parent.setIsScreenReplaceUploaderActive( newValue );
					if ( newValue === true ) {
						$rootScope.$broadcast( "openThumbnailTray" );
						$timeout( function () {
							dom.target
								.stop( true, true )
								.fadeIn( "fast", refreshUploader );
							$( window ).on(
								"error.projectUploader",
								function ( event ) {
									if ( isFlashRuntime ) {
										return ( false );
									}
								}
							);
						}, 200 );
					} else if ( newValue === false ) {
						dom.target
							.stop( true, true )
							.fadeOut( "fast" );
						clearUploader();
						$( window ).off( "error.projectUploader" );
					}
				}
			);
			$scope.$on(
				"toggleScreenReplaceUploader",
				function ( $event, config ) {
					if ( !_.isUndefined( config ) ) {
						$scope.isShowingUploader = config.showUploader;
					} else {
						$scope.isShowingUploader = !$scope.isShowingUploader;
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					$( window )
						.off( "error.projectUploader" )
						.off( "dragenter.invConsoleReplaceScreenUploader" );
					$document
						.off( "mousedown.invConsoleReplaceScreenUploader" )
						.off( "mouseup.invConsoleReplaceScreenUploader" )
						.off( "dragend.invConsoleReplaceScreenUploader" );
					dom.target.remove();
				}
			);
		};
		return ( {
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/console-replace-screen-uploader.htm",
			scope: {
				projectID: "=projectId",
				screenID: "=screenId",
				xsrfToken: "=xsrfToken"
			},
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! console-screen-anchor-setter.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleScreenAnchorSetter", Directive );
	/** @ngInject */
	function Directive( $, $window, modelEvents ) {
		return {
			restrict: 'A',
			transclude: true,
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/console-screen-anchor-setter.htm",
			link: function ( $scope, element, attrs ) {
				var overlay = $( element ).find( ".modalOverlay" );
				var anchorSetterModal = $( element ).find( "#anchorSetterModal" );
				var marginTop = 0;
				var marginLeft = 0;
				var cursorAnchor = $( element ).find( "#cursorAnchor" );
				var anchorDottedLine = $( element ).find( "#anchorDottedLine" );
				var anchorCurrentPosition = 0;
				var resizeModal = function () {
					overlay.css( "height", $( window ).height() );
					overlay.css( "width", $( window ).width() );
					var screenImage = $( element ).find( "img" );
					var screenHeight = $scope.screen.height;
					var screenWidth = $scope.screen.width;
					var modalMaxHeight = $( window ).height() * .75;
					var modalMaxWidth = $( window ).width() * .85;
					if ( screenHeight < modalMaxHeight ) {
						modalMaxHeight = screenHeight;
					}
					if ( screenWidth < modalMaxWidth ) {
						modalMaxWidth = screenWidth;
					}
					anchorSetterModal.css( "height", modalMaxHeight + "px" );
					anchorSetterModal.css( "width", modalMaxWidth + "px" );
					marginTop = ( $( window ).height() - modalMaxHeight ) / 2;
					marginLeft = ( $( window ).width() - modalMaxWidth ) / 2;
					anchorSetterModal.css( "margin-top", marginTop );
					anchorSetterModal.css( "margin-left", marginLeft );
				}
				var positionAnchor = function ( e ) {
					var anchorIconSize = 40;
					var windowScrollOffsetY = $( window ).scrollTop();
					var modalScrollOffsetY = anchorSetterModal.scrollTop();
					var offsetY = e.pageY * 1 - marginTop + modalScrollOffsetY - windowScrollOffsetY;
					var offsetX = e.pageX * 1 - ( anchorIconSize / 2 ) - marginLeft;
					cursorAnchor.css( {
						top: offsetY - ( anchorIconSize / 2 ) + "px",
						left: offsetX + "px"
					} );
					anchorDottedLine.css( {
						top: offsetY + "px"
					} );
					anchorCurrentPosition = offsetY;
				}
				resizeModal();
				$( window ).on( "resize.anchorSetterModal", resizeModal );
				anchorSetterModal.on( "mousemove", function ( e ) {
					positionAnchor( e )
				} );
				$scope.finalizeAnchorPosition = function () {
					$scope.setScreenAnchorPosition( parseInt( anchorCurrentPosition ) );
					$scope.closeScreenAnchorSetter();
				}
				$scope.$on( "$destroy", function () {
					$( window ).off( "resize.anchorSetterModal" );
					anchorSetterModal.off( "mousemove" );
				} );
			}
		};
	}
} )( angular, InVision );;;
/*! console-sketch-builder.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleSketchBuilder", Directive );
	/** @ngInject */
	function Directive( $, $window, modelEvents, _ ) {
		return {
			restrict: 'A',
			transclude: true,
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/console-sketch-builder.htm",
			link: function ( $scope, element, attrs ) {
				var sketchBuilder_window = $( element ).find( "#builderWindow" );
				var sketch_tool = $( element ).find( '.sketch_tool' );
				var sketchImageWrapper = $( element ).find( '.sketchImage_wrapper' );
				var sketch_image = $( element ).find( '.sketch_image' );
				var top_bar = $( element ).find( '#sketchToolbar' );
				var sketch_toolbar = $( element ).find( '.tools' );
				var $whiteboard = $( element ).find( "#whiteboard_overlay" ),
					$scrollWrap = $( element ).find( ".scroll-wrap" );
				var init_sketch = function () {
						sketch_image.on( 'dragstart', function ( event ) {
							event.preventDefault();
						} );
						sketch_tool.on( 'click', function ( e ) {
							e.preventDefault();
							sketch_tool.removeClass( 'active' )
								.filter( $( this ) ).addClass( 'active' );
						} );
						sketchImageWrapper.onselectstart = function () {
							return false;
						}
						var UndoManager = function () {
							"use strict";
							var commandStack = [],
								index = -1,
								undoManagerContext = false,
								callback;

							function execute( command ) {
								if ( !command ) {
									return;
								}
								undoManagerContext = true;
								command.f.apply( command.o, command.p );
								undoManagerContext = false;
							}

							function createCommand( undoObj, undoFunc, undoParamsList, undoMsg, redoObj, redoFunc, redoParamsList, redoMsg ) {
								return {
									undo: {
										o: undoObj,
										f: undoFunc,
										p: undoParamsList,
										m: undoMsg
									},
									redo: {
										o: redoObj,
										f: redoFunc,
										p: redoParamsList,
										m: redoMsg
									}
								};
							}
							return {
								/*
Registers an undo and redo command. Both commands are passed as parameters and turned into command objects.
param undoObj: caller of the undo function
param undoFunc: function to be called at myUndoManager.undo
param undoParamsList: (array) parameter list
param undoMsg: message to be used
*/
								register: function ( undoObj, undoFunc, undoParamsList, undoMsg, redoObj, redoFunc, redoParamsList, redoMsg ) {
									if ( undoManagerContext ) {
										return;
									}
									commandStack.splice( index + 1, commandStack.length - index );
									commandStack.push( createCommand( undoObj, undoFunc, undoParamsList, undoMsg, redoObj, redoFunc, redoParamsList, redoMsg ) );
									index = commandStack.length - 1;
									if ( callback ) {
										callback();
									}
								},
								/*
Pass a function to be called on undo and redo actions.
*/
								setCallback: function ( callbackFunc ) {
									callback = callbackFunc;
								},
								undo: function () {
									var command = commandStack[ index ];
									if ( !command ) {
										return;
									}
									execute( command.undo );
									index -= 1;
									if ( callback ) {
										callback();
									}
								},
								redo: function () {
									var command = commandStack[ index + 1 ];
									if ( !command ) {
										return;
									}
									execute( command.redo );
									index += 1;
									if ( callback ) {
										callback();
									}
								},
								/*
Clears the memory, losing all stored states.
*/
								clear: function () {
									var prev_size = commandStack.length;
									commandStack = [];
									index = -1;
									if ( callback && ( prev_size > 0 ) ) {
										callback();
									}
								},
								hasUndo: function () {
									return index !== -1;
								},
								hasRedo: function () {
									return index < ( commandStack.length - 1 );
								}
							};
						};
						( function () {
							'use strict';
							var sketchIMG_width = sketch_image.width(),
								sketchIMG_height = sketch_image.height();
							var sketchImg = sketch_image;
							window.div_paper = sketchImageWrapper;
							window.paper = new ScaleRaphael( div_paper[ 0 ], sketchIMG_width, sketchIMG_height );
							window.stack = {};
							window.glow_stack = {};
							window.undo_manager = new UndoManager();
							paper.setSize( sketchIMG_width, sketchIMG_height );
							sketchImageWrapper.append( sketchImg );
							/*
div_paper.css({
width: sketchIMG_width
});
*/
							$( element ).find( "a#undo" )
								.on( 'click', function ( e ) {
									e.preventDefault();
									if ( undo_manager.hasUndo() ) undo_manager.undo();
								} );
							$( element ).find( "a#redo" )
								.on( 'click', function ( e ) {
									e.preventDefault();
									if ( undo_manager.hasRedo() ) undo_manager.redo();
								} );
							undo_manager.setUndoKeydown = function () {
								$( document ).off( 'keydown' )
									.on( 'keydown', function ( e ) {
										if ( e.keyCode == 8 || e.keyCode == 46 ) {
											e.preventDefault();
											if ( undo_manager.hasUndo() ) undo_manager.undo();
										}
									} );
							}
							undo_manager.setCallback( function () {
								if ( undo_manager.hasUndo() ) {
									$( element ).find( "a#undo" )
										.removeClass( 'inactive' );
								} else $( element ).find( "a#undo" )
									.addClass( 'inactive' );
								if ( undo_manager.hasRedo() ) {
									$( element ).find( "a#redo" )
										.removeClass( 'inactive' );
								} else $( element ).find( "a#redo" )
									.addClass( 'inactive' );
							} );
							var Sketch = function ( o ) {
								if ( typeof ( o ) != 'undefined' ) $.extend( true, this, o );
								var $this = this;
								this.startX = 0;
								this.startY = 0;
								this.offset = this.findPos( div_paper );
								$( window )
									.resize( function () {
										$this.offset = $this.findPos( div_paper );
									} );
								this.el = $( element ).find( '.sketch_tool' );
							}
							Sketch.prototype.findPos = function ( obj ) {
								obj = obj[ 0 ];
								var curleft = 0,
									curtop = 0
								if ( obj.offsetParent ) {
									do {
										curleft += obj.offsetLeft;
										curtop += obj.offsetTop;
									} while ( obj = obj.offsetParent );
									return [ curleft, curtop ];
								} else {
									return false;
								}
							}
							Sketch.prototype.normalizeContent = function ( html, invert ) {
								if ( !invert ) {
									html = html.replace( /<div>/gi, '\r\n' );
									html = html.replace( /<\/div>/gi, '' );
									html = html.replace( /(<br\s*\/?>)/gi, "\r\n" );
								} else {
									html = html.replace( /\r\n/gi, "<br>" );
								}
								return html;
							}
							Sketch.prototype.getCoords = function ( event ) {
								event = event || window.event;
								return {
									x: event.clientX + $scrollWrap.scrollLeft(), //- $(sketch_image).css("left").replace("px","")
									y: event.clientY + $scrollWrap.scrollTop()
								};
							}
							Sketch.prototype.add_glow = function ( el ) {
								/*
glow_stack[el.id] = el.glow({
color: "#000",
width: 2,
opacity: 0.3,
fill: true,
offsety: 2
});
*/
							}
							var SketchRectangular = function () {
								this.figure = null;
								return new Sketch( this );
							}
							SketchRectangular.prototype.redraw = function ( event ) {
								var mousePos = rectangular.getCoords( event );
								var currentX = mousePos.x - rectangular.offset[ 0 ];
								var currentY = mousePos.y - rectangular.offset[ 1 ];
								var width = currentX - rectangular.startX;
								var height = currentY - rectangular.startY;
								if ( width < 0 ) {
									rectangular.figure.attr( {
										'x': currentX,
										'width': width * -1
									} );
								} else {
									rectangular.figure.attr( {
										'x': rectangular.startX,
										'width': width
									} );
								}
								if ( height < 0 ) {
									rectangular.figure.attr( {
										'y': currentY,
										'height': height * -1
									} );
								} else {
									rectangular.figure.attr( {
										'y': rectangular.startY,
										'height': height
									} );
								}
								rectangular.figure.attr( {
									'fill': '#fff',
									'fill-opacity': 0
								} );
							}
							SketchRectangular.prototype.draw = function () {
								var that = this;
								this.el.filter( '.square' )
									.on( 'click', function () {
										div_paper.off();
										deselectHandObject();
										undo_manager.setUndoKeydown();
										hand.wrapper.css( {
											"cursor": "url('/assets/apps/d/img/cursor-square.png') 23 23,crosshair"
										} );
										div_paper.on( {
											mousedown: function ( event ) {
												event.preventDefault();
												var mouseCoords = that.getCoords( event );
												that.startX = mouseCoords.x - that.offset[ 0 ];
												that.startY = mouseCoords.y - that.offset[ 1 ];
												that.figure = paper.rect( that.startX, that.startY, 0, 0, 10 )
													.attr( {
														'stroke': '#f74272',
														'stroke-width': 4,
														'stroke-opacity': 1
													} );
												div_paper.on( 'mousemove', that.redraw );
												$( document ).on( "mouseup.sketchDraw", function () {
													if ( that.figure.attr( "width" ) == 0 ) {
														that.figure.remove();
														return;
													}
													if ( that.figure ) {
														that.figure.toFront();
														stack[ that.figure.id ] = that.figure;
														undo_manager.register(
															that.figure, that.figure.hide, [], 'Hide Rect',
															that.figure, that.figure.show, [], 'Show Rect' );
													}
													div_paper.off( 'mousemove' );
													$( document ).off( "mouseup.sketchDraw" );
												} );
											}
										} );
									} );
							}
							var SketchCircle = function () {
								this.figure = null;
								return new Sketch( this );
							}
							SketchCircle.prototype.redraw = function ( event ) {
								var mousePos = circle.getCoords( event );
								var currentX = mousePos.x - circle.offset[ 0 ];
								var currentY = mousePos.y - circle.offset[ 1 ];
								var width = currentX - circle.startX;
								var height = currentY - circle.startY;
								var size = width > height ? width : height;
								var size = size / 2;
								hand.wrapper.css( {
									"cursor": "url('/assets/apps/d/img/cursor-circle.png') 23 23,crosshair"
								} );
								if ( size < 0 ) {
									circle.figure.attr( {
										'cx': circle.startX + size,
										'rx': size * -1
									} );
								} else {
									circle.figure.attr( {
										'cx': circle.startX + size,
										'rx': size
									} );
								}
								if ( size < 0 ) {
									circle.figure.attr( {
										'cy': circle.startY + size,
										'ry': size * -1
									} );
								} else {
									circle.figure.attr( {
										'cy': circle.startY + size,
										'ry': size
									} );
								}
							}
							SketchCircle.prototype.draw = function () {
								var that = this;
								this.el.filter( '.circle' )
									.on( 'click', function () {
										div_paper.off();
										deselectHandObject();
										undo_manager.setUndoKeydown();
										hand.wrapper.css( {
											"cursor": "url('/assets/apps/d/img/cursor-circle.png') 23 23,crosshair"
										} );
										div_paper.on( {
											mousedown: function ( event ) {
												event.preventDefault();
												var mouseCoords = that.getCoords( event );
												that.startX = mouseCoords.x - that.offset[ 0 ];
												that.startY = mouseCoords.y - that.offset[ 1 ];
												that.figure = paper.ellipse( that.startX, that.startY, 0, 0 )
													.attr( {
														'fill': '#fff',
														'fill-opacity': 0,
														'stroke': '#f74272',
														'stroke-width': 4,
														'stroke-opacity': 1
													} );
												div_paper.on( 'mousemove', that.redraw );
												$( document ).on( "mouseup.sketchDraw", function () {
													if ( that.figure.attr( "rx" ) == 0 ) {
														that.figure.remove();
														return;
													}
													if ( that.figure ) {
														stack[ that.figure.id ] = that.figure;
														undo_manager.register(
															that.figure, that.figure.hide, [], 'Hide Cirle',
															that.figure, that.figure.show, [], 'Show Cirle' );
														that.figure.toFront();
													}
													div_paper.off( 'mousemove' );
													$( document ).off( "mouseup.sketchDraw" );
												} );
											}
										} );
									} );
							}
							var SketchLine = function () {
								this.figure = null;
								return new Sketch( this );
							}
							SketchLine.prototype.redraw = function ( event ) {
								var mousePos = line.getCoords( event );
								var currentX = mousePos.x - line.offset[ 0 ];
								var currentY = mousePos.y - line.offset[ 1 ];
								line.figure.attr( "path", "M" + line.startX + " " + line.startY + "L" + ( currentX > 0 ? currentX : 0 ) + " " + ( currentY > 0 ? currentY : 0 ) );
							}
							SketchLine.prototype.draw = function () {
								var that = this;
								this.el.filter( '.line' )
									.on( 'click', function () {
										div_paper.off();
										deselectHandObject();
										undo_manager.setUndoKeydown();
										hand.wrapper.css( {
											"cursor": "url('/assets/apps/d/img/cursor-line.png') 23 23,crosshair"
										} );
										div_paper.on( {
											mousedown: function ( event ) {
												event.preventDefault();
												var mouseCoords = that.getCoords( event );
												that.startX = mouseCoords.x - that.offset[ 0 ];
												that.startY = mouseCoords.y - that.offset[ 1 ];
												that.figure = paper.path( [ "M", that.startX, that.startY, "L" ] )
													.attr( {
														'stroke': '#f74272',
														'stroke-width': 4,
														'stroke-opacity': 1
													} );
												div_paper.on( 'mousemove', that.redraw );
												$( document ).on( "mouseup.sketchDraw", function () {
													if ( that.figure.getTotalLength() == 0 ) {
														that.figure.remove();
														return;
													}
													if ( that.figure ) {
														stack[ that.figure.id ] = that.figure;
														undo_manager.register(
															that.figure, that.figure.hide, [], 'Hide Line',
															that.figure, that.figure.show, [], 'Show Line' );
														that.figure.toFront();
													}
													div_paper.off( 'mousemove' );
													$( document ).off( "mouseup.sketchDraw" );
												} );
											}
										} );
									} );
							}
							var SketchArrow = function () {
								this.figure = null;
								this.has_arrow = false;
								return new Sketch( this );
							}
							SketchArrow.prototype.redraw = function ( event ) {
								var mousePos = arrow.getCoords( event );
								var currentX = mousePos.x - arrow.offset[ 0 ];
								var currentY = mousePos.y - arrow.offset[ 1 ];
								arrow.figure.attr( "path", "M" + arrow.startX + " " + arrow.startY + "L" + ( currentX > 0 ? currentX : 0 ) + " " + ( currentY > 0 ? currentY : 0 ) );
								if ( arrow.figure.getTotalLength() > 10 && !arrow.has_arrow ) {
									arrow.figure.attr( {
										"arrow-end": "classic-wide-long",
										"stroke-width": 4,
										'stroke': '#f74272',
										'stroke-opacity': 1
									} );
									arrow.has_arrow = true;
								}
							}
							SketchArrow.prototype.draw = function () {
								var that = this;
								this.el.filter( '.arrow' )
									.on( 'click', function () {
										div_paper.off();
										deselectHandObject();
										undo_manager.setUndoKeydown();
										hand.wrapper.css( {
											"cursor": "crosshair"
										} );
										div_paper.on( {
											mousedown: function ( event ) {
												event.preventDefault();
												that.has_arrow = false;
												var mouseCoords = that.getCoords( event );
												that.startX = mouseCoords.x - that.offset[ 0 ];
												that.startY = mouseCoords.y - that.offset[ 1 ];
												that.figure = paper.path( [ "M", that.startX, that.startY, "L" ] );
												div_paper.on( 'mousemove', that.redraw );
											},
											mouseup: function () {
												if ( that.figure.getTotalLength() === 0 ) {
													that.figure.remove();
													return;
												}
												stack[ that.figure.id ] = that.figure;
												if ( that.figure ) {
													that.figure.toFront();
													that.figure.add_glow = true;
													that.figure.hide_arrow = arrow.hide_arrow;
													that.figure.show_arrow = arrow.show_arrow;
													that.figure.move_arrow = arrow.move_arrow;
													that.add_glow( that.figure );
													undo_manager.register(
														that.figure, that.figure.hide_arrow, [], 'Hide Arrow',
														that.figure, that.figure.show_arrow, [], 'Show Arrow' );
												}
												div_paper.off( 'mousemove' );
											}
										} );
									} );
							}
							SketchArrow.prototype.hide_arrow = function () {
								var glows = glow_stack[ this.id ];
								if ( typeof ( glows ) != 'undefined' && glows.length > 0 ) glows.hide();
								this.hide();
							}
							SketchArrow.prototype.show_arrow = function () {
								var glows = glow_stack[ this.id ];
								if ( typeof ( glows ) != 'undefined' && glows.length > 0 ) glows.show();
								this.show();
							}
							SketchArrow.prototype.move_arrow = function ( position ) {
								var glows = glow_stack[ this.id ];
								if ( typeof ( glows ) != 'undefined' && glows.length > 0 ) glows.remove();
								this.transform( position );
								arrow.add_glow( this );
							}
							var SketchText = function () {
								this.figure = null;
								this.toggle = false;
								this.editing = false;
								this.wrapper = $( '.sketchImage_wrapper' );
								return new Sketch( this );
							}
							SketchText.prototype.write = function ( text, startX, startY, height ) {
								text = text.replace( /&nbsp;/gi, " " );
								text = this.normalizeContent( text );
								text = _.unescape( text );
								window.text.figure = paper.text( startX, startY + height, text )
									.attr( {
										'font-family': 'Arial',
										'font-size': '18px',
										'font-weight': '400',
										'fill': '#f74272',
										'fill-opacity': 1,
										"text-anchor": "start",
										"margin-top": "10px"
									} );
								undo_manager.register(
									window.text.figure, window.text.figure.hide, [], 'Hide Text',
									window.text.figure, window.text.figure.show, [], 'Show Text' );
							}
							SketchText.prototype.alignTop = function ( t ) {
								var b = t.getBBox();
								var h = Math.abs( b.y2 ) - Math.abs( b.y ) + 1;
								t.attr( {
									'y': b.y + h
								} );
							}
							SketchText.prototype.draw = function () {
								var that = this;
								this.el.filter( '.text' )
									.on( 'click', function () {
										div_paper.off();
										that.wrapper.off();
										deselectHandObject();
										$( document ).off( 'keydown' );
										hand.wrapper.css( {
											"cursor": "text"
										} );
										that.wrapper.on( 'click', function ( event ) {
											event.preventDefault();
											event.stopPropagation();
											if ( that.editing ) return;
											if ( that.toggle ) {
												that.toggle = false;
												return;
											} else that.toggle = true;
											var mouseCoords = that.getCoords( event );
											var startX = mouseCoords.x - that.offset[ 0 ] - 2;
											var startY = mouseCoords.y - that.offset[ 1 ] - 12;
											$( '<div contenteditable="true" class="type_tool"></div>' )
												.appendTo( $( this ) )
												.css( {
													top: startY,
													left: startX
												} )
												.focus()
												.on( 'blur', function ( e ) {
													e.preventDefault();
													e.stopPropagation();
													var $this = $( this ),
														text = that.normalizeContent( $this.html(), false );
													if ( !text.trim() ) {
														$this.remove();
														return;
													}
													that.write( text, startX, startY, 9 );
													stack[ that.figure.id ] = that.figure;
													$this.remove();
													that.figure.click( function () {
														if ( hand.move_tool ) return;
														that.editing = true;
														var el = this;
														var html = that.normalizeContent( this.attr( 'text' ), false );
														var obj = this.getBBox();
														var x = obj.x;
														var y = obj.y;
														this.hide();
														html = _.escape( html );
														$( '<div contenteditable="true" class="type_tool">' + html + '</div>' )
															.data( "encoded-text", html )
															.appendTo( that.wrapper )
															.css( {
																top: y,
																left: x
															} )
															.focus()
															.on( 'blur', function ( e ) {
																e.preventDefault();
																e.stopPropagation();
																var $this = $( this ),
																	text = $this.html();
																that.editing = false;
																that.toggle = true;
																if ( !text.trim() ) {
																	text = html;
																}
																text = text.replace( /&nbsp;/gi, " " );
																text = _.unescape( text );
																undo_manager.register(
																	el, el.attr, [ 'text', el.attr( 'text' ) ], 'Undo Text',
																	el, el.attr, [ 'text', text ], 'Redo Text' );
																el.attr( 'text', that.normalizeContent( text, false ) );
																el.show();
																$this.remove();
															} );
													} );
												} );
										} );
									} );
							}
							var SketchHand = function () {
								this.figure = null;
								this.selected = false;
								this.set = paper.set();
								this.wrapper = sketchImageWrapper;
								return new Sketch( this );
							}
							SketchHand.prototype.draw = function () {
								var that = this;
								this.el.filter( '.move' )
									.on( {
										click: function () {
											that.move_tool = true;
											that.wrapper.off();
											deselectHandObject();
											$( document ).off( 'keydown' )
												.on( 'keydown', that.deleteKey );
											hand.wrapper.css( {
												"cursor": "default"
											} );
											$( element ).off( 'keydown' );
											$( element ).find( "a#delete" ).off();
											that.set = paper.set();
											for ( var k in stack ) {
												that.set.push( stack[ k ] );
											}
											that.set.drag( that.move, that.start, that.up );
											that.set.hover( that.hoverIn, that.hoverOut );
											that.set.click( that.clickIn );
											that.wrapper.on( 'click', that.clickOut );
											$( "a#delete" )
												.on( 'click', that.deleteKey );
										}
									} );
								this.el.on( {
									click: function () {
										if ( !$( this ).hasClass( 'move' ) ) {
											that.move_tool = false;
											that.set.undrag();
											that.set.unhover( that.hoverIn, that.hoverOut );
										}
									}
								} );
							}
							SketchHand.prototype.clickIn = function () {
								deselectHandObject();
								this.dx = this.attr( "dx" );
								this.dy = this.attr( "dy" );
								hand.selected = this;
								$( element ).find( "a#delete" )
									.removeClass( 'inactive' );
								this.attr( {
									'stroke': '#00aeef',
									'stroke-opacity': 1
								} );
							}
							SketchHand.prototype.deleteKey = function ( e ) {
								if ( e.keyCode == 8 || e.keyCode == 46 || e.type == "click" ) {
									e.preventDefault();
									undo_manager.register(
										hand.selected, ( hand.selected.show_arrow ) ? hand.selected.show_arrow : hand.selected.show, [], 'Show Object',
										hand.selected, ( hand.selected.hide_arrow ) ? hand.selected.hide_arrow : hand.selected.hide, [], 'Hide Object' );
									if ( hand.selected.hide_arrow ) hand.selected.hide_arrow();
									else hand.selected.hide();
									$( element ).find( "a#delete" ).addClass( 'inactive' );
								}
							}
							SketchHand.prototype.clickOut = function ( e ) {
								if ( e.target.nodeName === 'svg' && hand.selected ) {
									if ( hand.selected.node.nodeName === "text" ) {
										hand.selected.attr( {
											'fill': '#f74272',
											'fill-opacity': 1,
											'stroke': 'none',
											'stroke-opacity': 0
										} );
									} else {
										hand.selected.attr( {
											'fill': '#fff',
											'fill-opacity': 0,
											'stroke': '#f74272',
											'stroke-opacity': 1
										} );
									}
									$( element ).find( "a#delete" )
										.addClass( 'inactive' );
								} else if ( e.target.nodeName === "tspan" ) {
									hand.selected.attr( {
										'fill': '#00aeef',
										'fill-opacity': 1,
										'stroke': '#00aeef',
										'stroke-opacity': 1
									} );
								}
							}
							SketchHand.prototype.start = function () {
								deselectHandObject();
								this.attr( {
									'stroke': '#00aeef'
								} )
								this.dx = this.attr( "dx" );
								this.dy = this.attr( "dy" );
								this.previous_pos = this.transform()
									.toString();
								hand.wrapper.css( {
									"cursor": "move"
								} );
								this.unhover( hand.hoverIn, hand.hoverOut );
								var glows = glow_stack[ this.id ];
								if ( typeof ( glows ) != 'undefined' && glows.length > 0 ) glows.remove();
							}
							SketchHand.prototype.move = function ( dx, dy ) {
								this.translate( dx - this.dx, dy - this.dy );
								this.dx = dx;
								this.dy = dy;
							}
							SketchHand.prototype.up = function () {
								this.attr( {
									'fill': '#f74272',
									'fill-opacity': 0,
									'stroke': '#f74272',
									'stroke-opacity': 1
								} );
								hand.wrapper.css( {
									"cursor": "default"
								} );
								this.hover( hand.hoverIn, hand.hoverOut );
								if ( this.add_glow ) hand.add_glow( this );
								if ( this.previous_pos !== this.transform()
									.toString() ) undo_manager.register(
									this, ( this.move_arrow ) ? this.move_arrow : this.transform, [ this.previous_pos ], 'Previous Position',
									this, ( this.move_arrow ) ? this.move_arrow : this.transform, [ this.transform()
										.toString()
									], 'Current Position' );
							}
							SketchHand.prototype.hoverIn = function () {
								hand.wrapper.css( {
									cursor: 'move'
								} );
							};
							SketchHand.prototype.hoverOut = function () {
								hand.wrapper.css( {
									cursor: "default"
								} );
							}
							var SketchPencil = function () {
								this.figure = null;
								this.wrapper = sketchImageWrapper;
								this.pathString = null;
								this.startX = 0;
								this.startY = 0;
								return new Sketch( this );
							}
							SketchPencil.prototype.redraw = function ( event ) {
								var mousePos = pencil.getCoords( event );
								var currentX = mousePos.x - pencil.offset[ 0 ];
								var currentY = mousePos.y - pencil.offset[ 1 ];
								pencil.pathString += 'l' + ( currentX - pencil.startX ) + ' ' + ( currentY - pencil.startY );
								pencil.figure.attr( 'path', pencil.pathString );
								pencil.startX = currentX;
								pencil.startY = currentY;
							}
							SketchPencil.prototype.draw = function () {
								var that = this;
								this.el.filter( '.pencil' )
									.on( 'click', function () {
										that.set = paper.set();
										div_paper.off();
										that.wrapper.off();
										deselectHandObject();
										undo_manager.setUndoKeydown();
										hand.wrapper.css( {
											"cursor": "url('/assets/apps/d/img/cursor-pen.png') 23 23,crosshair"
										} );
										that.wrapper.on( 'mousedown', function ( event ) {
											event.preventDefault();
											var mouseCoords = that.getCoords( event );
											that.startX = mouseCoords.x - that.offset[ 0 ];
											that.startY = mouseCoords.y - that.offset[ 1 ];
											that.pathString = 'M' + that.startX + ' ' + that.startY + 'l0 0';
											that.figure = paper.path( that.pathString );
											stack[ that.figure.id ] = that.figure;
											that.figure.attr( {
												'stroke': '#f74272',
												'stroke-linecap': 'round',
												'stroke-linejoin': 'round',
												'stroke-width': 4,
												'stroke-opacity': 1,
												'fill-opacity': 0
											} );
											that.wrapper.on( 'mousemove', that.redraw );
											$( document ).on( 'mouseup.sketchDraw', function () {
												if ( that.figure ) {
													that.figure.toFront();
													undo_manager.register(
														that.figure, that.figure.hide, [], 'Hide Pencil',
														that.figure, that.figure.show, [], 'Show Pencil' );
												}
												div_paper.off( 'mousemove' );
												$( document ).off( 'mouseup.sketchDraw' );
											} );
										} );
									} );
							}
							window.rectangular = new SketchRectangular();
							rectangular.draw();
							window.circle = new SketchCircle();
							circle.draw();
							window.line = new SketchLine();
							line.draw();
							window.arrow = new SketchArrow();
							arrow.draw();
							window.text = new SketchText();
							text.draw();
							window.hand = new SketchHand();
							hand.draw();
							window.pencil = new SketchPencil();
							pencil.draw();
						} )();
						$( element ).find( "#pencil" ).click();
						sizeSketchBuilder();
					} // end init_sketch()
				var deselectHandObject = function () {
					if ( hand && hand.selected ) {
						if ( hand.selected.node.nodeName === "text" ) {
							hand.selected.attr( {
								'fill': '#f74272',
								'fill-opacity': 1,
								'stroke': 'none',
								'stroke-opacity': 0
							} );
						} else {
							hand.selected.attr( {
								'stroke': '#f74272',
								'stroke-opacity': 1,
								'fill': '#f74272',
								'fill-opacity': 0
							} );
						}
					}
				}
				var sizeSketchBuilder = function () {
					var $builderWindow = sketchBuilder_window,
						$wrapper = sketchImageWrapper,
						_window = {
							height: $( window ).height(),
							width: $( window ).width()
						},
						_sketch = {
							height: sketch_image.height(),
							width: sketch_image.width()
						},
						scrollSize = 15,
						windowPadding = 60,
						toolbarHeight = 49,
						builderCSS = {},
						wrapperCSS = {},
						scrollCSS = {};
					var minWidth = ( _sketch.width < 800 ) ? 800 : _sketch.width;
					builderCSS = {
						height: ( _sketch.height > _window.height ) ? ( _window.height - windowPadding ) : _sketch.height + 81,
						width: ( _sketch.width > _window.width ) ? ( _window.width - windowPadding ) : minWidth,
						left: "50%",
						top: "50%",
						marginLeft: "-" + ( minWidth / 2 ) + "px"
					};
					builderCSS.marginTop = "-" + ( builderCSS.height / 2 ) + "px";
					wrapperCSS = {
						height: _sketch.height,
						width: _sketch.width
					};
					scrollCSS = {
						height: builderCSS.height - toolbarHeight,
						width: builderCSS.width
					};
					if ( _sketch.width > _window.width ) {
						builderCSS.height += scrollSize;
						builderCSS.left = 0;
						builderCSS.marginLeft = windowPadding / 2;
						scrollCSS.height += scrollSize;
					};
					if ( ( _sketch.height + toolbarHeight + windowPadding ) > _window.height ) {
						builderCSS.top = 0;
						builderCSS.marginTop = windowPadding / 2;
					};
					$builderWindow.css( builderCSS );
					$wrapper.css( wrapperCSS );
					$scrollWrap.css( scrollCSS );
					$whiteboard.css( {
						height: _sketch.height,
						width: _sketch.width
					} );
					$whiteboard.appendTo( sketchImageWrapper );
				}
				var scrollToMatchCurrentScroll = function () {
					var sTop = 0,
						sLeft = 0,
						topOffset = -51; // topOffset is to account for the toolbar at the top of comments mode.
					if ( $scope.project.isMobile ) {
						sTop = $( "#comments" ).scrollTop() + topOffset;
						sLeft = $( "#comments" ).scrollLeft();
					} else {
						sTop = $( window ).scrollTop() + topOffset;
						sLeft = $( window ).scrollLeft();
					}
					$scrollWrap.scrollTop( sTop ).scrollLeft( sLeft );
				}
				$scope.whiteboardOpacity = 0;
				$scope.whiteboardSelected = 'none';
				$scope.setWhiteboardOpacity = function ( opacity, name ) {
					$scope.whiteboardOpacity = opacity;
					$scope.whiteboardSelected = name;
				}
				$scope.saveSketch = function () {
					deselectHandObject();
					var svg_string = window.paper.toSVG();
					var scale = $scope.getReverseDisplayScale( $scope.screen );
					var $svg = $.parseXML( svg_string );
					var numOfSketchElements = $( $svg ).find( "svg" ).children().size();
					var opacity = $scope.whiteboardOpacity;
					if ( numOfSketchElements == 0 ) {
						$scope.openModalWindow( "error", "Your sketch is empty.  There's nothing to save." );
						return;
					}
					var sketch = {
						tempID: $scope.tempSketches.length + 1,
						screenID: $scope.screenID,
						svg: svg_string,
						svgScale: scale,
						opacity: opacity
					}
					$scope.tempSketches.push( sketch );
					$scope.hideSketchBuilder();
				}
				setTimeout( init_sketch, 220 );
				$( sketch_image ).on( "load", function () {
					sizeSketchBuilder();
					scrollToMatchCurrentScroll();
				} );
				$( window ).on( "resize.sketchBuilderModal", sizeSketchBuilder );
				$scope.$on( "$destroy", function () {
					$( window ).off( "resize.sketchBuilderModal" );
					$( document ).off( 'keydown' );
				} );
			}
		};
	}
} )( angular, InVision );;;
/*! console-sketch-viewer-image.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleSketchViewerImage", Directive );
	/** @ngInject */
	function Directive( $ ) {
		return {
			restrict: "A",
			link: function ( $scope, element ) {
				var retry = 1;
				var timer;
				var baseURL = "/api/comments/" + $scope.sketchViewerSketch.commentID + "/sketch/" + $scope.sketchViewerSketch.id;
				element.bind( "error", function () {
					$scope.setSketchImageIsProcessing( true );
					$scope.$apply();
					if ( retry <= 5 ) {
						timer = setTimeout( function () {
							element.attr( "src", baseURL + "?retry=" + retry );
							retry++;
						}, 5000 );
					}
				} );
				element.bind( "load", function () {
					$scope.$emit( "resizeViewerWindow" );
					$scope.setSketchImageIsProcessing( false );
					$scope.$apply();
				} );
				$scope.$on( "$destroy", function () {
					$( window ).off( "resize.sketchViewerModal" );
					clearTimeout( timer );
				} );
			}
		};
	}
} )( angular, InVision );;;
/*! console-sketch-viewer.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleSketchViewer", Directive );
	/** @ngInject */
	function Directive( $, modelEvents, $window, $timeout ) {
		return {
			restrict: "A",
			transclude: true,
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/console-sketch-viewer.htm",
			link: function ( $scope, element ) {
				var $win = $( $window );
				var resizeSketchViewer = function ( isImageReady ) {
					isImageReady = typeof isImageReady === "undefined" ? false : isImageReady;
					var $element = $( element ),
						$sketchViewerWindow = $element.find( ".sketchViewer" ),
						$sketchImage = $element.find( ".imageContainer img" ),
						windowPadding = 40;
					var sketchHeight = $scope.screen.height * $scope.screen.displayScale,
						sketchWidth = $scope.screen.width * $scope.screen.displayScale;
					if ( isImageReady ) {
						var sketchHeight = $sketchImage.height(),
							sketchWidth = $sketchImage.width();
					}
					$sketchViewerWindow.removeClass( "taller" );
					$sketchViewerWindow.removeClass( "wider" );
					if ( $win.height() < sketchHeight + windowPadding ) {
						sketchHeight = $win.height() - windowPadding;
						$sketchViewerWindow.addClass( "taller" );
					}
					if ( $win.width() < sketchWidth + windowPadding ) {
						sketchWidth = $win.width() - windowPadding;
						$sketchViewerWindow.addClass( "wider" );
					}
					$sketchViewerWindow.css( {
						height: sketchHeight,
						width: sketchWidth,
						"margin-left": "-" + ( sketchWidth / 2 ) + "px",
						"margin-top": "-" + ( sketchHeight / 2 ) + "px"
					} );
				};
				var autoScrollSketchViewer = function () {
					var sTop = $scope.sketchViewerMarker.y * $scope.screen.displayScale - ( $( element ).find( ".sketchViewer" ).height() / 2 );
					var sLeft = $scope.sketchViewerMarker.x * $scope.screen.displayScale - ( $( element ).find( ".sketchViewer" ).width() / 2 );
					sTop = sTop > 0 ? sTop : 0;
					sLeft = sLeft > 0 ? sLeft : 0;
					$( element ).find( '.imageContainer' ).scrollTop( sTop ).scrollLeft( sLeft );
				}
				$timeout( function () {
					resizeSketchViewer();
					autoScrollSketchViewer();
				} );
				$scope.$on( "resizeViewerWindow", function () {
					resizeSketchViewer( true );
					autoScrollSketchViewer();
				} );
				$win.on( "resize.sketchViewerModal", resizeSketchViewer );
				$scope.$on( "$destroy", function () {
					$win.off( "resize.sketchViewerModal" );
				} );
			}
		};
	}
} )( angular, InVision );;;
/*! console-template-bar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConsoleTemplateBar", Directive );
	/** @ngInject */
	function Directive( $, _, $timeout, templateService, Deferred ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				$scope.addNewTemplate = function () {
					$scope.stopEditingAllTemplateNames();
					$scope.templates.push( {
						isEditing: true,
						name: "",
						id: 0,
						projectID: $scope.projectID,
						screens: []
					} );
					$scope.$broadcast( "templateAdded" );
				};
				$scope.stopEditingAllTemplateNames = function () {
					_.each( $scope.templates, function ( template ) {
						if ( template.originalName ) {
							template.name = template.originalName;
							template.isEditing = false;
						}
					} );
				};
				$scope.editTemplateName = function ( template ) {
					$scope.stopEditingAllTemplateNames();
					template.originalName = template.name;
					template.isEditing = true;
				};
				$scope.save = function ( template ) {
					if ( !template.name ) {
						return;
					}
					var isNewTemplate = !template.id;
					template.isEditing = false;
					template.originalName = template.name;
					$scope.saveTemplate( template, function () {
						if ( isNewTemplate ) {
							$scope.addTemplateToScreen( template.id, $scope.screenID, false );
						}
					} );
				};
			}
		};
	}
} )( angular, InVision );;;
/*! console-thumbnail-tray.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invThumbnailTray", Directive );
	/** @ngInject */
	function Directive( $, $window, $timeout, modelEvents ) {
		return {
			restrict: "A",
			link: function ( $scope, element, attrs ) {
				var THUMBWIDTH = 214,
					$window = $( window ),
					$tray = $( element ),
					dataVar = attrs.ngModel,
					shouldScrollToScreen = true; // This should be true when uploading a screen to the end, false when uploading to a specific position.
				function sizeTray( firstLoad ) {
					var numberOfScreens = firstLoad ? $scope.screens.length : $tray.find( "#thumbs" ).find( ".screen-item" ).length,
						numberOfScreensPlusUploader = numberOfScreens + 1,
						width = ( numberOfScreensPlusUploader * THUMBWIDTH ) + 22,
						trayHeight,
						wrapHeight;
					if ( $scope.isBrowse ) {
						width = $window.width();
						trayHeight = $window.height() - 52;
						wrapHeight = $window.height() - 108;
					} else {
						trayHeight = 265;
						wrapHeight = 210;
					}
					$tray.css( {
						height: trayHeight
					} );
					$tray.find( "#thumbs" ).width( width );
					$tray.find( "#thumb_scroll" ).css( {
						height: wrapHeight,
						width: $window.width()
					} );
					$tray.find( "#thumb_scroll" ).tinyscrollbar_update( "relative" );
					$scope.screenCount = numberOfScreens;
				}

				function toggleTray() {
					$timeout( function () {
						sizeTray();
					} );
				}
				$scope.$watch(
					dataVar,
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						$timeout( function () {
							sizeTray( true );
						} );
					}
				);
				$scope.$watch(
					"screenID",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						if ( !$scope.isPresentation && shouldScrollToScreen ) {
							$timeout( function () {
								scrollToScreen( newValue );
							}, 10 );
						}
					}
				);
				$scope.$watch(
					"filter.searchCriteria",
					function ( newValue, oldValue ) {
						if ( newValue !== oldValue ) {
							if ( newValue.length ) {
								$scope.$emit( "isFilteringScreens", true );
							} else {
								$scope.$emit( "isFilteringScreens", false );
							}
							$timeout( function resize() {
								sizeTray();
							} );
						}
					}
				);
				$scope.$watch(
					"isBrowse",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						toggleTray();
					}
				);
				modelEvents.on( "screenUploaded", function ( event, screen ) {
					sizeTray( true );
				} );
				$window.on( "resize", sizeTray );
				$scope.filter = {
					searchCriteria: ""
				};
				$scope.isShowingThumbnailTray = false;
				$scope.isBrowse = false;
				$scope.screenCount = 0;
				$scope.toggleThumbnailTray = function () {
					$scope.closeReplaceScreenUploader();
					$timeout( function () {
						$scope.isShowingThumbnailTray = !$scope.isShowingThumbnailTray;
						if ( $scope.isBrowse ) {
							$scope.hideThumbnailTray();
						}
					} );
				};
				$scope.toggleBrowse = function () {
					$scope.closeReplaceScreenUploader();
					$timeout( function () {
						$scope.isBrowse = !$scope.isBrowse;
					} );
				};
				$scope.openThumbTray = function () {
					$scope.isBrowse = false;
					$scope.isShowingThumbnailTray = true;
				};
				$scope.closeThumbTray = function () {
					$scope.closeReplaceScreenUploader();
					$timeout( function () {
						$scope.isBrowse = false;
						$scope.isShowingThumbnailTray = false;
					} );
				};
				$scope.closeReplaceScreenUploader = function () {
					if ( !!$scope.$parent.isScreenReplaceUploaderActive ) {
						$scope.$parent.$broadcast( "toggleScreenReplaceUploader", {
							showUploader: false
						} );
					}
				};
				$scope.$on(
					"openThumbnailTray",
					function () {
						$scope.openThumbTray();
					}
				);
				$scope.$on(
					"closeThumbnailTray",
					function () {
						$scope.closeThumbTray();
					}
				);
				$scope.$on(
					"openHotspotBrowseMenu",
					function ( event, hotSpotID ) {
						$scope.browseForHotspotID = hotSpotID;
						$scope.isShowingThumbnailTray = true;
					}
				);
				$scope.$on(
					"closeBrowseMenu",
					function () {
						$scope.isBrowse = false;
					}
				);
				$scope.$on(
					"toggleThumbnailTray",
					function () {
						$scope.toggleThumbnailTray();
					}
				);
				$scope.$on( "scrollToUploadedScreen", function ( event, screen ) {
					sizeTray();
					if ( shouldScrollToScreen ) {
						$timeout( function () {
							var scrollTo = screen === false ? "end" : screen.id;
							scrollToScreen( scrollTo );
						}, 10 );
					}
				} );
				$scope.$on( "setShouldScrollToScreen", function ( event, scrollToScreen ) {
					shouldScrollToScreen = scrollToScreen;
				} );
				$scope.$on(
					"$destroy",
					function () {
						modelEvents.off( "screenUploaded" );
						$window.unbind( "resize", sizeTray );
					}
				);

				function scrollToScreen( screenID ) {
					var currentScreen = element.find( "#screen" + screenID );
					if ( screenID === "end" ) {
						currentScreen = element.find( ".screen:last" );
					}
					var screen = {
							left: currentScreen.offset().left,
							right: currentScreen.offset().left + currentScreen.width()
						},
						windowWidth = $( window ).width(),
						trackSize = $tray.find( "#thumbs" ).find( ".screen-item" ).length * THUMBWIDTH,
						scrollTo = 0;
					if ( screen.left > 0 && screen.right <= trackSize ) {
						scrollTo = screen.left - THUMBWIDTH;
					}
					if ( screen.right >= ( trackSize - windowWidth ) ) {
						scrollTo = ( trackSize - windowWidth ) + 12;
					}
					if ( screen.right === trackSize ) {
						scrollTo = ( trackSize - windowWidth ) + 12;
					}
					$tray.find( "#thumb_scroll" ).tinyscrollbar_update( Math.max( scrollTo, 0 ) );
				}
			}
		};
	}
} )( angular, InVision );;;
/*! conversation-marker.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invConversationMarker", Directive );
	/** @ngInject */
	function Directive( $, _, $location, $window, $timeout, Deferred, conversationService, sessionService, modelEvents, projectService, userService ) {
		return {
			restrict: "A",
			link: function ( $scope, element, attrs ) {
				$scope.cancelEditingComment = function ( comment ) {
					comment.isEditing = false;
					if ( comment.originalComment ) {
						comment.comment = comment.originalComment;
					}
				};
				$scope.closeConversationPanel = function () {
					$scope.newComment = "";
					$scope.notifyOthers = "";
					$scope.isCommentInputVisible = false;
					$scope.isNotifySettingsVisible = false;
					$scope.clearCommentSketches();
					$scope.closeAllConversationPanels();
					$location.path( "/console/" + $scope.projectID + "/" + $scope.screenID + "/comments" );
				};
				$scope.closeJustThisConversationPanel = function ( initialConversationID ) {
					var currentOpenConversation = _.filterWithProperty( $scope.conversations, "isConversationPanelVisible", true );
					$scope.newComment = "";
					$scope.notifyOthers = "";
					$scope.isCommentInputVisible = false;
					$scope.isNotifySettingsVisible = false;
					$scope.clearCommentSketches();
					$scope.marker.isConversationPanelVisible = false;
					if ( currentOpenConversation[ 0 ].id === initialConversationID ) {
						$location.path( "/console/" + $scope.projectID + "/" + $scope.screenID + "/comments" );
					}
				};
				$scope.deleteComment = function ( comment ) {
					conversationService.deleteComment( comment );
					$scope.marker.comments = _.rejectWithProperty( $scope.marker.comments, "id", comment.id );
				};
				$scope.deleteSketch = function ( sketchID ) {
					conversationService.deleteSketch( sketchID );
					for ( var c = 0; c < $scope.marker.comments.length; c++ ) {
						$scope.marker.comments[ c ].sketches = _.rejectWithProperty( $scope.marker.comments[ c ].sketches, "id", sketchID );
					}
				};
				$scope.editComment = function ( comment ) {
					$scope.stopEditingComments();
					comment.isEditing = true;
					comment.originalComment = comment.comment;
				};
				$scope.getNotifyCount = function () {
					var count = 0;
					_.each( $scope.projectMembers, function ( user ) {
						if ( user.isNotify ) {
							count++;
						}
					} );
					if ( !$scope.marker.isForDevelopment && !$scope.marker.isPrivate ) {
						_.each( $scope.projectStakeholders, function ( user ) {
							if ( user.isNotify ) {
								count++;
							}
						} );
					}
					if ( $scope.notifyOthers ) {
						var others = $scope.notifyOthers.split( "," );
						count += others.length;
					}
					if ( ( $scope.projectStakeholders.length + $scope.projectMembers.length ) !== count && $scope.hasAllChecked ) {
						$scope.hasAllChecked = false;
					}
					if ( ( $scope.projectStakeholders.length + $scope.projectMembers.length ) === count ) {
						$scope.hasAllChecked = true;
					}
					return count;
				};
				$scope.getMarkerClass = function () {
					if ( $scope.marker.isForDevelopment ) {
						if ( !$scope.marker.isComplete ) {
							return "development";
						} else {
							return "complete development";
						}
					} else if ( $scope.marker.isPrivate ) {
						if ( !$scope.marker.isComplete ) {
							return "conversation-private";
						} else {
							return "complete conversation-private";
						}
					} else if ( $scope.marker.isComplete ) {
						return "complete";
					} else {
						return "conversation";
					}
				};
				$scope.hideDeleteConfirmation = function ( comment ) {
					( comment || $scope ).isDeleting = false;
				};
				$scope.isStakeholdersShowing = function () {
					var isStakeholdersListEmpty = !$scope.projectStakeholders.length;
					if ( $scope.marker.isPrivate ||
						$scope.marker.isForDevelopment ||
						isStakeholdersListEmpty ) {
						return false;
					} else {
						return true;
					}
				};
				$scope.onMarkerClick = function () {
					if ( hasDragged ) {
						hasDragged = false;
						if ( $scope.marker.isSaved === false ) {
							$scope.marker.isConversationPanelVisible = true;
						}
					} else if ( $scope.areConversationsDirty() ) {
						alert( "Oops, you haven't saved your comment!" );
					} else if ( $scope.marker.isConversationPanelVisible ) {
						$scope.closeConversationPanel();
					} else {
						$scope.clearCommentSketches();
						$location.path( "/console/" + $scope.projectID + "/" + $scope.screenID + "/comments/" + $scope.marker.id );
					}
				};
				$scope.saveComment = function ( comment ) {
					if ( !comment.comment && !$scope.tempSketches.length ) {
						return;
					}
					if ( submissionInProgress ) {
						return;
					}
					submissionInProgress = true;
					var isNewConversation = !$scope.marker.isSaved;
					if ( !comment.isEditing ) {
						pushPlaceholderComment( comment.comment, isNewConversation );
					}
					comment.isEditing = false;
					comment.originalComment = comment.comment;
					comment.html = conversationService.getHtmlForComment( comment.comment );
					if ( $scope.marker.isSaved ) {
						save( $scope.marker.id );
					} else {
						$scope.saveConversation( $scope.marker, save );
					}

					function save( conversationID ) {
						if ( comment.id ) {
							var notify = {
								members: [],
								stakeholders: [],
								others: [],
								unsubscribe: []
							};
						} else {
							var memberIDs = _.filterWithProperty( $scope.projectMembers, "isNotify", true );
							var stakeholderIDs = _.filterWithProperty( $scope.projectStakeholders, "isNotify", true );
							var notify = {
								members: _.pluck( memberIDs, "id" ),
								stakeholders: _.pluck( stakeholderIDs, "id" ),
								others: [],
								unsubscribe: []
							};
							var membersToUnsubscribe = _.filterWithProperty( $scope.projectMembers, "isNotify", false );
							var stakeholdersToUnsubscribe = _.filterWithProperty( $scope.projectStakeholders, "isNotify", false );
							notify.unsubscribe = _.pluck( membersToUnsubscribe, "id" );
							notify.unsubscribe = notify.unsubscribe.concat( _.pluck( stakeholdersToUnsubscribe, "id" ) );
							if ( $scope.notifyOthers ) {
								notify.others = $scope.notifyOthers.split( "," );
							}
							if ( isNewConversation ) {
								$scope.setDefaultUserIDs(
									notify.members.concat( notify.stakeholders )
								);
							}
						}
						comment.notify = notify;
						comment.conversationID = conversationID;
						$scope.updateConversationPosition( $scope.marker );
						Deferred.handlePromise(
							conversationService.saveComment( comment ),
							function ( savedComment ) {
								submissionInProgress = false;
								if ( !comment.id ) {
									modelEvents.trigger( "console:comment:saved", {
										"comment": savedComment,
										"screenID": $scope.screenID
									} );
								}
								$scope.marker.subscribers = notify.members.concat( notify.stakeholders );
								if ( notify.others.length ) {
									var promise = $scope.loadStakeholders();
									promise.then(
										function ( stakeholders ) {
											var newUserIDs = [];
											_.each(
												stakeholders,
												function ( stakeholder ) {
													if (
														_.contains( $scope.marker.subscribers, stakeholder.id ) ||
														_.contains( notify.unsubscribe, stakeholder.id )
													) {
														return;
													}
													newUserIDs.push( stakeholder.id );
												}
											);
											if ( !newUserIDs.length ) {
												return;
											}
											$scope.marker.subscribers = $scope.marker.subscribers.concat( newUserIDs );
											if ( isNewConversation ) {
												$scope.setDefaultUserIDs(
													notify.members.concat( notify.stakeholders ).concat( newUserIDs )
												);
											}
											$scope.notifyOthers = "";
										}
									);
								}
							},
							function () {
								submissionInProgress = false;
							}
						);
					}
				};
				$scope.setTypeAsComment = function () {
					$scope.marker.isForDevelopment = false;
					$scope.marker.isPrivate = false;
					_.setProperty( $scope.projectStakeholders, "isNotify", true );
				};
				$scope.setTypeAsPrivateComment = function () {
					$scope.marker.isForDevelopment = false;
					$scope.marker.isPrivate = true;
					_.setProperty( $scope.projectStakeholders, "isNotify", false );
					$scope.notifyOthers = "";
				};
				$scope.setTypeAsDevNote = function () {
					$scope.marker.isForDevelopment = true;
					$scope.marker.isPrivate = true;
					_.setProperty( $scope.projectStakeholders, "isNotify", false );
					$scope.notifyOthers = "";
				};
				$scope.showCommentInput = function () {
					$scope.isCommentInputVisible = true;
					$timeout( function () {
						element.find( "textarea" ).focus();
					} );
				};
				$scope.stopEditingComments = function () {
					_.each( $scope.marker.comments, function ( comment ) {
						$scope.cancelEditingComment( comment );
					} );
				};
				$scope.toggleIsPrivate = function () {
					if ( $scope.marker.isPrivate ) {
						$scope.marker.isPrivate = false;
					} else {
						$scope.marker.isPrivate = true;
						_.setProperty( $scope.projectStakeholders, "isNotify", false );
						$scope.notifyOthers = "";
					}
				};
				$scope.toggleUserList = function () {
					$scope.isNotifySettingsVisible = !$scope.isNotifySettingsVisible;
				};
				$scope.scrollToMarker = function () {
					if ( !isScrolledIntoView( element.find( ".marker" ) ) ||
						!isScrolledIntoView( element.find( ".comment-thread" ) )
					) {
						var containers = $( "html,body" );
						var duration = 500;
						containers.stop( true )
							.animate( {
									scrollTop: ( $scope.marker.y - 100 )
								},
								duration
						)
							.animate( {
									scrollLeft: ( $scope.marker.x - 100 )
								},
								duration
						);
					}
				};
				$scope.showDeleteConfirmation = function ( comment, isFirstComment ) {
					if ( isFirstComment ) {
						$scope.isDeleting = true;
					} else {
						comment.isDeleting = true;
					}
				};
				$scope.removeStakeholder = function ( stakeholder ) {
					$( "html,body" ).stop().animate( {
							scrollTop: ( $scope.marker.y / $scope.screen.displayScale ) - 100,
							scrollLeft: ( $scope.marker.x / $scope.screen.displayScale ) - 100
						},
						500
					);
					projectService.removeStakeholderFromProject( $scope.projectID, stakeholder.id );
				};
				$scope.getUsersToBeNotified = function () {
					var userNames = [];
					var pushUserOnStackIfNotified = function ( user ) {
						if ( user.isNotify ) {
							userNames.push( userService.getFirstName( user.name ) );
						}
					};
					_.each( $scope.projectMembers, pushUserOnStackIfNotified );
					if ( !$scope.marker.isForDevelopment && !$scope.marker.isPrivate ) {
						_.each( $scope.projectStakeholders, pushUserOnStackIfNotified );
					}
					if ( $scope.notifyOthers ) {
						var others = $scope.notifyOthers.split( "," );
						userNames = userNames.concat( others );
					}
					return userNames[ 0 ];
				};

				function moveConversationPanelPosition( x, y ) {
					var leftPadding = 15;
					var markerTop = y;
					var markerLeft = x;
					var markerWidth = 49;
					var markerHeight = 49;
					var imageWidth = image.width();
					var imageOffsetLeft = image.offset().left;
					var formWidth = element.find( ".comment-thread" ).width();
					var maxRight = Math.max( imageWidth, $( $window ).width() );
					var newFormTop = ( markerTop * $scope.screen.displayScale ) + Math.round( markerHeight / 2 ) - 25;
					var newFormLeft = ( markerLeft * $scope.screen.displayScale ) + markerWidth + leftPadding;
					if ( newFormLeft + formWidth + imageOffsetLeft >= maxRight ) {
						$scope.conversationPanelClass = "right";
					} else {
						$scope.conversationPanelClass = "left";
					}
					formContainer.css( {
						"top": newFormTop + "px",
						"left": newFormLeft + "px"
					} );
				}

				function isScrolledIntoView( elem ) {
					var docView = {
						"top": $( $window ).scrollTop(),
						"bottom": $( $window ).scrollTop() + $( $window ).height() - 60,
						"left": $( $window ).scrollLeft(),
						"right": $( $window ).scrollLeft() + $( $window ).width()
					};
					var item = {
						"top": $( elem ).offset().top,
						"bottom": $( elem ).offset().top + $( elem ).height(),
						"left": $( elem ).offset().left,
						"right": $( elem ).offset().left + $( elem ).width()
					};
					return (
						( item.bottom >= docView.top ) &&
						( item.top <= docView.bottom ) &&
						( item.bottom <= docView.bottom ) &&
						( item.top >= docView.top ) &&
						( item.left >= docView.left ) &&
						( item.right <= docView.right )
					);
				}

				function dragStart( event, ui ) {}

				function drag( event, ui ) {
					var x = ui.position.left;
					var y = ui.position.top;
					moveConversationPanelPosition( x, y );
					hasDragged = true;
				}

				function dragStop( event, ui ) {
					var x = ui.position.left / $scope.screen.displayScale;
					var y = ui.position.top / $scope.screen.displayScale;
					var isEditingAComment = _.filterWithProperty( $scope.marker.comments, "isEditing", true ).length ? true : false;
					$scope.marker.x = x;
					$scope.marker.y = y;
					if ( $scope.marker.isSaved && !isEditingAComment ) {
						$scope.saveConversation( $scope.marker );
					}
				}

				function updateCollapsedStates( collection ) {
					_.each( collection, function ( comment ) {
						var isFirstOrLastN = false,
							isCollapsed = false,
							isFirstCollapsed = false,
							previousCollapsedComments = [],
							index = -1;
						index = _.indexOfWithProperty( collection, "id", comment.id );
						isFirstOrLastN = ( index === 0 || index >= ( collection.length - 3 ) );
						previousCollapsedComments = _.filterWithProperty( collection.slice( 0, index ), "isCollapsed", true );
						isCollapsed = !( isFirstOrLastN || comment.isUnread );
						isFirstCollapsed = isCollapsed && ( previousCollapsedComments.length === 0 );
						comment.isFirstCollapsed = isFirstCollapsed;
						comment.isCollapsed = isCollapsed;
					} );
				}

				function updateConversation( conversationID ) {
					Deferred.handlePromise(
						conversationService.getConversation( conversationID ),
						function ( updatedConversation ) {
							updateCollapsedStates( updatedConversation.comments );
							_.each( updatedConversation.comments, function ( comment ) {
								comment.userInitials = userService.getInitials( comment.userName );
								comment.userHasSystemAvatar = userService.isSystemAvatar( comment.avatarID );
								comment.html = conversationService.getHtmlForComment( comment.comment );
								comment.userFirstName = comment.userName.split( " " )[ 0 ];
								comment.userOnlineStatus = userService.getOnlineStatus( comment.lastRequestAt );
								comment.niceDate = moment( comment.createdAt ).fromNow();
							} );
							_.extend( $scope.marker, updatedConversation );
							moveConversationPanelPosition( $scope.marker.x, $scope.marker.y );
							if ( $scope.isCommentInputVisible ) {
								$timeout( function () {
									formContainer.find( ".post-new-comment textarea" ).focus();
								} );
							}
						},
						function () {}
					);
				}

				function addComment( commentID ) {
					var commentExists = _.findWithProperty( $scope.marker.comments, "id", commentID );
					if ( !commentExists ) {
						Deferred.handlePromise(
							conversationService.getComment( commentID ),
							function ( comment ) {
								var commentExists = _.findWithProperty( $scope.marker.comments, "id", commentID );
								if ( commentExists ) {
									return;
								}
								comment.html = conversationService.getHtmlForComment( comment.comment );
								$scope.marker.comments.push( comment );
								if ( comment.isUnread ) {
									$scope.marker.isUnread = true;
									$scope.$emit( "conversationsChanged" );
								}
							},
							function () {}
						);
					}
				}

				function updateComment( commentID ) {
					var comment = _.findWithProperty( $scope.marker.comments, "id", commentID );
					if ( comment ) {
						Deferred.handlePromise(
							conversationService.getComment( commentID ),
							function ( updatedComment ) {
								if ( comment.comment !== updatedComment.comment ) {
									_.assign( comment, updatedComment );
									comment.originalComment = updatedComment.originalComment;
								}
								comment.numberOfLikes = updatedComment.numberOfLikes;
								comment.hasUserLiked = updatedComment.hasUserLiked;
								comment.likedByList = conversationService.formatCommentLikers( updatedComment );
							},
							function () {}
						);
					}
				}

				function deleteComment( commentID ) {
					$scope.marker.comments = _.rejectWithProperty( $scope.marker.comments, "id", commentID );
				}

				function handleCommentAdded( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						addComment( commentID );
					}
				}

				function handleCommentUpdated( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						updateComment( commentID );
					}
				}

				function handleCommentDeleted( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						deleteComment( commentID );
					}
				}

				function handleConversationUpdated( event, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						updateConversation( conversationID );
					}
				}

				function handleProjectStakeholderRemoved( event, projectID, userID ) {
					$scope.projectStakeholders = _.rejectWithProperty( $scope.projectStakeholders, "id", userID );
				}

				function watchForDirtyComment() {
					var unwatchNewComment = $scope.$watch(
						"newComment",
						function ( newValue, oldValue ) {
							if ( newValue === oldValue ) {
								return;
							}
							$scope.setConversationsAsDirty();
							unwatchNewComment();
						}
					);
				}

				function pushPlaceholderComment( newComment, isNewConversation ) {
					isNewConversation = isNewConversation || false;
					$scope.isShowingUserList = false;
					$scope.newComment = "";
					$scope.setConversationsAsClean();
					$scope.clearCommentSketches();
					$scope.$broadcast( "invSuccessButton:success" );
					var placeholderComment = {
						userName: $scope.user.name,
						avatarID: $scope.user.avatarID || 0,
						userHasSystemAvatar: $scope.user.hasSystemAvatar,
						userInitials: $scope.user.initials,
						userOnlineStatus: "Online",
						niceDate: "a few seconds ago",
						html: newComment,
						numberOfLikes: 0,
						isEditing: false,
						isPlaceholder: true
					};
					if ( isNewConversation ) {
						$scope.marker.comments = [];
					};
					$scope.marker.comments.push( placeholderComment );
				}
				var screenContainer = element.parents( ".screen" );
				var image = element.parents( ".screen" ).find( ".screenImage" );
				var formContainer = element.find( ".comment-thread-container" );
				var hasDragged = false;
				var submissionInProgress = false;
				$scope.isDeleting = false;
				$scope.marker.isMarkerVisible = true;
				$scope.marker.isSaved = !!$scope.marker.id;
				$scope.marker.isConversationPanelVisible = $scope.marker.isConversationPanelVisible || false;
				$scope.newComment = "";
				$scope.notifyOthers = "";
				$scope.isCommentInputVisible = false;
				$scope.isNotifySettingsVisible = false;
				$scope.conversationPanelClass = "left";
				$scope.showNotifyOthers = false;
				$scope.hasAllChecked = false;
				$scope.notifyOptionSelected = "All";
				$scope.checkAll = function () {
					_.setProperty( $scope.projectMembers, "isNotify", true );
					_.setProperty( $scope.projectStakeholders, "isNotify", true );
				};
				$scope.uncheckAll = function () {
					_.setProperty( $scope.projectMembers, "isNotify", false );
					_.setProperty( $scope.projectStakeholders, "isNotify", false );
				};
				$scope.checkAllCollaborators = function () {
					$scope.uncheckAll();
					_.setProperty( $scope.projectMembers, "isNotify", true );
				};
				$scope.selectAll = function () {
					$scope.checkAll();
					$scope.notifyOptionSelected = "All";
				};
				$scope.selectCollaborators = function () {
					$scope.checkAllCollaborators();
					$scope.notifyOptionSelected = "Collaborators";
				};
				$scope.toggleNotifyOption = function () {
					if ( $scope.getNotifyCount() > 0 ) {
						$scope.uncheckAll();
						return;
					}
					switch ( $scope.notifyOptionSelected ) {
					case "All":
						$scope.selectAll();
						break;
					case "Collaborators":
						$scope.selectCollaborators();
						break;
					}
				};
				$scope.$watch(
					"marker.isComplete",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						if ( !$scope.marker.isSaved ) {
							return;
						}
						$scope.saveConversation( $scope.marker );
						if ( $scope.areConversationsDirty() ) {
							return;
						}
						if ( newValue ) {
							$timeout(
								function () {
									$scope.closeConversationPanel();
								},
								250
							);
						}
					}
				);
				$scope.$watch( "marker.isForDevelopment", function ( newValue, oldValue ) {
					if ( newValue !== oldValue ) {
						if ( $scope.marker.isSaved ) {
							$scope.saveConversation( $scope.marker );
						}
					}
				} );
				$scope.$watch( "marker.isPrivate", function ( newValue, oldValue ) {
					if ( newValue !== oldValue ) {
						if ( $scope.marker.isSaved ) {
							$scope.saveConversation( $scope.marker );
						}
					}
				} );
				$scope.$watch( "marker.isConversationPanelVisible", function ( newValue, oldValue ) {
					moveConversationPanelPosition( $scope.marker.x, $scope.marker.y );
					if ( newValue ) {
						$scope.isNotifySettingsVisible = !$scope.marker.isSaved;
						if ( $scope.marker.isSaved ) {
							var subscribers = $scope.marker.subscribers;
						} else {
							var subscribers = $scope.getDefaultUserIDs();
						}
						_.setProperty( $scope.projectMembers, "isNotify", false );
						_.setProperty( $scope.projectStakeholders, "isNotify", false );
						var selectedMembers = _.withPropertyRange( $scope.projectMembers, "id", subscribers );
						var selectedAffiliates = _.withPropertyRange( $scope.projectStakeholders, "id", subscribers );
						_.setProperty( selectedMembers, "isNotify", true );
						_.setProperty( selectedAffiliates, "isNotify", true );
						watchForDirtyComment();
					}
					if ( newValue !== oldValue ) {
						if ( $scope.marker.isSaved && newValue === false ) {
							$scope.markCommentsAsRead( $scope.marker );
							$scope.stopEditingComments();
							$scope.newComment = "";
							$scope.notifyOthers = "";
							$scope.marker.isConversationPanelVisible = false;
							$scope.isCommentInputVisible = false;
							$scope.isNotifySettingsVisible = false;
							$scope.showNotifyOthers = false;
						}
					}
					if ( !$scope.marker.isSaved && newValue === true ) {
						$scope.showCommentInput();
					}
					if ( newValue ) {
						$scope.scrollToMarker();
					}
				} );
				$scope.$on( "$destroy", function () {
					modelEvents.off( "commentAdded", handleCommentAdded );
					modelEvents.off( "commentUpdated", handleCommentUpdated );
					modelEvents.off( "commentDeleted", handleCommentDeleted );
					modelEvents.off( "conversationUpdated", handleConversationUpdated );
					modelEvents.off( "projectStakeholderRemoved", handleProjectStakeholderRemoved );
				} );
				$scope.$on(
					"autosizeResized",
					function ( event, textarea, newHeight, oldHeight ) {
						if ( textarea.attr( "name" ) !== "post-comment" ) {
							return;
						}
						var TOP_TOOLBAR_HEIGHT = 47;
						var BOTTOM_TOOLBAR_HEIGHT = 60;
						var win = $( $window );
						var windowHeight = win.height();
						var windowScrollTop = win.scrollTop();
						var viewportTop = ( windowScrollTop + TOP_TOOLBAR_HEIGHT );
						var viewportBottom = ( windowScrollTop + windowHeight - BOTTOM_TOOLBAR_HEIGHT );
						var form = element.find( ".comment-thread" );
						var formHeight = ( form.height() - textarea.height() + newHeight );
						var formTop = form.offset().top;
						var formBottom = ( formTop + formHeight );
						var hiddenFormHeight = ( formBottom - viewportBottom );
						if ( hiddenFormHeight <= 0 ) {
							return;
						}
						var textareaScollTop = ( textarea.offset().top - 5 );
						var targetViewportTop = ( viewportTop + hiddenFormHeight );
						if ( targetViewportTop > textareaScollTop ) {
							return;
						}
						$( "html, body" ).stop().animate( {
								scrollTop: ( windowScrollTop + hiddenFormHeight )
							},
							"fast"
						);
					}
				);
				modelEvents.on( "commentAdded", handleCommentAdded );
				modelEvents.on( "commentUpdated", handleCommentUpdated );
				modelEvents.on( "commentDeleted", handleCommentDeleted );
				modelEvents.on( "conversationUpdated", handleConversationUpdated );
				modelEvents.on( "projectStakeholderRemoved", handleProjectStakeholderRemoved );
				element.find( ".marker" ).draggable( {
					start: function ( event, ui ) {
						$scope.$apply( function () {
							dragStart( event, ui );
						} );
					},
					drag: function ( event, ui ) {
						$scope.$apply( function () {
							drag( event, ui );
						} );
					},
					stop: function ( event, ui ) {
						$scope.$apply( function () {
							dragStop( event, ui );
						} );
					}
				} );
			}
		};
	}
} )( angular, InVision );;;
/*! copy-to-clipboard.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invCopyToClipboard",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var $element = $( element ),
					$button = $element.find( "button" ),
					$copied = $element.find( ".copied" );
				if ( $button.length === 0 ) {
					$button = $element.find( "a.copy" );
				}
				ZeroClipboard.config( {
					debug: false
				} );
				var clip = new ZeroClipboard( $button, {
					moviePath: "/assets/zeroclipboard/ZeroClipboard.swf"
				} );
				clip.on( "complete", function ( clip, args ) {
					if ( $scope.startSuccessMessageWorkflow ) {
						$scope.$apply(
							function () {
								$scope.startSuccessMessageWorkflow();
							}
						);
						return;
					}
					$copied.show();
					$timeout( function () {
						$copied.hide();
					}, 4000 );
				} );
				$scope.$on(
					"$destroy",
					function () {
						clip.destroy();
					}
				);
			};
			return ( {
				link: linkFunction
			} );
		}
	);
} )( angular, InVision );;;
/*! document-click.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invDocumentClick", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var doc = $( document );
			var expression = attributes.invDocumentClick;
			var doNotRunOn = ( attributes.invDocumentClickDoNotRun || "" );
			doc.on(
				"mousedown.invDocumentClick",
				function ( event ) {
					var target = $( event.target );
					var targetIsSelfOrChild = ( element.is( target ) || ( element.has( target ).length > 0 ) );
					var checkException = ( doNotRunOn.length > 0 );
					var targetIsDoNotRunOn = !target.is( doNotRunOn );
					if ( !targetIsSelfOrChild ) {
						if ( checkException && targetIsDoNotRunOn ) {
							$scope.$apply( expression );
						}
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					doc.off( "mousedown.invDocumentClick" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! dyn-image-loader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invDynImageLoader", Directive );
	/** @ngInject */
	function Directive() {
		function link( $scope, element, attributes ) {
			var eventType = ( attributes.invImageLoadEvent || "imageLoaded" );
			element.on( "load.invDynImageLoader",
				function ( event ) {
					element.show();
				}
			);
			attributes.$observe(
				"src",
				function ( srcAttributes ) {
					element.hide();
				} );
			$scope.$on(
				"$destroy",
				function () {
					element.off( "load.invDynImageLoader" );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! dynamic-height-adjust.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invDynamicHeightAdjust", Directive );
	/** @ngInject */
	function Directive( $window ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var offset = element.attr( 'dynamic-height-offset' ) || 0;
			var win = $( window );

			function adjustMaxHeight() {
				var windowHeight = win.height() - offset;
				element.css( "max-height", windowHeight );
			}
			adjustMaxHeight();
			win.on( "resize.dynamicHeight", function () {
				adjustMaxHeight();
			} );
			$scope.$on(
				"$destroy",
				function () {
					win.off( "resize.dynamicHeight" );
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! enter.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invEnter", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var expression = attributes.invEnter;
			element.on(
				"keypress.invEnter",
				function ( event ) {
					if ( event.which === 13 ) {
						$scope.$apply( expression );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "keypress.invEnter" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! enterprise-company-branding-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invEnterpriseCompanyBrandingUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$scope.label = attributes.label;
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				if ( error.message == "File extension error." ) {
					$scope.openModalWindow(
						"error", ( "The file, \"" + error.file.name + ",\" is not the correct file type. Please make sure it is a vector file.  (.ai, .eps, .pdf, or .svg file)" )
					);
				}
				$scope.$apply(
					function () {
						uploader.splice();
						$scope.isUploading = false;
						$scope.$emit( "enterpriseCompanyVectorUploader:error", error );
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				if ( isUploading() ) {
					files.splice( 0, files.length );
					return;
				}
				files.splice( 1, files.length );
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.filename = ng.fromJson( response.response );
				$scope.$apply(
					function () {
						$scope.isUploading = false;
						uploader.removeFile( file );
						$scope.filename = ng.fromJson( response.response );
						$scope.$emit( "enterpriseCompanyVectorUploader:uploaded", company );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							$scope.isUploading = true;
							$scope.percentage = 0;
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						$scope.progress = file.percent;
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			$scope.isUploading = false;
			$scope.percentage = 0;
			var target = $( element );
			target.children( '.wrap' ).attr( 'id', target.attr( 'id' ) + "Button" );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/company/upload-vector",
				browse_button: target.children( '.wrap' ).attr( 'id' ),
				container: target.attr( 'id' ),
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				filters: [ {
					title: "Vector files",
					extensions: "ai,eps,pdf,svg,jpg,jpeg,gif,png"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.init();
			$( window ).on(
				"error.enterpriseCompanyVectorUploader",
				function ( event ) {
					if ( isFlashRuntime ) {
						return ( false );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "error.enterpriseCompanyVectorUploader" );
					target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/enterprise-company-branding-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! enterprise-company-logo-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invEnterpriseCompanyLogoUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$scope.$apply(
					function () {
						uploader.splice();
						$scope.isUploading = false;
						$scope.$emit( "enterpriseCompanyLogoUploader:error", error );
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				if ( isUploading() ) {
					files.splice( 0, files.length );
					return;
				}
				files.splice( 1, files.length );
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.$apply(
					function () {
						$scope.isUploading = false;
						uploader.removeFile( file );
						var company = ng.fromJson( response.response );
						$scope.$emit( "enterpriseCompanyLogoUploader:uploaded", company );
						modelEvents.trigger( "companyAccountUpdated", company );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							$scope.isUploading = true;
							$scope.percentage = 0;
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						$scope.progress = file.percent;
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			$scope.isUploading = false;
			$scope.percentage = 0;
			var target = $( element );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/company/upload-logo",
				browse_button: "enterpriseCompanyLogoUploaderButton",
				container: "enterpriseCompanyLogoUploaderContainer",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,pict,png,tiff"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.init();
			$( window ).on(
				"error.enterpriseCompanyLogoUploader",
				function ( event ) {
					if ( isFlashRuntime ) {
						return ( false );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "error.enterpriseCompanyLogoUploader" );
					target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/enterprise-company-logo-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! fade-show.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invFadeShow", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var duration = ( attributes.fadeduration || "fast" );
			var expression = attributes.invFadeShow;
			var delayShow = ( attributes.delayShow || 0 );
			if ( !$scope.$eval( expression ) ) {
				element.css( "display", "none" );
			}
			$scope.$watch(
				expression,
				function ( newValue, oldValue ) {
					var isVisible = element.is( ":visible" );
					var isHidden = !isVisible;
					var shouldShow = newValue;
					var shouldHide = !shouldShow;
					if ( shouldShow && isHidden ) {
						element
							.stop( true, true )
							.delay( delayShow )
							.fadeIn( duration );
					} else if ( shouldHide && isVisible ) {
						element
							.stop( true )
							.fadeOut( duration );
					} else if ( shouldHide ) {
						element.stop( true );
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! features-sidebar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invFeaturesSidebar", Directive );
	/** @ngInject */
	function Directive( _, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element ),
				$window = $( window ),
				topOffset = 230;

			function setSidebarHeight() {
				var _height = $window.height();
				$element.height( _height );
			}

			function startScrollbar() {
				$element
					.addClass( "fixed" )
					.perfectScrollbar( {
						wheelPropagation: true,
						suppressScrollX: true
					} );
			}

			function endScrollbar() {
				$element
					.removeClass( "fixed" )
					.scrollTop( 0 )
					.perfectScrollbar( "destroy" );
			}
			$timeout( function () {
				setSidebarHeight();
				$window.on( "scroll.feature-sidebar", function () {
					var $this = $( this );
					if ( $this.scrollTop() >= topOffset && !$element.hasClass( "fixed" ) ) {
						startScrollbar();
					} else if ( $this.scrollTop() <= topOffset && $element.hasClass( "fixed" ) ) {
						endScrollbar();
					}
				} );
			} );
			$scope.$watch( "featureAnnouncements", function () {
				$( ".title" ).on( "click", function ( e ) {
					e.preventDefault();
					$( "html, body" ).animate( {
						scrollTop: $( $( this ).attr( "href" ) ).offset().top - 40
					}, 250 );
				} );
			} );
			$window.on( "resize", function () {
				setSidebarHeight();
			} );
			$scope.$on( "$destroy", function () {
				$element.remove();
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! fill-height.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invFillHeight", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			$timeout( function () {
				$( element ).css( "min-height", $( attributes.fillTo ).height() );
			} );
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! focus.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invFocus", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			element.one(
				"focus.invFocus",
				function ( event ) {
					$scope.$apply( attributes.invFocus );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "focus.invFocus" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! follow-cursor-tooltip.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invFollowCursorToolip",
		function ( $document ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var $element = $( element );
				$scope.shouldShowCursorPointer = true;
				$document.on( "mousemove.cursorTooltip", function ( e ) {
					if ( !$( e.target ).is( attributes.showOn ) && attributes.showOn && !$( e.target ).is( $element ) ) {
						$element.css( "display", "none" );
						return;
					}
					var display = ( $scope.shouldShowCursorPointer ? "block" : "none" );
					$element.css( {
						"margin-left": e.pageX + 15,
						"margin-top": e.pageY - 10,
						"display": display
					} );
				} );
				$scope.$on(
					"$destroy",
					function () {
						$document.off( "mousemove.cursorTooltip" );
					}
				);
				$scope.$on( "showCursorTooltip", function () {
					$scope.shouldShowCursorPointer = true;
				} );
				$scope.$on( "hideCursorTooltip", function () {
					$scope.shouldShowCursorPointer = false;
				} );
			};
			return ( {
				link: linkFunction,
				restrict: "A",
				scope: false
			} );
		}
	);
} )( angular, InVision );;;
/*! google-map-loader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invGoogleMapLoader", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function init() {
				google.load(
					"maps",
					"3", {
						other_params: 'sensor=false',
						callback: function () {
							$.getScript( infoBoxURL )
								.done( function () {
									$scope.$broadcast( "googleMapsLoaded" );
								} )
								.fail( function () {
									$scope.openModalWindow( "error", "For some reason, we couldn't load your team's map. Try refreshing your browser." );
								} );
						}
					}
				);
			}
			var googleMapsApiURL = "https://maps.googleapis.com/maps/api/js?sensor=false&.js";
			var infoBoxURL = "/assets/google-maps-utility/infobox.js";
			var dom = {};
			dom.target = $( element );
			dom.head = $( "head" );
			var isInitialized = false;
			init();
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! group-name-input.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invGroupNameInput", Directive );
	/** @ngInject */
	function Directive( Debouncer ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var expression = attributes.invGroupNameInput,
				cancelExpression = attributes.invGroupNameCancel,
				applyDebounce = new Debouncer( Debouncer.ONE_SECOND );
			var executeExpression = function () {
				if ( applyDebounce.canProceed() ) {
					$scope.$apply( expression );
				}
			}
			var executeCancelExpression = function () {
				$scope.$apply( cancelExpression );
			}
			element.on(
				"keypress.invGroupNameInput",
				function ( event ) {
					if ( event.which === 13 ) {
						executeExpression();
					}
				}
			);
			element.on(
				"keyup.invGroupNameInput",
				function ( event ) {
					if ( event.which === 27 ) {
						executeCancelExpression();
					}
				}
			);
			element.on(
				"blur.invGroupNameInput",
				function ( event ) {
					executeExpression();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "keypress.invGroupNameInput" );
					element.off( "keyup.invGroupNameInput" );
					element.off( "blur.invGroupNameInput" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! history-overlay.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invHistoryOverlay", Directive );
	/** @ngInject */
	function Directive( _, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $window = $( window ),
				$comment = element.parent(),
				$icon = $comment.find( ".view-history" ),
				$thumbnail = element.find( "img" ),
				$buttons = element.find( "a" ),
				timer;
			$icon.on( "mouseenter.history.overlay", function () {
				timer = $timeout( function () {
					if ( ( element.offset().top - $window.scrollTop() ) <= 47 ) {
						element.addClass( "flip" );
					};
				}, 1 );
				element.stop().fadeIn( 250 );
			} );
			$comment.on( "mouseleave.history-overlay", function () {
				if ( element.is( "hover" ) ) {
					return;
				};
				element.stop().fadeOut( 250, function () {
					element.removeClass( "flip" );
				} );
			} );
			$scope.$on( "$destroy", function () {
				$icon.unbind( "mouseenter.history-overlay" );
				$comment.unbind( "mouseleave.history-overlay" );
				$buttons.unbind( "click.history-overlay" );
				$timeout.cancel( timer );
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! http-activity.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "inHttpActivity", Directive );
	/** @ngInject */
	function Directive( $timeout, httpActivityService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var delay = 250;
			var timer = null;
			var prepareToShowIndicator = function () {
				timer = $timeout( showIndicator, delay, false );
			};
			var showIndicator = function () {
				NProgress.start();
			};
			var hideIndicator = function () {
				$timeout.cancel( timer );
				NProgress.done();
			};
			$scope.$watch(
				function () {
					return ( httpActivityService.isActiveWithPost() );
				},
				function ( isActive ) {
					if ( isActive ) {
						prepareToShowIndicator();
					} else {
						hideIndicator();
					}
				}
			);
		};
		return ( linkFunction );
	}
} )( angular, InVision );;;
/*! i8n-telephone.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invI8nTelephone", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var defaultCountry = ( $scope[ attributes.countryCode ] || "us" );
			$( element ).intlTelInput( {
				defaultCountry: defaultCountry,
				americaMode: false,
				defaultStyling: true
			} );
			$scope.$watch(
				attributes.countryCode,
				function ( newValue ) {
					if ( newValue && newValue !== $( element ).intlTelInput( "getSelectedCountryData" ).iso2 ) {
						$( element ).intlTelInput( "selectCountry", newValue );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! ignore-uploader-link-click.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invIgnoreUploaderClick", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element );
			$element.on( "click", function ( e ) {
				window.location = $element.attr( "href" );
				e.preventDefault();
				return false;
			} );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! image-load-event.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invImageLoadEvent", Directive );
	/** @ngInject */
	function Directive( modelEvents ) {
		function link( $scope, element, attributes ) {
			var eventType = ( attributes.invImageLoadEvent || "imageLoaded" );
			element.on( "load.invImageLoadEvent",
				function ( event ) {
					applyDisplayScaleToThisImageElement();
					$scope.$apply(
						function () {
							$scope.$emit( eventType, element );
						} );
				}
			);

			function applyDisplayScaleToThisImageElement() {
				if ( $scope.screen.displayScale != 1 ) {
					element.css( {
						width: ( $scope.screen.width * $scope.screen.displayScale + 'px' ),
						height: ( $scope.screen.height * $scope.screen.displayScale + 'px' )
					} );
				} else {
					element.css( {
						width: "",
						height: ""
					} );
				}
			}
			$scope.$watch(
				"screen",
				function ( newValue, OldValue ) {
					if ( newValue != OldValue ) {
						if ( $scope.screen.displayScale == 1 ) {
							element.css( {
								width: "",
								height: ""
							} );
						}
					}
				} );
			$( window ).on( "resize.screenImage", function () {
				applyDisplayScaleToThisImageElement();
			} );
			modelEvents.on(
				"screenConfig:changed",
				function ( event, newConfig ) {
					applyDisplayScaleToThisImageElement();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "load.invImageLoadEvent" );
					$( window ).off( "resize.screenImage" );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! img-load-failure.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invImgLoadFailure", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			element.one(
				"error",
				function () {
					var expression = attributes.invImgLoadFailure;
					element.attr( "src", null );
					element.attr( "src", expression );
				} );
			$scope.$on(
				"$destroy",
				function () {
					element.off( "error.invImgLoadFailure" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			priority: 1
		} );
	}
} )( angular, InVision );;;
/*! infinite-scroll.js */
;;
( function ( ng, app ) {
	"use strict";
	/** @ngInject */
	app.directive(
		"invInfiniteScroll",
		function ( $timeout ) {
			/** @ngInject */
			var linkFunction = function ( $scope, element, attributes ) {
				function inspectContent() {
					var viewportTop = win.scrollTop();
					var viewportBottom = ( viewportTop + win.height() );
					var bottomOfElement = ( elementTop + element.height() - scrollOffsetBuffer );
					var bottomIsExposed = ( bottomOfElement <= viewportBottom );
					if ( bottomIsExposed ) {
						$scope.$eval( loadContentExpression );
					}
					return ( bottomIsExposed );
				}
				var doc = $( document );
				var win = $( window );
				var loadContentExpression = attributes.invInfiniteScroll;
				var elementTop = element.offset().top;
				var scrollOffsetBuffer = ( attributes.infiniteScrollOffsetBuffer || 200 );
				win.on(
					"scroll.invInfiniteScroll",
					function ( event ) {
						if ( inspectContent() ) {
							$scope.$apply();
						}
					}
				);
				win.on(
					"resize.invInfiniteScroll",
					function ( event ) {
						if ( inspectContent() ) {
							$scope.$apply();
						}
					}
				);
				$timeout( inspectContent );
				$scope.$on(
					"$destroy",
					function () {
						win.off( "resize.invInfiniteScroll" );
						win.off( "scroll.invInfiniteScroll" );
					}
				);
			};
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! lazier-src.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invLazierSrc", Directive );
	/** @ngInject */
	function Directive( $window, $document ) {
		var lazyLoader = ( function () {
			var images = [];
			var renderTimer = null;
			var renderDelay = 200;
			var win = $( $window );
			var windowHeight = null;
			var isWatchingWindow = false;

			function addImage( image ) {
				images.push( image );
				if ( !renderTimer ) {
					startRenderTimer();
				}
				if ( !isWatchingWindow ) {
					startWatchingWindow();
				}
			}

			function checkLayout() {
				if ( !renderTimer ) {
					startRenderTimer();
				}
				if ( !isWatchingWindow ) {
					startWatchingWindow();
				}
			}

			function removeImage( image ) {
				for ( var i = 0; i < images.length; i++ ) {
					if ( images[ i ] === image ) {
						images.splice( i, 1 );
						break;
					}
				}
				if ( !images.length ) {
					clearRenderTimer();
					stopWatchingWindow();
				}
			}

			function checkImages() {
				var visible = [];
				var hidden = [];
				if ( windowHeight === null ) {
					windowHeight = win.height();
				}
				var scrollTop = win.scrollTop();
				var topFoldOffset = scrollTop;
				var bottomFoldOffset = ( topFoldOffset + windowHeight );
				for ( var i = 0; i < images.length; i++ ) {
					var image = images[ i ];
					if ( image.isVisible( topFoldOffset, bottomFoldOffset ) ) {
						visible.push( image );
					} else {
						hidden.push( image );
					}
				}
				for ( var i = 0; i < visible.length; i++ ) {
					visible[ i ].render();
				}
				images = hidden;
				clearRenderTimer();
				if ( !images.length ) {
					stopWatchingWindow();
				}
			}

			function clearRenderTimer() {
				clearTimeout( renderTimer );
				renderTimer = null;
			}

			function keyPressed() {
				if ( !renderTimer ) {
					startRenderTimer();
				}
			}

			function startRenderTimer() {
				renderTimer = setTimeout( checkImages, renderDelay );
			}

			function startWatchingWindow() {
				isWatchingWindow = true;
				win.on( "resize.invLazierSrc", windowResized );
				win.on( "scroll.invLazierSrc", windowScrolled );
				$document.on( "keyup.invLazierSrc", keyPressed );
			}

			function stopWatchingWindow() {
				isWatchingWindow = false;
				win.off( "resize.invLazierSrc" );
				win.off( "scroll.invLazierSrc" );
				$document.off( "keyup.invLazierSrc" );
			}

			function windowResized() {
				windowHeight = win.height();
				if ( !renderTimer ) {
					startRenderTimer();
				}
			}

			function windowScrolled() {
				if ( !renderTimer ) {
					startRenderTimer();
				}
			}
			return ( {
				addImage: addImage,
				checkLayout: checkLayout,
				removeImage: removeImage
			} );
		} )();

		function LazyImage( element ) {
			this.element = element;
			this.offsetElement = this.element;
			this.source = null;
			this.rendered = false;
			this.height = null;
		}
		LazyImage.prototype = {
			isVisible: function ( topFoldOffset, bottomFoldOffset ) {
				if ( !this.offsetElement.is( ":visible" ) ) {
					return ( false );
				}
				if ( !this.height ) {
					while ( !( this.height = this.offsetElement.height() ) ) {
						this.offsetElement = this.offsetElement.parent();
					}
				}
				var top = this.offsetElement.offset().top;
				var bottom = ( top + this.height );
				return (
					(
						( top <= bottomFoldOffset ) &&
						( top >= topFoldOffset )
					) ||
					(
						( bottom <= bottomFoldOffset ) &&
						( bottom >= topFoldOffset )
					) ||
					(
						( top <= topFoldOffset ) &&
						( bottom >= bottomFoldOffset )
					)
				);
			},
			render: function () {
				this.rendered = true;
				this.renderSource();
			},
			renderSource: function () {
				this.element[ 0 ].src = this.source;
			},
			setSource: function ( newSource ) {
				this.source = newSource;
				if ( this.rendered ) {
					this.renderSource();
				}
			}
		};

		function handleIndexChange( newValue, oldValue ) {
			if ( newValue === oldValue ) {
				return;
			}
			lazyLoader.checkLayout();
		}

		function link( $scope, element, attributes ) {
			var lazyImage = new LazyImage( element );
			lazyLoader.addImage( lazyImage );
			attributes.$observe(
				"invLazierSrc",
				function ( newSource ) {
					lazyImage.setSource( newSource );
				}
			);
			if ( "$index" in $scope ) {
				$scope.$watch( "$index", handleIndexChange );
			}
			$scope.$on(
				"$destroy",
				function () {
					lazyLoader.removeImage( lazyImage );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! lazy-src.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invLazySrc", Directive );
	/** @ngInject */
	function Directive() {
		var pendingTimer = null;
		var pending = [];

		function dequeueHandler() {
			for ( var i = 0, length = pending.length; i < length; i++ ) {
				pending[ i ]();
			}
			pendingTimer = null;
			pending = [];
		}

		function queueHandler( handler ) {
			pending.push( handler );
			if ( !pendingTimer ) {
				pendingTimer = setTimeout( dequeueHandler, 100 );
			}
		}

		function isElementVisible( element ) {
			if ( !element.is( ":visible" ) ) {
				return ( false );
			}
			var bottomOfScreen = ( win.height() + win.scrollTop() );
			return ( element.offset().top < bottomOfScreen );
		}
		var win = $( window );
		var doc = $( document );
		var link = function ( $scope, element, attributes ) {
			function examineImage() {
				if ( isElementVisible( element ) ) {
					showImage();
					stopMonitoring();
				}
			}

			function handleWatchCallback( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				examineImage();
			}

			function setupMonitoring() {
				if ( isElementVisible( element ) ) {
					return ( showImage() );
				}
				startMonitoring();
			}

			function showImage() {
				element.prop( "src", src );
				isVisible = true;
			}

			function startMonitoring() {
				isMonitoring = true;
				win.on( "resize", examineImage );
				win.on( "scroll", examineImage );
				watchDocumentHeight();
				watchLazyExpression();
			}

			function stopMonitoring() {
				isMonitoring = false;
				win.off( "resize", examineImage );
				win.off( "scroll", examineImage );
				unbindLazyWatch();
				unbindDocumentWatch();
			}

			function watchDocumentHeight() {
				unbindDocumentWatch = $scope.$watch(
					function () {
						return ( doc.height() )
					},
					handleWatchCallback
				);
			}

			function watchLazyExpression() {
				if ( !attributes.lazyWatch ) {
					return;
				}
				unbindLazyWatch = $scope.$watch( attributes.lazyWatch, handleWatchCallback );
			}
			var src = null;
			var isMonitoring = false;
			var isVisible = false;
			var unbindLazyWatch = ng.noop;
			var unbindDocumentWatch = ng.noop;
			attributes.$observe(
				"invLazySrc",
				function ( interpolatedSource ) {
					src = interpolatedSource;
					if ( isVisible ) {
						return ( showImage() );
					}
					if ( isMonitoring ) {
						return;
					}
					queueHandler( setupMonitoring );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					win.off( "resize", examineImage );
					win.off( "scroll", examineImage );
				}
			);
		};
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! line-chart.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invLineChart", Directive );
	/** @ngInject */
	function Directive( $, moment, _ ) {
		function createPrettyAxis( minimumValue, maxiumumValue ) {
			var ticksArray = [ 0, 1, 2 ];
			if ( maxiumumValue === 0 || maxiumumValue === 1 ) {
				ticksArray = [ 0, 1, 2 ];
			}
			if ( maxiumumValue > 1 && maxiumumValue < 4 ) {
				ticksArray = [ 0, 2, 4 ];
			}
			if ( maxiumumValue >= 4 && maxiumumValue < 6 ) {
				ticksArray = [ 0, 2, 4, 6 ];
			}
			if ( maxiumumValue >= 6 && maxiumumValue < 8 ) {
				ticksArray = [ 0, 4, 8 ];
			}
			if ( maxiumumValue >= 8 && maxiumumValue < 10 ) {
				ticksArray = [ 0, 5, 10 ];
			}
			if ( maxiumumValue >= 10 && maxiumumValue < 20 ) {
				ticksArray = [ 0, 10, 20 ];
			}
			if ( maxiumumValue >= 20 && maxiumumValue < 30 ) {
				ticksArray = [ 0, 10, 20, 30 ];
			}
			if ( maxiumumValue >= 30 && maxiumumValue < 40 ) {
				ticksArray = [ 0, 20, 40 ];
			}
			if ( maxiumumValue >= 40 && maxiumumValue < 60 ) {
				ticksArray = [ 0, 20, 40, 60 ];
			}
			if ( maxiumumValue >= 60 && maxiumumValue < 80 ) {
				ticksArray = [ 0, 40, 80 ];
			}
			if ( maxiumumValue >= 80 && maxiumumValue < 90 ) {
				ticksArray = [ 0, 30, 60, 90 ];
			}
			if ( maxiumumValue >= 90 && maxiumumValue < 120 ) {
				ticksArray = [ 0, 40, 80, 120 ];
			}
			if ( maxiumumValue >= 120 && maxiumumValue < 150 ) {
				ticksArray = [ 0, 50, 100, 150 ];
			}
			if ( maxiumumValue >= 150 && maxiumumValue < 200 ) {
				ticksArray = [ 0, 100, 200 ];
			}
			if ( maxiumumValue >= 200 && maxiumumValue < 300 ) {
				ticksArray = [ 0, 100, 200, 300 ];
			}
			if ( maxiumumValue >= 300 && maxiumumValue < 400 ) {
				ticksArray = [ 0, 200, 400 ];
			}
			if ( maxiumumValue >= 400 && maxiumumValue < 600 ) {
				ticksArray = [ 0, 300, 600 ];
			}
			if ( maxiumumValue >= 600 && maxiumumValue < 1000 ) {
				ticksArray = [ 0, 500, 1000 ];
			}
			if ( maxiumumValue >= 1000 && maxiumumValue < 1600 ) {
				ticksArray = [ 0, 800, 1600 ];
			}
			if ( maxiumumValue >= 1600 && maxiumumValue < 2000 ) {
				ticksArray = [ 0, 1000, 2000 ];
			}
			if ( maxiumumValue >= 2000 && maxiumumValue < 3000 ) {
				ticksArray = [ 0, 1000, 2000, 3000 ];
			}
			if ( maxiumumValue >= 3000 && maxiumumValue < 5000 ) {
				ticksArray = [ 0, 2500, 5000 ];
			}
			if ( maxiumumValue >= 5000 && maxiumumValue < 8000 ) {
				ticksArray = [ 0, 4000, 8000 ];
			}
			if ( maxiumumValue >= 8000 && maxiumumValue < 12000 ) {
				ticksArray = [ 0, 4000, 8000, 12000 ];
			}
			return ticksArray;
		}
		/** @ngInject */
		var linkFunction = function ( $scope, element, attributes ) {
			/*
[
[
[ new Date(), value ],
[ new Date(), value2 ]
]
]
*/
			var data = $scope[ attributes.ngModel ];
			$scope.$watch( attributes.ngModel, function ( newData, oldData ) {
				drawGraph( element, newData );
			} );
		};

		function formatTimeByDayOfWeek( val, axis ) {
			var days = [ 'SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT' ];
			return days[ moment().utc( val ).day() ];
		}

		function drawGraph( element, data ) {
			var viewData = _.pluck( data, "views" );
			var minValue = _.min( viewData );
			var maxValue = _.max( viewData );
			var transformedData = _.map( data, function ( datum ) {
				return [
					moment.utc( datum.startedAt ),
					datum.views
				];
			} );
			if ( viewData.length == 1 ) {
				options.xaxis.tickSize = null;
				options.xaxis.minTickSize = null;
				options.xaxis.timeformat = "%b %d";
				options.tooltipOpts.content = "%y.0 views on %x";
				options.xaxis.tickFormatter = formatTimeByDayOfWeek;
			}
			if ( viewData.length >= 2 ) {
				options.xaxis.tickSize = [ 1, "day" ];
				options.xaxis.minTickSize = [ 1, "day" ];
				options.xaxis.timeformat = "%d %b";
				options.tooltipOpts.content = "%y.0 views on %x";
				options.xaxis.tickFormatter = formatTimeByDayOfWeek;
			}
			if ( viewData.length > 7 && viewData.length <= 60 ) {
				options.xaxis.minTickSize = [ 7, "day" ];
				options.xaxis.tickSize = [ 7, "day" ];
				options.xaxis.timeformat = "%b %d";
				options.tooltipOpts.content = "%y.0 views during the week of %x";
				options.xaxis.tickFormatter = null;
				var groupedByWeek = _.groupBy( transformedData, function ( datum ) {
					var momentObj = datum[ 0 ];
					return momentObj.startOf( "week" );
				} );
				var mappedData = _.map( groupedByWeek, function ( weekData, startOfWeek ) {
					return [
						moment( startOfWeek ),
						_.reduce( weekData, function ( sum, data, key ) {
							return sum + data[ 1 ];
						}, 0 )
					];
				} );
				transformedData = mappedData.slice( 0, 8 );
				maxValue = _.max( transformedData, function ( datum ) {
					return datum[ 1 ];
				} )[ 1 ];
			}
			if ( viewData.length > 60 ) {
				options.xaxis.minTickSize = [ 1, "month" ];
				options.xaxis.tickSize = [ 1, "month" ];
				options.xaxis.timeformat = "%b '%y";
				options.tooltipOpts.content = "%y.0 views during %x";
				options.xaxis.tickFormatter = null;
				var groupedByMonth = _.groupBy( transformedData, function ( datum ) {
					var momentObj = datum[ 0 ];
					return momentObj.startOf( "month" );
				} );
				var mappedData = _.map( groupedByMonth, function ( monthData, startOfMonth ) {
					return [
						moment( startOfMonth ),
						_.reduce( monthData, function ( sum, data, key ) {
							return sum + data[ 1 ];
						}, 0 )
					];
				} );
				transformedData = mappedData.slice( 0, 8 );
				maxValue = _.max( transformedData, function ( datum ) {
					return datum[ 1 ];
				} )[ 1 ];
			}
			options.yaxis.ticks = createPrettyAxis( minValue, maxValue );
			var augmentedData = [ transformedData ];
			$.plot( element, augmentedData, options );
			element.show();
		}
		var options = {
			grid: {
				borderWidth: 0,
				borderColor: "#ccc",
				margin: 0,
				labelMargin: 20,
				hoverable: true
			},
			xaxis: {
				tickLength: 0,
				color: '#999999',
				mode: "time",
				timeformat: "%b %d"
			},
			yaxis: {
				color: '#999999',
				min: 0,
				ticks: createPrettyAxis( 0, 10 ),
				tickFormatter: function ( val, axis ) {
					if ( val === 0 ) {
						return "";
					} else {
						return val.toFixed( axis.tickDecimals );
					}
				}
			},
			series: {
				lines: {
					show: true,
					fill: true,
					lineWidth: 3
				},
				points: {
					show: true,
					radius: 5,
					lineWidth: 0,
					fill: true,
					fillColor: "#58A2EC"
				}
			},
			colors: [ "#BEDCF6" ],
			shadowSize: 0,
			tooltip: true,
			tooltipOpts: {
				content: "%y.0 views on %x",
				defaultTheme: true,
				shifts: {
					x: 0,
					y: -50
				}
			}
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! loading.js */
;;
/**
 * Loading directive to display loading animation.
 * Usage: <span loding="isLoading"></span>
 */
angular.module( 'InVision' )
	.directive( 'loading', function () {
		return {
			restrict: 'AE',
			replace: true,
			template: '<div class="loader" ng-show="isLoading">' +
				'<div class="spinner">' +
				'<div class="bounce1"></div>' +
				'<div class="bounce2"></div>' +
				'<div class="bounce3">' +
				'</div></div></div>',
			scope: {
				isLoading: '=loading'
			}
		}
	} );;;
/*! map-info-box.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invMapInfoBox", Directive );
	/** @ngInject */
	function Directive( $parse, $compile ) {
		var infoWindowEvents = 'closeclick content_change domready ' +
			'position_changed zindex_changed';
		var options = {};

		function bindMapEvents( scope, eventsStr, googleObject, element ) {
			angular.forEach(
				eventsStr.split( ' ' ),
				function ( eventName ) {
					var $event = {
						type: 'map-' + eventName
					};
					google.maps.event.addListener(
						googleObject,
						eventName,
						function ( evt ) {
							element.trigger( angular.extend( {}, $event, evt ) );
							if ( !scope.$$phase ) scope.$apply();
						}
					);
				}
			);
		}
		var linkFunction = function ( scope, elm, attrs ) {
			var opts = angular.extend( {}, options, scope.$eval( attrs.uiOptions ) );
			opts.content = elm[ 0 ];
			var model = $parse( attrs.invMapInfoBox );
			var infoWindow = model( scope );
			if ( !infoWindow ) {
				infoWindow = new InfoBox( opts );
				model.assign( scope, infoWindow );
			}
			bindMapEvents( scope, infoWindowEvents, infoWindow, elm );
			/* The info window's contents dont' need to be on the dom anymore,
google maps has them stored.  So we just replace the infowindow element
with an empty div. (we don't just straight remove it from the dom because
straight removing things from the dom can mess up angular) */
			elm.replaceWith( '<div></div>' );
			var _open = infoWindow.open;
			infoWindow.open = function open( a1, a2, a3, a4, a5, a6 ) {
				$compile( elm.contents() )( scope );
				_open.call( infoWindow, a1, a2, a3, a4, a5, a6 );
			};
		}
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! mobile-simulated-loading-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invMobileSimulatedLoadingScreen",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				$timeout( function hideLoadingScreen() {
					element.fadeOut( 400 );
					$scope.setHasShownSimulatedMobileLoadingScreen( true );
				}, 2000 );
				$scope.$on(
					"relaunchMobileApp",
					function ( event, screenID ) {
						element.show();
						$timeout( function hideLoadingScreen() {
							element.fadeOut( 600 );
							$scope.setHasShownSimulatedMobileLoadingScreen( true );
						}, 1000 );
					}
				);
			}
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! mobile-skin.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invMobileSkin", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var positionSkin = function () {
				var winHeight = $( window ).height();
				var bottomBarHeight = 52;
				var winWidth = $( window ).height();
				var skinHeight = $( element ).height();
				var shadowHeight = 25; // This is the height of the shaddow at the bottom of the skin
				if ( ( skinHeight - shadowHeight + 25 ) >= ( winHeight - bottomBarHeight ) ) {
					var topMargin = "25px";
					var bottomMargin = "0px";
				} else {
					var topMargin = ( winHeight - bottomBarHeight - skinHeight + shadowHeight ) / 2;
					var bottomMargin = winHeight - topMargin - skinHeight - shadowHeight;
					bottomMargin = bottomMargin > 0 ? bottomMargin : 0;
				}
				$( element ).css( {
					"margin-top": topMargin,
					"margin-bottom": bottomMargin
				} );
			}
			$timeout( function () {
				positionSkin();
			} );
			$( window ).on( "resize.mobileSkin", positionSkin );
			$scope.$on(
				"mobileSkinChanged",
				function changeMobileSkin( event ) {
					$timeout( function () {
						positionSkin();
					} );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "resize.mobileSkin" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! mobile-skins-viewport.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invMobileSkinsViewport", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$timeout( function () {
				if ( applyScroll() ) {
					$( element ).niceScroll( {
						cursordragontouch: true,
						bouncescroll: true,
						mousescrollstep: 20,
						touchbehavior: true,
						horizrailenabled: false,
						enablekeyboard: false,
						railpadding: {
							top: ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) + 3,
							right: 2,
							left: 0,
							bottom: ( $scope.screen.fixedFooterHeight * $scope.screen.displayScale ) + 3
						}
					} );
				}
			} );
			$scope.$parent.getMobileViewportScrollPosition = function () {
				return $( element ).scrollTop();
			}
			$scope.$parent.scrollMobileViewport = function ( scrollPosition, animateTime ) {
				$( element ).animate( {
						scrollTop: scrollPosition
					},
					animateTime
				);
			}
			var applyScroll = function () {
				var renderedScreenHeight = $scope.screen.height * $scope.screen.displayScale;
				var viewportHeight = element.height();
				var sizeDifference = viewportHeight - renderedScreenHeight;
				var threshold = 3;
				if ( Math.abs( sizeDifference ) > threshold && // There is a significant different size between the image and the viewport
					sizeDifference < 0 //screen image is larger than the viewport
				) {
					return true; // apply the scrollbars
				} else {
					return false // do not apply the scrollbars
				}
			};
			$scope.$on(
				"$destroy",
				function () {
					if ( applyScroll() ) {
						$( element ).getNiceScroll().remove();
					}
				}
			);
			$scope.$watch(
				"screen",
				function ( newValue, oldValue ) {
					$timeout( function () {
						if ( newValue != oldValue ) {
							$( element ).getNiceScroll().remove();
							if ( applyScroll() ) {
								$( element ).niceScroll( {
									cursordragontouch: true,
									bouncescroll: true,
									mousescrollstep: 20,
									touchbehavior: true,
									horizrailenabled: false,
									enablekeyboard: false,
									railpadding: {
										top: ( $scope.screen.fixedHeaderHeight * $scope.screen.displayScale ) + 3,
										right: 0,
										left: 0,
										bottom: ( $scope.screen.fixedFooterHeight * $scope.screen.displayScale ) + 3
									}
								} );
							}
						}
					} );
				} );
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! mobile-slicer-transparency-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invMobileSlicerTransparencyHelper", Directive );
	/** @ngInject */
	function Directive() {
		var cachedColors = {};

		function link( $scope, element, attributes ) {
			var screenImage = element.find( "img" )
			screenImage.on( "load.invSlicerTransparencyHelper",
				function ( event ) {
					var image = $( this );
					var imageSrc = image.attr( "src" );
					getImageColorAtCoodinates(
						imageSrc, [ {
							x: 1,
							y: $scope.screen.fixedHeaderHeight + 2
						}, {
							x: 1,
							y: $scope.screen.height - $scope.screen.fixedFooterHeight - 2
						} ],
						function applyColors( colors ) {
							if ( imageSrc !== image.attr( "src" ) ) {
								return;
							}
							var headerColor = colors[ 0 ];
							var footerColor = colors[ 1 ];
							element.css( {
								"border-top-color": headerColor,
								"border-bottom-color": footerColor
							} );
							element.parent().css( {
								"background-color": footerColor
							} );
							image = imageSrc = null;
						}
					);
				}
			);
			$scope.$watch(
				"screen",
				function ( newValue, OldValue ) {
					if ( newValue != OldValue ) {}
				} );

			function getImageColorAtCoodinates( imageUrl, coordinates, callback ) {
				if ( imageUrl in cachedColors ) {
					return ( callback( cachedColors[ imageUrl ] ) );
				}
				var colors = [];
				var image = new Image();
				image.crossOrigin = "Anonymous";
				image.onload = function () {
					var canvas = document.createElement( "canvas" );
					canvas.width = image.width;
					canvas.height = image.height;
					var ctx = canvas.getContext( "2d" );
					ctx.drawImage( image, 0, 0 );
					var imageData = ctx.getImageData( 0, 0, canvas.width, canvas.height );
					for ( var i = 0; i < coordinates.length; i++ ) {
						var xCoord = coordinates[ i ].x;
						var yCoord = coordinates[ i ].y;
						var index = ( 4 * ( yCoord * imageData.width + xCoord ) );
						var r = imageData.data[ index ];
						var g = imageData.data[ index + 1 ];
						var b = imageData.data[ index + 2 ];
						var a = imageData.data[ index + 3 ];
						colors.push( "rgba(" + r + "," + g + "," + b + "," + a + ")" );
					}
					callback( cachedColors[ imageUrl ] = colors );
					imageUrl = coordinates = callback = colors = image = null;
				};
				image.src = imageUrl;
			}
			$scope.$on(
				"$destroy",
				function () {
					element.off( "load.invSlicerTransparencyHelper" );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! mobile-transition-layer.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invMobileTransitionLayer",
		function ( $timeout ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var transitionLayerInner = element.find( ".transitionLayerInner" );
				var currentScreenImage = transitionLayerInner.find( ".currentScreen" );
				var currentScreenFixedHeader = transitionLayerInner.find( ".currentScreenFixedHeader" );
				var currentScreenFixedFooter = transitionLayerInner.find( ".currentScreenFixedFooter" );
				var targetScreenImage = transitionLayerInner.find( ".targetScreen" );
				var currentScrollPostition = $scope.getMobileViewportScrollPosition();
				var animationTime = 600;
				switch ( $scope.transitionData.transitionTypeID ) {
				case 2:
					pushRight();
					animationTime = 400; //+100 ms from actual animation time
					break;
				case 3:
					pushLeft();
					animationTime = 400; //+100 ms from actual animation time
					break;
				case 4:
					slideUp();
					animationTime = 400; //+100 ms from actual animation time
					break;
				case 5:
					slideDown();
					animationTime = 400; //+100 ms from actual animation time
					break;
				case 6:
					flipRight();
					break;
				case 7:
					flipLeft();
					break;
				case 8:
					dissolve();
					animationTime = 400; //+100 ms from actual animation time
					break;
				}

				function pushRight() {
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenImage.show().addClass( "front slide out reverse" );
					targetScreenImage.show().addClass( "back slide in reverse" );
				}

				function pushLeft() {
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenImage.show().addClass( "front slide out" );
					targetScreenImage.show().addClass( "back slide in" );
				}

				function slideUp() {
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenImage.addClass( "back" );
					currentScreenImage.show();
					targetScreenImage.addClass( "front" )
					targetScreenImage.show();
					targetScreenImage.addClass( "slideup in" );
				}

				function slideDown() {
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					targetScreenImage.addClass( "back" )
					targetScreenImage.show();
					currentScreenImage.addClass( "front" );
					currentScreenImage.show();
					currentScreenImage.addClass( "slideup out reverse" );
				}

				function flipRight() {
					transitionLayerInner.addClass( "viewport-flip" );
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenImage.show().addClass( "flip out" );
					setTimeout( function () {
						targetScreenImage.show().addClass( "flip in" );
					}, 200 );
				}

				function flipLeft() {
					transitionLayerInner.addClass( "viewport-flip" );
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenImage.show().addClass( "flip out reverse" );
					setTimeout( function () {
						targetScreenImage.show().addClass( "flip in reverse" );
					}, 200 );
				}

				function dissolve() {
					currentScreenImage.css( {
						top: ( currentScrollPostition * -1 ) + "px"
					} );
					currentScreenFixedHeader.css( {
						display: "block"
					} );
					currentScreenFixedFooter.css( {
						display: "block"
					} );
					currentScreenImage.addClass( "front" );
					currentScreenImage.show();
					transitionLayerInner.fadeOut( 400 );
				}
				$timeout( function () {
					$scope.setIsTransitioning( false );
					currentScreenImage.css( {
						top: 0,
						display: "none"
					} );
					currentScreenImage.removeClass( "back front in out reverse slide flip slipedown slideup" );
					currentScreenImage.hide();
					targetScreenImage.css( {
						top: 0,
						display: "none"
					} );
					targetScreenImage.removeClass( "back front in out reverse slide flip slidedown slideup" );
					targetScreenImage.hide();
					transitionLayerInner.removeClass( "viewport-flip" );
					transitionLayerInner.show();
				}, animationTime );
			};
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! modal.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invModal", Directive );
	/** @ngInject */
	function Directive( $timeout, $window, modalWindowRequest ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element ),
				$win = $( window ),
				isClosedByPlugin = true,
				modalType = ( attributes.invModalType || "top" ),
				settings = !modalWindowRequest.isSuppressClose() ? {} : {
					keyboard: false,
					backdrop: "static"
				};
			if ( modalWindowRequest.isSuppressFade() && $element.is( ".animate" ) ) {
				$element.removeClass( "animate" );
				$element.on(
					"shown.invModal",
					function () {
						$element.add( "div.modal-backdrop" ).addClass( "animate-in" );
					}
				);
			}
			$element
				.addClass( "modal" )
				.modal( settings );
			$( ".modal-backdrop" ).addClass( "animate-in " + $element.attr( "id" ) );
			setModalPosition();

			function forcePositive( number ) {
				return number < 0 ? 0 : number;
			}

			function setModalPosition() {
				$timeout( function () {
					var newCSS = {
						top: $win.scrollTop(),
						left: $win.scrollLeft(),
						marginLeft: forcePositive( Math.round( ( $win.outerWidth() - $element.outerWidth() ) / 2 ) ),
						marginTop: forcePositive( Math.round( ( $win.outerHeight() - $element.outerHeight() ) / 2 ) )
					};
					$element.css( newCSS ).attr( "tabindex", -1 ).addClass( "animate-in" );
				} );
			}
			$element.on(
				"hidden.invModal",
				function () {
					$scope.$emit( "modalWindowHidden" );
					$timeout( ng.noop );
				}
			);
			$element.on(
				"shown.invModal",
				function () {
					if ( modalType !== "top" ) {
						return;
					}
					setModalPosition();
					$scope.$emit( "modalWindowShown" );
				}
			);
			$win.on( "resize.invModal", function modalResize() {
				setModalPosition();
			} );
			$scope.$on(
				"resizeModal",
				function () {
					setModalPosition();
				}
			);
			$scope.$on(
				"closeModalWindowWithoutFade",
				function () {
					$scope.closeModalWindow( true );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$win.off( "resize.invModal" );
					$element.off( "hide.invModal" );
					$element.off( "hidden.invModal" );
					$element.off( "shown.invModal" );
					$element.removeClass( "animate-in" );
					$element.removeClass( "animate-out" );
				}
			);
			$scope.closeModalWindow = function ( suppressFade ) {
				isClosedByPlugin = false;
				if ( suppressFade ) {
					$( ".modal-backdrop" ).removeClass( "animate-in" );
					$element.modal( "hide" );
				} else {
					$element.addClass( "animate-out" );
					$( ".modal-backdrop" ).removeClass( "animate-in" );
					$timeout( function closeModal() {
						$element.modal( "hide" );
					}, 200 );
				}
			};
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! new-features-bar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invNewFeaturesBar", Directive );
	/** @ngInject */
	function Directive( _, $timeout, Deferred, accountService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $container = $( element ),
				$wrapper = $container.parent();
			$scope.$parent.$watch( "shouldShowNewFeatureLink", function ( a, b ) {
				if ( a !== false ) {
					return;
				};
				$wrapper.removeClass( "has-new-feature" );
			} );
			$scope.dismissThisAnnouncement = function ( announcement ) {
				var cookie = $.cookie( "announcementIDsDismissed" ),
					cookie = _.isUndefined( cookie ) ? "" : cookie,
					announcementIDsDismissed = [],
					hasVisibleAnnouncements = 0;
				if ( cookie !== "" ) {
					announcementIDsDismissed = _.map( cookie.split( "," ), function ( i ) {
						return parseInt( i );
					} );
				}
				announcement.isHidden = true;
				hasVisibleAnnouncements = ( !_.isUndefined( _.find( $scope.announcements, {
					"isHidden": false
				} ) ) );
				announcementIDsDismissed.push( announcement.id );
				$.cookie.raw = true;
				$.cookie( "announcementIDsDismissed", announcementIDsDismissed.join( "," ), {
					expires: 7 * 365
				} );
				$.cookie.raw = false;
				if ( !hasVisibleAnnouncements ) {
					$scope.$emit( "allFeatureAnnouncementsHidden" );
					Deferred.handlePromise(
						accountService.updateFeatureAnnouncementsLastViewedAt(
							moment.utc().format( "YYYY-MM-DD HH:mm:ss" )
						),
						function ( response ) {},
						function ( response ) {}
					);
				}
			};
			$scope.$on( "$destroy", function () {} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! new-share-form.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invNewShareForm", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element );

			function handleEmailAddressesKeyPress( event ) {
				if ( !isEnterKeyEvent( event ) ) {
					return;
				}
				$scope.$apply( $scope.sendEmail );
			}

			function handleKeyChange() {
				$element.find( ".zeroClipboardText" ).select();
			}

			function handlePhoneNumberKeyPress( event ) {
				if ( !isEnterKeyEvent( event ) ) {
					return;
				}
				$scope.$apply( $scope.sendSMS );
			}

			function handleShareMethodViewChange() {
				switch ( $scope.shareSubview ) {
				case "url":
					$element.find( "#shortlink" ).select();
					break;
				case "sms":
					$element.find( "#phonenumber" ).on( "keypress.invNewShareForm", handlePhoneNumberKeyPress );
					break;
				case "email":
					$element.find( "#emailaddress" ).focus();
					$element.find( "#emailaddress" ).on( "keypress.invNewShareForm", handleEmailAddressesKeyPress );
					break;
				}
			}

			function isEnterKeyEvent( event ) {
				return ( event.which === 13 );
			}
			$scope.$watch(
				"isLoading",
				function ( isLoading ) {
					if ( !isLoading ) {
						$scope.$emit( "resizeModal" );
					}
				}
			);
			$scope.$watch(
				"form.key",
				function ( newKey ) {
					if ( $scope.isLoading || ( $scope.shareSubview !== "url" ) ) {
						return;
					}
					$timeout( handleKeyChange );
				}
			);
			$scope.$watch(
				"shareSubview",
				function ( newValue ) {
					if ( $scope.isLoading ) {
						return;
					}
					$timeout( handleShareMethodViewChange );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$element.find( "#phonenumber" ).off( "keypress.invNewShareForm" );
					$element.find( "#emailaddress" ).off( "keypress.invNewShareForm" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! nicescroll.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invNicescroll", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$timeout( function () {
				_.defaults( attributes, {
					cursorwidth: 8,
					cursorcolor: "#000000",
					cursoropacitymin: 0,
					cursoropacitymax: 1,
					background: ""
				} );
				target.niceScroll( attributes );
			}, 500 );
			var target = $( element );
			$scope.$watch(
				function () {
					return ( target.height() );
				},
				function ( newValue ) {
					target.getNiceScroll().onResize();
				}
			);
			$scope.$on(
				"modalWindowShown",
				function () {
					target.getNiceScroll().onResize();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.getNiceScroll().remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! non-bubbling-click.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invNonBubblingClick", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			function handleClick( event ) {
				event.stopPropagation();
			}
			element.on( "click.invNonBubblingClick", handleClick );
			$scope.$on(
				"$destroy",
				function () {
					element.off( "click.invNonBubblingClick" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! notify-text.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invNotifyText", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var notifyNames = "0 people",
				notifyOthers = "";

			function setText( names, others ) {
				element[ 0 ].innerText = "Send notification to " + names + " " + others;
			}
			attributes.$observe( "names", function ( value ) {
				value = value || "0 people";
				notifyNames = value;
				setText( value, notifyOthers );
			} );
			attributes.$observe( "others", function ( value ) {
				value = value - 1;
				var text = value <= 0 ? "" : "& " + value + " other" + ( value > 1 ? "s" : "" );
				notifyOthers = text;
				setText( notifyNames, text );
			} );
		};
		return ( {
			link: linkFunction,
			restrict: 'A',
			scope: true
		} );
	}
} )( angular, InVision );;;
/*! perfect-scrollbar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPerfectScrollbar", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element );
			$timeout( function () {
				$element.perfectScrollbar( {
					wheelSpeed: 20,
					wheelPropagation: true,
					suppressScrollX: true
				} );
			} );
			$scope.$on(
				"$destroy",
				function () {
					$element.perfectScrollbar( "destroy" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! prevent-submit.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPreventSubmit", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var isEnterKeyEvent = function ( event ) {
				return ( event.which === 13 );
			};
			var target = $( element );
			target.on(
				"keypress.invPreventSubmit",
				function ( event ) {
					if ( isEnterKeyEvent( event ) ) {
						event.preventDefault();
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "keypress.invPreventSubmit" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! preview-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPreviewScreen", Directive );
	/** @ngInject */
	function Directive( $, _, $window, $timeout, $anchorScroll, hotspotService, modelEvents, screenService ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				$scope.$parent.maintainScrollPositionOnNextScreenLoad = function () {
					isMaintainScrollPosition = true;
				};
				$scope.$parent.openScreenAsOverlay = function ( screen ) {
					var screen = $scope.applyScreenDisplayScaleToScreen( screen );
					if ( $scope.overlayScreen.id != screen.id ) {
						var overlayImage = "/screens/" + screen.id + "/" + screen.imageVersion;
						var overlayHotspots = hotspotService.getByScreenID( screen.id );
						var overlayScreen = screen;
						$scope.setupOverlay( overlayImage, overlayHotspots, overlayScreen );
					}
				};
				$scope.$parent.setIsHotspotNavigation = function ( value ) {
					isHotspotNavigation = value;
				};
				$scope.hasOverlay = function () {
					return $scope.$parent.overlayImage.length > 0 ? true : false;
				}

				function onMousedown( event ) {
					event.preventDefault();
					if ( !$( event.target ).hasClass( 'hotspotOverlay' ) ) {
						flashHotspots();
					}
					return false;
				}

				function onKeydown( event ) {
					if ( event.shiftKey || event.ctrlKey ) {
						element.closest( "#preview" ).find( ".hotspotOverlay" ).addClass( "show" );
					}
				}

				function onKeyup( event ) {
					element.closest( "#preview" ).find( ".hotspotOverlay" ).removeClass( "show" );
				}

				function flashHotspots() {
					var hotspots = element.closest( "#preview" ).find( ".hotspotOverlay" );
					hotspots.stop( true ).fadeTo( 300, 1 ).delay( 300 ).fadeTo( 300, 0 );
				}

				function scrollScreenToAlignment( screenID, isConfigChange ) {
					var screen = _.findWithProperty( $scope.screens, "id", screenID );
					var screenAlignment = screen.alignment;
					var screenWidth = screen.width * screen.displayScale;
					var screenHeight = screen.height * screen.displayScale;
					var windowHeight = jqWindow.height();
					var windowWidth = jqWindow.width();
					if (
						( screenWidth <= windowWidth ) && ( screenHeight <= windowHeight )
					) {
						if ( !$( element ).hasClass( "headerSlice" ) ) {
							$( element ).css( {
								"margin-left": ""
							} );
						}
						return;
					}
					if ( isConfigChange ) {
						screen = $.extend( {}, screen, $scope.config );
					}
					if ( isMaintainScrollPosition ) {
						var targetScrollLeft = jqWindow.scrollLeft();
					} else if ( screen.alignment === "left" ) {
						var targetScrollLeft = 0;
					} else if ( screen.alignment === "right" ) {
						var targetScrollLeft = ( screenWidth - windowWidth );
					} else {
						var targetScrollLeft = ( ( screenWidth - windowWidth ) / 2 );
					}
					if ( screen.zoomScrollBehavior == screenService.zoomScrollBehaviors.DISABLE_HORIZONTAL_SCROLLING ) {
						if ( !$( element ).hasClass( "headerSlice" ) ) {
							if ( screenWidth > windowWidth ) {
								$( element ).css( {
									"margin-left": targetScrollLeft * -1
								} );
							} else {
								$( element ).css( {
									"margin-left": ""
								} );
							}
						}
					} else { // All other conditions
						if ( !$( element ).hasClass( "headerSlice" ) ) {
							$( element ).css( {
								"margin-left": ""
							} );
						}
						jqWindow.scrollLeft( targetScrollLeft );
						$scope.setFixedDesktopHeaderLeftOffset( targetScrollLeft );
						$timeout(
							function () {
								jqWindow.scrollLeft( targetScrollLeft );
								if ( jqWindow.scrollLeft() != targetScrollLeft ) {
									$timeout( function () {
										jqWindow.scrollLeft( targetScrollLeft );
										$scope.setFixedDesktopHeaderLeftOffset( targetScrollLeft );
									}, 0 );
								}
							},
							0
						);
					}
				}
				var image = element.find( ".screenImage" );
				var isHotspotNavigation = false;
				var isMaintainScrollPosition = false;
				var isOverlay = false;
				var jqWindow = $( window );
				var isInitialLoad = true;
				$scope.$watch(
					"screenID",
					function ( newValue, oldValue ) {
						if ( isInitialLoad ) {
							scrollScreenToAlignment( newValue );
							isInitialLoad = false;
						}
						if ( !isHotspotNavigation ) {
							scrollScreenToAlignment( newValue );
						} else if ( !isMaintainScrollPosition ) {
							$anchorScroll();
							if ( $scope.$parent.project.isMobile ) {
								$scope.scrollMobileViewport( 0, 0 );
							} else {
								scrollScreenToAlignment( newValue );
							}
						}
						isHotspotNavigation = false;
						isMaintainScrollPosition = false;
						isOverlay = false;
					}
				);
				modelEvents.on(
					"screenConfig:changed",
					function ( event, newConfig ) {
						scrollScreenToAlignment( $scope.screen.id, true );
					} );
				$( $window ).on( "keydown", onKeydown );
				$( $window ).on( "keyup", onKeyup );
				$scope.onMousedown = onMousedown;
				$scope.$parent.overlayImage = "";
			}
		};
	}
} )( angular, InVision );;;
/*! profile-avatar-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProfileAvatarUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$scope.$apply(
					function () {
						uploader.splice();
						$scope.isUploading = false;
						$scope.$emit( "profileAvatarUploader:error", error );
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				uploader.splice( 1 );
				files.splice( 1, files.length );
				if ( isUploading() ) {
					files.splice( 0, 1 );
					return;
				}
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.$apply(
					function () {
						$scope.isUploading = false;
						uploader.removeFile( file );
						var account = ng.fromJson( response.response );
						$scope.$emit( "profileAvatarUploader:uploaded", account );
						modelEvents.trigger( "accountUpdated", account );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							$scope.isUploading = true;
							$scope.percentage = 0;
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						$scope.progress = file.percent;
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			$scope.isUploading = false;
			$scope.percentage = 0;
			var target = $( element );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/account/upload-avatar",
				browse_button: "profileAvatarUploaderButton",
				container: "profileAvatarUploaderContainer",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,pict,png,tiff"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.init();
			$( window ).on(
				"error.profileAvatarUploader",
				function ( event ) {
					if ( isFlashRuntime ) {
						return ( false );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "error.profileAvatarUploader" );
					target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/profile-avatar-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! profile-company-logo-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProfileCompanyLogoUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$scope.$apply(
					function () {
						uploader.splice();
						$scope.isUploading = false;
						$scope.$emit( "profileCompanyLogoUploader:error", error );
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				uploader.splice( 1 );
				files.splice( 1, files.length );
				if ( isUploading() ) {
					files.splice( 0, 1 );
					return;
				}
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.$apply(
					function () {
						$scope.isUploading = false;
						uploader.removeFile( file );
						var account = ng.fromJson( response.response );
						$scope.$emit( "profileCompanyLogoUploader:uploaded", account );
						modelEvents.trigger( "accountUpdated", account );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							$scope.isUploading = true;
							$scope.percentage = 0;
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						$scope.progress = file.percent;
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			$scope.isUploading = false;
			$scope.percentage = 0;
			var target = $( element );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/account/upload-company-logo",
				browse_button: "profileCompanyLogoUploaderButton",
				container: "profileCompanyLogoUploaderContainer",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,pict,png,tiff"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.init();
			$( window ).on(
				"error.profileCompanyLogoUploader",
				function ( event ) {
					if ( isFlashRuntime ) {
						return ( false );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "error.profileCompanyLogoUploader" );
					target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/profile-company-logo-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! project-assets.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectAssets", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var announceDragEnter = function () {
				$scope.$apply(
					function () {
						$scope.$emit( "projectAssets:dragEnter" );
					}
				);
			};
			var target = $( document );
			target.on(
				"dragstart.projectAssets",
				function ( event ) {
					return ( false );
				}
			);
			target.on(
				"dragenter.projectAssets",
				function ( event ) {
					announceDragEnter();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "dragstart.projectAssets" );
					target.off( "dragenter.projectAssets" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! project-background-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectBackgroundUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$scope.$apply(
					function () {
						uploader.splice();
						$scope.isUploading = false;
						$scope.$emit( "projectBackgroundUploader:error", error );
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				uploader.splice( 1 );
				files.splice( 1, files.length );
				if ( isUploading() ) {
					files.splice( 0, 1 );
					return;
				}
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				$scope.$apply(
					function () {
						$scope.isUploading = false;
						uploader.removeFile( file );
						var background = ng.fromJson( response.response );
						$scope.$emit( "projectBackgroundUploader:uploaded", background );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							$scope.isUploading = true;
							$scope.percentage = 0;
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						$scope.progress = file.percent;
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			$scope.isUploading = false;
			$scope.percentage = 0;
			var target = $( element );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/backgrounds/",
				multipart_params: {
					"projectID": $scope.projectID
				},
				browse_button: "projectBackgroundUploaderButton",
				container: "projectBackgroundUploaderContainer",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				multi_selection: false,
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.init();
			$( window ).on(
				"error.projectBackgroundUploader",
				function ( event ) {
					if ( isFlashRuntime ) {
						return ( false );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( window ).off( "error.projectBackgroundUploader" );
					target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/project-background-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! project-comments-conversation.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectCommentsConversation", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function getTargetIsComplete() {
				var currentFilter = $scope.filters.status.value;
				if ( currentFilter === "all" ) {
					return ( null );
				}
				return ( currentFilter === "completed" );
			}

			function getTargetIsUnread() {
				var currentFilter = $scope.filters.read.value;
				if ( currentFilter === "all" ) {
					return ( null );
				}
				return ( currentFilter === "unread" );
			}

			function handleIsCompleteTransitionCleanup() {
				$scope.$apply(
					function () {
						$scope.removeConversation( $scope.screen, $scope.conversation );
					}
				);
			}

			function handleIsUnreadTransitionCleanup() {
				$scope.$apply(
					function () {
						$scope.hideConversation( $scope.screen, $scope.conversation );
					}
				);
			}
			var targetIsComplete = getTargetIsComplete();
			var targetIsUnread = getTargetIsUnread();
			var isCompleteTimer = null;
			/*
$scope.$watch(
"conversation.isComplete",
function( isComplete, oldValue ) {
if ( isCompleteTimer ) {
clearTimeout( isCompleteTimer );
isCompleteTimer = null;
return;
}
if ( targetIsComplete === null ) {
return;
}
if ( isComplete === oldValue ) {
return;
}
if ( isComplete !== targetIsComplete ) {
isCompleteTimer = setTimeout(
function() {
isCompleteTimer = null;
element.fadeOut( 500, handleIsCompleteTransitionCleanup );
},
250
);
} else {
element.stop().css( "opacity", "" );
}
}
);
*/
			$scope.$watch(
				"conversation.isUnread",
				function ( isUnread, oldValue ) {
					if ( targetIsUnread === null ) {
						return;
					}
					if ( isUnread === oldValue ) {
						return;
					}
					if ( isUnread !== targetIsUnread ) {
						element.fadeOut( 500, handleIsUnreadTransitionCleanup );
					}
				}
			);
			$scope.$watch(
				"filters.read",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					targetIsUnread = getTargetIsUnread();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearTimeout( isCompleteTimer );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! project-comments-modal.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectCommentsModal", Directive );
	/** @ngInject */
	function Directive( $, _, $location, $window, $timeout, Deferred, conversationService, sessionService, dateHelper, modelEvents, projectService, userService, moment ) {
		return {
			restrict: "A",
			link: function ( $scope, element, attrs ) {
				$scope.cancelEditingComment = function ( comment ) {
					comment.isEditing = false;
					if ( comment.originalComment ) {
						comment.comment = comment.originalComment;
					}
				};
				$scope.closeConversationPanel = function () {
					$scope.newComment = "";
					$scope.notifyOthers = "";
					$scope.isNotifySettingsVisible = false;
					$scope.clearCommentSketches();
				};
				$scope.editComment = function ( comment, event ) {
					$scope.stopEditingComments();
					comment.isEditing = true;
					comment.originalComment = comment.comment;
				};
				$scope.getNotifyCount = function () {
					var count = 0;
					_.each( $scope.projectMembers, function ( user ) {
						if ( user.isNotify ) {
							count++;
						}
					} );
					if ( !$scope.marker.isForDevelopment && !$scope.marker.isPrivate ) {
						_.each( $scope.projectStakeholders, function ( user ) {
							if ( user.isNotify ) {
								count++;
							}
						} );
					}
					if ( $scope.conversation.notifyOthers ) {
						var others = $scope.conversation.notifyOthers.split( "," );
						count += others.length;
					}
					return count;
				};
				$scope.getMarkerClass = function () {
					if ( $scope.marker.isForDevelopment ) {
						if ( !$scope.conversation.isComplete ) {
							return "development";
						} else {
							return "complete development";
						}
					} else if ( $scope.marker.isPrivate ) {
						if ( !$scope.conversation.isComplete ) {
							return "private";
						} else {
							return "complete private";
						}
					} else if ( $scope.conversation.isComplete ) {
						return "complete";
					} else {
						return "conversation";
					}
				};
				$scope.hideDeleteConfirmation = function ( comment ) {
					( comment || $scope ).isDeleting = false;
				};
				$scope.isStakeholdersShowing = function () {
					var isStakeholdersListEmpty = !$scope.projectStakeholders.length;
					if ( $scope.marker.isPrivate ||
						$scope.marker.isForDevelopment ||
						isStakeholdersListEmpty ) {
						return false;
					} else {
						return true;
					}
				};
				$scope.setTypeAsComment = function () {
					$scope.marker.isForDevelopment = false;
					$scope.marker.isPrivate = false;
					$scope.checkAll();
				};
				$scope.setTypeAsPrivateComment = function () {
					$scope.marker.isForDevelopment = false;
					$scope.marker.isPrivate = true;
					$scope.checkAllCollaborators();
					$scope.notifyOthers = "";
				};
				$scope.setTypeAsDevNote = function () {
					$scope.marker.isForDevelopment = true;
					$scope.marker.isPrivate = true;
					$scope.uncheckAll();
					$scope.notifyOthers = "";
				};
				$scope.stopEditingComments = function () {
					_.each( $scope.marker.comments, function ( comment ) {
						$scope.cancelEditingComment( comment );
					} );
				};
				$scope.toggleIsPrivate = function () {
					if ( $scope.marker.isPrivate ) {
						$scope.marker.isPrivate = false;
					} else {
						$scope.marker.isPrivate = true;
						_.setProperty( $scope.projectStakeholders, "isNotify", false );
						$scope.notifyOthers = "";
					}
				};
				$scope.toggleUserList = function () {
					$scope.isNotifySettingsVisible = !$scope.isNotifySettingsVisible;
				};
				$scope.showDeleteConfirmation = function ( comment, isFirstComment ) {
					if ( isFirstComment ) {
						$scope.isDeleting = true;
					} else {
						comment.isDeleting = true;
					}
				};
				$scope.removeStakeholder = function ( stakeholder ) {
					projectService.removeStakeholderFromProject( $scope.projectID, stakeholder.id );
				};
				$scope.notifyOptionSelected = "All";
				$scope.checkAll = function () {
					_.setProperty( $scope.projectMembers, "isNotify", true );
					_.setProperty( $scope.projectStakeholders, "isNotify", true );
				};
				$scope.uncheckAll = function () {
					_.setProperty( $scope.projectMembers, "isNotify", false );
					_.setProperty( $scope.projectStakeholders, "isNotify", false );
				};
				$scope.checkAllCollaborators = function () {
					$scope.uncheckAll();
					_.setProperty( $scope.projectMembers, "isNotify", true );
				};
				$scope.selectAll = function () {
					$scope.checkAll();
					$scope.notifyOptionSelected = "All";
				};
				$scope.selectCollaborators = function () {
					$scope.checkAllCollaborators();
					$scope.notifyOptionSelected = "Collaborators";
				};
				$scope.toggleNotifyOption = function () {
					if ( $scope.getNotifyCount() > 0 ) {
						$scope.uncheckAll();
						return;
					}
					switch ( $scope.notifyOptionSelected ) {
					case "All":
						$scope.selectAll();
						break;
					case "Collaborators":
						$scope.selectCollaborators();
						break;
					}
				};

				function updateCollapsedStates( collection ) {
					_.each( collection, function ( comment ) {
						var isFirstOrLastN = false,
							isCollapsed = false,
							isFirstCollapsed = false,
							previousCollapsedComments = [],
							index = -1;
						index = _.indexOfWithProperty( collection, "id", comment.id );
						isFirstOrLastN = ( index === 0 || index >= ( collection.length - 3 ) );
						previousCollapsedComments = _.filterWithProperty( collection.slice( 0, index ), "isCollapsed", true );
						isCollapsed = !( isFirstOrLastN || comment.isUnread );
						isFirstCollapsed = isCollapsed && ( previousCollapsedComments.length === 0 );
						comment.isFirstCollapsed = isFirstCollapsed;
						comment.isCollapsed = isCollapsed;
					} );
				}

				function updateConversation( conversationID ) {
					Deferred.handlePromise(
						conversationService.getConversation( conversationID ),
						function ( updatedConversation ) {
							updateCollapsedStates( updatedConversation.comments );
							_.each( updatedConversation.comments, function ( comment ) {
								comment.dateLabel = dateHelper.formatRecentDate( comment.updatedAt, "MMM d" );
								comment.timeLabel = dateHelper.formatTime( comment.updatedAt, "h:mm TT" );
								comment.niceDate = moment( comment.updatedAt ).fromNow();
								comment.userInitials = userService.getInitials( comment.userName );
								comment.userHasSystemAvatar = userService.isSystemAvatar( comment.avatarID );
								comment.userOnlineStatus = userService.getOnlineStatus( comment.lastRequestAt );
								comment.userFirstName = userService.getFirstName( comment.userName );
								comment.userNiceName = userService.getNiceUsername( comment.userName, comment.userID, sessionService.user.id );
								comment.html = conversationService.getHtmlForComment( comment.comment );
							} );
							$scope.conversation = updatedConversation;
							$timeout( function () {
								$scope.markRead( updatedConversation );
							}, 5000 );
						},
						function () {}
					);
				}

				function addComment( commentID ) {
					var commentExists = _.findWithProperty( $scope.marker.comments, "id", commentID );
					if ( !commentExists ) {
						Deferred.handlePromise(
							conversationService.getComment( commentID ),
							function ( comment ) {
								comment.html = conversationService.getHtmlForComment( comment.comment );
								$scope.marker.comments.push( comment );
								if ( comment.isUnread ) {
									$scope.marker.isUnread = true;
									$scope.$emit( "conversationsChanged" );
								}
							},
							function () {}
						);
					}
				}

				function updateComment( commentID ) {
					var comment = _.findWithProperty( $scope.marker.comments, "id", commentID );
					if ( comment ) {
						Deferred.handlePromise(
							conversationService.getComment( commentID ),
							function ( updatedComment ) {
								if ( comment.comment !== updatedComment.comment ) {
									_.assign( comment, updatedComment );
									comment.originalComment = updatedComment.originalComment;
								}
							},
							function () {}
						);
					}
				}

				function deleteComment( commentID ) {
					$scope.marker.comments = _.rejectWithProperty( $scope.marker.comments, "id", commentID );
				}

				function handleCommentAdded( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						addComment( commentID );
					}
				}

				function handleCommentUpdated( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						updateComment( commentID );
					}
				}

				function handleCommentDeleted( event, commentID, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						deleteComment( commentID );
					}
				}

				function handleConversationUpdated( event, conversationID ) {
					if ( conversationID === $scope.marker.id ) {
						updateConversation( conversationID );
					}
				}

				function handleProjectStakeholderRemoved( event, projectID, userID ) {
					$scope.projectStakeholders = _.rejectWithProperty( $scope.projectStakeholders, "id", userID );
				}

				function watchForDirtyComment() {
					var unwatchNewComment = $scope.$watch(
						"newComment",
						function ( newValue, oldValue ) {
							if ( newValue === oldValue ) {
								return;
							}
							unwatchNewComment();
						}
					);
				}

				function getNotifiedUsers() {
					_.setProperty( $scope.projectMembers, "isNotify", false );
					_.setProperty( $scope.projectStakeholders, "isNotify", false );
					var selectedMembers = _.withPropertyRange( $scope.projectMembers, "id", $scope.marker.subscribers );
					var selectedAffiliates = _.withPropertyRange( $scope.projectStakeholders, "id", $scope.marker.subscribers );
					_.setProperty( selectedMembers, "isNotify", true );
					_.setProperty( selectedAffiliates, "isNotify", true );
				}
				var submissionInProgress = false;
				$scope.isDeleting = false;
				$scope.marker.isSaved = !!$scope.marker.id;
				$scope.newComment = "";
				$scope.notifyOthers = "";
				$scope.isNotifySettingsVisible = false;
				$scope.isTeamChecked = false;
				$scope.isStakeholdersChecked = false;
				$scope.showNotifyOthers = false;
				$scope.$watch(
					"conversation.isComplete",
					function ( newValue, oldValue ) {
						if ( newValue === oldValue ) {
							return;
						}
						$scope.saveConversation( $scope.conversation );
						modelEvents.trigger( "commentModal.handleCommentUpdates" );
					}
				);
				$scope.$watch( "marker.isForDevelopment", function ( newValue, oldValue ) {
					if ( newValue !== oldValue ) {
						$scope.saveConversation( $scope.marker );
					}
				} );
				$scope.$watch( "marker.isPrivate", function ( newValue, oldValue ) {
					if ( newValue !== oldValue ) {
						$scope.saveConversation( $scope.marker );
					}
				} );
				$scope.$watch( "marker.isConversationPanelVisible", function ( newValue, oldValue ) {
					if ( newValue ) {
						getNotifiedUsers();
						watchForDirtyComment();
					}
					if ( newValue !== oldValue ) {
						if ( $scope.marker.isSaved && newValue === false ) {
							$scope.markCommentsAsRead( $scope.marker );
							$scope.stopEditingComments();
							$scope.newComment = "";
							$scope.notifyOthers = "";
							$scope.marker.isConversationPanelVisible = false;
							$scope.isNotifySettingsVisible = false;
							$scope.showNotifyOthers = false;
						}
					}
					if ( !$scope.marker.isSaved && newValue === true ) {
						$scope.showCommentInput();
					}
				} );
				$scope.$watch( "marker", function ( newValue, oldValue ) {
					if ( newValue ) {
						getNotifiedUsers();
						watchForDirtyComment();
					}
				} );
				$scope.$on(
					"commentSaved",
					function () {
						$scope.newComment = "";
						$scope.notifyOthers = "";
						$scope.showNotifyOthers = false;
						$scope.isNotifySettingsVisible = false;
					}
				);
				$scope.$on(
					"updateConversation",
					function () {
						updateConversation( $scope.marker.id );
					}
				);
				$scope.$on( "$destroy", function () {
					modelEvents.off( "commentAdded", handleCommentAdded );
					modelEvents.off( "commentUpdated", handleCommentUpdated );
					modelEvents.off( "commentDeleted", handleCommentDeleted );
					modelEvents.off( "conversationUpdated", handleConversationUpdated );
					modelEvents.off( "projectStakeholderRemoved", handleProjectStakeholderRemoved );
				} );
				modelEvents.on( "commentAdded", handleCommentAdded );
				modelEvents.on( "commentUpdated", handleCommentUpdated );
				modelEvents.on( "commentDeleted", handleCommentDeleted );
				modelEvents.on( "conversationUpdated", handleConversationUpdated );
				modelEvents.on( "projectStakeholderRemoved", handleProjectStakeholderRemoved );
				updateConversation( $scope.marker.id );
			}
		};
	}
} )( angular, InVision );;;
/*! project-item-loader.js */
;;
/* global $ */
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectItemLoader", Directive );

	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var progressTemplate = "<input type=\"text\" class=\"dial\">",
				type = attributes.loaderType || "simple",
				cleanup = attributes.cleanup || "true";
			var $element = $( element );
			$element.addClass( "screen-loader type-" + type );

			function animateTo( value ) {
				$element.find( ".dial" ).animate( {
					value: value
				}, {
					duration: 500,
					easing: "swing",
					progress: function () {
						$( this ).val( Math.round( this.value ) ).trigger( "change" );
					}
				} );
			}
			if ( type === "progress" ) {
				$element.append( progressTemplate );
				$element.find( ".dial" ).knob( {
					readOnly: true,
					displayInput: false,
					thickness: ".07",
					width: attributes.loaderWidth || 75,
					bgColor: attributes.loaderBg || "#757a84",
					fgColor: "#52b266"
				} );
				attributes.$observe( "progress", function ( progress ) {
					progress = parseInt( progress, 10 );
					animateTo( progress );
					if ( cleanup === "true" && progress >= 100 ) {
						$timeout( function () {
							$element.animate( {
								opacity: 0
							}, 500, function () {
								$element.remove();
							} );
						}, 500 );
					}
				} );
			}
			$scope.$on(
				"$destroy",
				function () {
					$element.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! project-mobile-icon-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectIconUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents, Deferred, projectService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
				$scope.$emit( "screenUploadStop" );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id == id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$timeout(
					function () {
						var file = error.file;
						uploader.removeFile( file );
						removeFileFromQueue( file.id );
						if ( error.code === plupload.FILE_SIZE_ERROR ) {
							$scope.openModalWindow(
								"error", ( "The file, \"" + file.name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
							);
						} else {
							$scope.openModalWindow(
								"error", ( "We could not process the image, \"" + file.name + "\". This often happens when people accidentally give a PSD or HTML file a \".jpg\" file extension." )
							);
						}
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						$scope.openModalWindow(
							"error", ( "Icon images must be formatted as a PNG." )
						);
						$scope.$apply(); // shows the modal right away
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				files.sort(
					function ( a, b ) {
						var aName = a.name.toLowerCase();
						var bName = b.name.toLowerCase();
						return ( aName < bName ? -1 : 1 );
					}
				);
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size
					);
				}
				$scope.$emit( "screenUploadStart" );
				modelEvents.trigger( "screenUploadStart" );
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				$scope.$apply(
					function () {
						var screen = ng.fromJson( response.response );
						modelEvents.trigger( "screenUploaded", screen );
						$scope.setShowSampleScreens( false );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							uploader.start();
							$scope.mobileUploadingIndicators.isUploadingIcon = true;
						}
					);
				}
			};
			var handlePluploadUploadComplete = function ( uploader, files ) {
				$scope.$emit( "screenUploadStop" );
				$scope.mobileUploadingIndicators.isUploadingIcon = false;
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						setFileProgress(
							file.id,
							file.uploaded,
							file.percent
						);
					}
				);
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(png)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				if ( !listItem.length ) {
					return ( deleteFileFromQueue( id ) );
				}
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var setFileProgress = function ( id, loaded, percent ) {};
			var dom = {};
			dom.target = element;
			dom.queue = dom.target.find( "div.queue" );
			dom.files = dom.queue.find( "ol.files" );
			dom.window = $( window );
			var uploader = new plupload.Uploader( {
				runtimes: "html5, flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID,
					"isAppIcon": true
				},
				browse_button: "appIconUpload",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png"
				} ],
				max_file_size: "10mb"
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOADING: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.$watch(
				"projectID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					dom.window.off( "error.projectIconUploader" );
					dom.target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: false,
			scope: true
		} );
	}
} )( angular, InVision );;;
/*! project-mobile-loading-screen-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectLoadingScreenUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents, Deferred, projectService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
				$scope.$emit( "screenUploadStop" );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id == id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				$timeout(
					function () {
						var file = error.file;
						uploader.removeFile( file );
						removeFileFromQueue( file.id );
						if ( error.code === plupload.FILE_SIZE_ERROR ) {
							$scope.openModalWindow(
								"error", ( "The file, \"" + file.name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
							);
						} else {
							$scope.openModalWindow(
								"error", ( "We could not process the image, \"" + file.name + "\". This often happens when people accidentally give a PSD or HTML file a \".jpg\" file extension." )
							);
						}
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						$scope.openModalWindow(
							"error", ( "Loading Screen images must be formatted as a PNG." )
						);
						$scope.$apply(); // shows the modal right away
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				files.sort(
					function ( a, b ) {
						var aName = a.name.toLowerCase();
						var bName = b.name.toLowerCase();
						return ( aName < bName ? -1 : 1 );
					}
				);
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size
					);
				}
				$scope.$emit( "screenUploadStart" );
				modelEvents.trigger( "screenUploadStart" );
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				$scope.$apply(
					function () {
						var screen = ng.fromJson( response.response );
						modelEvents.trigger( "screenUploaded", screen );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							uploader.start();
							$scope.mobileUploadingIndicators.isUploadingLoadingScreen = true;
						}
					);
				}
			};
			var handlePluploadUploadComplete = function ( uploader, files ) {
				$scope.$emit( "screenUploadStop" );
				$scope.mobileUploadingIndicators.isUploadingLoadingScreen = false;
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(png)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				if ( !listItem.length ) {
					return ( deleteFileFromQueue( id ) );
				}
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var dom = {};
			dom.target = element;
			dom.queue = dom.target.find( "div.queue" );
			dom.files = dom.queue.find( "ol.files" );
			dom.window = $( window );
			var uploader = new plupload.Uploader( {
				runtimes: "html5, flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID,
					"isLoadingScreen": true
				},
				browse_button: "loadingScreenUpload",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png"
				} ],
				max_file_size: "10mb"
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOADING: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.$watch(
				"projectID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					dom.window.off( "error.projectIconUploader" );
					dom.target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: false,
			scope: true
		} );
	}
} )( angular, InVision );;;
/*! project-screen-divider-placeholder.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectScreenDividerPlaceholder", Directive );
	/** @ngInject */
	function Directive( $filter, screenDividerService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			element.click( function () {
				var thisScreenPosition = $scope.object.position;
				var thisDisplayObjectsPosition = $scope.object.displayObjectsPosition;
				var newLabel = "New Section";
				screenDividerService.createScreenDivider( $scope.projectID, newLabel, thisScreenPosition, thisDisplayObjectsPosition );
				$scope.displayObjects[ thisDisplayObjectsPosition ] = {
					dividerID: "new",
					type: "divider",
					label: newLabel,
					position: thisScreenPosition,
					sort: 0,
					expanded: true
				};
				$scope.dividers.push( {
					dividerID: 0,
					type: "divider",
					label: newLabel,
					position: thisScreenPosition,
					sort: 0,
					expanded: true
				} );
				if ( !$scope.$$phase ) {
					$scope.$apply();
				}
				$scope.applyDividerScreenCounts();
			} );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! project-screen-divider.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectScreenDivider", Directive );
	/** @ngInject */
	function Directive( $filter, screenDividerService, validationService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var isSetup = false;
			var input = {};
			var label = {};
			var originalValue = null;
			var request = null;
			$scope.$watch( "isEditingDividerLabel", function ( newVal, oldVal ) {
				if ( !isSetup ) {
					input = element.find( ".dividerLabelInput" );
					label = element.find( ".divider_label" );
					setupEditLabel( input );
				}
				input.focus();
				input.select();
			} );
			$scope.deleteDivider = function ( dividerID ) {
				screenDividerService.deleteScreenDivider( $scope.projectID, dividerID );
			};

			function escapeHtml( str ) {
				return String( str )
					.replace( /&/g, '&amp;' )
					.replace( /"/g, '&quot;' )
					.replace( /'/g, '&apos;' )
					.replace( /</g, '&lt;' )
					.replace( />/g, '&gt;' );
			}

			function setupEditLabel( input ) {
				originalValue = input.val();
				input.on( "blur.invUpdateScreenDivider", handleBlur );
				input.on( "keypress.invUpdateScreenDivider", handleKeyPress );
				input.on( "keyup.invUpdateScreenDivider", handleKeyUp );
				$scope.$on(
					"$destroy",
					function () {
						input.off( "blur.invUpdateScreenDivider" );
						input.off( "keypress.invUpdateScreenDivider" );
						input.off( "keyup.invUpdateScreenDivider" );
						input.popover( "destroy" );
						isSetup = false;
					}
				);
				isSetup = true;
			}
			var getErrorMessage = function ( response ) {
				if ( validationService.isInvalidField( response ) ) {
					return ( "Your divider label contians invalid characters. Try removing some punctuation." );
				}
				return ( response.message );
			};
			var handleBlur = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				submitForm();
				hideInput();
			};
			var handleKeyPress = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var theChar = String.fromCharCode( event.which );
			};
			var handleKeyUp = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var enterKey = 13;
				var escapeKey = 27;
				if ( event.which === enterKey ) {
					submitForm();
				} else if ( event.which === escapeKey ) {
					resetValue( originalValue );
					hideInput();
				}
			};
			var hideInput = function () {
				$scope.finishEditingScreenDividerLabel();
				input.popover( "destroy" );
				if ( !$scope.$$phase ) {
					$scope.$apply();
				}
			};
			var resetValue = function ( originalValue ) {
				input.val( originalValue );
				label.html( escapeHtml( originalValue ) );
				hideInput();
			};
			var submitForm = function () {
				var newValue = input.val();
				if ( !newValue ||
					( newValue === originalValue )
				) {
					hideInput();
					return;
				}
				input.popover( "destroy" );
				var dividerID = $scope.object.dividerID;
				$scope.object.label = newValue;
				if ( !$scope.$$phase ) {
					$scope.$apply();
				}
				request = screenDividerService.updateScreenDivider( $scope.projectID, dividerID, newValue, 1 );
				request.then(
					function ( divider ) {
						request = null;
						originalValue = newValue;
						hideInput();
					},
					function ( response ) {
						request = null;
						input
							.popover( {
								content: getErrorMessage( response ),
								placement: "top",
								title: "Oops: Something Went Wrong",
								trigger: "manual"
							} )
							.popover( "show" );
						input.focus();
						input.select();
					}
				);
			};
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! project-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectScreen", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			element.on(
				"mouseleave.invProjectScreen",
				function () {
					$scope.hideArchiveConfirmation();
					$scope.hideDeleteConfirmation();
					element.find( "li.dropdown" )
						.removeClass( "open" );
					$scope.$apply();
				}
			);
			$scope.progress = 0;
			$scope.$on(
				"$destroy",
				function () {
					element.off( "mouseleave.invProjectScreen" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! project-screens-key-bindings.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectScreensKeyBindings", Directive );
	/** @ngInject */
	function Directive( $window, $ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$( $window ).on( "keydown.invProjectScreensKeyBindings", function ( event ) {
				var key = event.which;
				var target = event.target;
				if ( event.metaKey || event.ctrlKey ) {
					$scope.$emit( "metaKey-keydown" );
				}
			} );
			$scope.$on(
				"$destroy",
				function () {
					$( $window ).off( "keydown.invProjectScreensKeyBindings" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! project-screens.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectScreens", Directive );
	/** @ngInject */
	function Directive( $window, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var announceDragEnter = function () {
				$scope.$apply(
					function () {
						$scope.$emit( "projectScreens:dragEnter" );
					}
				);
			};
			var doc = $( document );
			var win = $( $window );
			var scrollTimeout;
			doc.on(
				"dragstart.projectScreens",
				function ( event ) {
					return ( false );
				}
			);
			doc.on(
				"dragenter.projectScreens",
				function ( event ) {
					announceDragEnter();
				}
			);
			win.on( 'scroll.projectScreens', function () {
				if ( !scrollTimeout ) {
					$scope.isScrolling = true;
				}
				$timeout.cancel( scrollTimeout );
				scrollTimeout = $timeout( function () {
						$scope.isScrolling = false;
						scrollTimeout = false;
					},
					200
				);
			} );
			$scope.$on(
				"$destroy",
				function () {
					doc.off( "dragstart.projectScreens" );
					doc.off( "dragenter.projectScreens" );
					win.off( "scroll.projectScreens" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! project-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectUploader", Directive );
	var helperNotice = {
		beenChecked: false,
		beenSeen: false,
		prefID: 0
	};
	var retinaNotice = {
		beenChecked: false,
		beenSeen: false,
		prefID: 0,
		hasRetinaSize: false
	};
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents, Deferred, projectService, userPreferenceService ) {
		var maxInBytes = 10485760;
		var linkFunction = function ( $scope, element ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
				$scope.$emit( "screenUploadStop" );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id === id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handleDragEnter = function ( event ) {
				event.stopPropagation();
				$scope.isDraggingOverHotspot = true;
				if ( dom.dropzone.is( ".hotDropzone" ) ) {
					return;
				}
				dom.dropzone.addClass( "hotDropzone" );
				$document.on( "dragenter.invProjectUploader", handleDragEnterOnDocument );
			};
			var handleDragEnterOnDocument = function () {
				dom.dropzone.removeClass( "hotDropzone" );
				$scope.isDraggingOverHotspot = false;
				$document.off( "dragenter.invProjectUploader" );
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				if ( error.code === plupload.FILE_EXTENSION_ERROR ) {
					if ( error.file.name === "Data" || error.file.name === "version" ) {
						isSketch = 1;
						$timeout( function () {
							$scope.openModalWindow( "sketchSoon" );
						} );
						clearUploader();
					}
					return;
				}
				$timeout(
					function () {
						var file = error.file;
						uploader.removeFile( file );
						removeFileFromQueue( file.id );
						if ( error.code === plupload.FILE_SIZE_ERROR ) {
							$scope.openModalWindow(
								"error", ( "The file, \"" + file.name + ",\" is too large. Are you sure that it's not a mislabeled file?" )
							);
						} else {
							$scope.openModalWindow(
								"error", ( "We could not process the image, \"" + file.name + "\". This often happens when people accidentally give an HTML file a \".jpg\" file extension." )
							);
						}
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				if ( isSketch === 1 ) {
					for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
						uploader.removeFile( files[ i ] );
					}
					isSketch = 0;
					return;
				}
				dom.dropzone.removeClass( "hotDropzone" );
				files = _.sortOnPropertyUsingNaturalOrder( files, "name" );
				var filesLength = files.length;
				var queueLength = uploader.files.length;
				for ( var i = 0; i < filesLength; i++ ) {
					uploader.files[ queueLength - filesLength + i ] = files[ i ];
				}
				var fileExcludedBasedOnName = null;
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						fileExcludedBasedOnName = files[ i ].name;
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					} else if ( files[ i ].size > maxInBytes && !isPDF( files[ i ].name ) && !isSourceFile( files[ i ].name ) ) { // limit the max file size, unless it's a PDF or a screen source file
						$scope.openModalWindow(
							"error", ( "The file, \"" + files[ i ].name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
						);
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				if ( fileExcludedBasedOnName ) {
					$scope.openModalWindow( "error", "The file, \"" + fileExcludedBasedOnName + ",\" was skipped since it doesn't appear to be an image file." );
				}
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size
					);
					$scope.totalFilesInQueue = i + 1;
				}
				if ( files.length ) {
					$scope.$emit( "screenUploadStart" );
					modelEvents.trigger( "screenUploadStart" );
				}
				$scope.$apply();
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				if ( !retinaNotice.beenSeen && !retinaNotice.hasRetinaSize ) {
					var imgInfo = ng.fromJson( response.response );
					if ( imgInfo.hasOwnProperty( "width" ) && imgInfo.width >= 2000 ) {
						retinaNotice.hasRetinaSize = true;
					}
				}
				$timeout(
					function () {
						var screen = ng.fromJson( response.response );
						modelEvents.trigger( "screenUploaded", screen );
						$scope.setShowSampleScreens( false );
					}
				);
			};
			var handlePluploadInit = function ( uploader ) {
				$scope.isHtml5Runtime = ( uploader.runtime === "html5" );
				$scope.isFlashRuntime = ( uploader.runtime === "flash" );
				$timeout( angular.noop );
				if ( $scope.isHtml5Runtime ) {
					dom.dropzone.on( "dragenter", handleDragEnter );
					if ( isIE() ) {
						dom.dropzone.on( "mousemove", ieHackHandleMouseMove );
						dom.container.on( "dragover", "div.plupload", ieHackHandleDragOver );
					}
					$document.draghover( {
						namespace: "invProjectUploaderDrag"
					} ).on( {
						"draghoverstart": function () {},
						"draghoverend": function ( e, dragEvent ) {
							window.dragEvent = dragEvent;
							if ( !!dragEvent.originalEvent ) {
								var pageX = dragEvent.originalEvent.pageX,
									pageY = dragEvent.originalEvent.pageY;
								if ( !$scope.isDraggingOverHotspot ||
									(
										pageX === 0 ||
										pageX <= $( window ).scrollLeft() ||
										pageX >= ( $( window ).width() + $( window ).scrollLeft() ) ||
										pageY === 0 ||
										pageY <= $( window ).scrollTop() ||
										pageY >= ( $( window ).height() + $( window ).scrollTop() )
									)
								) {
									$timeout( function () {
										if ( $scope.screens.length ) {
											modelEvents.trigger( "projectScreensUploadComplete" );
										}
									} );
								}
							} else {
								if ( !$scope.isDraggingOverHotspot ) {
									$timeout( function () {
										if ( $scope.screens.length ) {
											modelEvents.trigger( "projectScreensUploadComplete" );
										}
									} );
								}
							}
						}
					} );
				} else {
					$scope.setShowSampleScreens( false );
				}
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				$scope.remainingFilesInQueue = uploader.files.length;
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadComplete = function () {
				$scope.totalFilesInQueue = 0;
				$scope.remainingFilesInQueue = 0;
				$scope.overallProgress = 100;
				$timeout( function () {
					$scope.overallProgress = 0;
				}, 2000 );
				if ( retinaNotice.hasRetinaSize && !retinaNotice.beenSeen && !$scope.isMobile ) {
					$scope.openModalWindow( "retinaHelper" );
				}
				retinaNotice.hasRetinaSize = false;
				$scope.isDraggingOverHotspot = false;
				$scope.$emit( "screenUploadStop" );
				$timeout( function () {
					modelEvents.trigger( "projectScreensUploadComplete" );
				}, 1000 );
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$timeout( function () {
					$scope.$apply(
						function () {
							setOverallProgress();
							setFileProgress(
								file.id,
								file.loaded,
								file.percent
							);
						}
					);
				} );
			};
			var handleWindowScroll = function () {
				var uploaderOffset = dom.target.offset();
				var uploaderTop = uploaderOffset.top;
				var isAboveFold = ( uploaderTop < dom.window.scrollTop() );
				if ( !$scope.displayImageObjects.length ) {
					$scope.isFixedDropzone = false;
				} else if ( isAboveFold && !dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = true;
				} else if ( !isAboveFold && dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = false;
				}
				$timeout(
					function () {
						$scope.$apply();
						setTimeout( refreshUploader ); // Allow pause for DOM to update before shim is refreshed.
					}
				);
			};
			var ieHackHandleDragOver = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
					if ( dom.dynamicPluploadWidget.css( "zIndex" ) === 99999 ) {
						dom.target.addClass( "highZIndex" );
					}
				}
				dom.dynamicPluploadWidget.hide();
			};
			var ieHackHandleMouseMove = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
					if ( dom.dynamicPluploadWidget.css( "zIndex" ) === 99999 ) {
						dom.target.addClass( "highZIndex" );
					}
				}
				if ( !dom.dynamicPluploadWidget.is( ":visible" ) &&
					!ieHackHandleMouseMove.timer
				) {
					ieHackHandleMouseMove.timer = setTimeout(
						function () {
							dom.dynamicPluploadWidget.show();
							ieHackHandleMouseMove.timer = null;
						},
						150
					);
				}
			};
			var isIE = function () {
				return ( /\bmsie\b/i.test( $window.navigator.userAgent ) );
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isPDF = function ( name ) {
				var pattern = /\.(pdf)$/i;
				return (
					pattern.test( name )
				);
			};
			var isSourceFile = function ( name ) {
				var pattern = /\.(psd|ai)$/i;
				return (
					pattern.test( name )
				);
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(gif|jpe?g|png|pdf|psd|ai)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
				setupDropZones();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				if ( !listItem.length ) {
					return ( deleteFileFromQueue( id ) );
				}
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var setFileProgress = function ( id, loaded, percent ) {
				var queueItem = getQueueItemByID( id );
				if ( !queueItem ) {
					return;
				}
				queueItem.percentage = percent;
				if ( queueItem.state === $scope.fileStates.PENDING ) {
					queueItem.state = $scope.fileStates.UPLOADING;
				}
			};
			var onSampleScreenDrop = function () {
				$scope.$emit( "screenUploadStart" );
				$scope.setShowSampleScreens( false );
				$scope.uploadQueue.push( {
					id: "sample1",
					name: "Sample 1",
					size: 10000,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
				$scope.uploadQueue.push( {
					id: "sample2",
					name: "Sample 2",
					size: 10000,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
				$scope.$apply();
				$timeout( function () {
					setFileProgress( "sample1", false, 35 );
					setFileProgress( "sample2", false, 35 );
					$timeout( function () {
						setFileProgress( "sample1", false, 80 );
						setFileProgress( "sample2", false, 80 );
						Deferred.handlePromise(
							projectService.addSampleScreensToProject( $scope.projectID ),
							function () {
								$scope.$emit( "screenUploadStop" );
							}
						);
						$timeout( function () {
							setFileProgress( "sample1", false, 100 );
							setFileProgress( "sample2", false, 100 );
							removeFileFromQueue( "sample1" );
							removeFileFromQueue( "sample2" );
						}, 250 );
					}, 250 );
				}, 400 );
			};
			var checkHelperNotification = function () {
				if ( !helperNotice.beenChecked ) {
					checkUserPreference( "uploadHelperNotification", helperNotice, $scope.showUploadHelper );
				} else {
					$scope.showUploadHelper = !helperNotice.beenSeen;
				}
			};
			var checkRetinaModalNotification = function () {
				if ( !retinaNotice.beenChecked ) {
					retinaNotice.beenSeen = checkUserPreference( "showRetinaHelperModal", retinaNotice, $scope.showRetinaModal );
				} else {
					$scope.showRetinaModal = !helperNotice.beenSeen;
				}
			};
			var checkUserPreference = function ( prefName, prefStruct, scopeFlag ) {
				prefStruct.beenChecked = true;
				userPreferenceService.getPreferenceTypeByName( prefName, true, "boolean" ).then(
					function ( typeResponse ) {
						prefStruct.prefID = typeResponse.data.id;
						userPreferenceService.getUserPreferenceById( typeResponse.data.id ).then(
							function ( valueResponse ) {
								if ( valueResponse.exists === "true" && valueResponse.data.value === "1" ) {
									prefStruct.beenSeen = true;
								} else {
									prefStruct.beenSeen = false;
								}
								scopeFlag = !prefStruct.beenSeen;
								typeResponse = null;
								valueResponse = null;
							}
						);
					}
				);
			};
			var handleInlineDropZoneDragEnter = function ( event ) {
				event.stopPropagation();
				$scope.isDraggingOverHotspot = true;
				if ( $( this ).is( ".hotDropzone" ) ) {
					return;
				}
				$( this ).addClass( "hotDropzone" );
				$document.on( "dragenter.inlinedropzone", handleInlineDragEnterOnDocument );
			};
			var handleInlineDragEnterOnDocument = function () {
				$( ".hotDropzone" ).removeClass( "hotDropzone" );
				$scope.isDraggingOverHotspot = false;
				$document.off( "dragenter.inlinedropzone" );
			};
			var setupDropZones = function () {
				$( ".inlineDropZone" ).each( function () {
					var thisInlineDropZone = $( this );
					if ( thisInlineDropZone.is( ".dropzone" ) ) {
						return;
					}
					thisInlineDropZone.addClass( "dropzone" );
					var dropzone = new mOxie.FileDrop( {
						drop_zone: this
					} );
					thisInlineDropZone.on( "dragenter", handleInlineDropZoneDragEnter );
					dropzone.ondrop = function ( event ) {
						var dividerID = parseInt( thisInlineDropZone.attr( "data-divider-id" ) || 0 );
						var position = parseInt( thisInlineDropZone.attr( "data-position" ) || 9999 );
						handleInlineDragEnterOnDocument( event );
						for ( var i = 0, len = dropzone.files.length; i < len; i++ ) {
							dropzone.files[ i ].suggestedSort = position + i;
							dropzone.files[ i ].dividerID = dividerID;
						}
						modelEvents.trigger( "createLoadingScreens", dropzone.files );
						uploader.addFile( dropzone.files );
					};
					dropzone.init();
				} );
			};

			function setOverallProgress() {
				var progress = ( ( $scope.totalFilesInQueue - $scope.remainingFilesInQueue ) / $scope.totalFilesInQueue ) * 100;
				$scope.overallProgress = Math.floor( progress );
			}
			$scope.$watch( "overallProgress", function ( newValue ) {
				$( ".progress-cloud .bar" ).css( {
					height: newValue + "%"
				} );
			} );
			var isSketch = 0;
			var dom = {};
			dom.target = element;
			dom.container = dom.target.find( "div.positioned-container" );
			dom.dropzone = dom.target.find( "div.dropzone" );
			dom.files = dom.target.find( "ol.queue" );
			dom.html5Instructions = dom.target.find( ".html5Instructions" );
			dom.window = $( $window );
			dom.dynamicPluploadWidget = null;
			$( ".dropzone" ).droppable( {
				accept: ".sampleScreens",
				drop: onSampleScreenDrop
			} );
			var uploader = new plupload.Uploader( {
				runtimes: "html5,flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID
				},
				drop_element: "projectUploaderDropzone",
				container: "projectUploaderDropzone",
				browse_button: "projectUploaderButton",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png,pdf,psd,ai"
				} ]
			} );
			$scope.isHtml5Runtime = false;
			$scope.isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.bind( "BeforeUpload", function ( uploader, file ) {
				if ( file.getSource().suggestedSort >= 0 ) {
					uploader.settings.multipart_params.suggestedSort = file.getSource().suggestedSort;
					uploader.settings.multipart_params.dividerID = file.getSource().dividerID;
				} else {
					uploader.settings.multipart_params.suggestedSort = -1;
					uploader.settings.multipart_params.dividerID = 0;
				}
			} );
			uploader.init();
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOAIND: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.isFixedDropzone = false;
			$scope.showUploadHelper = false;
			$scope.showRetinaModal = false;
			$scope.isDraggingOverHotspot = false;
			$scope.totalFilesInQueue = 0;
			$scope.remainingFilesInQueue = 0;
			$scope.overallProgress = 0;
			$scope.$watch(
				"!! displayImageObjects.length",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				}
			);
			$scope.$watch(
				"displayObjects",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				} );
			$scope.$watch(
				"isFixedDropzone",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$timeout( refreshUploader, 150 );
				}
			);
			$scope.$watch(
				"projectID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				}
			);
			$scope.$on(
				"showProjectUploader",
				function () {
					$scope.isShowingUploader = true;
				}
			);
			$scope.closeUploaderHelper = function () {
				$scope.showUploadHelper = false;
				helperNotice.beenSeen = true;
				userPreferenceService.setUserPreferenceById( helperNotice.prefID, 1 );
			};
			$scope.$watch(
				"isShowingUploader",
				function ( newValue ) {
					if ( newValue === true ) {
						if ( !$scope.displayImageObjects.length ) {
							dom.target.show();
						} else {
							var minHeight = dom.target.css( "minHeight" );
							dom.target
								.stop( true, true )
								.css( "minHeight", 0 )
								.slideDown(
									"fast",
									function () {
										dom.target.css( "minHeight", minHeight );
										refreshUploader();
									}
							);
						}
						dom.window.on(
							"error.projectUploader",
							function () {
								if ( $scope.isFlashRuntime ) {
									return ( false );
								}
							}
						);
						dom.window.on( "scroll.projectUploader", handleWindowScroll );
						handleWindowScroll();
					} else if ( newValue === false ) {
						$scope.isFixedDropzone = false;
						var minHeight = dom.target.css( "minHeight" );
						dom.target
							.stop( true, true )
							.css( "minHeight", 0 )
							.slideUp(
								"fast",
								function () {
									dom.target.css( "minHeight", minHeight );
								}
						);
						clearUploader();
						dom.window.off( "error.projectUploader" );
						dom.window.off( "scroll.projectUploader" );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					$document.off( "dragenter.invProjectUploader" );
					dom.window.off( "error.projectUploader" );
					dom.window.off( "scroll.projectUploader" );
					dom.dropzone.off( "dragenter" );
					$document.off( "draghoverstart" );
					$document.off( "draghoverend" );
					$document.off( "dragenter.inlinedropzone" );
					$( ".inlineDropZone" ).remove();
					dom.target.remove();
				}
			);
			modelEvents.on( "showRetinaModalHelperUpdated", function ( event, pref ) {
				retinaNotice.beenSeen = pref;
			} );
			checkHelperNotification();
			checkRetinaModalNotification();
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/project-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! projects-with-groups.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectsWithGroups", ProjectsWithGroups );
	/** @ngInject */
	function ProjectsWithGroups( $filter, $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var createSortable = function () {
				groupSelector = '.group';
				sortableSelector = ( "#" + $scope.section.id + " .group:not(.empty.placeholder.bottom) .projects-in-group" );
				sortables = $( sortableSelector );
				sortables.sortable( {
					cursor: "move",
					items: ".project-tile",
					placeholder: "sortablePlaceholder",
					connectWith: sortableSelector,
					revert: 300,
					start: handleSortStart,
					stop: handleSortStop,
					update: handleSortUpdate,
					tolerance: "pointer",
					scroll: true
				} );
			}
			var destroySortable = function ( isAdding ) {
				sortables = isAdding ? sortables : $( sortableSelector );
				if ( sortables && sortables.data( 'ui-sortable' ) ) {
					sortables.sortable( "destroy" );
				}
			};
			var handleSortStart = function ( event, ui ) {
				startProjectScope = ng.element( ui.item ).scope();
				startGroupScope = ng.element( ui.item.parents( groupSelector ).first() ).scope();
				ui.item.addClass( "dragging" );
				$scope.$apply(
					function () {
						$scope.$emit( "projects:sortStart" );
					}
				);
			};
			var handleSortStop = function ( event, ui ) {
				ui.item.removeClass( "dragging" );
				$scope.$apply(
					function () {
						$scope.$emit( "projects:sortStop" );
					}
				);
			};
			var handleSortUpdate = function ( event, ui ) {
				endGroupScope = ng.element( ui.item.parents( groupSelector ).first() ).scope();
				if ( _.isUndefined( endGroupScope ) ) {
					return;
				}
				var fromProjects = startGroupScope.group.projects,
					toProjects = endGroupScope.group.projects,
					fromIndex = startProjectScope.$index,
					toIndex = ui.item.index();
				toProjects.splice(
					toIndex,
					0,
					fromProjects.splice( fromIndex, 1 )[ 0 ]
				);
				$scope.$apply(
					function () {
						$scope.$emit( "projects:sortUpdate", {
							fromGroup: startGroupScope.group,
							toGroup: endGroupScope.group,
							movedProject: ui.item.scope().project
						} );
					}
				);
			};
			var insertAfter = function ( collection, movedItem, prevItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					( locateItem( collection, prevItem ) + 1 ),
					0,
					movedItem
				);
			};
			var insertBefore = function ( collection, movedItem, nextItem ) {
				collection.splice(
					locateItem( collection, movedItem ),
					1
				);
				collection.splice(
					locateItem( collection, nextItem ),
					0,
					movedItem
				);
			};
			var locateItem = function ( collection, item ) {
				for ( var i = 0, length = collection.length; i < length; i++ ) {
					if ( collection[ i ] === item ) {
						return ( i );
					}
				}
				return ( -1 );
			};
			var startIndex = null;
			var endIndex = null;
			var groupSelector,
				startGroupScope,
				startProjectScope,
				endGroupScope,
				endProjectScope,
				sortableSelector,
				sortables;
			createSortable();
			$scope.$watch( "filters.projectFilter", function ( newValue, oldValue ) {
				if ( newValue === oldValue ) {
					return;
				}
				if ( newValue === "" ) {
					sortables.sortable( "option", "disabled", false );
				} else {
					sortables.sortable( "option", "disabled", true );
				}
			} );
			$scope.$watch( "section.groups.length", function ( newValue, oldValue, scope ) {
				var adding = newValue > oldValue;
				$timeout( function () {
					destroySortable( adding );
					createSortable();
				}, 900 );
			} );
			$scope.$on( "addNewGroup", function ( scope, targetSection, onTop ) {
				if ( $scope.section == targetSection ) {
					var groupIndex = onTop ? 1 : targetSection.groups.length - 2;
					$timeout( function () {
						$( element ).find( groupSelector ).find( 'input:visible' ).select();
						destroySortable( true );
						createSortable();
					}, 900 );
				}
			} );
			$scope.$on( "splitGroup", function ( scope, targetSection, newGroup ) {
				if ( $scope.section == targetSection ) {
					var groupIndex = targetSection.groups.indexOf( newGroup )
					$timeout( function () {
						$( element ).find( groupSelector ).find( 'input:visible' ).select();
					} );
				}
			} );
			$scope.$on( "editingGroup", function ( scope, group ) {
				$timeout( function () {
					$( element ).find( groupSelector ).find( 'input:visible' ).select();
				} );
			} );
			$scope.$on(
				"$destroy",
				function () {
					destroySortable( false );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! projects-without-groups.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invProjectsWithoutGroups", ProjectsWithoutGroups );
	/** @ngInject */
	function ProjectsWithoutGroups( $compile ) {
		function compile( tElement, tAttributes ) {
			var deferredOverlay = tElement.find( "li.project-tile .image .overlay" )
				.replaceWith( "<var rel='deferred-overlay' style='display: none ;'></var>" );
			var deferredInfo = tElement.find( "li.project-tile .project-info .hover" )
				.replaceWith( "<var rel='deferred-info' style='display: none ;'></var>" );
			var deferredForm = tElement.find( "li.project-tile form" )
				.replaceWith( "<var rel='deferred-form' style='display: none ;'></var>" );
			var transcludeOverlay = $compile( deferredOverlay );
			var transcludeInfo = $compile( deferredInfo );
			var transcludeForm = $compile( deferredForm );
			return ( link );

			function link( $scope, element, attributes ) {
				element.on(
					"mouseenter.invProjectsWithoutSort",
					"li.project-tile",
					handleMouseEnter
				);
				$scope.$on(
					"$destroy",
					function ( event ) {
						element.off( "mouseenter.invProjectsWithoutSort" );
					}
				);

				function handleMouseEnter( event ) {
					var projectTile = $( this );
					var localScope = projectTile.scope();
					if ( localScope.deferredElementsAreRendered ) {
						return;
					}
					localScope.deferredElementsAreRendered = true;
					var overlayPlaceholder = projectTile.find( "var[ rel = 'deferred-overlay' ]" );
					var infoPlaceholder = projectTile.find( "var[ rel = 'deferred-info' ]" );
					var formPlaceholder = projectTile.find( "var[ rel = 'deferred-form' ]" );
					transcludeOverlay(
						localScope,
						function ( clonedContent ) {
							overlayPlaceholder.replaceWith( clonedContent );
						}
					);
					transcludeInfo(
						localScope,
						function ( clonedContent ) {
							infoPlaceholder.replaceWith( clonedContent );
						}
					);
					transcludeForm(
						localScope,
						function ( clonedContent ) {
							formPlaceholder.replaceWith( clonedContent );
						}
					);
					localScope.$apply();
				}
			}
		}
		return ( {
			compile: compile,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! pulse-activity-dialog.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPulseActivityDialog", Directive );
	/** @ngInject */
	function Directive( $document ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var target = $( element );
			var fullWidth = 727;
			var fullHeight = 546;
			target.animate( {
					width: fullWidth,
					height: fullHeight
				},
				500
			);
			$document.on(
				"mousedown.invPulseActivityDialog",
				function ( event ) {
					if ( $.contains( target[ 0 ], event.target ) ) {
						return;
					} else if (
						$( event.target ).closest( "div.modal-backdrop" ).length ||
						$( event.target ).closest( "div.modal" ).length
					) {
						return;
					}
					$scope.$apply(
						function () {
							$scope.hideSubview();
						}
					);
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$document.off( "mousedown.invPulseActivityDialog" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! realtime.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invRealtime", Directive );
	/** @ngInject */
	function Directive( $window, config, Pusher, modelEvents, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function buildModelEventTriggerArguments( event, eventType, propertyNames ) {
				var triggerArguments = _.map(
					propertyNames,
					function ( propertyName ) {
						return ( event.data[ propertyName ] );
					}
				);
				triggerArguments.unshift( eventType );
				return ( triggerArguments );
			}

			function mapPushEvent( channel, eventType, property1, property2, propertyN ) {
				var propertyNames = _.toArray( arguments );
				channel = propertyNames.shift();
				eventType = propertyNames.shift();
				channel.bind(
					eventType,
					function ( event ) {
						var triggerArguments = buildModelEventTriggerArguments( event, eventType, propertyNames );
						$scope.$apply(
							function () {
								modelEvents.trigger.apply( modelEvents, triggerArguments );
							}
						);
					}
				);
			}
			$window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = true;
			Pusher.channel_auth_endpoint = "/api/pusher/authenticate";
			var pusher = new Pusher( config.pusher.appKey );
			var userChannel = pusher.subscribe( "private-user-" + config.userID );
			userChannel.bind( 'pusher:subscription_error', function ( status ) {
				if ( status === 403 ) {
					$window.location.reload();
				}
				/*else{
Handle other errors differently?
}*/
			} );
			mapPushEvent( userChannel, "projectCreated", "project" );
			mapPushEvent( userChannel, "projectUpdated", "project" );
			mapPushEvent( userChannel, "projectDeleted", "projectID" );
			mapPushEvent( userChannel, "projectUserAdded", "projectID", "userID" );
			mapPushEvent( userChannel, "projectUserRemoved", "projectID", "userID" );
			mapPushEvent( userChannel, "projectHomeScreenUpdated", "projectID", "screenID" );
			mapPushEvent( userChannel, "projectDuplicationStatusUpdated", "project" );
			mapPushEvent( userChannel, "screenActivated", "screen" );
			mapPushEvent( userChannel, "screenArchived", "screen" );
			mapPushEvent( userChannel, "screenDeleted", "screenID" );
			mapPushEvent( userChannel, "screenUploaded", "screen" );
			mapPushEvent( userChannel, "screenSortUpdated", "projectID", "screens" );
			mapPushEvent( userChannel, "screenCopyProgress", "screenID", "progress" );
			mapPushEvent( userChannel, "screenSourceUploaded", "screenSource" );
			mapPushEvent( userChannel, "screenSourceSyncUpdated", "assetID", "status", "projectID" );
			mapPushEvent( userChannel, "dividerDeleted", "dividerID" );
			mapPushEvent( userChannel, "dividerCreated", "divider" );
			mapPushEvent( userChannel, "dividerUpdated", "divider" );
			mapPushEvent( userChannel, "dividerPositionsUpdated", "dividers", "screens" );
			mapPushEvent( userChannel, "teamMemberCreated", "teamMember" );
			mapPushEvent( userChannel, "teamMemberUpdated", "teamMember" );
			mapPushEvent( userChannel, "companyTeamMemberCreated", "companyMember" );
			mapPushEvent( userChannel, "commentAdded", "commentID", "conversationID", "projectID" );
			mapPushEvent( userChannel, "commentUpdated", "commentID", "conversationID", "projectID" );
			mapPushEvent( userChannel, "commentDeleted", "commentID", "conversationID" );
			mapPushEvent( userChannel, "conversationAdded", "conversationID", "screenID" );
			mapPushEvent( userChannel, "conversationUpdated", "conversationID" );
			mapPushEvent( userChannel, "conversationDeleted", "conversationID" );
			mapPushEvent( userChannel, "assetDeleted", "assetID" );
			var globalChannel = pusher.subscribe( "all-users" );
			mapPushEvent( globalChannel, "newFeatureAnnounced", "mostRecentHeadline", "utcArray", "announcementID" );
			mapPushEvent( globalChannel, "breakingChangesAnnounced", "severity", "message" );
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! recent-shares-menu.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invRecentSharesMenu",
		function ( $document ) {
			function link( $scope, element, attributes ) {
				$document.on( "mousedown", handleMouseDown );
				$scope.$on(
					"$destroy",
					function () {
						$document.off( "mousedown", handleMouseDown );
					}
				);

				function handleMouseDown( event ) {
					var target = $( event.target );
					if (
						target.closest( "div.recent-shares-menu" ).length ||
						target.closest( "a.recent-shares-toggle" ).length ||
						target.closest( "div.global-zeroclipboard-container" ).length ) {
						return;
					}
					$scope.$apply(
						function () {
							$scope.hideRecentShares();
						}
					);
				}
			}
			return ( {
				link: link,
				restrict: "A"
			} );
		}
	);
	app.directive(
		"invCopyRecentShare",
		function () {
			ZeroClipboard.config( {
				debug: false,
				forceHandCursor: true,
				moviePath: "/assets/zeroclipboard/ZeroClipboard.swf"
			} );
			var hasSeenNoFlashError = false;

			function handleNoFlash() {
				if ( hasSeenNoFlashError ) {
					return;
				}
				hasSeenNoFlashError = true;
				alert( "Sorry, you have to Flash installed in order to use the \"Copy\" buttons." );
			}

			function link( $scope, element, attributes ) {
				var client = new ZeroClipboard( element );
				client.on( "noflash", handleNoFlash );
				client.on(
					"complete",
					function ( client, args ) {
						$scope.$apply(
							function () {
								$scope.copyRecentShare( $scope.recentShare );
							}
						);
						client.reposition();
					}
				);
				$scope.$on(
					"$destroy",
					function () {
						client.destroy();
					}
				);
			};
			return ( {
				link: link,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! rename-project.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invRenameProject", Directive );
	/** @ngInject */
	function Directive( projectService, validationService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var getErrorMessage = function ( response ) {
				if ( validationService.isAlreadyExists( response ) ) {
					return ( "A project with that name already exists. Project names must be unique." );
				}
				if ( validationService.isInvalidField( response ) ) {
					return ( "Your project name contians invalid characters. Try removing some punctuation." );
				}
				return ( response.message );
			};
			var handleBlur = function ( event ) {
				if ( request ) {
					return;
				}
				if ( islastReqeustFailed ) {
					hideInput();
				} else {
					submitForm();
				}
			};
			var handleClick = function ( event ) {
				showInput();
			};
			var handleKeyPress = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var theChar = String.fromCharCode( event.which );
				if ( !isValidCharacter( theChar ) ) {
					event.preventDefault();
				}
			};
			var handleKeyUp = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var enterKey = 13;
				var escapeKey = 27;
				if ( event.which === enterKey ) {
					submitForm();
				} else if ( event.which === escapeKey ) {
					hideInput();
				}
			};
			var hideInput = function () {
				input.popover( "destroy" );
				input.off( "blur.invRenameProject" );
				input.off( "keypress.invRenameProject" );
				input.off( "keyup.invRenameProject" );
				title.show();
				input.hide();
			};
			var isValidCharacter = function ( charToTest ) {
				var invalidCharacters = new RegExp( "[/\\\\:*?\"<>|]", "i" );
				return ( invalidCharacters.test( charToTest ) === false );
			};
			var showInput = function () {
				input.val( $scope.project.name );
				originalValue = input.val();
				title.hide();
				input.on( "blur.invRenameProject", handleBlur );
				input.on( "keypress.invRenameProject", handleKeyPress );
				input.on( "keyup.invRenameProject", handleKeyUp );
				input.show();
				input[ 0 ].focus();
				input[ 0 ].select();
				islastReqeustFailed = false;
			};
			var submitForm = function () {
				var newValue = input.val();
				if ( newValue === originalValue ) {
					return ( hideInput() );
				}
				input.popover( "destroy" );
				request = projectService.renameProject( $scope.project.id, newValue );
				request.then(
					function ( project ) {
						request = null;
						islastReqeustFailed = false;
						hideInput();
					},
					function ( response ) {
						request = null;
						islastReqeustFailed = true;
						input
							.popover( {
								content: getErrorMessage( response ),
								placement: "top",
								title: "Oops: Something Went Wrong",
								trigger: "manual"
							} )
							.popover( "show" );;
						input[ 0 ].focus();
						input[ 0 ].select();
					}
				);
			};
			var title = element.find( "h1" );
			var input = $( "<input type='text' />" )
				.appendTo( element )
				.hide();
			var originalValue = null;
			var request = null;
			var islastReqeustFailed = false;
			title.on( "click.invRenameProject", handleClick );
			$scope.$on(
				"$destroy",
				function () {
					title.off( "click.invRenameProject" );
					input.off( "blur.invRenameProject" );
					input.off( "keypress.invRenameProject" );
					input.off( "keyup.invRenameProject" );
					input.popover( "destroy" );
				}
			);
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! rename-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invRenameScreen", Directive );
	/** @ngInject */
	function Directive( screenService, validationService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var getErrorMessage = function ( response ) {
				if ( validationService.isInvalidField( response ) ) {
					return ( "Your screen name contains invalid characters. Try removing some punctuation." );
				}
				return ( response.message );
			};
			var handleBlur = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				submitForm();
			};
			var handleClick = function () {
				showInput();
			};
			var handleKeyPress = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var theChar = String.fromCharCode( event.which );
			};
			var handleKeyUp = function ( event ) {
				if ( request ) {
					return ( event.preventDefault() );
				}
				var enterKey = 13;
				var escapeKey = 27;
				if ( event.which === enterKey ) {
					submitForm();
				} else if ( event.which === escapeKey ) {
					hideInput();
				}
			};
			var hideInput = function () {
				screenInfo.removeClass( "editing" );
				input.popover( "destroy" );
				input.off( "blur.invRenameScreen" );
				input.off( "keypress.invRenameScreen" );
				input.off( "keyup.invRenameScreen" );
				$scope.$emit( "screenRenameBlur" );
			};
			var showInput = function () {
				input.val( $scope.object.name );
				originalValue = input.val();
				screenInfo.addClass( "editing" );
				input.on( "blur.invRenameScreen", handleBlur );
				input.on( "keypress.invRenameScreen", handleKeyPress );
				input.on( "keyup.invRenameScreen", handleKeyUp );
				input[ 0 ].focus();
				input[ 0 ].select();
				$scope.$emit( "screenRenameFocus" );
			};
			var submitForm = function () {
				var newValue = input.val().replace( /^\s+|\s+$/g, "" );
				if ( !newValue ||
					( newValue === originalValue )
				) {
					return ( hideInput() );
				}
				input.popover( "destroy" );
				request = screenService.renameScreen( $scope.object.id, newValue );
				request.then(
					function ( screen ) {
						$scope.object.name = newValue;
						request = null;
						hideInput();
					},
					function ( response ) {
						request = null;
						input
							.popover( {
								content: getErrorMessage( response ),
								placement: "top",
								title: "Oops: Something Went Wrong",
								trigger: "manual"
							} )
							.popover( "show" );;
						input[ 0 ].focus();
						input[ 0 ].select();
					}
				);
			};
			var target = $( element );
			var screenInfo = target;
			var name = target.find( "h2" );
			var input = $( "<input type='text' />" )
				.addClass( "name_new" )
				.appendTo( target );
			var originalValue = null;
			var request = null;
			name.on( "click.invRenameScreen", handleClick );
			$scope.$on(
				"$destroy",
				function () {
					name.off( "click.invRenameScreen" );
					input.off( "blur.invRenameScreen" );
					input.off( "keypress.invRenameScreen" );
					input.off( "keyup.invRenameScreen" );
					input.popover( "destroy" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! rotate-slide.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invRotateSlide", Directive );
	/** @ngInject */
	function Directive( $timeout, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$scope.goToAndPauseRotation = function ( index ) {
				$scope.currentIndex = index;
				$timeout.cancel( timer );
				timer = $timeout( rotate, timeout * 2 );
			};

			function rotate() {
				$scope.currentIndex = ( $scope.currentIndex % maxRotations ) + 1
				$timeout.cancel( timer );
				timer = $timeout( rotate, timeout );
			};
			var timer = null;
			var timeout = attributes.invRotateSpeed ? ( attributes.invRotateSpeed * 1000 ) : ( 4 * 1000 );
			var currentIndex = ( $scope.$parent[ attributes.invRotateStartingAt ] || 0 );
			var target = $( element );
			var items = target.children( '.item' );
			var maxRotations = items.length;
			$scope.currentIndex = currentIndex;
			rotate();
			$scope.$on(
				"$destroy",
				function () {
					$timeout.cancel( timer );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: "=attr"
		} );
	}
} )( angular, InVision );;;
/*! rotate.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invRotate", Directive );
	/** @ngInject */
	function Directive( $timeout, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$scope.currentIndex = 0;
			var timer = null;
			var timeout = attributes.invRotateSpeed ? ( attributes.invRotateSpeed * 1000 ) : ( 4 * 1000 );
			var target = $( element );
			var avatars = target.children( ':first' );
			var quotes = target.children( ':last' );
			$scope.goToAndPauseRotation = function ( index ) {
				$scope.currentIndex = index;
				$timeout.cancel( timer );
				timer = $timeout( rotateQuote, timeout * 2 );
			};
			var maxRotations = avatars.children().length;
			var rotateQuote = function () {
				$scope.currentIndex = ( $scope.currentIndex % maxRotations ) + 1
				$timeout.cancel( timer );
				timer = $timeout( rotateQuote, timeout );
			};
			rotateQuote();
			$scope.$on(
				"$destroy",
				function () {
					$timeout.cancel( timer );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: "=attr"
		} );
	}
} )( angular, InVision );;;
/*! sample-screens-faux-upload.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSampleScreensFauxUpload", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var dom = {};
			dom.target = element;
			$( dom.target ).on( "dragstart", function ( event ) {
				event.stopPropagation();
			} );
			$( dom.target ).draggable( {
				revert: 'invalid',
				containment: "#projectUploaderDropzone"
			} );
			$scope.$on(
				"$destroy",
				function () {}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! screen-selector.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScreenSelector", Directive );
	/** @ngInject */
	function Directive( $timeout, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element ),
				$pickerElement = $element.find( "select.select-screen" ),
				$dropdownLinks,
				selectTimer = null;
			selectTimer = $timeout(
				function () {
					var $window = $( window ),
						$parent = $element,
						maxHeight = 458,
						dropdownSize = $element.find( "option" ).length > 15 ? 15 : false,
						$ddWrapper,
						$thumbTemplate = $( '<span class="thumb"><span class="loading">Loading...</span></span>' ),
						$thumbPreview,
						previewOffset = 33,
						picker;
					if ( $scope.placement === "right" ) {
						$thumbTemplate.addClass( "pos-right" );
					}
					picker = $pickerElement
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							size: dropdownSize,
							searchPlaceholder: "Search screen names..."
						} );
					$parent.find( ".dropdown-toggle" ).on( "click", function () {
						var container = $element;
						container.top = $element.position().top;
						var dropdown = {
							element: container.find( "div.dropdown-menu" )
						};
						dropdown.top = container.top;
						dropdown.height = dropdownSize ? maxHeight : dropdown.element.outerHeight();
						dropdown.bottom = ( container.top + dropdown.height ) + 113;
						var viewport = {
							top: $window.scrollTop() + 48,
							bottom: ( $window.scrollTop() + $window.innerHeight() ) - 70,
							height: $window.height(),
							width: $window.width()
						};
						if ( !dropdown.element.is( ":visible" ) ) {
							if ( dropdown.bottom < viewport.top || dropdown.bottom > viewport.bottom ) {
								$( "body, html" ).animate( {
									scrollTop: dropdown.top - 20
								}, 500 );
							};
						}
					} );
					$pickerElement
						.on( 'isActive', function ( e, obj ) {
							var $this = $( obj ),
								rel = $this.parent().attr( "rel" );
							if ( !isNaN( rel ) && isFinite( rel ) ) {
								rel = rel - 1;
								if ( $scope.screens[ rel ] ) {
									$thumbPreview = $thumbTemplate.clone();
									var $thumbLoader = $( 'span', $thumbPreview ),
										top = $this.parent().position().top + $this.parent().height() + $this.height(),
										img = "/thumbnails/" + $scope.screens[ rel ].id + "/" + $scope.screens[ rel ].imageVersion,
										imgW = 0,
										imgH = 0;
									$thumbPreview
										.appendTo( $ddWrapper )
										.css( 'top', ( top - previewOffset ) )
										.show();
									$( '<img />' )
										.load( function () {
											imgW = this.width;
											imgH = this.height;
											$thumbPreview
												.html( $( this ) )
												.css( {
													top: ( top - ( imgH / 2 ) )
												} );
										} )
										.attr( 'src', img );
								}
							}
						} )
						.on( 'isNonActive', function () {
							$ddWrapper.find( '.thumb' ).remove();
						} );
					$ddWrapper = $pickerElement.next();
					$dropdownLinks = $element.find( 'ul.dropdown-menu a' );
					setupThumbHover();
				}
			);

			function setupThumbHover() {
				if ( $dropdownLinks == undefined ) {
					return;
				}
				$dropdownLinks
					.off( "mouseenter mouseleave click" )
					.on( "mouseenter", function ( e ) {
						$pickerElement.trigger( 'isActive', e.currentTarget );
					} )
					.on( "mouseleave click", function () {
						$pickerElement.trigger( 'isNonActive' );
					} );
			}
			$scope.$on(
				"$destroy",
				function () {
					$( element ).remove();
					$timeout.cancel( selectTimer );
				}
			);
			$scope.$watch(
				"selected.id",
				function ( newValue, oldValue ) {
					if ( newValue ) {
						var screen = _.findWithProperty( $scope.screens, "id", newValue );
						$scope.selected.versionId = screen.imageVersion;
					} else {
						$scope.selected.versionId = 0;
					}
				}
			);
			$scope.$watch(
				"selected",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$pickerElement.selectpicker( "refresh" );
					setupThumbHover();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: {
				screens: "=",
				fieldName: "@",
				selected: "=",
				defaultOpt: "@",
				disabled: "=",
				placement: "@" // either 'left' or 'right'
			},
			restrict: "A",
			templateUrl: "/assets/apps/d/views/directives/screen-selector.htm"
		} );
	}
} )( angular, InVision );;;
/*! screen-sizer.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScreenSizer", Directive );
	/** @ngInject */
	function Directive( $filter ) {
		function link( $scope, element, attributes ) {
			var dom = {
				screenSize: element.find( "div.screenSize" ),
				leftOverlay: element.find( "div.leftOverlay" ),
				rightOverlay: element.find( "div.rightOverlay" ),
				bottomOverlay: element.find( "div.bottomOverlay" )
			};
			$scope.width = 0;
			$scope.height = 0;
			applySizerDimensions(
				$scope.screenSizer.selectedSize.width,
				$scope.screenSizer.selectedSize.height,
				$scope.screen.alignment
			);
			$scope.$watch(
				"screen.alignment",
				function ( screen, oldScreen ) {
					applySizerDimensions(
						$scope.screenSizer.selectedSize.width,
						$scope.screenSizer.selectedSize.height,
						$scope.screen.alignment
					);
				}
			);

			function applySizerDimensions( width, height, alignment ) {
				$scope.width = width;
				$scope.height = height;
				dom.screenSize.css( {
					height: ( $scope.height + "px" ),
					left: "",
					margin: "",
					right: "",
					width: ( $scope.width + "px" )
				} );
				dom.leftOverlay.css( {
					height: ( $scope.height + "px" ),
					margin: "",
					right: ""
				} );
				dom.rightOverlay.css( {
					height: ( $scope.height + "px" ),
					margin: "",
					left: ""
				} );
				dom.bottomOverlay.css( {
					top: ( $scope.height + "px" )
				} );
				switch ( alignment ) {
				case "left":
					dom.screenSize.css( {
						left: "0px"
					} );
					dom.leftOverlay.hide();
					dom.rightOverlay.show();
					dom.rightOverlay.css( {
						left: ( $scope.width + "px" )
					} );
					break;
				case "right":
					dom.screenSize.css( {
						right: "0px"
					} );
					dom.leftOverlay.show();
					dom.rightOverlay.hide();
					dom.leftOverlay.css( {
						right: ( $scope.width + "px" )
					} );
					break;
				default:
					dom.screenSize.css( {
						left: "50%",
						marginLeft: ( -$scope.width / 2 + "px" )
					} );
					dom.leftOverlay.show();
					dom.rightOverlay.show();
					dom.leftOverlay.css( {
						marginRight: ( $scope.width / 2 + "px" ),
						right: "50%"
					} );
					dom.rightOverlay.css( {
						marginLeft: ( $scope.width / 2 + "px" ),
						left: "50%"
					} );
					break;
				}
			}
		};
		return ( {
			link: link,
			restrict: "A",
			scope: true
		} );
	}
} )( angular, InVision );;;
/*! screen-version-image-scaler.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScreenVersionImageScaler", Directive );
	/** @ngInject */
	function Directive() {
		function link( $scope, element, attributes ) {
			function watchForImageLoad() {
				element.on(
					"load.invHistoryImageLoadEvent",
					function ( event ) {
						scaleImage();
						element.off( "load.invHistoryImageLoadEvent" );
						$scope.$emit( "consoleImageLoaded", element );
					}
				);
			}

			function scaleImage() {
				var imageWidth = element[ 0 ].naturalWidth;
				var imageHeight = element[ 0 ].naturalHeight;
				var displayScale = $scope.screen.displayScale;
				var scaledWidth = displayScale * imageWidth;
				var scaledHeight = displayScale * imageHeight;
				element.css( {
					height: "auto",
					width: scaledWidth + "px"
				} );
			}
			$scope.$watch(
				"activeVersion.imageUrl",
				function ( oldImageUrl, newImageUrl ) {
					if ( oldImageUrl != newImageUrl ) {
						$scope.setIsImageLoading( true );
						watchForImageLoad();
					}
				}
			);
			$scope.$watch(
				"screen.displayScale",
				function ( oldDisplayScale, newDisplayScale ) {
					if ( oldDisplayScale != newDisplayScale ) {
						$scope.setIsImageLoading( true );
						watchForImageLoad();
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					element.off( "load.invHistoryImageLoadEvent" );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! screen-version-share-form.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScreenVersionShareForm", Directive );
	/** @ngInject */
	function Directive( $timeout, ZeroClipboard ) {
		var linkFunction = function ( $scope, element, attributes ) {
			function handleCopySuccess() {
				$scope.showSuccessMessage = true;
				$scope.$apply();
				if ( dom.copied.is( ".highlight" ) ) {
					dom.copied.removeClass( "highlight highlight-out" );
					clearTimeout( handleCopySuccess.timer1 );
					clearTimeout( handleCopySuccess.timer2 );
				}
				dom.copied.addClass( "highlight" );
				handleCopySuccess.timer1 = setTimeout(
					function () {
						dom.copied.addClass( "highlight-out" );
					}, ( 1 * 1000 )
				);
				handleCopySuccess.timer2 = setTimeout(
					function () {
						dom.copied.removeClass( "highlight highlight-out" );
					}, ( 2.5 * 1000 )
				);
			}

			function handleKeyChange() {
				dom.shareLink[ 0 ].select();
				clipboard.setText( dom.shareLink.val() );
			}

			function handleInit() {
				clipboard.glue( dom.copyButton[ 0 ], dom.copyButtonContainer[ 0 ] );
			}
			var dom = {};
			dom.target = $( element );
			dom.shareLink = dom.target.find( "input.zeroClipboardText" );
			dom.copyButtonContainer = dom.target.find( "div.zeroClipboardContainer" );
			dom.copyButton = dom.copyButtonContainer.find( "a.zeroClipboardButton" );
			dom.copied = dom.target.find( "div.copied_successful span" );
			var clipboard = new ZeroClipboard.Client();
			clipboard.setHandCursor( true );
			clipboard.addEventListener( "onComplete", handleCopySuccess );
			$scope.$watch(
				"isShowingShareUI",
				function ( isShowingShareUI ) {
					if ( isShowingShareUI ) {
						$timeout( handleInit, 500 );
					}
				}
			);
			$scope.$watch(
				"shareLink",
				function ( shareLink ) {
					if ( $scope.isLoading ) {
						return;
					}
					$timeout( handleKeyChange, ( $scope.isShowingShareUI ? 500 : 0 ) );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clipboard.destroy();
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! scroll-on-anything.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScrollOnAnything", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var scrollToTarget = function () {
				var targetOffset = target.offset();
				var offsetTop = Math.max( 0, ( targetOffset.top + scrollOffset ) );
				$( 'html,body' ).animate( {
						scrollTop: offsetTop
					},
					scrollSpeed
				);
			};
			var elm = $( element ),
				target = $( element );
			var scrollOffset = -25;
			var scrollTriggerEvent = "click";
			var scrollSpeed = 0;
			if ( "scrollOffset" in attributes ) {
				scrollOffset = parseInt( attributes.scrollOffset );
			}
			if ( "scrollTarget" in attributes ) {
				target = $( attributes.scrollTarget );
			}
			if ( "scrollTriggerEvent" in attributes ) {
				scrollTriggerEvent = attributes.scrollTriggerEvent;
			}
			if ( "scrollSpeed" in attributes ) {
				scrollSpeed = parseInt( attributes.scrollSpeed );
			}
			elm.on(
				scrollTriggerEvent + ".invScrollOnAnything",
				function ( event ) {
					scrollToTarget();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					elm.off( scrollTriggerEvent + ".invScrollOnAnything" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! scroll-on-submit.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invScrollOnSubmit", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var scrollToTarget = function () {
				var targetOffset = target.offset();
				var offsetTop = Math.max( 0, ( targetOffset.top + scrollOffset ) );
				$( window ).scrollTop( offsetTop );
			};
			var target = $( element );
			var scrollOffset = -25;
			if ( "scrollOffset" in attributes ) {
				scrollOffset = parseInt( attributes.scrollOffset );
			}
			target.on(
				"submit.invScrollOnSubmit",
				function ( event ) {
					scrollToTarget();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.off( "submit.invScrollOnSubmit" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! select-hotspot-menu.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSelectHotspotMenu", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			var $element = $( element ),
				$dropdownLinks,
				selectTimer = null;
			selectTimer = $timeout(
				function () {
					var $window = $( window ),
						$parent = $element.parent(),
						maxHeight = 458,
						dropdownSize = $element.find( "option" ).length > 15 ? 15 : false,
						$ddWrapper,
						$thumbTemplate = $( '<span class="thumb"><span class="loading">Loading...</span></span>' ),
						$thumbPreview,
						previewOffset = 33,
						picker;
					picker = $element
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							size: dropdownSize,
							searchPlaceholder: "Search screen names..."
						} );
					/*$parent.on(
"click",
".selectPicker",
function( event ) {
$scope.$apply( attributes.ngClick );
}
);*/
					$parent.find( ".dropdown-toggle" ).on( "click", function () {
						var hotspot = {
							element: $( element ).parents( '.hotspotSetupContainer' )
						};
						hotspot.top = hotspot.element.position().top;
						var dropdown = {
							element: hotspot.element.find( "div.dropdown-menu" )
						};
						dropdown.top = hotspot.top;
						dropdown.height = dropdownSize ? maxHeight : dropdown.element.outerHeight();
						dropdown.bottom = ( hotspot.top + dropdown.height ) + 113;
						var viewport = {
							top: $window.scrollTop() + 48,
							bottom: ( $window.scrollTop() + $window.innerHeight() ) - 70,
							height: $window.height(),
							width: $window.width()
						};
						if ( !dropdown.element.is( ":visible" ) ) {
							if ( dropdown.bottom < viewport.top || dropdown.bottom > viewport.bottom ) {
								$( "body, html" ).animate( {
									scrollTop: dropdown.top - 20
								}, 500 );
							};
						}
					} );
					$element
						.on( 'isActive', function ( e, obj ) {
							var $this = $( obj ),
								rel = $this.parent().attr( "rel" );
							if ( !isNaN( rel ) && isFinite( rel ) ) {
								rel = rel - 1;
								if ( $scope.targetOptions[ rel ] && $scope.targetOptions[ rel ].targetTypeID === 1 ) {
									$thumbPreview = $thumbTemplate.clone();
									var $thumbLoader = $( 'span', $thumbPreview ),
										top = $this.parent().position().top + $this.parent().height() + $this.height(),
										img = $scope.targetOptions[ rel ].targetScreenThumbnailUrl,
										imgW = 0,
										imgH = 0;
									$thumbPreview
										.appendTo( $ddWrapper )
										.css( 'top', ( top - previewOffset ) )
										.show();
									$( '<img />' )
										.load( function () {
											imgW = this.width;
											imgH = this.height;
											$thumbPreview
												.html( $( this ) )
												.css( 'top', ( top - ( imgH / 2 ) ) );
										} )
										.attr( 'src', img );
								}
							}
						} )
						.on( 'isNonActive', function () {
							$ddWrapper.find( '.thumb' ).remove();
						} );
					$ddWrapper = $element.next();
					$dropdownLinks = $element.parent().find( 'ul.dropdown-menu a' );
					setupThumbHover();
				}
			);

			function setupThumbHover() {
				if ( $dropdownLinks == undefined ) {
					return;
				}
				$element.parent().find( 'ul.dropdown-menu a' )
					.off( "mouseenter mouseleave click" )
					.on( "mouseenter", function ( e ) {
						$element.trigger( 'isActive', e.currentTarget );
					} )
					.on( "mouseleave click", function () {
						$element.trigger( 'isNonActive' );
					} );
			}
			$scope.$watch(
				"form.selectedTargetOption",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$( element ).selectpicker( "refresh" );
					setupThumbHover();
				}
			);
			$scope.$watch(
				"selectedTargetOption",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					$( element ).selectpicker( "refresh" );
					setupThumbHover();
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( element ).remove();
					$timeout.cancel( selectTimer );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! select.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSelect", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			var selectTimer = null;
			selectTimer = $timeout(
				function () {
					var $element = $( element );
					/*
if ( attributes.usesNgRepeatOptions && attributes.ngModel ) {
$element.find("option:first").remove();
};
*/
					$element
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							size: $( element ).data( "size" ) || false
						} );
					$element.parent().on(
						"click",
						".selectPicker",
						function ( event ) {
							$scope.$apply( attributes.ngClick );
						}
					);
					$element.parent().on(
						"hover",
						"button.btn",
						function ( event ) {
							$( this ).attr( "title", "" );
						}
					);
					$element.next().on( "click", function () {
						$scope.$apply( attributes.ngClick );
					} );
					if ( attributes.ngModel ) {
						$scope.$watch( attributes.ngModel, function watchNgModel() {
							$element.selectpicker( "refresh" );
						} );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( element ).remove();
					$timeout.cancel( selectTimer );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! showonhoverparent.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invShowonhoverparent", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			element.parent().bind( "mouseenter", function () {
				element.show();
			} );
			element.parent().bind( "mouseleave", function () {
				element.hide();
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! slice-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invSliceHelper",
		function ( $document, $timeout, _, modelEvents, screenService ) {
			var linkFunction = function ( $scope, element, attributes, keyCombosController ) {
				var $window = $( window ),
					$element = $( element ),
					$screen = $element.find( "img" ),
					leftOffset = 0;
				$( window ).on( "scroll.invSliceHelper", function () {
					if ( $scope.screen.width * $scope.screen.displayScale < $window.width ||
						$scope.project.isMobile ||
						$scope.config.zoomScrollBehavior == screenService.zoomScrollBehaviors.DISABLE_HORIZONTAL_SCROLLING
					) {
						return;
					}
					$scope.$apply( function () {
						leftOffset = $( document ).scrollLeft();
						$scope.setFixedDesktopHeaderLeftOffset( leftOffset );
					} );
				} );

				function flashHotspots() {
					var hotspots = element.closest( "#preview" ).find( ".hotspotOverlay" );
					hotspots.stop( true ).fadeTo( 300, 1 ).delay( 300 ).fadeTo( 300, 0 );
				}
				element.on( "mousedown.slice", function ( event ) {
					event.preventDefault();
					if ( !$( event.target ).hasClass( 'hotspotOverlay' ) ) {
						flashHotspots();
					}
					return false;
				} );

				function adjustHorizontalOffset( screen, isConfigChange ) {
					var screenAlignment = screen.alignment;
					var screenWidth = screen.width * screen.displayScale;
					var screenHeight = screen.height * screen.displayScale;
					var windowHeight = $( window ).height();
					var windowWidth = $( window ).width();
					var $element = $( element );
					var targetScrollLeft = 0;
					if ( $scope.project.isMobile || screenWidth <= windowWidth ) {
						$scope.setFixedDesktopHeaderLeftOffset( 0 );
						return;
					}
					if ( isConfigChange ) {
						screen = $.extend( {}, screen, $scope.config );
					}
					if ( screen.alignment === "left" ) {
						targetScrollLeft = 0;
					} else if ( screen.alignment === "right" ) {
						targetScrollLeft = ( screenWidth - windowWidth );
					} else {
						targetScrollLeft = ( ( screenWidth - windowWidth ) / 2 );
					}
					$scope.setFixedDesktopHeaderLeftOffset( targetScrollLeft );
				}
				adjustHorizontalOffset( $scope.screen );
				$scope.$on(
					"$destroy",
					function () {
						element.off( "mousedown.slice" );
						$window.off( "scroll.invSliceHelper" );
					}
				);
				$scope.$watch(
					"screen",
					function ( newValue, oldValue ) {
						adjustHorizontalOffset( newValue, false );
					} );
				modelEvents.on(
					"screenConfig:changed",
					function ( event, newConfig ) {
						adjustHorizontalOffset( $scope.screen, true );
					} );
			};
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! slide-show.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSlideShow", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var slideDuration = ( attributes.slideDuration || "fast" );
			if ( !$scope.$eval( attributes.invSlideShow ) ) {
				element.css( "display", "none" );
			}
			$scope.$watch(
				attributes.invSlideShow,
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( newValue ) {
						element.stop( true, true ).slideDown( slideDuration );
					} else {
						element.stop( true, true ).slideUp( slideDuration );
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! slider.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSlider", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element ),
				options = $scope.$eval( attributes.sliderOptions ) || {};
			var slider = $element.bxSlider( options );
			$scope.$on(
				"$destroy",
				function () {
					slider.destroySlider();
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! snaps-uploader.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSnapsUploader", Directive );
	/** @ngInject */
	function Directive( _, $window, $document, $timeout, modelEvents, Deferred, projectService ) {
		var maxInBytes = 10485760;
		var linkFunction = function ( $scope, element, attributes ) {
			var addFileToQueue = function ( id, name, size ) {
				uploadQueue.push( {
					id: id,
					name: name,
					size: size,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
			};
			var clearUploader = function () {
				uploader.stop();
				uploader.splice( 0, uploader.files.length );
				uploadQueue.splice( 0, uploadQueue.length );
			};
			var deleteFileFromQueue = function ( id ) {
				for ( var i = 0, length = uploadQueue.length; i < length; i++ ) {
					if ( uploadQueue[ i ].id == id ) {
						uploadQueue.splice( i, 1 );
						return;
					}
				}
			};
			var getQueueItemByID = function ( id ) {
				return (
					_.findWithProperty( uploadQueue, "id", id )
				);
			};
			var handleDragEnter = function ( event ) {
				event.stopPropagation();
				if ( dom.dropzone.is( ".hotDropzone" ) ) {
					return;
				}
				dom.dropzone.addClass( "hotDropzone" );
				$document.on( "dragenter.invSnapUploader", handleDragEnterOnDocument );
			};
			var handleDragEnterOnDocument = function ( event ) {
				dom.dropzone.removeClass( "hotDropzone" );
				$document.off( "dragenter.invSnapUploader" );
			};
			var handleMouseEnter = function ( event ) {
				dom.dropzone.addClass( "hotDropzone" );
			};
			var handleMouseLeave = function ( event ) {
				dom.dropzone.removeClass( "hotDropzone" );
			};
			var handlePluploadError = function ( uploader, error ) {
				if ( !error.file ) {
					return;
				}
				if ( error.code === plupload.FILE_EXTENSION_ERROR ) {
					if ( error.file.name === "Data" || error.file.name === "version" ) {
						isSketch = 1;
						$timeout( function () {
							$scope.openModalWindow( "sketchSoon" );
						} );
						clearUploader();
					}
					return;
				}
				$timeout(
					function () {
						var file = error.file;
						uploader.removeFile( file );
						removeFileFromQueue( file.id );
						console.log( error );
						if ( error.code === plupload.FILE_SIZE_ERROR ) {
							$scope.openModalWindow(
								"error", ( "The file, \"" + file.name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
							);
						} else {
							$scope.openModalWindow(
								"error", ( "We could not process the image, \"" + file.name + "\". This often happens when people accidentally give a PSD or HTML file a \".jpg\" file extension." )
							);
						}
					}
				);
			};
			var handlePluploadFilesAdded = function ( uploader, files ) {
				if ( isSketch === 1 ) {
					for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
						uploader.removeFile( files[ i ] );
					}
					isSketch = 0;
					return;
				}
				files = _.sortOnPropertyUsingNaturalOrder( files, "name" );
				var filesLength = files.length;
				var queueLength = uploader.files.length;
				for ( var i = 0; i < filesLength; i++ ) {
					uploader.files[ queueLength - filesLength + i ] = files[ i ];
				}
				var fileExcludedBasedOnName = null;
				for ( var i = ( files.length - 1 ); i >= 0; i-- ) {
					if ( !isValidFilename( files[ i ].name ) ) {
						fileExcludedBasedOnName = files[ i ].name;
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					} else if ( files[ i ].size > maxInBytes && !isPDF( files[ i ].name ) ) { // limit the max file size, unless it's a PDF
						$scope.openModalWindow(
							"error", ( "The file, \"" + files[ i ].name + ",\" is too large. Are you sure that it's not a mislabeled PSD file?" )
						);
						uploader.removeFile( files[ i ] );
						files.splice( i, 1 );
					}
				}
				if ( fileExcludedBasedOnName ) {
					if ( fileExcludedBasedOnName.split( '.' ).pop() === "sketch" ) {
						$scope.openModalWindow( "sketchSoon" );
					} else {
						$scope.openModalWindow( "error", "The file, \"" + fileExcludedBasedOnName + ",\" was skipped since it doesn't appear to be an image file." );
					}
				}
				for ( var i = 0; i < files.length; i++ ) {
					addFileToQueue(
						files[ i ].id,
						files[ i ].name,
						files[ i ].size
					);
				}
				if ( files.length ) {
					$scope.$emit( "screenUploadStart" );
					modelEvents.trigger( "screenUploadStart" );
				}
				$scope.$apply();
			};
			var handlePluploadFileUploaded = function ( uploader, file, response ) {
				uploader.removeFile( file );
				removeFileFromQueue( file.id );
				$timeout(
					function () {
						var screen = ng.fromJson( response.response );
						modelEvents.trigger( "screenUploaded", screen );
						$scope.setShowSampleScreens( false );
					}
				);
			};
			var handlePluploadInit = function ( uploader, params ) {
				isHtml5Runtime = ( uploader.runtime === "html5" );
				isFlashRuntime = ( uploader.runtime === "flash" );
				if ( isHtml5Runtime ) {
					dom.dropzone.on( "mouseenter", handleMouseEnter );
					dom.dropzone.on( "mouseleave", handleMouseLeave );
					dom.dropzone.on( "dragenter", handleDragEnter );
					dom.dropzone
						.removeClass( "flashDropzone" )
						.addClass( "html5Dropzone" );
					if ( isIE() ) {
						dom.dropzone.on( "mousemove", ieHackHandleMouseMove );
						dom.container.on( "dragover", "div.plupload", ieHackHandleDragOver );
					}
				} else {
					$scope.setShowSampleScreens( false );
					dom.target.find( "div.plupload.flash" ).on( "mouseenter", handleMouseEnter );
					dom.target.find( "div.plupload.flash" ).on( "mouseleave", handleMouseLeave );
					dom.dropzone
						.removeClass( "html5Dropzone" )
						.addClass( "flashDropzone" )
				}
			};
			var handlePluploadQueueChanged = function ( uploader ) {
				if ( uploader.files.length && isNotUploading() ) {
					$scope.$apply(
						function () {
							uploader.start();
						}
					);
				}
			};
			var handlePluploadUploadComplete = function ( uploader, files ) {
				$scope.$emit( "screenUploadStop" );
			};
			var handlePluploadUploadProgress = function ( uploader, file ) {
				$scope.$apply(
					function () {
						setFileProgress(
							file.id,
							file.uploaded,
							file.percent
						);
					}
				);
			};
			var handleWindowScroll = function ( event ) {
				var uploaderOffset = dom.target.offset();
				var uploaderTop = uploaderOffset.top;
				var isAboveFold = ( uploaderTop < dom.window.scrollTop() );
				if ( !$scope.activeScreens.length ) {
					$scope.isFixedDropzone = false;
				} else if ( isAboveFold && !dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = true;
				} else if ( !isAboveFold && dom.target.is( ".fixed" ) ) {
					$scope.isFixedDropzone = false;
				}
				$timeout(
					function () {
						$scope.$apply();
						setTimeout( refreshUploader ); // Allow pause for DOM to update before shim is refreshed.
					}
				);
			};
			var ieHackHandleDragOver = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
				}
				dom.dynamicPluploadWidget.hide();
			};
			var ieHackHandleMouseMove = function () {
				if ( dom.dynamicPluploadWidget === null ) {
					dom.dynamicPluploadWidget = dom.container.find( "div.plupload" );
				}
				if ( !dom.dynamicPluploadWidget.is( ":visible" ) &&
					!ieHackHandleMouseMove.timer
				) {
					ieHackHandleMouseMove.timer = setTimeout(
						function () {
							dom.dynamicPluploadWidget.show();
							ieHackHandleMouseMove.timer = null;
						},
						150
					);
				}
			};
			var isIE = function () {
				return ( /\bmsie\b/i.test( $window.navigator.userAgent ) );
			};
			var isNotUploading = function () {
				return ( uploader.state === plupload.STOPPED );
			};
			var isPDF = function ( name ) {
				var pattern = /\.(pdf)$/i;
				return (
					pattern.test( name )
				);
			};
			var isUploading = function () {
				return ( uploader.state === plupload.STARTED );
			};
			var isValidFilename = function ( name ) {
				var pattern = /\.(gif|jpe?g|png|pdf)$/i;
				return (
					pattern.test( name )
				);
			};
			var refreshUploader = function () {
				uploader.refresh();
			};
			var removeFileFromQueue = function ( id ) {
				var queueItem = getQueueItemByID( id );
				queueItem.state = $scope.fileStates.COMPLETED;
				var listItem = dom.files.children( "li[ data-id = '" + id + "' ]" );
				if ( !listItem.length ) {
					return ( deleteFileFromQueue( id ) );
				}
				listItem.fadeOut(
					"slow",
					function () {
						listItem.remove();
						deleteFileFromQueue( id );
						$scope.$apply();
					}
				);
			};
			var setFileProgress = function ( id, loaded, percent ) {
				var queueItem = getQueueItemByID( id );
				queueItem.percentage = percent;
				if ( queueItem.state === $scope.fileStates.PENDING ) {
					queueItem.state = $scope.fileStates.UPLOADING;
				}
			};
			var onSampleScreenDrop = function () {
				$scope.$emit( "screenUploadStart" );
				$scope.setShowSampleScreens( false );
				$scope.uploadQueue.push( {
					id: 'sample1',
					name: "Sample 1",
					size: 10000,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
				$scope.uploadQueue.push( {
					id: 'sample2',
					name: "Sample 2",
					size: 10000,
					percentage: 0,
					state: $scope.fileStates.PENDING
				} );
				$scope.$apply();
				$timeout( function () {
					setFileProgress( "sample1", false, 35 );
					setFileProgress( "sample2", false, 35 );
					$timeout( function () {
						setFileProgress( "sample1", false, 80 );
						setFileProgress( "sample2", false, 80 );
						Deferred.handlePromise(
							projectService.addSampleScreensToProject( $scope.projectID ),
							function () {
								$scope.$emit( "screenUploadStop" );
							}
						);
						$timeout( function () {
							setFileProgress( "sample1", false, 100 );
							setFileProgress( "sample2", false, 100 );
							removeFileFromQueue( "sample1" );
							removeFileFromQueue( "sample2" );
						}, 250 );
					}, 250 );
				}, 400 );
			};
			var dom = {};
			dom.target = element;
			dom.container = dom.target.find( "div.positioned-container" );
			dom.dropzone = dom.target.find( "div.dropzone" );
			dom.queue = dom.target.find( "div.queue" );
			dom.files = dom.queue.find( "ol.files" );
			dom.macAppAdvert = dom.target.find( ".mac-app-cta" );
			dom.mobileTips = dom.target.find( "p.tips a" );
			dom.html5Instructions = dom.target.find( ".html5Instructions" );
			dom.window = $( window );
			dom.dynamicPluploadWidget = null;
			$( '.html5Instructions' ).droppable( {
				accept: ".sampleScreens",
				drop: onSampleScreenDrop
			} );
			var uploader = new plupload.Uploader( {
				runtimes: "html5, flash",
				url: "/api/screens",
				multipart_params: {
					"projectID": $scope.projectID,
					"snap": true
				},
				drop_element: "snapUploaderDropzone",
				browse_button: "snapUploaderDropzone",
				container: "snapUploaderContainerBuffer",
				flash_swf_url: "/assets/plupload/js/plupload.flash.swf",
				urlstream_upload: true,
				headers: {
					"X-XSRF-TOKEN": $scope.xsrfToken
				},
				filters: [ {
					title: "Image files",
					extensions: "gif,jpg,jpeg,png,pdf"
				} ]
			} );
			var isHtml5Runtime = false;
			var isFlashRuntime = false;
			uploader.bind( "Init", handlePluploadInit );
			uploader.bind( "Error", handlePluploadError );
			uploader.bind( "FilesAdded", handlePluploadFilesAdded );
			uploader.bind( "QueueChanged", handlePluploadQueueChanged );
			uploader.bind( "UploadProgress", handlePluploadUploadProgress );
			uploader.bind( "FileUploaded", handlePluploadFileUploaded );
			uploader.bind( "UploadComplete", handlePluploadUploadComplete );
			uploader.init();
			var isSketch = 0;
			var uploadQueue = $scope.uploadQueue = [];
			$scope.fileStates = {
				PENDING: "PENDING",
				UPLOAIND: "UPLOADING",
				COMPLETED: "COMPLETED"
			};
			$scope.isFixedDropzone = false;
			$scope.openMacAppAdvertModal = function () {
				$scope.openModalWindow( "macAppAdvert" );
			};
			$scope.hideMacAppAdvert = function () {
				$scope.$parent.hideMacAppAdvert();
			};
			$scope.$watch(
				"!! activeScreens.length",
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( newValue >= 1 ) {
						$scope.user.hasSnaps = true;
					} else {
						$scope.user.hasSnaps = false;
					}
					$scope.isShowingUploader = true;
					$timeout( refreshUploader );
				}
			);
			$scope.$watch(
				"projectID",
				function ( newValue ) {
					uploader.settings.multipart_params.projectID = newValue;
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					clearUploader();
					dom.window.off( "error.snapUploader" );
					dom.window.off( "scroll.snapUploader" );
					dom.target.remove();
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			scope: true,
			templateUrl: "/assets/apps/d/views/directives/snaps-uploader.htm"
		} );
	}
} )( angular, InVision );;;
/*! spinner.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSpinner", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			var valueToWatch = ( attributes.controlValue || "isLoading" );
			var opts = {
				lines: 11, // The number of lines to draw
				length: 21, // The length of each line
				width: 13, // The line thickness
				radius: 28, // The radius of the inner circle
				corners: 1, // Corner roundness (0..1)
				rotate: 0, // The rotation offset
				direction: 1, // 1: clockwise, -1: counterclockwise
				color: "#000", // #rgb or #rrggbb or array of colors
				speed: 1.3, // Rounds per second
				trail: 65, // Afterglow percentage
				shadow: false, // Whether to render a shadow
				hwaccel: false, // Whether to use hardware acceleration
				className: "spinner", // The CSS class to assign to the spinner
				zIndex: 2e9, // The z-index (defaults to 2000000000)
				top: "50%", // Top position relative to parent in px
				left: "auto" // Left position relative to parent in px
			};
			var spinner = new Spinner( opts )
				.spin( element[ 0 ] );
			var fadeInDuration = 300;
			var fadeOutDuration = 250;
			if ( $scope[ valueToWatch ] ) {
				element.fadeIn( fadeInDuration );
			} else {
				element.stop( true ).fadeOut( fadeOutDuration );
			}
			$scope.$watch(
				valueToWatch,
				function ( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( newValue ) {
						element.stop( true ).fadeIn( fadeInDuration );
					} else {
						element.stop( true ).fadeOut( fadeOutDuration );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					if ( spinner && spinner.stop ) {
						spinner.stop();
					}
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! sticky-element.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invStickyElement", Directive );
	/** @ngInject */
	function Directive( _, $timeout, Deferred, accountService ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $window = $( window ),
				$body = $( "body" ),
				$element = $( element ),
				elementTop = $element.offset().top,
				offset = attributes.stickyOffset || 0;

			function setTooltipPlacement( placement ) {
				_.forEach( $element.find( "a[inv-tooltip], a[inv-confirm-popover]" ), function ( element ) {
					var $element = $( element );
					$element.attr( "placement", placement );
				} );
			}

			function hideTooltips() {
				$( ".popover" ).hide();
			}
			$window.on( "scroll.sticky", function windowScrolling() {
				if ( attributes.shouldStick == "false" ) {
					return;
				}
				var checkHeight = ( $( this ).scrollTop() + parseInt( offset ) );
				if ( checkHeight >= elementTop && !$element.hasClass( "fixed" ) ) {
					$( ".popover, .tooltip" ).hide();
					$element.addClass( "fixed" );
					$body.addClass( "has-sticky-element" );
					setTooltipPlacement( "bottom" );
				} else if ( checkHeight <= elementTop && $element.hasClass( "fixed" ) ) {
					$( ".popover, .tooltip" ).hide();
					$element.removeClass( "fixed" );
					$body.removeClass( "has-sticky-element" );
					setTooltipPlacement( "top" );
				}
			} );
			attributes.$observe( "shouldStick", function ( shouldStick ) {
				if ( shouldStick === false || shouldStick === "false" ) {
					$element.removeClass( "fixed" );
					$body.removeClass( "has-sticky-element" );
				}
			} );
			$scope.$on( "$destroy", function () {
				$window.off( "scroll.sticky" );
			} );
		};
		return ( {
			link: linkFunction
		} );
	}
} )( angular, InVision );;;
/*! success-button.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSuccessButton", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $button = $( element ),
				markup = "<span class=\"success-wrap\">" +
				"<span class=\"content\">" + $button.text() + "</span>" +
				"<span class=\"success\"></span>" +
				"</span>",
				delay = attributes.delay || 1500;
			$button
				.text( "" )
				.addClass( "success-button" )
				.append( $( markup ) );
			$scope.$on( "invSuccessButton:success", function () {
				$button.addClass( "success" );
				$timeout( function () {
					$scope.$apply( attributes.afterSuccess );
				}, delay );
			} );
			$scope.$on(
				"$destroy",
				function () {
					$button.off( "click.invSuccessButton" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! template-dropdown-menu.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTemplateDropdownMenu", Directive );
	/** @ngInject */
	function Directive( _, $window, $timeout, $document ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				var window = $( $window );
				var WINDOW_OFFSET = 190;
				var TEMPLATE_HEIGHT = 67;
				var isScrollbarAdded = false;

				function adjustHeight() {
					element.css( "height", getCalculatedHeight() );
				}

				function adjustScrollbarHeight( isResize ) {
					var height = getCalculatedHeight();
					var templatesHeight = getTotalTemplates() * TEMPLATE_HEIGHT;
					var maxMenuSize = window.height() - WINDOW_OFFSET;
					$timeout( function () {
						element.find( ".viewport" ).height( "100%" );
						if ( !height || templatesHeight < maxMenuSize ) {
							element.find( ".overview" ).height( "100%" );
							element.addClass( "noscroll" );
						} else {
							element.removeClass( "noscroll" );
							element.find( ".overview" ).height( getTotalTemplates() * TEMPLATE_HEIGHT );
							if ( !isScrollbarAdded || isResize ) {
								scrollableList.tinyscrollbar( {
									size: height
								} );
								isScrollbarAdded = true;
							} else {
								scrollableList.tinyscrollbar_update( "relative" );
							}
						}
					}, 50 );
				}

				function getCalculatedHeight() {
					var height = window.height() - WINDOW_OFFSET;
					var templateCount = getTotalTemplates();
					var templateListSize = templateCount * TEMPLATE_HEIGHT;
					if ( templateListSize < height ) {
						return templateListSize;
					} else {
						return height;
					}
				}

				function getTotalTemplates() {
					var templateCount = 0;
					_.each( $scope.templates, function ( template ) {
						if ( !template.isDeleted ) {
							templateCount++;
						}
					} );
					return templateCount;
				}

				function scrollToBottom() {
					$timeout( function () {
						element.scrollTop( 9999999 );
					}, 20 );
				}

				function addScrollbarElements() {
					element
						.wrapInner( "<div class='overview'>" )
						.wrapInner( "<div class='viewport'>" )
						.prepend( "<div unselectable='on' class='scrollbar unselectable'><div class='track'><div class='thumb'><div class='end'></div></div></div></div>" );
				}

				function toggleTemplateMenu() {
					if ( $( '#template-drop-down:visible' ).length == 0 ) {
						$( '#template-drop-down' ).show();
						$document.bind( 'mousedown', mousedown );
					} else {
						$( '#template-drop-down' ).hide();
						$document.unbind( 'mousedown', mousedown );
					}
				}

				function mousedown( event ) {
					if ( !$( event.target ).closest( element ).length && !$( event.target ).closest( dropdownButton ).length && !$( event.target ).closest( helpTemplate ).length && !$scope.isSelectingBulkScreens ) {
						$( '#template-drop-down' ).hide();
					}
				}
				$scope.$on( "templateDeleted", function ( event ) {
					adjustHeight();
					adjustScrollbarHeight();
				} );
				$scope.$on( "templateAdded", function ( event ) {
					adjustHeight();
					adjustScrollbarHeight();
				} );
				$scope.$on( "templateDuplicated", function ( event ) {
					adjustHeight();
					adjustScrollbarHeight();
				} );
				$scope.$on(
					"$destroy",
					function () {
						$document.unbind( 'mousedown', mousedown );
					}
				);
				var dropdownButton = element.parents( ".dropdown" ).find( ".dropdown-toggle" );
				var helpTemplate = element.parents( ".dropdown" ).find( ".new-template-how-to-video" );
				var scrollableList = element;
				var addNewTemplate = element.parent().find( ".add-new-template" );
				dropdownButton.on( "click", function ( event ) {
					toggleTemplateMenu();
					adjustHeight();
					adjustScrollbarHeight();
				} );
				$timeout( function () {
					$( "a.close-template-menu" ).on( "click", function ( event ) {
						$( '#template-drop-down' ).hide();
					} );
				} );
				addNewTemplate.on( "click", function ( event ) {
					event.preventDefault();
					return false;
				} );
				addNewTemplate.find( "a" ).on( "click", scrollToBottom );
				window.resize( function () {
					adjustHeight();
					adjustScrollbarHeight( true );
				} );
				$timeout( addScrollbarElements, 1, false );
				$timeout( adjustHeight );
			}
		};
	}
} )( angular, InVision );;;
/*! timepicker.js */
;;
/**
 * Angular wrapper for jQuery timepicker
 */
angular.module( 'InVision' )
	.directive( 'invTimepicker', function () {
		return {
			restrict: 'A',
			require: 'ngModel',
			link: function ( $scope, element, attrs, ngModel ) {
				var config = {
					step: 30,
					timeFormat: 'h:i A',
					forceRoundTime: false
				};
				ngModel.$render = function () {
					var date = ngModel.$modelValue;
					if ( angular.isDefined( date ) && date !== null && !angular.isDate( date ) ) {
						throw new Error( 'ng-Model value must be a Date object - currently it is a ' + typeof date + '.' );
					}
					if ( !element.is( ":focus" ) ) {
						element.timepicker( 'setTime', date );
					}
				};
				ngModel.$parsers.unshift( function () {
					return element.timepicker( 'getTime', ngModel.$modelValue );
				} );
				$scope.$watch( attrs.ngModel, function () {
					ngModel.$render();
				}, true );
				element.timepicker( config );
				element.on( 'changeTime', function () {
					$scope.$evalAsync( function () {
						var date = element.timepicker( 'getTime', ngModel.$modelValue );
						ngModel.$setViewValue( date );
					} );
				} );
			}
		};
	} );;;
/*! tinyscrollbar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTinyscrollbar", Directive );
	/** @ngInject */
	function Directive( $timeout, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var target = $( element );
			target
				.wrapInner( "<div class='overview'>" )
				.wrapInner( "<div class='viewport'>" )
				.prepend( "<div unselectable='on' class='scrollbar unselectable'><div unselectable='on' class='track unselectable'><div unselectable='on' class='thumb unselectable'><div unselectable='on' class='end unselectable'></div></div></div></div>" )
				.tinyscrollbar( {
					axis: attributes.axis || "y",
					wheelSpeed: attributes.axis || 40
				} );
			var viewport = target.children( "div.viewport" );
			var overview = viewport.children( "div.overview" );
			var scrollbar = target.children( "div.scrollbar" );
			scrollbar.on(
				"mousedown.invTinyscrollbar selectstart.invTinyscrollbar",
				function ( event ) {
					event.preventDefault();
				}
			);
			$scope.$watch(
				function () {
					return ( overview[ 0 ].innerHTML.length );
				},
				function ( newValue ) {
					target.tinyscrollbar_update( "relative" );
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					target.remove();
					scrollbar.off( "mousedown.invTinyscrollbar" );
					scrollbar.off( "selectstart.invTinyscrollbar" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! toggle-body-click.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invToggleBodyClick", Directive );

	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $body = $( "body" ),
				$element = $( element ),
				ignored = attributes.ignore && attributes.ignore.split( ',' );
			$element.on( "click", function () {
				$body.on( "mousedown.invToggleBodyClick", function bodyClick( event ) {
					if ( ignored.length ) {
						for ( var i = 0; i < ignored.length; ++i ) {
							if ( $( ignored[ i ] ).find( $( event.target ) ).length || $( event.target ).is( $element ) ) {
								return;
							}
						}
					}
					$timeout( function () {
						angular.element( $element ).triggerHandler( "click" );
						$body.off( "mousedown.invToggleBodyClick" );
					} );
				} );
			} );
			$scope.$on(
				"$destroy",
				function () {
					$body.off( "mousedown.invToggleBodyClick" );
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! toggle.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invToggle", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes, modelController ) {
			function applyModelValue( value ) {
				if ( value ) {
					element
						.addClass( "on" )
						.removeClass( "off" );
				} else {
					element
						.addClass( "off" )
						.removeClass( "on" );
				}
			}

			function toggle() {
				var newValue = !modelController.$modelValue;
				applyModelValue( newValue );
				modelController.$setViewValue( newValue );
			}
			var thumb = element.find( "a.toggle-thumb" );
			thumb.on(
				"click.invToggle",
				function ( event ) {
					event.preventDefault();
					$scope.$apply( toggle );
				}
			);
			modelController.$render = function () {
				applyModelValue( modelController.$modelValue );
			};
			$scope.$on(
				"$destroy",
				function () {
					thumb.off( "click.invToggle" );
				}
			);
		};
		return ( {
			link: linkFunction,
			replace: true,
			require: "^ngModel",
			restrict: "A",
			templateUrl: "/assets/apps/d/views/directives/toggle.htm"
		} );
	}
} )( angular, InVision );;;
/*! tooltip.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTooltip", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			function tryToKillTooltip() {
				if ( tooltipInstance ) {
					tooltipInstance.show = ng.noop;
					if ( tooltipInstance.$tip ) {
						tooltipInstance.$tip.remove();
					}
				}
				target.tooltip( "destroy" );
			}

			function escapeHtml( str ) {
				var safeContent = String( str )
					.replace( /&/g, "&amp;" )
					.replace( /"/g, "&quot;" )
					.replace( /'/g, "&apos;" )
					.replace( /</g, "&lt;" )
					.replace( />/g, "&gt;" );
				safeContent = safeContent
					.replace( /&lt;(br)\s*\/?&gt;/ig, "<$1 />" )
					.replace( /&lt;(\/)?(strong|em)&gt;/ig, "<$1$2>" );
				return ( safeContent );
			}

			function getOptions() {
				return {
					placement: function () {
						return ( target.attr( "placement" ) || "top" );
					},
					delay: 100,
					title: function () {
						return ( escapeHtml( attributes.invTooltip ) );
					},
					template: '<div class="tooltip ' +
						( attributes.tooltipWidth === 'content' ? 'content-width' : styleClass ) +
						'"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
				};
			}
			var target = $( element );
			var tooltipInstance = null;
			var styleClass = ( attributes.tooltipstyleclass || "" );
			target.on( 'mouseenter', function () {
				target.data( 'isShowing', true );
			} );
			target.on( 'mouseleave', function () {
				target.data( 'isShowing', false );
			} );
			attributes.$observe(
				"invTooltip",
				function ( newValue ) {
					if ( target.data( 'isShowing' ) ) {
						if ( newValue.length > 0 ) {
							tooltipInstance.show();
						} else {
							tooltipInstance.hide();
						}
					}
				}
			);
			attributes.$observe(
				"tooltipDisabled",
				function ( newValue ) {
					newValue = ( newValue || "false" );
					var isEnabled = ( newValue === "false" );
					if ( isEnabled ) {
						var tooltipOptions = getOptions();
						target.tooltip( tooltipOptions );
						tooltipInstance = target.data( "tooltip" );
					} else {
						tryToKillTooltip();
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					tryToKillTooltip();
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: 'A',
			replace: true
		} );
	}
} )( angular, InVision );;;
/*! truncate.js */
;;
angular.module( 'truncate', [] )
	.filter( 'characters', function () {
		return function ( input, chars, breakOnWord ) {
			if ( isNaN( chars ) ) return input;
			if ( chars <= 0 ) return '';
			if ( input && input.length >= chars ) {
				input = input.substring( 0, chars );
				if ( !breakOnWord ) {
					var lastspace = input.lastIndexOf( ' ' );
					if ( lastspace !== -1 ) {
						input = input.substr( 0, lastspace );
					}
				} else {
					while ( input.charAt( input.length - 1 ) == ' ' ) {
						input = input.substr( 0, input.length - 1 );
					}
				}
				return input + '...';
			}
			return input;
		};
	} )
	.filter( 'words', function () {
		return function ( input, words ) {
			if ( isNaN( words ) ) return input;
			if ( words <= 0 ) return '';
			if ( input ) {
				var inputWords = input.split( /\s+/ );
				if ( inputWords.length > words ) {
					input = inputWords.slice( 0, words ).join( ' ' ) + '...';
				}
			}
			return input;
		};
	} );;;
/*! unfocus.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invUnfocus", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			element.bind( "blur", function () {
				$scope.$apply( attributes[ "invUnfocus" ] );
			} );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! uniform.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invUniform", Directive );
	/** @ngInject */
	function Directive() {
		var pendingTimer = null;
		var pending = [];

		function dequeueLink() {
			for ( var i = 0, length = pending.length; i < length; i++ ) {
				pending[ i ]();
			}
			pendingTimer = null;
			pending = [];
		}

		function queueLink( linkHandler ) {
			pending.push( linkHandler );
			if ( !pendingTimer ) {
				pendingTimer = setTimeout( dequeueLink, 50 );
			}
		}
		var linkFunction = function ( $scope, element, attributes ) {
			function handler() {
				$( element ).uniform();
				$scope.$watch(
					attributes.ngModel,
					function ( newValue, oldValue ) {
						$.uniform.update( element );
					}
				);
			}
			if ( attributes.immediate == "true" ) {
				handler();
			} else {
				queueLink( handler );
			}
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! video-overlay.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invVideoOverlay", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes ) {
			var $element = $( element ),
				playerId = ( attributes.playerId || "unknown" ),
				videoId = ( attributes.videoId || "unknown" ),
				videoType = ( attributes.videoType || 'vimeo' ),
				autoPlay = ( attributes.autoplay || "false" ),
				videoName = ( attributes.videoName || videoId ),
				videoWidth = ( attributes.videoWidth || 788 ),
				videoHeight = ( attributes.videoHeight || 444 ),
				$overlay = $element.find( ".play-overlay" ),
				$embed = videoType == "wistia" ?
				$( '<iframe id="' + playerId + '" src="//fast.wistia.net/embed/iframe/' + videoId + '" allowtransparency="true" frameborder="0" scrolling="no" class="wistia_embed" name="wistia_embed" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width="' + videoWidth + '" height="' + videoHeight + '"></iframe>' ) :
				$( '<iframe id="' + videoId + '" src="//player.vimeo.com/video/' + videoId + '?title=0&amp;byline=0&amp;portrait=0?api=1&amp;player_id=' + playerId + '" width="' + videoWidth + '" height="' + videoHeight + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>' ),
				player = $f( $embed[ 0 ] );
			$element.append( $embed );
			/* Wistia Video */
			/********************************************************/
			function loadWistiaVideo() {
				var wistiaEmbed = document.getElementById( playerId ).wistiaApi;
				wistiaEmbed.ready( function () {
					$overlay.find( "a" ).on( "click", function ( e ) {
						e.preventDefault();
						$timeout( function () {
							$overlay.fadeOut( 250 );
							wistiaEmbed.play();
						}, 250 );
					} );
					if ( autoPlay === "true" ) {
						$overlay.find( "a" ).click();
					}
					wistiaEmbed.bind( 'play', function () {
						_kmq.push( [ 'record', 'Played Video - ' + videoName ] );
					} );
					wistiaEmbed.bind( 'pause', function () {
						_kmq.push( [ 'record', 'Paused Video - ' + videoName ] );
					} );
					wistiaEmbed.bind( "end", function () {
						$overlay.fadeIn( 250 );
						_kmq.push( [ 'record', 'Finished Video - ' + videoName ] );
					} );
				} );
			}
			if ( attributes.videoType == 'wistia' ) {
				if ( !window.wistiaApi ) {
					$.getScript( '//fast.wistia.net/static/iframe-api-v1.js' ).then( loadWistiaVideo );
				} else {
					loadWistiaVideo();
				}
				/* Vimeo Video */
				/********************************************************/
			} else {
				player.addEvent( "ready", function () {
					$overlay.find( "a" ).on( "click", function ( e ) {
						e.preventDefault();
						player.api( "play" );
						$timeout( function () {
							$overlay.fadeOut( 250 );
						}, 250 );
					} );
					if ( autoPlay === "true" ) {
						$embed.load( function () {
							$overlay.find( "a" ).click();
						} );
					}
					player.addEvent( 'play', function () {
						_kmq.push( [ 'record', 'Played Video - ' + videoName ] );
					} );
					player.addEvent( 'pause', function () {
						_kmq.push( [ 'record', 'Paused Video - ' + videoName ] );
					} );
					player.addEvent( "finish", function () {
						$overlay.fadeIn( 250 );
						_kmq.push( [ 'record', 'Finished Video - ' + videoName ] );
					} );
				} );
			}
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! err-src.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "errSrc", Directive );
	/** @ngInject */
	function Directive( $filter ) {
		return {
			link: function ( scope, element, attrs ) {
				element.bind( 'error', function () {
					element.attr( 'src', attrs.errSrc );
				} );
			}
		}
	};
} )( angular, InVision );;;
/*! test-comparison-comment.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTestComparisonComment", Directive );
	/** @ngInject */
	function Directive( userService, _ ) {
		var linkFunction = function ( $scope, element, attributes ) {
			$scope.getFirstLetter = function ( name ) {
				return _.first( name.split( "" ) ).toUpperCase();
			};
			$scope.defaultgravatar = location.protocol + "//" + location.hostname + "/assets/apps/d/img/default-gravatar.png";
			$scope.isSystemAvatar = userService.isSystemAvatar( $scope.comment.avatarID );
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: {
				comment: "="
			},
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/test-comparison-comment.htm"
		} );
	}
} )( angular, InVision );;;
/*! test-comparison-review-panel.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTestComparisonReviewPanel", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		var linkFunction = function ( $scope, element, attributes, controller ) {
			$( ".knob", element ).knob();
			$scope.viewScreen = "screen" + attributes.which; // "which" is just a text value, not being dynamic
			$scope.viewPanel = function ( screen ) {
				$scope.$parent.view.screen = $scope.$parent.test.screens[ screen ];
				$scope.$parent.view.showFullSize = true;
			};
			$scope.$watch(
				"results.percentage",
				function ( newValue, oldValue ) {
					if ( newValue ) {
						$( ".knob", element ).val( newValue ).trigger( "change" );
					}
				}
			);
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: {
				screen: "=",
				which: "@", // Is it screen 'A' or 'B'?
				testId: "=",
				results: "="
			},
			replace: true,
			templateUrl: "/assets/apps/d/views/directives/test-comparison-review-panel.htm"
		} );
	}
} )( angular, InVision );;;
/*! test-popover.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invTestPopover", Directive );
	/** @ngInject */
	function Directive() {
		var linkFunction = function ( $scope, element, attributes ) {
			var FIELDS = [ "email", "agerange", "incomelevel", "gender", "location" ],
				show = false;
			for ( var i = 0; i < FIELDS.length; i++ ) { // test all fields but name
				if ( $scope.comment[ FIELDS[ i ] ].length ) {
					show = true;
					break;
				}
			}
			if ( !show && $scope.comment.name.length ) {
				show = !/Anon/i.test( $scope.comment.name );
			}
			if ( show ) {
				element.popover( {
					title: "<span class=\'testPopTitle\'>Participant Information<\/span>",
					content: function () {
						var clone = $( "~ .commentorExpanded", this ).clone();
						return clone.removeClass( "hide" );
					},
					trigger: "hover"
				} );
				$scope.$on(
					"$destroy",
					function () {
						element.popover( "destroy" );
					}
				);
			} else {
				element.addClass( "anon" );
			}
		};
		return ( {
			link: linkFunction,
			restrict: "A",
			scope: false
		} );
	}
} )( angular, InVision );;;
/*! test-screen-viewer.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invTestScreenViewer",
		/** @ngInject */
		function ( modelEvents, $window ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var $win = $( $window );
				var resizeScreenViewer = function ( isImageReady ) {
					isImageReady = typeof isImageReady === "undefined" ? false : isImageReady;
					var $element = $( element ),
						$screenViewerWindow = $element.find( ".screenViewer" ),
						$screenImage = $element.find( ".imageContainer img" ),
						windowPadding = 40;
					var screenHeight = $scope.view.screen.height,
						screenWidth = $scope.view.screen.width;
					if ( isImageReady ) {
						screenHeight = $screenImage.height(),
						screenWidth = $screenImage.width();
					}
					$screenViewerWindow.removeClass( "taller" );
					$screenViewerWindow.removeClass( "wider" );
					if ( $win.height() < screenHeight + windowPadding ) {
						screenHeight = $win.height() - windowPadding;
						$screenViewerWindow.addClass( "taller" );
					}
					if ( $win.width() < screenWidth + windowPadding ) {
						screenWidth = $win.width() - windowPadding;
						$screenViewerWindow.addClass( "wider" );
					}
					$screenViewerWindow.css( {
						height: screenHeight,
						width: screenWidth,
						"margin-left": "-" + ( screenWidth / 2 ) + "px",
						"margin-top": "-" + ( screenHeight / 2 ) + "px"
					} );
				};
				resizeScreenViewer();
				$scope.$on( "resizeViewerWindow", function () {} );
				$win.on( "resize.screenViewerModal", resizeScreenViewer );
				$scope.$on( "$destroy", function () {
					$win.off( "resize.screenViewerModal" );
				} );
				$scope.$watch(
					"view.showFullSize",
					function ( newValue, oldValue ) {
						if ( newValue ) {
							resizeScreenViewer( true );
						}
					}
				);
			};
			return ( {
				link: linkFunction,
				transclude: true,
				replace: true,
				restrict: "A",
				templateUrl: "/assets/apps/d/views/directives/test-screen-viewer.htm"
			} );
		}
	);
} )( angular, InVision );;;
/*! custom-screens.js */
;;
( function ( ng, app ) {
	"use strict";
	app.filter( 'customScreensFilter', function () {
		return function ( objects, searchValue ) {
			var $divider = $( ".divider" );
			$divider.show();
			if ( searchValue == "" ) {
				return objects;
			}
			objects = _.filter( objects, function ( object ) {
				if ( object != undefined && object.type != undefined ) {
					return true;
				} else {
					return false;
				}
			} );
			var results = [];
			angular.forEach( objects, function ( object, key ) {
				if ( object.type != undefined && ( object.type === "divider" ||
					( object.type === "screenObj" && object.name.toUpperCase().indexOf( searchValue.toUpperCase() ) !== -1 ) ) ) {
					results.push( object );
				}
			} );
			_.forEach( $divider, function ( element ) {
				var $this = $( element );
				if ( !$this.next().hasClass( "screenObj" ) ) {
					$this.hide();
				}
			} );
			results = updateFilteredScreenCountForDividers( results );
			return results;
		};
	} );
	app.filter( 'customScreenStatusFilter', function () {
		return function ( objects, activeFilter ) {
			var results = [];
			if ( activeFilter.workflowStatusID == 0 && activeFilter.label == "All Screens" ) {
				results = objects;
			} else if ( activeFilter.workflowStatusID == 0 && activeFilter.label == "Without Hotspots" ) {
				angular.forEach( objects, function ( object ) {
					if ( object.type != undefined &&
						( object.type == "divider" ||
							( object.type == "screenObj" &&
								object.hotspotCount == 0 ) // screenObj does not have hotspots.
						)
					) {
						results.push( object );
					}
				} );
			} else {
				angular.forEach( objects, function ( object ) {
					if ( object.type != undefined &&
						( object.type == "divider" ||
							( object.type == "screenObj" &&
								object.workflowStatusID == activeFilter.workflowStatusID )
						)
					) {
						results.push( object );
					}
				} );
			}
			angular.forEach(
				results,
				function ( displayObject ) {
					if ( displayObject.type == "divider" ) {
						var objectsInSection = getFilteredScreensInSection( results, displayObject );
						var screenCount = 0;
						angular.forEach( objectsInSection, function ( object ) {
							if ( object.type == "screenObj" ) {
								screenCount++;
							}
						} );
						displayObject.filteredScreenCount = screenCount;
					}
				}
			);
			results = updateFilteredScreenCountForDividers( results );
			return results;
		};
	} );

	function updateFilteredScreenCountForDividers( displayObjects ) {
		angular.forEach(
			displayObjects,
			function ( displayObject ) {
				if ( displayObject.type == "divider" ) {
					var objectsInSection = getFilteredScreensInSection( displayObjects, displayObject );
					var screenCount = 0;
					angular.forEach( objectsInSection, function ( object ) {
						if ( object.type == "screenObj" ) {
							screenCount++;
						}
					} );
					displayObject.filteredScreenCount = screenCount;
				}
			}
		);
		return displayObjects;
	}

	function getFilteredScreensInSection( displayObjects, object ) {
		if ( object.type !== "divider" ) {
			return [];
		}
		var screensInSection = [];
		var thisPosition = _.indexOfWithProperty( displayObjects, "dividerID", object.dividerID );
		var objects = displayObjects.slice( thisPosition + 1 );
		var nextDividerPosition = _.indexOfWithProperty( objects, "type", "divider" );
		if ( nextDividerPosition >= 0 ) {
			screensInSection = objects.slice( 0, Math.max( 0, nextDividerPosition ) );
		} else {
			screensInSection = objects;
		}
		return ( screensInSection );
	}
} )( angular, InVision );;;
/*! moment.js */
;;
/**
 * Format date through moment service.
 * Usage: {{ myDate | moment:'D MMM' }}
 */
angular.module( 'InVision' )
	.filter( 'moment', function ( moment ) {
		return function ( date, format ) {
			return moment( new Date( date ) ).format( format || 'D MMMM, h:mm a' );
		};
	} );;;
/*! truncate.js */
;;
/**
 * Truncate long string and add ...
 * Usage: {{ myLongString | truncate:5 }}
 */
angular.module( 'InVision' )
	.filter( 'truncate', function () {
		return function ( text, length ) {
			if ( !text || !length ) {
				return text;
			}
			var end = '...';
			return ( text.length - end.length <= length ) ?
				text :
				text.substring( 0, length - end.length ) + end;
		};
	} );;;
/*! account-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "accountService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function changePassword( currentPassword, newPassword, confirmationPassword ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "changePassword",
				parameters: {
					currentPassword: currentPassword,
					newPassword: newPassword,
					confirmationPassword: confirmationPassword
				}
			} );
			return ( promise );
		}

		function importGravatarAvatar( email ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "importGravatarAvatar",
				parameters: {
					email: email
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function importTwitterAvatar( username ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "importTwitterAvatar",
				parameters: {
					username: username
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markActivitySeen() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markActivitySeen",
				parameters: {}
			} );
			return ( promise );
		}

		function markMacAppAdvertisementClosed() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markMacAppAdvertisementClosed",
				parameters: {
					markMacAppAdvertisementClosed: true
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markTeamSetupTipClosed( oneOrTwo ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markTeamSetupTipClosed",
				parameters: {
					markTeamSetupTipClosed: oneOrTwo
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markAssetTourClosed() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markAssetTourClosed",
				parameters: {
					markAssetTourClosed: true
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markLiveShareIntroClosed( hasClosedLiveshareIntro ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markLiveShareIntroClosed",
				parameters: {
					option: hasClosedLiveshareIntro
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markPresentationTourIntroClosed( hasClosedPresentationTourIntro ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markPresentationTourIntroClosed",
				parameters: {
					option: hasClosedPresentationTourIntro
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function markShareIntroClosed( hasClosedShareIntro ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markShareIntroClosed",
				parameters: {
					option: hasClosedShareIntro
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function sawConsoleIntroModal( hasSeenConsoleIntroModal ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sawConsoleIntroModal",
				parameters: {
					hasSeenConsoleIntroModal: hasSeenConsoleIntroModal
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function sawOnboardingTour( hasSeenDashboardTour ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sawOnboardingTour",
				parameters: {
					hasSeenDashboardTour: hasSeenDashboardTour
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function sendEnterpriseInfoRequest( leadType ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendEnterpriseInfoRequest",
				parameters: {
					leadType: leadType
				}
			} );
			return ( promise );
		}

		function sendEnterpriseInfoRequestWithLeadInfo( leadType, lead ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendEnterpriseInfoRequest",
				parameters: {
					leadType: leadType,
					lead: lead
				}
			} );
			return ( promise );
		}

		function sendEnterpriseChangePlan( plan ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendEnterpriseChangePlan",
				parameters: {
					planName: plan.name
				}
			} );
			return ( promise );
		}

		function submitSupportTicket( supportType, description, isPriority ) {
			var isPriority = isPriority ? isPriority : false;
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "submitSupportTicket",
				parameters: {
					supportType: supportType,
					description: description,
					isPriority: isPriority
				}
			} );
			return ( promise );
		}

		function sendInviteToSignup( emails ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendInviteToSignup",
				parameters: {
					emails: emails
				}
			} );
			return ( promise );
		}

		function updateCompany( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateCompany",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateFeatureAnnouncementsLastViewedAt( dateTimeInMillisecs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateFeatureAnnouncementsLastViewedAt",
				parameters: {
					featureAnnouncementsLastViewedAt: dateTimeInMillisecs
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateProjectsSortPreference( projectsSortPreference ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateProjectsSortPreference",
				parameters: {
					"projectsSortPreference": projectsSortPreference
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateProfile( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateProfile",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/account/:command", {
				command: "@command"
			}, {
				changePassword: {
					method: "POST",
					params: {
						command: "change-password"
					}
				},
				importGravatarAvatar: {
					method: "POST",
					params: {
						command: "import-gravatar-avatar"
					}
				},
				importTwitterAvatar: {
					method: "POST",
					params: {
						command: "import-twitter-avatar"
					}
				},
				markActivitySeen: {
					method: "POST",
					params: {
						command: "mark-activity-as-seen"
					}
				},
				markLiveShareIntroClosed: {
					method: "POST",
					params: {
						command: "mark-liveshare-intro-closed"
					}
				},
				markMacAppAdvertisementClosed: {
					method: "POST",
					params: {
						command: "mark-mac-app-advertisement-closed"
					}
				},
				markPresentationTourIntroClosed: {
					method: "POST",
					params: {
						command: "mark-presentation-tour-intro-closed"
					}
				},
				markTeamSetupTipClosed: {
					method: "POST",
					params: {
						command: "mark-team-setup-tip-closed"
					}
				},
				markAssetTourClosed: {
					method: "POST",
					params: {
						command: "mark-asset-tour-closed"
					}
				},
				sawConsoleIntroModal: {
					method: "POST",
					params: {
						command: "has-seen-console-intro"
					}
				},
				sawOnboardingTour: {
					method: "POST",
					params: {
						command: "has-seen-onboarding-tour"
					}
				},
				sendEnterpriseInfoRequest: {
					method: "POST",
					params: {
						command: "wants-enterprise-info"
					}
				},
				sendEnterpriseChangePlan: {
					method: "POST",
					params: {
						command: "enterprise-change-plan"
					}
				},
				sendInviteToSignup: {
					method: "POST",
					params: {
						command: "send-invite-to-signup"
					}
				},
				submitSupportTicket: {
					method: "POST",
					params: {
						command: "submit-support-ticket"
					}
				},
				updateCompany: {
					method: "POST",
					params: {
						command: "update-company"
					}
				},
				updateFeatureAnnouncementsLastViewedAt: {
					method: "POST",
					params: {
						command: "update-feature-announcements-last-viewed"
					}
				},
				updateProjectsSortPreference: {
					method: "POST",
					params: {
						command: "update-projects-sort-preference"
					}
				},
				updateProfile: {
					method: "POST",
					params: {
						command: "update-profile"
					}
				}
			}
		);
		return ( {
			changePassword: changePassword,
			importGravatarAvatar: importGravatarAvatar,
			importTwitterAvatar: importTwitterAvatar,
			markActivitySeen: markActivitySeen,
			markAssetTourClosed: markAssetTourClosed,
			markLiveShareIntroClosed: markLiveShareIntroClosed,
			markMacAppAdvertisementClosed: markMacAppAdvertisementClosed,
			markPresentationTourIntroClosed: markPresentationTourIntroClosed,
			markTeamSetupTipClosed: markTeamSetupTipClosed,
			sawConsoleIntroModal: sawConsoleIntroModal,
			sawOnboardingTour: sawOnboardingTour,
			sendEnterpriseInfoRequest: sendEnterpriseInfoRequest,
			sendEnterpriseInfoRequestWithLeadInfo: sendEnterpriseInfoRequestWithLeadInfo,
			sendEnterpriseChangePlan: sendEnterpriseChangePlan,
			sendInviteToSignup: sendInviteToSignup,
			submitSupportTicket: submitSupportTicket,
			updateCompany: updateCompany,
			updateFeatureAnnouncementsLastViewedAt: updateFeatureAnnouncementsLastViewedAt,
			updateProjectsSortPreference: updateProjectsSortPreference,
			updateProfile: updateProfile
		} );
	}
} )( angular, InVision );;;
/*! asset-folder-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "assetFolderService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function deleteFolder( projectID, assetFolderID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteFolder",
				parameters: {
					id: assetFolderID,
					projectID: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetFolderDeleted", assetFolderID );
				}
			} );
			return ( promise );
		}

		function createFolder( projectID, parentFolderID, folderName ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "createFolder",
				parameters: {
					projectID: projectID,
					parentID: parentFolderID,
					folderName: folderName
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetFolderCreated", projectID );
				}
			} );
			return ( promise );
		}

		function renameFolder( projectID, assetFolderID, newFolderName ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "renameFolder",
				parameters: {
					id: assetFolderID,
					projectID: projectID,
					newFolderName: newFolderName
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetFolderRenamed", assetFolderID );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/asset-folders/:id", {
				id: "@id"
			}, {
				deleteFolder: {
					method: "DELETE"
				},
				createFolder: {
					method: "POST",
					isArray: true
				},
				renameFolder: {
					method: "POST",
					isArray: true
				}
			}
		);
		return ( {
			deleteFolder: deleteFolder,
			createFolder: createFolder,
			renameFolder: renameFolder
		} );
	}
} )( angular, InVision );;;
/*! asset-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "assetService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function info( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "info",
				parameters: {
					id: assetID
				}
			} );
			return ( promise );
		}

		function deleteAsset( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteAsset",
				parameters: {
					id: assetID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetDeleted", assetID );
				}
			} );
			return ( promise );
		}

		function updateSort( projectID, assetIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateSort",
				parameters: {
					projectID: projectID,
					assetIDs: assetIDs.join( "," )
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectAssetsSorted", projectID, assetIDs );
				}
			} );
			return ( promise );
		}

		function subscribeToAsset( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "subscribeToAsset",
				parameters: {
					assetID: assetID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetSubscribed", assetID );
				}
			} );
			return ( promise );
		}

		function unSubscribeToAsset( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "unSubscribeToAsset",
				parameters: {
					assetID: assetID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "assetUnSubscribed", assetID );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/assets/:listCommand:id/:docCommand", {
				id: "@id",
				listCommand: "@listCommand",
				docCommand: "@docCommand"
			}, {
				info: {
					method: "GET",
					isArray: false,
					params: {
						listCommand: ""
					}
				},
				deleteAsset: {
					method: "DELETE"
				},
				updateSort: {
					method: "POST",
					isArray: true,
					params: {
						listCommand: "update-sort"
					}
				},
				subscribeToAsset: {
					method: "POST",
					isArray: true,
					params: {
						listCommand: "subscribe"
					}
				},
				unSubscribeToAsset: {
					method: "POST",
					isArray: true,
					params: {
						listCommand: "unSubscribe"
					}
				}
			}
		);
		return ( {
			info: info,
			deleteAsset: deleteAsset,
			updateSort: updateSort,
			subscribeToAsset: subscribeToAsset,
			unSubscribeToAsset: unSubscribeToAsset
		} );
	}
} )( angular, InVision );;;
/*! base-resource-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.value( "BaseResourceService", BaseResourceService );
	/** @ngInject */
	function BaseResourceService( $resource, Deferred ) {
		assignPrototypeMethods( BaseResourceService, this );
		this.Resource = $resource;
		this.Deferred = Deferred;
		this.resource = null;
		return ( this );
	}
	BaseResourceService.prototype = {
		applyCacheIfAvailable: function ( deferred, resourceResponse, cachedResponse ) {
			if ( cachedResponse !== null ) {
				deferred.resolve(
					this.applyCacheToResourceResponse( resourceResponse, cachedResponse )
				);
			}
		},
		applyCacheToResourceResponse: function ( resourceResponse, cachedResponse ) {
			if ( ng.isArray( resourceResponse ) ) {
				resourceResponse.splice.apply(
					resourceResponse, [ 0, 0 ].concat( cachedResponse )
				);
			} else {
				ng.extend( resourceResponse, cachedResponse );
			}
			return ( resourceResponse );
		},
		bindMethod: function ( method ) {
			if ( ng.isString( method ) ) {
				method = this[ method ];
			}
			return (
				ng.bind( this, method )
			);
		},
		executeCacheableResourceRequest: function ( options ) {
			var name = options.name;
			var parameters = ( options.parameters || {} );
			var cachedResponse = ( options.cachedResponse || null );
			var successCallback = ( options.successCallback || ng.noop );
			var errorCallback = ( options.errorCallback || ng.noop );
			var deferred = new this.Deferred();
			var resourceResponse = this.resource[ name ](
				parameters,
				this.bindMethod(
					function ( response ) {
						successCallback.call( this, response );
						deferred.resolve( response );
					}
				),
				this.bindMethod(
					function ( response ) {
						errorCallback.call( this, response );
						deferred.reject(
							this.unwrapErrorMessage( response )
						);
					}
				)
			);
			this.applyCacheIfAvailable( deferred, resourceResponse, cachedResponse );
			return ( deferred.promise );
		},
		interceptResourceMethods: function ( methodMap ) {
			var service = this;
			var resource = this.resource;
			ng.forEach(
				methodMap,
				function ( serviceMethodName, resourceMethodName ) {
					resource.prototype[ resourceMethodName ] = function () {
						return (
							service[ serviceMethodName ]( this )
						);
					};
				}
			);
		},
		rejectDeferredOnResourceError: function ( deferred ) {
			var errorHandler = this.bindMethod(
				function ( response ) {
					deferred.reject(
						this.unwrapErrorMessage( response )
					);
				}
			);
			return ( errorHandler );
		},
		toArray: function ( fakeArray ) {
			return (
				Array.prototype.slice.call( fakeArray )
			);
		},
		unwrapErrorMessage: function ( errorResponse ) {
			try {
				var response = ng.fromJson( errorResponse.data );
				if ( ng.isString( response ) ) {
					response = {
						message: response,
						code: -1
					};
				}
			} catch ( error ) {
				var response = {
					message: errorResponse.data,
					code: -1
				};
			}
			return ( response );
		}
	};

	function assignPrototypeMethods( constructorMethod, context ) {
		for ( var methodName in constructorMethod.prototype ) {
			if (
				constructorMethod.prototype.hasOwnProperty( methodName ) &&
				!context[ methodName ]
			) {
				context[ methodName ] = constructorMethod.prototype[ methodName ];
			}
		}
	}
} )( angular, InVision );;;
/*! before-unload-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "beforeUnloadService", BeforeUnloadService );
	/** @ngInject */
	function BeforeUnloadService( $window, _ ) {
		this.functionQueue = [];
		$window.onbeforeunload = ng.bind( this, this.run );
		return ( this );
	}
	BeforeUnloadService.prototype = {
		run: function () {
			ng.forEach( this.functionQueue, function ( bundle ) {
				bundle.funcRef.apply( bundle.context, bundle.args );
			} );
		},
		push: function ( context, funcRef, args ) {
			if ( _.isUndefined( funcRef ) || !_.isFunction( funcRef ) ) {
				funcRef = ng.noop;
			}
			this.functionQueue.push( {
				context: context,
				funcRef: funcRef,
				args: args
			} );
		}
	};
} )( angular, InVision );;;
/*! billing-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "billingService", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, sessionService ) {
		function getCountries() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCountries",
				cachedResponse: cache.getResponse( "countries" ),
				successCallback: function ( response ) {
					cache.setResponse( "countries", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "countries" );
				}
			} );
			return ( promise );
		}

		function getInvoices() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getInvoices",
				cachedResponse: cache.getResponse( "invoices" ),
				successCallback: function ( response ) {
					cache.setResponse( "invoices", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "invoices" );
				}
			} );
			return ( promise );
		}

		function getPaymentInfo() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getPaymentInfo",
				cachedResponse: cache.getResponse( "paymentInfo" ),
				successCallback: function ( response ) {
					cache.setResponse( "paymentInfo", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "paymentInfo" );
				}
			} );
			return ( promise );
		}

		function changeCreditCard(
			hasCardChanged,
			hasOtherBillingInfoChanged,
			billingFirstName,
			billingLastName,
			cardDigits,
			cardExpirationMonth,
			cardExpirationYear,
			cardCSV,
			company,
			billingAddress1,
			billingAddress2,
			billingCity,
			billingState,
			billingZip,
			billingCountry
		) {
			var params = {
				billingFirstName: billingFirstName,
				billingLastName: billingLastName,
				company: company,
				billingAddress1: billingAddress1,
				billingAddress2: billingAddress2,
				billingCity: billingCity,
				billingState: billingState,
				billingZip: billingZip,
				billingCountry: billingCountry,
				shouldUpdateNonCardInfo: hasOtherBillingInfoChanged
			};
			if ( hasCardChanged ) {
				params.cardDigits = cardDigits;
				params.expirationMonth = cardExpirationMonth;
				params.expirationYear = cardExpirationYear;
				params.csv = cardCSV;
			}
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "changeCreditCard",
				successCallback: function ( response ) {
					cache.setResponse( "paymentInfo", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "paymentInfo" );
				},
				parameters: params
			} );
			return ( promise );
		}
		var cache = new PartialCache( "billingServiceCache" );
		var resource = $resource(
			"/api/billing/:command", {
				command: "@command"
			}, {
				getCountries: {
					method: "GET",
					isArray: true,
					params: {
						command: "get-countries"
					}
				},
				getInvoices: {
					method: "GET",
					isArray: true,
					params: {
						command: "get-invoices"
					}
				},
				getPaymentInfo: {
					method: "GET",
					isArray: false,
					params: {
						command: "get-payment-info"
					}
				},
				changeCreditCard: {
					method: "POST",
					params: {
						command: "change-credit-card"
					}
				}
			}
		);
		return ( {
			getCountries: getCountries,
			getInvoices: getInvoices,
			getPaymentInfo: getPaymentInfo,
			changeCreditCard: changeCreditCard
		} );
	}
} )( angular, InVision );;;
/*! cache.js */
;;
( function ( ng, app ) {
	"use strict";
	app.value( "Cache", Cache );

	function Cache( uniqueIdentifier, initialCollection ) {
		this.uniqueIdentifier = ( uniqueIdentifier || "id" );
		this.cache = ( initialCollection || null );
		return ( this );
	}
	Cache.prototype = {
		addItem: function ( item ) {
			if ( this.cache === null ) {
				return (
					this.replaceCache( [ ng.copy( item ) ] )
				);
			}
			this.cache.push(
				ng.copy( item )
			);
		},
		addItems: function ( items ) {
			for ( var i = 0; items.length; i++ ) {
				this.addItem( items[ i ] );
			}
		},
		clearCache: function () {
			this.cache = [];
		},
		deleteItem: function ( item ) {
			var name = this.uniqueIdentifier;
			var value = item[ this.uniqueIdentifier ];
			return (
				this.deleteItemByProperty( name, value )
			);
		},
		deleteItemsByFilter: function ( filter ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = ( this.cache.length - 1 ); i >= 0; i-- ) {
				if ( filter( this.cache[ i ] ) === true ) {
					this.cache.splice( i, 1 );
				}
			}
		},
		deleteItemByFilter: function ( filter ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( filter( this.cache[ i ] ) === true ) {
					this.cache.splice( i, 1 );
					return;
				}
			}
		},
		deleteItemByProperty: function ( name, value ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( this.cache[ i ][ name ] === value ) {
					this.cache.splice( i, 1 );
					return;
				}
			}
		},
		deleteItems: function ( items ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = 0; i < items.length; i++ ) {
				this.deleteItem( items[ i ] );
			}
		},
		deleteItemsByProperty: function ( name, value ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = ( this.cache.length - 1 ); i >= 0; i-- ) {
				if ( this.cache[ i ][ name ] === value ) {
					this.cache.splice( i, 1 );
				}
			}
		},
		deleteItemsByPropertyRange: function ( name, valueRange ) {
			if ( this.cache === null ) {
				return;
			}
			for ( var i = 0; i < valueRange.length; i++ ) {
				this.deleteItemsByProperty( name, valueRange[ i ] );
			}
		},
		getCache: function () {
			if ( this.cache === null ) {
				return ( null );
			}
			return (
				ng.copy( this.cache )
			);
		},
		getItemByFilter: function ( filter ) {
			if ( this.cache === null ) {
				return ( null );
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( filter( this.cache[ i ] ) === true ) {
					return (
						ng.copy( this.cache[ i ] )
					);
				}
			}
			return ( null );
		},
		getItemByProperty: function ( name, value ) {
			if ( this.cache === null ) {
				return ( null );
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( this.cache[ i ][ name ] === value ) {
					return (
						ng.copy( this.cache[ i ] )
					);
				}
			}
			return ( null );
		},
		getItemsByFilter: function ( filter ) {
			if ( this.cache === null ) {
				return ( null );
			}
			var items = [];
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( filter( this.cache[ i ] ) === true ) {
					items.push(
						ng.copy( this.cache[ i ] )
					);
				}
			}
			if ( items.length ) {
				return ( items );
			}
			return ( null );
		},
		getItemsByProperty: function ( name, value ) {
			if ( this.cache === null ) {
				return ( null );
			}
			var items = [];
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( this.cache[ i ][ name ] === value ) {
					items.push(
						ng.copy( this.cache[ i ] )
					);
				}
			}
			if ( items.length ) {
				return ( items );
			}
			return ( null );
		},
		getItemsByPropertyRange: function ( name, valueRange ) {
			if ( this.cache === null ) {
				return ( null );
			}
			var items = [];
			for ( var i = 0; i < valueRange.length; i++ ) {
				var matchingItems = this.getItemsByProperty( name, valueRange[ i ] );
				if ( matchingItems ) {
					items = items.concat( matchingItems );
				}
			}
			if ( items.length ) {
				return ( items );
			}
			return ( null );
		},
		getItemsByRange: function ( valueRange ) {
			return (
				this.getItemsByPropertyRange(
					this.uniqueIdentifier,
					valueRange
				)
			);
		},
		hasItem: function ( value ) {
			if ( this.getItemByProperty( this.uniqueIdentifier, value ) ) {
				return ( true );
			}
			return ( false );
		},
		processPromiseInCacheContext: function ( promise, successCallback, errorCallback ) {
			var _this = this;
			promise.then(
				function () {
					( successCallback || ng.noop ).apply( _this, arguments );
				},
				function () {
					( errorCallback || ng.noop ).apply( _this, arguments );
				}
			);
			return ( promise );
		},
		replaceCache: function ( collection ) {
			this.cache = ng.copy( collection );
		},
		replaceItem: function ( item ) {
			this.replaceItemByProperty(
				this.uniqueIdentifier,
				item
			);
		},
		replaceItemByFilter: function ( filter, item ) {
			if ( this.cache === null ) {
				return (
					this.replaceCache( [ ng.copy( item ) ] )
				);
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( filter( this.cache[ i ] ) === true ) {
					this.cache[ i ] = ng.copy( item );
					return;
				}
			}
			this.cache.push( ng.copy( item ) );
		},
		replaceItemByProperty: function ( name, item ) {
			if ( this.cache === null ) {
				return (
					this.replaceCache( [ ng.copy( item ) ] )
				);
			}
			for ( var i = 0; i < this.cache.length; i++ ) {
				if ( this.cache[ i ][ name ] === item[ name ] ) {
					this.cache[ i ] = ng.copy( item );
					return;
				}
			}
			this.cache.push( ng.copy( item ) );
		},
		replaceItems: function ( items ) {
			this.replaceItemsByProperty(
				this.uniqueIdentifier,
				items
			);
		},
		replaceItemsByProperty: function ( name, items ) {
			for ( var i = 0; i < items.length; i++ ) {
				this.replaceItemByProperty( name, items[ i ] );
			}
		},
		resetItemsByFilter: function ( filter, items ) {
			this.deleteItemsByFilter( filter );
			this.replaceItems( items );
		},
		resetItemsByProperty: function ( name, value, items ) {
			this.deleteItemsByProperty( name, value );
			this.replaceItems( items );
		}
	};
} )( angular, InVision );;;
/*! color-contrast-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "colorContrastService", ColorContrastService );
	/** @ngInject */
	function ColorContrastService() {
		var nonHexPattern = /[^a-f0-9]+/gi;
		var cache = {};
		return ( {
			isDark: isDark,
			isLight: isLight
		} );

		function isDark( hex ) {
			return ( !isLight( hex ) );
		}

		function isLight( hex ) {
			var cacheKey = getCacheKey( hex );
			if ( !cache.hasOwnProperty( cacheKey ) ) {
				hex = sanitizeHex( hex );
				var redHex = hex.slice( 0, 2 );
				var greenHex = hex.slice( 2, 4 );
				var blueHex = hex.slice( 4 );
				var redDecimal = parseInt( redHex, 16 );
				var greenDecimal = parseInt( greenHex, 16 );
				var blueDecimal = parseInt( blueHex, 16 );
				var brightness = ( ( ( redDecimal * 299 ) + ( greenDecimal * 587 ) + ( blueDecimal * 114 ) ) / 1000 );
				cache[ cacheKey ] = {
					hex: hex,
					red: redDecimal,
					green: greenDecimal,
					blue: blueDecimal,
					brightness: brightness,
					isLight: ( brightness > 130 )
				};
			}
			return ( cache[ cacheKey ].isLight );
		}

		function getCacheKey( hex ) {
			return ( "hex_" + hex );
		}

		function sanitizeHex( hex ) {
			hex = String( hex || "" ).replace( nonHexPattern, "" );
			return ( ( hex + "000000" ).slice( 0, 6 ) );
		}
	}
} )( angular, InVision );;;
/*! company-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "companyService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, partialHelper, PartialCache, modelEvents ) {
		function updateCompany( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateCompany",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyAccountUpdated", response );
				}
			} );
			return ( promise );
		}

		function get( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: options
			} );
			return ( promise );
		}

		function getCompanyMembershipCount( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getCompanyMembershipCount",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyMembershipCount", response.count );
				}
			} );
			return ( promise );
		}

		function getCompanyMember( userID, companyID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getCompanyMember",
				parameters: {
					userID: userID
				},
				cachedResponse: cache.getResponse( "companyUser_" + userID + "_" + companyID ),
				successCallback: function ( response ) {
					cache.setResponse( "companyUser_" + userID + "_" + companyID, response );
				},
				errorCallback: function () {
					cache.deleteResponse( "companyUser_" + userID + "_" + companyID );
				}
			} );
			return ( promise );
		}

		function getCompanyTeamsCount( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getCompanyTeamsCount",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "getCompanyTeamsCount", response.count );
				}
			} );
			return ( promise );
		}

		function getCompanyTeams( options ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCompanyTeams",
				parameters: options,
				cachedResponse: cache.getResponse( "companyTeams" ),
				successCallback: function ( response ) {
					cache.setResponse( "companyTeams", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "companyTeams" );
				}
			} );
			return ( promise );
		}

		function getProjectCompanyTeams( projectId ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCompanyTeams",
				parameters: {
					projectId: projectId
				},
				cachedResponse: cache.getResponse( "companyTeams:" + projectId ),
				successCallback: function ( response ) {
					cache.setResponse( "companyTeams:" + projectId, response );
				},
				errorCallback: function () {
					cache.deleteResponse( "companyTeams:" + projectId );
				}
			} );
			return ( promise );
		}

		function updateCompanyTeamMembers( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateCompanyTeamMembers",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "updateCompanyTeamMembers", response );
				}
			} );
			return ( promise );
		}

		function getBillingInformation( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getBillingInformation",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyBillingInformationLoaded", response );
				}
			} );
			return ( promise );
		}

		function saveBillingInformation( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "saveBillingInformation",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyBillingInformationUpdated", response );
				}
			} );
			return ( promise );
		}

		function sendCustomBranding( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendCustomBranding",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "customBrandingSent", response );
				}
			} );
			return ( promise );
		}

		function getCompanyMembership( companyID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCompanyMembership",
				cachedResponse: cache.getResponse( "pulledCompanyMembership" ),
				successCallback: function ( response ) {
					cache.setResponse( "pulledCompanyMembership", response );
					modelEvents.trigger( "pulledCompanyMembership", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "pulledCompanyMembership" );
				}
			} );
			return ( promise );
		}

		function getCompanyMembershipWithInvites( companyID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCompanyMembershipWithInvites",
				cachedResponse: cache.getResponse( "pulledCompanyMembershipWithInvites" ),
				successCallback: function ( response ) {
					cache.setResponse( "pulledCompanyMembershipWithInvites", response );
					modelEvents.trigger( "pulledCompanyMembershipWithInvites", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "pulledCompanyMembershipWithInvites" );
				}
			} );
			return ( promise );
		}

		function createCompanyTeam( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "createCompanyTeam",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyTeamCreated", response );
				}
			} );
			return ( promise );
		}

		function deleteCompanyTeam( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteCompanyTeam",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyTeamDeleted", response );
				}
			} );
			return ( promise );
		}

		function setCompanyUserRoles( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setCompanyUserRoles",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyUserRoleChanged", response );
				}
			} );
			return ( promise );
		}

		function inviteUsersToCompany( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "inviteUsersToCompany",
				parameters: options,
				successCallback: function ( response ) {
					modelEvents.trigger( "companyMembersInvited", response );
				}
			} );
			return ( promise );
		}

		function removeUsersFromCompany( memberIDs, inviteIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "removeUsersFromCompany",
				parameters: {
					userIDs: memberIDs.join( ',' ),
					inviteIDs: inviteIDs.join( ',' )
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "usersRemovedFromCompany", response.usersremoved, response.invitesremoved );
				}
			} );
			return ( promise );
		}
		var cache = new PartialCache( "companyServiceCache" );
		var resource = $resource(
			"/api/company/:command", {
				command: "@command"
			}, {
				updateCompany: {
					method: "POST",
					params: {
						command: "update-company"
					}
				},
				get: {
					method: "GET",
					params: {
						command: "get"
					}
				},
				getCompanyMembershipCount: {
					method: "GET",
					params: {
						command: "get-company-membership-count"
					}
				},
				getCompanyTeamsCount: {
					method: "GET",
					params: {
						command: "get-company-teams-count"
					}
				},
				getCompanyTeams: {
					method: "GET",
					isArray: true,
					params: {
						command: "get-company-teams"
					}
				},
				sendCustomBranding: {
					method: "POST",
					params: {
						command: "send-custom-branding"
					}
				},
				getBillingInformation: {
					method: "GET",
					params: {
						command: "get-billing-information"
					}
				},
				saveBillingInformation: {
					method: "POST",
					params: {
						command: "save-billing-information"
					}
				},
				getCompanyMembership: {
					method: "POST",
					isArray: true,
					params: {
						command: "get-company-membership"
					}
				},
				getCompanyMember: {
					method: "GET",
					isArray: true,
					params: {
						command: "get-company-member"
					}
				},
				getCompanyMembershipWithInvites: {
					method: "POST",
					isArray: false,
					params: {
						command: "get-company-membership-with-invites"
					}
				},
				createCompanyTeam: {
					method: "POST",
					params: {
						command: "create-company-team"
					}
				},
				deleteCompanyTeam: {
					method: "POST",
					params: {
						command: "delete-company-team"
					}
				},
				setCompanyUserRoles: {
					method: "POST",
					params: {
						command: "set-company-user-roles"
					}
				},
				updateCompanyTeamMembers: {
					method: "POST",
					params: {
						command: "update-company-team-members"
					}
				},
				inviteUsersToCompany: {
					method: "POST",
					params: {
						command: "invite-users-to-company"
					}
				},
				removeUsersFromCompany: {
					method: "POST",
					params: {
						command: "remove-users"
					}
				},
			}
		);
		return ( {
			updateCompany: updateCompany,
			get: get,
			getCompanyMembership: getCompanyMembership,
			getCompanyMembershipWithInvites: getCompanyMembershipWithInvites,
			getCompanyMembershipCount: getCompanyMembershipCount,
			getCompanyTeamsCount: getCompanyTeamsCount,
			getCompanyTeams: getCompanyTeams,
			sendCustomBranding: sendCustomBranding,
			getBillingInformation: getBillingInformation,
			saveBillingInformation: saveBillingInformation,
			setCompanyUserRoles: setCompanyUserRoles,
			createCompanyTeam: createCompanyTeam,
			deleteCompanyTeam: deleteCompanyTeam,
			updateCompanyTeamMembers: updateCompanyTeamMembers,
			inviteUsersToCompany: inviteUsersToCompany,
			removeUsersFromCompany: removeUsersFromCompany,
			getProjectCompanyTeams: getProjectCompanyTeams,
			getCompanyMember: getCompanyMember
		} );
	}
} )( angular, InVision );;;
/*! conversation-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "conversationService", ConversationService );
	/** @ngInject */
	function ConversationService( _, $resource, serviceHelper, modelEvents, MAX_COMMENT_LIKES_DISPLAYED ) {
		function getConversation( conversationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: ConversationResource,
				name: "get",
				parameters: {
					id: conversationID
				},
				successCallback: function ( conversation ) {}
			} );
			return promise;
		}

		function getComment( commentID ) {
			var promise = serviceHelper.executeRequest( {
				resource: CommentResource,
				name: "get",
				parameters: {
					id: commentID
				},
				successCallback: function ( comment ) {}
			} );
			return promise;
		}

		function getByScreenID( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: ConversationResource,
				name: "query",
				parameters: {
					screenID: screenID
				},
				successCallback: function ( conversations ) {}
			} );
			return promise;
		}

		function getHtmlForComment( comment ) {
			comment = comment.replace(
				/(<)|(>)|(&)|(")/g,
				function ( $0, lt, gt, amp, quot ) {
					if ( lt ) {
						return ( "&lt;" );
					} else if ( gt ) {
						return ( "&gt;" );
					} else if ( amp ) {
						return ( "&amp;" );
					} else if ( quot ) {
						return ( "&quot;" );
					}
				}
			);
			comment = replaceLinks( comment );
			comment = comment.replace( /(\r\n?|\n)/g, "<br />" );
			return ( comment );
		}

		function replaceLinks( comment ) {
			comment = comment.replace(
				/((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?????????]))/gi,
				function ( $0 ) {
					var hasProtocol = ( /^\w+:\/\//i ).test( $0 );
					var href = ( hasProtocol ? $0 : ( "http://" + $0 ) );
					var text = $0;
					return (
						"<a href=\"" + href + "\" target=\"_blank\">" + text + "</a>"
					);
				}
			);
			return ( comment );
		}

		function saveConversation( conversation ) {
			var parameters = _.pick( conversation, "id", "screenID", "label", "x", "y", "isPrivate", "isForDevelopment", "isComplete" );
			if ( !parameters.id ) {
				delete parameters.id;
			}
			var promise = serviceHelper.executeRequest( {
				resource: ConversationResource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function updateConverstationPosition( conversation ) {
			var parameters = _.pick( conversation, "x", "y" );
			if ( !parameters.id ) {
				delete parameters.id;
			}
			var promise = serviceHelper.executeRequest( {
				resource: ConversationResource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function markCommentsAsRead( commentIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: CommentResource,
				name: "markAsRead",
				parameters: {
					commentIDs: commentIDs
				},
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function toggleCommentLike( commentID, conversationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: CommentResource,
				name: "toggleLike",
				parameters: {
					commentID: commentID
				},
				successCallback: function ( response ) {
					modelEvents.trigger(
						"commentUpdated",
						commentID,
						conversationID
					);
				}
			} );
			return promise;
		}

		function deleteConversation( conversation ) {
			var parameters = _.pick( conversation, "id" );
			var promise = serviceHelper.executeRequest( {
				resource: ConversationResource,
				name: "delete",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function saveComment( comment ) {
			var parameters = _.pick( comment, "id", "conversationID", "comment", "notify", "sketches" );
			var promise = serviceHelper.executeRequest( {
				resource: CommentResource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function deleteComment( comment ) {
			var parameters = _.pick( comment, "id" );
			var promise = serviceHelper.executeRequest( {
				resource: CommentResource,
				name: "delete",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function deleteSketch( sketchID ) {
			var promise = serviceHelper.executeRequest( {
				resource: sketchResource,
				name: "deleteSketch",
				parameters: {
					sketchID: sketchID
				},
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function formatCommentLikers( comment ) {
			var likedByList = _.pluck( comment.likedBy, "name" ).join( "<br />" );
			if ( comment.numberOfLikes > MAX_COMMENT_LIKES_DISPLAYED ) {
				likedByList += "<br />+" + ( comment.numberOfLikes - MAX_COMMENT_LIKES_DISPLAYED ) + " more";
			}
			return likedByList;
		}
		var ConversationResource = $resource( "/api/conversations/:id", {
			id: "@id"
		} );
		var CommentResource = $resource(
			"/api/comments/:command:id", {
				id: "@id",
				command: "@command"
			}, {
				markAsRead: {
					method: "POST",
					params: {
						command: "mark-as-read"
					}
				},
				toggleLike: {
					method: "POST",
					params: {
						command: "toggle-like"
					}
				}
			}
		);
		var sketchResource = $resource(
			"/api/comments/:command/:sketchID", {
				sketchID: "@sketchID",
				command: "deleteSketch"
			}, {
				deleteSketch: {
					method: "DELETE",
					params: {
						command: "deleteSketch"
					}
				}
			}
		);
		return {
			deleteComment: deleteComment,
			deleteConversation: deleteConversation,
			deleteSketch: deleteSketch,
			formatCommentLikers: formatCommentLikers,
			getByScreenID: getByScreenID,
			getComment: getComment,
			getConversation: getConversation,
			getHtmlForComment: getHtmlForComment,
			markCommentsAsRead: markCommentsAsRead,
			saveComment: saveComment,
			saveConversation: saveConversation,
			toggleCommentLike: toggleCommentLike
		};
	}
} )( angular, InVision );;;
/*! dashboard-map-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "dashboardMapService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function getRecentEvents( leadUserID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getRecentEvents",
				parameters: {
					leadUserID: leadUserID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/dashboard/stats/map/activity/:leadUserID", {
				leadUserID: "@leadUserID"
			}, {
				getRecentEvents: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			getRecentEvents: getRecentEvents
		} );
	}
} )( angular, InVision );;;
/*! date-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "dateHelper", Service );
	/** @ngInject */
	function Service() {
		this.dayAsStringMap = [ {
			"long": "Sunday",
			"short": "Sun"
		}, {
			"long": "Monday",
			"short": "Mon"
		}, {
			"long": "Tuesday",
			"short": "Tue"
		}, {
			"long": "Wednesday",
			"short": "Wed"
		}, {
			"long": "Thursday",
			"short": "Thr"
		}, {
			"long": "Friday",
			"short": "Fri"
		}, {
			"long": "Saturday",
			"short": "Sat"
		} ];
		this.monthAsStringMap = [ {
			"long": "January",
			"short": "Jan"
		}, {
			"long": "February",
			"short": "Feb"
		}, {
			"long": "March",
			"short": "Mar"
		}, {
			"long": "April",
			"short": "Apr"
		}, {
			"long": "May",
			"short": "May"
		}, {
			"long": "June",
			"short": "Jun"
		}, {
			"long": "July",
			"short": "Jul"
		}, {
			"long": "August",
			"short": "Aug"
		}, {
			"long": "September",
			"short": "Sep"
		}, {
			"long": "October",
			"short": "Oct"
		}, {
			"long": "November",
			"short": "Nov"
		}, {
			"long": "December",
			"short": "Dec"
		} ];
		return ( this );
	}
	Service.prototype = {
		add: function ( datetime, count, unit ) {
			var newDatetime = this.duplicate( datetime );
			switch ( unit.toLowerCase() ) {
			case "y":
				newDatetime.setFullYear( newDatetime.getFullYear() + count );
				break;
			case "m":
				newDatetime.setMonth( newDatetime.getMonth() + count );
				break;
			case "d":
				newDatetime.setDate( newDatetime.getDate() + count );
				break;
			case "w":
				newDatetime.setDate( newDatetime.getDate() + ( count * 7 ) );
				break;
			case "h":
				newDatetime.setTime( newDatetime.getTime() + ( count * 1000 * 60 * 60 ) );
				break;
			case "n":
				newDatetime.setTime( newDatetime.getTime() + ( count * 1000 * 60 ) );
				break;
			case "s":
				newDatetime.setTime( newDatetime.getTime() + ( count * 1000 ) );
				break;
			case "l":
				newDatetime.setTime( newDatetime.getTime() + count );
				break;
			}
			return ( newDatetime );
		},
		addDays: function ( datetime, dayCount ) {
			var newDatetime = this.duplicate( datetime );
			newDatetime.setDate( newDatetime.getDate() + dayCount );
			return ( newDatetime );
		},
		addLeadingZero: function ( value ) {
			if ( value.toString().length === 1 ) {
				return ( "0" + value );
			}
			return ( value );
		},
		convertSecondsToMinutes: function ( seconds, excludeZeroMinute ) {
			var minutes = Math.floor( seconds / 60 );
			var remainingSeconds = ( seconds % 60 );
			if (
				( excludeZeroMinute === true ) &&
				( minutes === 0 )
			) {
				return ( ":" + this.addLeadingZero( remainingSeconds ) );
			} else {
				return ( minutes + ":" + this.addLeadingZero( remainingSeconds ) );
			}
		},
		duplicate: function ( datetime ) {
			return (
				new Date( datetime )
			);
		},
		equals: function ( date1, date2 ) {
			return ( date1.getTime() === date2.getTime() );
		},
		formatDate: function ( datetime, dateMask ) {
			var self = this;
			var date = this.removeTime( datetime );
			var result = dateMask.replace(
				/M+|m+|d+|yyyy|yy/g,
				function ( $0 ) {
					return (
						self.getFormattedDatePart( date, $0 )
					);
				}
			);
			return ( result );
		},
		formatRecentDate: function ( datetime, dateMask ) {
			var date = this.removeTime( datetime );
			if ( this.isToday( date ) ) {
				return ( "Today" );
			} else if ( this.isYesterday( date ) ) {
				return ( "Yesterday" );
			} else {
				return ( this.formatDate( datetime, dateMask ) );
			}
		},
		formatTime: function ( datetime, timeMask ) {
			var self = this;
			var date = this.duplicate( datetime );
			var result = timeMask.replace(
				/H+|h+|m+|t+|T+/g,
				function ( $0 ) {
					return (
						self.getFormattedTimePart( date, $0 )
					);
				}
			);
			return ( result );
		},
		getDayOfWeekAsString: function ( dayOfWeek, useShortVersion ) {
			if ( useShortVersion ) {
				return ( this.dayAsStringMap[ dayOfWeek ][ "short" ] );
			} else {
				return ( this.dayAsStringMap[ dayOfWeek ][ "long" ] );
			}
		},
		getFormattedDatePart: function ( datetime, pattern ) {
			switch ( pattern ) {
			case "D":
			case "d":
				return ( datetime.getDate() );
				break;
			case "DD":
			case "dd":
				return ( this.addLeadingZero( datetime.getDate() ) );
				break;
			case "DDD":
				return ( this.getDayOfWeekAsString( datetime.getDay() ).toUpperCase() );
				break;
			case "ddd":
				return ( this.getDayOfWeekAsString( datetime.getDay() ) );
				break;
			case "dddd":
				return ( this.getDayOfWeekAsString( datetime.getDay(), true ) );
				break;
			case "M":
			case "m":
				return ( datetime.getMonth() + 1 );
				break;
			case "MM":
			case "mm":
				return ( this.addLeadingZero( datetime.getMonth() + 1 ) );
				break;
			case "MMM":
			case "mmm":
				return ( this.getMonthAsString( datetime.getMonth(), true ) );
				break;
			case "MMMM":
			case "mmmm":
				return ( this.getMonthAsString( datetime.getMonth(), false ) );
				break;
			case "YY":
			case "yy":
				return ( this.addLeadingZero( datetime.getFullYear() % 100 ) );
				break;
			case "YYYY":
			case "yyyy":
				return ( datetime.getFullYear() );
				break;
			}
			return ( pattern );
		},
		getFormattedTimePart: function ( datetime, pattern ) {
			switch ( pattern ) {
			case "H":
				return ( datetime.getHours() );
				break;
			case "HH":
				var value = datetime.getHours();
				return ( value < 10 ? "0" + value : value );
				break;
			case "h":
				var value = ( datetime.getHours() % 12 );
				return ( value === 0 ? 12 : value );
				break;
			case "hh":
				var value = ( datetime.getHours() % 12 );
				value = ( value === 0 ? 12 : value );
				return ( value < 10 ? "0" + value : value );
				break;
			case "M":
			case "MM":
			case "m":
			case "mm":
				var value = datetime.getMinutes();
				return ( value < 10 ? "0" + value : value );
				break;
			case "T":
				return ( datetime.getHours() < 12 ? "A" : "P" );
				break;
			case "TT":
				return ( datetime.getHours() < 12 ? "AM" : "PM" );
				break;
			case "t":
				return ( datetime.getHours() < 12 ? "a" : "p" );
				break;
			case "tt":
				return ( datetime.getHours() < 12 ? "am" : "pm" );
				break;
			}
			return ( pattern );
		},
		getMonthAsString: function ( month, useShortVersion ) {
			if ( useShortVersion ) {
				return ( this.monthAsStringMap[ month ][ "short" ] );
			} else {
				return ( this.monthAsStringMap[ month ][ "long" ] );
			}
		},
		isRecent: function ( datetime, delta, unit ) {
			var cutoff = this.add( new Date(), -delta, unit );
			return ( datetime >= cutoff );
		},
		isToday: function ( datetime ) {
			return (
				this.equals( datetime, this.today() )
			);
		},
		isYesterday: function ( datetime ) {
			return (
				this.equals( datetime, this.yesterday() )
			);
		},
		removeTime: function ( datetime ) {
			var newDatetime = this.duplicate( datetime );
			newDatetime.setHours( 0 );
			newDatetime.setMinutes( 0 );
			newDatetime.setSeconds( 0 );
			newDatetime.setMilliseconds( 0 );
			return ( newDatetime );
		},
		today: function () {
			return (
				this.removeTime( new Date() )
			);
		},
		yesterday: function () {
			return (
				this.addDays( this.today(), -1 )
			);
		},
		formatRelativeWithinMonth: function ( time ) {
			moment.lang( "smallDate", {
				relativeTime: {
					future: "in %s",
					past: "%s ago",
					s: "1s",
					m: "1m",
					mm: "%dm",
					h: "1h",
					hh: "%dh",
					d: "1d",
					dd: "%dd",
					M: "1mo",
					MM: "%d months",
					y: "a year",
					yy: "%d years"
				}
			} );
			var now = moment(),
				diff = moment( time ).diff( now, "months" ),
				output;
			if ( Math.abs( diff ) === 0 ) {
				moment.lang( "smallDate" );
				output = moment( time ).fromNow();
				moment.lang( false );
			} else {
				output = moment( time ).format( "MMM D" );
			}
			return output;
		}
	};
} )( angular, InVision );;;
/*! deferred.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "Deferred", Factory );
	/** @ngInject */
	function Factory( $q, _ ) {
		function Deferred() {
			var deferred = $q.defer();
			var promise = deferred.promise;
			var core = {
				resolve: deferred.resolve,
				reject: deferred.reject,
				then: promise.then
			};
			var isResolved = false;
			var isRejected = false;
			var updateCallbacks = [];
			var mistakeCallbacks = [];
			deferred.resolve = function () {
				if ( isResolved && !isRejected ) {
					for ( var i = 0, length = updateCallbacks.length; i < length; i++ ) {
						updateCallbacks[ i ].apply( {}, arguments );
					}
				} else {
					isResolved = true;
					core.resolve.apply( deferred, arguments )
				}
			};
			deferred.reject = function () {
				if ( isResolved ) {
					for ( var i = 0, length = mistakeCallbacks.length; i < length; i++ ) {
						mistakeCallbacks[ i ].apply( {}, arguments );
					}
				} else {
					isRejected = true;
					core.reject.apply( deferred, arguments )
				}
			};
			promise.then = function () {
				var newPromise = core.then.apply( promise, arguments );
				newPromise.update = promise.update;
				newPromise.mistake = promise.mistake;
				return ( newPromise );
			};
			promise.update = function ( callback ) {
				updateCallbacks.push( callback );
				return ( promise );
			};
			promise.mistake = function ( callback ) {
				mistakeCallbacks.push( callback );
				return ( promise );
			};
			return ( deferred );
		}
		Deferred.handleAllPromises = function ( promises, successCallback, errorCallback, runOnce ) {
			var handleSuccess = function ( index, response ) {
				if ( hasError ) {
					return;
				}
				results[ index ] = response;
				if ( _.contains( results, null ) ) {
					return;
				}
				successCallback.apply( null, results );
			};
			var handleError = function ( index, response ) {
				if ( hasError ) {
					return;
				}
				hasError = true;
				errorCallback.call( null, response );
			};
			var results = [];
			for ( var i = 0, length = promises.length; i < length; i++ ) {
				results.push( null );
			}
			var hasError = false;
			successCallback = ( successCallback || ng.noop );
			errorCallback = ( errorCallback || ng.noop );
			_.forEach(
				promises,
				function ( promise, index ) {
					Deferred.handlePromise(
						promise,
						function ( response ) {
							handleSuccess( index, response );
						},
						function ( response ) {
							handleError( index, response );
						},
						runOnce
					);
				}
			);
		};
		Deferred.handlePromise = function ( promise, successCallback, errorCallback, runOnce ) {
			var handleSuccess = function ( response ) {
				if ( hasRun && runOnce ) {
					return;
				}
				hasRun = true;
				successCallback( response );
			};
			var hasRun = false;
			successCallback = ( successCallback || ng.noop );
			errorCallback = ( errorCallback || ng.noop );
			promise.then( handleSuccess, errorCallback );
			promise.update( handleSuccess );
			promise.mistake( errorCallback );
			return ( promise );
		};
		return ( Deferred );
	}
} )( angular, InVision );;;
/*! design-quote-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "designQuoteService", DesignQuoteService );
	/** @ngInject */
	function DesignQuoteService( _ ) {
		function getRandomQuote() {
			var quoteCount = unusedQuotes.length;
			var index = _.random( 0, ( quoteCount - 1 ) );
			var quote = unusedQuotes[ index ];
			unusedQuotes.splice( index, 1 );
			if ( !unusedQuotes.length ) {
				unusedQuotes = [].concat( quotes );
			}
			return ( quote );
		}
		var quotes = [ {
			quote: "Everything is designed. Few things are designed well.",
			author: "Brian Reed"
		}, {
			quote: "Good design is obvious. Great design is transparent.",
			author: "Joe Sparano"
		}, {
			quote: "Design is where science and art break even.",
			author: "Robin Mathew"
		}, {
			quote: "Good design goes to heaven; bad design goes everywhere.",
			author: "Mieke Gerritzen"
		}, {
			quote: "Design should never say, 'Look at me.' It should always say, 'Look at this.'",
			author: "David Craib"
		}, {
			quote: "The design process, at its best, integrates the aspirations of art, science, and culture.",
			author: "Jeff Smith"
		}, {
			quote: "Content precedes design. Design in the absence of content is not design, it's decoration.",
			author: "Jeffrey Zeldman"
		}, {
			quote: "Design is not the narrow application of formal skills, it is a way of thinking.",
			author: "Chris Pullman"
		}, {
			quote: "Design creates culture. Culture shapes values. Values determine the future.",
			author: "Robert L. Peters"
		}, {
			quote: "Computers are to design as microwaves are to cooking.",
			author: "Milton Glaser"
		}, {
			quote: "Good design is all about making other designers feel like idiots because that idea wasn't theirs.",
			author: "Frank Chimero"
		}, {
			quote: "Truly elegant design incorporates top-notch functionality into a simple, uncluttered form.",
			author: "David Lewis"
		}, {
			quote: "The only important thing about design is how it relates to people.",
			author: "Victor Papanek"
		}, {
			quote: "I never design a building before I've seen the site and met the people who will be using it.",
			author: "Frank Lloyd Wright"
		}, {
			quote: "Creativity is allowing yourself to make mistakes. Design is knowing which ones to keep.",
			author: "Unknown"
		} ];
		var unusedQuotes = [].concat( quotes );
		return ( {
			getRandomQuote: getRandomQuote
		} );
	}
} )( angular, InVision );;;
/*! error-log-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "errorLogService", ErrorLogService );
	/** @ngInject */
	function ErrorLogService( $log, $window, stackTraceService ) {
		var debounceLog = {};
		var appLoadedAt = ( new Date() ).getTime();

		function log( exception ) {
			$log.error.apply( $log, arguments );
			try {
				var errorMessage = exception.toString();
				if ( shouldSkipErrorReporting( errorMessage ) ) {
					return;
				}
				var stackTrace = stackTraceService.print( {
					e: exception
				} );
				$.ajax( {
					type: "POST",
					url: "/api/error-log/javascript",
					contentType: "application/json",
					headers: {
						"X-Page-Loaded-At": appLoadedAt
					},
					data: ng.toJson( {
						errorUrl: $window.location.href,
						errorMessage: errorMessage,
						stackTrace: ng.toJson( stackTrace )
					} )
				} );
			} catch ( loggingError ) {
				$log.warn( "Error logging failed" );
				$log.log( loggingError );
			}
		}

		function normalizeErrorMessage( message ) {
			return (
				String( message ).toLowerCase().replace( /[^a-z0-9]+/gi, "_" )
			);
		}

		function shouldSkipErrorReporting( message ) {
			var errorKey = ( "debounce_" + normalizeErrorMessage( message ) );
			if ( debounceLog.hasOwnProperty( errorKey ) ) {
				return ( true );
			}
			debounceLog[ errorKey ] = true;
			return ( false );
		}
		return ( {
			exceptionHandler: log
		} );
	}
} )( angular, InVision );;;
/*! firebase-state-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "firebaseStateService", firebaseStateService );
	/** @ngInject */
	function firebaseStateService( _, $rootScope, $resource, config, $timeout, dateHelper, userService, sessionService, serviceHelper ) {
		var fbUserRef = new Firebase( config.firebaseUrl + "users/" + config.userID );
		var fbTargetRef = new Firebase( config.firebaseUrl + "/users/" + config.userID + "/target" );
		var fbRedirectUrlRef = new Firebase( config.firebaseUrl + "/redirectUrl" );
		var fbNotificationsRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/notifications" );
		var fbReadNotificationsRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/readNotifications" );
		var fbTopbarNotificationsRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/topbarNotifications" );
		var fbScheduledLiveSharesRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/scheduledLiveShares" );
		var fbFeaturedFlagsRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/featureFlags" );
		var fbDebugRef = new Firebase( config.firebaseUrl + "users/" + config.userID + "/debug" );
		var fbParticipantsRef = "";
		var fbParticipantRef;
		var liveshareStatusRef;
		var liveshareRef;
		var fbConferenceRef;
		var fbCallRef;
		var updateTimeout;
		var timeoutDelay = 50;
		var firebaseData = {
			target: "liveshare_" + guid(),
			currentTarget: null,
			conferenceId: "",
			participants: 0,
			node: "",
			key: "",
			nextScheduledLiveShare: "",
			notifications: [],
			topbarNotifications: [],
			scheduledLiveShares: [],
			debug: false,
			featureFlags: {
				notifications: false,
				scheduledLiveShare: false,
				userTesting: false
			}
		};

		function addNotification( notification ) {
			fbNotificationsRef.push( notification );
		}

		function addScheduledLiveShare( liveshare ) {
			fbScheduledLiveSharesRef.push( liveshare );
		}

		function closeScheduledLiveShareNotification( key ) {
			fbScheduledLiveSharesRef.child( key + "/isHidden" ).set( true );
		}

		function editScheduledLiveShare( liveshare ) {
			var targetKey = liveshare.key;
			delete liveshare.key;
			fbScheduledLiveSharesRef.child( targetKey ).set( liveshare );
		}

		function fireStateChange() {
			clearTimeout( updateTimeout );
			updateTimeout = setTimeout( function () {
				$rootScope.$apply( function () {
					$rootScope.$broadcast( "firebase.stateChange", angular.copy( firebaseData ) );
				} );
			}, timeoutDelay );
		}

		function removeScheduledLiveShare( liveshare ) {
			fbScheduledLiveSharesRef.child( liveshare.key ).remove();
		}

		function augmentNotifications( notifications ) {
			var extractedNotifications = ( function ( notifications ) {
				var augmentedNotifications = [];
				var i = 0;
				var lastLabel = "";
				_.forEach( notifications, function ( notification ) {
					function augmentConversation( note ) {
						var convo = note.conversation;
						var screen = note.screen;
						var firstComment = _.first( convo.comments );
						var latestComment = convo.comments.length > 1 ? _.last( convo.comments ) : false;
						var commentHasSketch = false;
						/*_.forEach( conversation.comments, function( comment ) {
if (comment.sketches.length) {
commentHasSketch = true;
return; // we found one, now stop looping.
}
});*/
						var augmentedConversation = {
							id: convo.id,
							label: convo.label,
							x: convo.x,
							y: convo.y,
							isPrivate: convo.isPrivate,
							isForDevelopment: convo.isForDevelopment,
							isUnread: convo.isUnread,
							isComplete: convo.isComplete,
							isShown: !convo.isComplete,
							commentCount: convo.comments.length,
							thumb: ( "/screens/" + screen.id + "/" + screen.imageVersion ),
							updatedAt: _.last( convo.comments ).updatedAt,
							comments: convo.comments,
							commentHasSketch: commentHasSketch,
							conversationID: convo.id,
							screenID: convo.screenID,
							screen: screen,
							firstComment: firstComment,
							latestComment: latestComment
						};
						_.merge( augmentedConversation.firstComment, {
							isJustSketch: _.isEmpty( firstComment.comment ) ? true : false,
							comment: firstComment.comment || firstComment.userName + " attached a sketch",
							userName: userService.getNiceUsername( firstComment.userName, firstComment.userID, sessionService.user.id ),
							userFirstName: firstComment.userName.split( /\s/ )[ 0 ],
							initials: userService.getInitials( firstComment.userName ),
							isSystemAvatar: userService.isSystemAvatar( firstComment.avatarID ),
							dateLabel: dateHelper.formatRecentDate( firstComment.updatedAt, "mmm d" )
						} );
						if ( latestComment ) {
							_.merge( augmentedConversation.latestComment, {
								isJustSketch: _.isEmpty( latestComment.comment ) ? true : false,
								comment: latestComment.comment || latestComment.userName + " attached a sketch",
								userName: userService.getNiceUsername( latestComment.userName, latestComment.userID, sessionService.user.id ),
								userFirstName: latestComment.userName.split( /\s/ )[ 0 ],
								initials: userService.getInitials( latestComment.userName ),
								isSystemAvatar: userService.isSystemAvatar( latestComment.avatarID ),
								dateLabel: dateHelper.formatRecentDate( latestComment.updatedAt, "mmm d" )
							} );
						} else {
							augmentedConversation.latestComment = augmentedConversation.firstComment;
						}
						var viewport = {
							width: 83,
							height: 58,
							midWidth: ( 83 / 2 ),
							midHeight: ( 58 / 2 )
						};
						var composite = augmentedConversation.composite = {
							x: 0,
							y: 0,
							width: 200,
							height: 0,
							scale: 1,
							marker: {
								x: convo.x,
								y: convo.y
							}
						};
						composite.scale = ( composite.width / screen.width );
						composite.height = Math.floor( screen.height * composite.scale );
						composite.marker.x *= composite.scale;
						composite.marker.y *= composite.scale;
						composite.x = Math.min( ( viewport.midWidth - composite.marker.x ), 0 );
						composite.y = Math.min( ( viewport.midHeight - composite.marker.y ), 0 );
						composite.x = Math.max( composite.x, ( viewport.width - composite.width ) );
						composite.y = Math.max( composite.y, ( viewport.height - composite.height ) );
						return ( augmentedConversation );
					};
					if ( notification.type == "comment" ) {
						notification.conversation = augmentConversation( notification );
					}
					if ( lastLabel !== notification.conversation.latestComment.dateLabel ) {
						lastLabel = notification.conversation.latestComment.dateLabel;
						notification.isDateHeader = true;
					} else {
						notification.isDateHeader = false;
					}
					augmentedNotifications = augmentedNotifications.concat( notification );
				} );
				return augmentedNotifications;
			} )( notifications );
			notifications = extractedNotifications;
		}

		function createLiveShare( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "create",
				parameters: options
			} );
			return ( promise );
		}

		function removeLiveShare( options ) {
			var promise = serviceHelper.executeRequest( {
				resource: removeResource,
				name: "remove",
				parameters: options
			} );
			return ( promise );
		}

		function markAllNotificationsAsRead() {
			fbNotificationsRef.once( "value", function ( snap ) {
				var snapVal = snap.val();
				if ( snapVal !== null ) {
					for ( var key in snapVal ) {
						if ( snapVal[ key ].unread ) {
							fbNotificationsRef.child( key + "/unread" ).set( false );
						}
					}
				}
			} );
		}

		function markNotificationAsRead( key ) {
			fbNotificationsRef.child( key + "/unread" ).set( false );
		};

		function getState() {
			return angular.copy( firebaseData );
		}

		function setTarget( target ) {
			firebaseData.target = target;
			fbTargetRef.set( target );
			fireStateChange();
		}

		function setKey( key ) {
			firebaseData.key = key;
			fireStateChange();
		}
		/**
		 * Generates a GUID string, according to RFC4122 standards.
		 * @returns {String} The generated GUID.
		 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
		 * @author Slavik Meltser (slavik@meltser.info).
		 * @link http://slavik.meltser.info/?p=142
		 */
		function guid() {
			function _p8( s ) {
				var p = ( Math.random().toString( 16 ) + "000000000" ).substr( 2, 8 );
				return s ? "-" + p.substr( 0, 4 ) + "-" + p.substr( 4, 4 ) : p;
			}
			return _p8() + _p8( true ) + _p8( true ) + _p8();
		}
		fbUserRef.auth( config.firebaseToken, function ( error, result ) {
			if ( error ) {
				console.log( 'auth failed', error );
			} else {
				fbUserRef.on( "value", function ( snap ) {
					if ( snap.val() != null ) {
						var userRecord = snap.val();
						var oldnode = firebaseData.node;
						if ( liveshareStatusRef ) {
							liveshareStatusRef.off( "value" );
						}
						if ( fbParticipantsRef ) {
							fbParticipantsRef.off( "value" );
						}
						if ( fbParticipantRef ) {
							fbParticipantRef.off( "value" );
						}
						if ( !userRecord.sharekey ) {
							return;
						}
						firebaseData.node = "liveshare/" + userRecord.sharekey;
						liveshareStatusRef = new Firebase( config.firebaseUrl + firebaseData.node + "/status" );
						fbParticipantsRef = new Firebase( config.firebaseUrl + firebaseData.node + "/sharebar/participants" );
						fbParticipantRef = new Firebase( config.firebaseUrl + firebaseData.node + "/sharebar/participants/" + userRecord.key );
						fbParticipantRef.on( "value", function ( participant ) {
							var participantVal = participant.val();
							if ( participantVal == null ) {
								if ( liveshareStatusRef ) {
									liveshareStatusRef.off( "value" );
								}
								if ( fbParticipantsRef ) {
									fbParticipantsRef.off( "value" );
								}
								if ( fbParticipantRef ) {
									fbParticipantRef.off( "value" );
								}
								firebaseData.conferenceId = "";
								firebaseData.currentTarget = null;
								firebaseData.participants = 0;
								firebaseData.key = "";
								fireStateChange();
								return;
							}
							if ( participantVal.isPresenter ) {
								liveshareStatusRef.on( "value", function ( status ) {
									if ( ( status.val() == "open" || status.val() == "redirecting" || status.val() == "redirecting_prep" ) && userRecord.target ) {
										firebaseData.key = userRecord.sharekey;
										fbParticipantsRef = new Firebase( config.firebaseUrl + "liveshare/" + userRecord.sharekey + "/sharebar/participants" );
										fbParticipantsRef.on( "value", function ( participants ) {
											var participantsVal = participants.val();
											if ( participantsVal != null ) {
												firebaseData.participants = Object.keys( participantsVal ).length - 1; // we don't count the presenter amongst the # of participants
											} else {
												firebaseData.participants = 0;
											}
											fireStateChange();
										} );
										firebaseData.conferenceId = userRecord.conferenceId;
										firebaseData.currentTarget = userRecord.target;
									} else {
										if ( fbParticipantsRef ) {
											fbParticipantsRef.off( "value" );
										}
										firebaseData.conferenceId = "";
										firebaseData.currentTarget = null;
										firebaseData.participants = 0;
										firebaseData.key = "";
									}
									fireStateChange();
								} );
							}
						} );
					}
				} );
				fbDebugRef.on( "value", function ( snap ) {
					if ( snap.val() !== null ) {
						firebaseData.debug = snap.val();
					} else {
						firebaseData.debug = false;
					}
					fireStateChange();
				} );
				fbFeaturedFlagsRef.on( "value", function ( snap ) {
					if ( snap.val() !== null ) {
						firebaseData.featureFlags = snap.val();
					} else {
						firebaseData.featureFlags = {};
					}
					fireStateChange();
				} );
				fbNotificationsRef.on( "value", function ( snap ) {
					if ( snap.val() !== null ) {
						var snapVal = snap.val();
						var notificationsArray = [];
						var i = 0;
						for ( var key in snapVal ) {
							notificationsArray.push( snapVal[ key ] );
							notificationsArray[ i ].key = key; // add the Firebase key so we can reference it later
							i++;
						}
						firebaseData.notifications = notificationsArray.reverse();
					} else {
						firebaseData.notifications = [];
					}
					augmentNotifications( firebaseData.notifications );
					fireStateChange();
				} );
				fbReadNotificationsRef.on( "value", function ( snap ) {
					if ( snap.val() !== null ) {
						var snapVal = snap.val();
						var snapList = Object.keys( snapVal );
						var unreadNotifications = _.filter( firebaseData.notifications, 'unread' );
						for ( var commentID in snapVal ) {
							var notificationIndex = _.findIndex( unreadNotifications, function ( notification ) {
								return notification.comment && notification.comment.id === parseInt( commentID );
							} );
							if ( notificationIndex >= 0 ) {
								fbNotificationsRef.child( firebaseData.notifications[ notificationIndex ].key + "/unread" ).set( false );
							}
							fbReadNotificationsRef.child( commentID ).remove();
						}
					}
				} );
				fbScheduledLiveSharesRef.on( "value", function ( snap ) {
					if ( snap.val() !== null ) {
						var snapVal = snap.val();
						var livesharesArray = [];
						var i = 0;
						for ( var key in snapVal ) {
							livesharesArray.push( snapVal[ key ] );
							livesharesArray[ i ].key = key; // add the Firebase key so we can reference it later
							i++;
						}
						livesharesArray = _.sortBy( livesharesArray, "date" );
						firebaseData.nextScheduledLiveShare = _.find( livesharesArray, function ( ls ) {
							return moment( ls.date ).isAfter( moment() );
						} );
						firebaseData.scheduledLiveShares = livesharesArray;
					} else {
						firebaseData.scheduledLiveShares = [];
						firebaseData.nextScheduledLiveShare = "";
					}
					fireStateChange();
				} );
			}
		} );
		var resource = $resource(
			"/liveshare/:command/:projectID", {
				command: "@command",
				projectID: "@projectID"
			}, {
				create: {
					method: "POST",
					params: {
						command: "create",
						json: true,
						scheduled: true
					}
				},
				delete: {
					method: "GET",
					params: {
						command: "create",
						json: true,
						scheduled: true
					}
				}
			}
		);
		var removeResource = $resource(
			"/liveshare/:key/cleanup", {
				key: "@key"
			}, {
				remove: {
					method: "GET"
				}
			}
		);
		return ( {
			addNotification: addNotification,
			addScheduledLiveShare: addScheduledLiveShare,
			closeScheduledLiveShareNotification: closeScheduledLiveShareNotification,
			editScheduledLiveShare: editScheduledLiveShare,
			removeScheduledLiveShare: removeScheduledLiveShare,
			createLiveShare: createLiveShare,
			removeLiveShare: removeLiveShare,
			guid: guid,
			getState: getState,
			markNotificationAsRead: markNotificationAsRead,
			markAllNotificationsAsRead: markAllNotificationsAsRead,
			setTarget: setTarget,
			setKey: setKey
		} );
	}
} )( angular, InVision );;;
/*! hashkey-copier.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "hashKeyCopier", HashKeyCopier );
	/** @ngInject */
	function HashKeyCopier( _ ) {
		function applyHashKeyIndex( hashKeyIndex, target, uniqueIdentifiers ) {
			if ( _.isArray( target ) ) {
				applyHashKeyIndexToArray( hashKeyIndex, "[]", target, uniqueIdentifiers );
			} else if ( _.isObject( target ) ) {
				applyHashKeyIndexToObject( hashKeyIndex, ".", target, uniqueIdentifiers );
			}
			return ( target );
		}

		function applyHashKeyIndexToArray( hashKeyIndex, path, target, uniqueIdentifiers ) {
			for ( var i = 0, length = target.length; i < length; i++ ) {
				var targetItem = target[ i ];
				if ( _.isArray( targetItem ) ) {
					applyHashKeyIndexToArray( hashKeyIndex, ( path + "[]" ), targetItem, uniqueIdentifiers );
				} else if ( _.isObject( targetItem ) ) {
					applyHashKeyIndexToObject( hashKeyIndex, ( path + "." ), targetItem, uniqueIdentifiers );
				}
			}
		}

		function applyHashKeyIndexToObject( hashKeyIndex, path, target, uniqueIdentifiers ) {
			var identifier = getUniqueIdentifierForObject( target, uniqueIdentifiers );
			if ( identifier ) {
				var hashKeyPath = ( path + target[ identifier ] );
				if ( hashKeyIndex.hasOwnProperty( hashKeyPath ) ) {
					target[ hashKeyLookup ] = hashKeyIndex[ hashKeyPath ];
					path += ( target[ identifier ] + "." );
				}
			}
			for ( var key in target ) {
				if ( target.hasOwnProperty( key ) ) {
					var targetItem = target[ key ];
					if ( _.isArray( targetItem ) ) {
						applyHashKeyIndexToArray( hashKeyIndex, ( path + key + "[]" ), targetItem, uniqueIdentifiers );
					} else if ( _.isObject( targetItem ) ) {
						applyHashKeyIndexToObject( hashKeyIndex, ( path + key + "." ), targetItem, uniqueIdentifiers );
					}
				}
			}
		}

		function buildHashKeyIndex( target, uniqueIdentifiers ) {
			var hashKeyIndex = {};
			if ( _.isArray( target ) ) {
				buildHashKeyIndexForArray( hashKeyIndex, "[]", target, uniqueIdentifiers );
			} else if ( _.isObject( target ) ) {
				buildHashKeyIndexForObject( hashKeyIndex, ".", target, uniqueIdentifiers );
			}
			return ( hashKeyIndex );
		}

		function buildHashKeyIndexForArray( hashKeyIndex, path, target, uniqueIdentifiers ) {
			for ( var i = 0, length = target.length; i < length; i++ ) {
				var targetItem = target[ i ];
				if ( _.isArray( targetItem ) ) {
					buildHashKeyIndexForArray( hashKeyIndex, ( path + "[]" ), targetItem, uniqueIdentifiers );
				} else if ( _.isObject( targetItem ) ) {
					buildHashKeyIndexForObject( hashKeyIndex, ( path + "." ), targetItem, uniqueIdentifiers );
				}
			}
		}

		function buildHashKeyIndexForObject( hashKeyIndex, path, target, uniqueIdentifiers ) {
			if ( target.hasOwnProperty( hashKeyLookup ) ) {
				var identifier = getUniqueIdentifierForObject( target, uniqueIdentifiers );
				if ( identifier ) {
					hashKeyIndex[ path + target[ identifier ] ] = target[ hashKeyLookup ];
					path += ( target[ identifier ] + "." );
				}
			}
			for ( var key in target ) {
				if ( target.hasOwnProperty( key ) ) {
					var targetItem = target[ key ];
					if ( _.isArray( targetItem ) ) {
						buildHashKeyIndexForArray( hashKeyIndex, ( path + key + "[]" ), targetItem, uniqueIdentifiers );
					} else if ( _.isObject( targetItem ) ) {
						buildHashKeyIndexForObject( hashKeyIndex, ( path + key + "." ), targetItem, uniqueIdentifiers );
					}
				}
			}
		}

		function copyHashKeys( existing, incoming, uniqueIdentifiers ) {
			if ( isExistingDataEmpty( existing ) ) {
				return ( incoming );
			}
			if ( !uniqueIdentifiers ) {
				uniqueIdentifiers = [ "id" ];
			}
			var hashKeyIndex = buildHashKeyIndex( existing, uniqueIdentifiers );
			applyHashKeyIndex( hashKeyIndex, incoming, uniqueIdentifiers );
			return ( incoming );
		}

		function getUniqueIdentifierForObject( target, uniqueIdentifiers ) {
			for ( var i = 0, length = uniqueIdentifiers.length; i < length; i++ ) {
				var identifier = uniqueIdentifiers[ i ];
				if ( target.hasOwnProperty( identifier ) ) {
					return ( identifier );
				}
			}
			return ( null );
		}

		function isEmptyArray( target ) {
			return (
				target.hasOwnProperty( "length" ) &&
				( target.length === 0 )
			);
		}

		function isExistingDataEmpty( existing ) {
			if ( !existing || isEmptyArray( existing ) ) {
				return ( true );
			}
			return ( false );
		}
		var hashKeyLookup = "$$hashKey";
		return ( {
			copyHashKeys: copyHashKeys
		} );
	}
} )( angular, InVision );;;
/*! hotspot-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "hotspotService", HotspotService );
	/** @ngInject */
	function HotspotService( _, $resource, serviceHelper, modelEvents ) {
		function getByScreenID( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "query",
				parameters: {
					screenID: screenID
				}
			} );
			return promise;
		}

		function saveHotspot( hotspot, currentScreen ) {
			var parameters = _.pick(
				hotspot,
				"id",
				"screenID",
				"eventTypeID",
				"targetTypeID",
				"transitionTypeID",
				"targetScreenID",
				"metaData",
				"templateID",
				"x",
				"y",
				"width",
				"height",
				"isScrollTo",
				"isBottomAligned"
			);
			parameters.eventTypeID = ( parameters.eventTypeID || eventTypes.click );
			parameters.transitionTypeID = ( parameters.transitionTypeID || transitionTypes.none );
			parameters.metaData = ( parameters.metaData || {} );
			parameters.templateID = ( parameters.templateID || 0 );
			parameters.isBottomAligned = parameters.templateID != 0 ? parameters.isBottomAligned : false;
			if ( parameters.isBottomAligned ) {
				parameters.bottomY = currentScreen.height - parameters.y - parameters.height;
				parameters.y = parameters.bottomY;
			}
			if ( !parameters.id ) {
				delete parameters.id;
			}
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {
					if ( !hotspot.id ) {
						hotspot.id = response.id;
					}
				}
			} );
			return promise;
		}

		function deleteHotspot( hotspot ) {
			var parameters = _.pick( hotspot, "id" );
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "delete",
				parameters: parameters
			} );
			return promise;
		}
		var resource = $resource( "/api/hotspots/:command:id", {
			id: "@id",
			command: "@command"
		} );
		var eventTypes = {
			click: 1,
			doubleTap: 2,
			pressHold: 3,
			swipeRight: 4,
			swipeLeft: 5,
			swipeUp: 6,
			swipeDown: 7,
			hover: 8
		};
		var targetTypes = {
			screen: 1,
			lastScreenVisited: 2,
			previousScreenInSort: 3,
			nextScreenInSort: 4,
			externalUrl: 5,
			positionOnScreen: 6
		};
		var transitionTypes = {
			none: 1,
			pushRight: 2,
			pushLeft: 3,
			slideUp: 4,
			slideDown: 5,
			flipRight: 6,
			flipLeft: 7,
			dissolve: 8
		};
		return {
			deleteHotspot: deleteHotspot,
			eventTypes: eventTypes,
			getByScreenID: getByScreenID,
			saveHotspot: saveHotspot,
			targetTypes: targetTypes,
			transitionTypes: transitionTypes
		};
	}
} )( angular, InVision );;;
/*! http-activity-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "httpActivityService", Service );
	/** @ngInject */
	function Service() {
		this.activeRequestCount = 0;
		this.activeGetRequestCount = 0;
		this.activePostRequestCount = 0;
		return ( this );
	}
	Service.prototype = {
		isActive: function () {
			return ( this.activeRequestCount !== 0 );
		},
		isActiveWithGet: function () {
			return ( this.activeGetRequestCount !== 0 );
		},
		isActiveWithPost: function () {
			return ( this.activePostRequestCount !== 0 );
		},
		requestCompleted: function ( isPostRequest ) {
			if ( isPostRequest ) {
				this.activePostRequestCount--;
			} else {
				this.activeGetRequestCount--;
			}
			this.activeRequestCount--;
			if ( this.activeRequestCount === 0 ) {
				this.activeGetRequestCount = 0;
				this.activePostRequestCount = 0;
			}
			return ( this.activeRequestCount );
		},
		requestStarted: function ( isPostRequest ) {
			if ( isPostRequest ) {
				this.activePostRequestCount++;
			} else {
				this.activeGetRequestCount++;
			}
			this.activeRequestCount++;
			return ( this.activeRequestCount );
		}
	};
} )( angular, InVision );;;
/*! ipinfo-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "ipInfoService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function getGeolocationData( parameter ) {
			if ( cachedPromise ) {
				return ( cachedPromise );
			}
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getGeolocationData"
			} );
			return ( cachedPromise = promise );
		}
		var cachedPromise = null;
		var resource = $resource(
			"/api/ipgeolocation", {}, {
				getGeolocationData: {
					method: "GET"
				}
			}
		);
		return ( {
			getGeolocationData: getGeolocationData
		} );
	}
} )( angular, InVision );;;
/*! jquery.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "$", Factory );

	function Factory() {
		return $;
	}
} )( angular, InVision );;;
/*! layersyncService.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "layersyncService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function info( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "info",
				parameters: {
					assetID: assetID
				}
			} );
			return ( promise );
		}

		function items( projectID, folderID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "items",
				parameters: {
					projectID: projectID,
					folderID: folderID
				}
			} );
			return ( promise );
		}

		function inspect( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "inspect",
				parameters: {
					assetID: assetID
				}
			} );
			return ( promise );
		}

		function enable( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "enable",
				parameters: {
					assetID: assetID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "layerSyncEnabled", assetID );
				}
			} );
			return ( promise );
		}

		function disable( assetID, deleteArtifacts ) {
			deleteArtifacts = deleteArtifacts || false;
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "disable",
				parameters: {
					assetID: assetID,
					deleteArtifacts: deleteArtifacts
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "layerSyncDisabled", assetID );
				}
			} );
			return ( promise );
		}

		function submit( assetID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "submit",
				parameters: {
					assetID: assetID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/layersync/:listCommand/:docCommand", {
				listCommand: "@listCommand",
				docCommand: "@docCommand"
			}, {
				info: {
					method: "GET",
					isArray: false,
					params: {
						listCommand: "info"
					}
				},
				items: {
					method: "GET",
					isArray: true,
					params: {
						listCommand: "items"
					}
				},
				inspect: {
					method: "POST",
					isArray: false,
					params: {
						listCommand: "inspect"
					}
				},
				enable: {
					method: "POST",
					isArray: false,
					params: {
						listCommand: "enable"
					}
				},
				disable: {
					method: "POST",
					isArray: false,
					params: {
						listCommand: "disable"
					}
				},
				submit: {
					method: "POST",
					isArray: false,
					params: {
						listCommand: "submitJob"
					}
				},
				check: {
					method: "POST",
					isArray: false,
					params: {
						listCommand: "checkJob"
					}
				}
			}
		);
		return ( {
			info: info,
			items: items,
			inspect: inspect,
			enable: enable,
			disable: disable,
			submit: submit
		} );
	}
} )( angular, InVision );;;
/*! liveshare-state-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "liveshareStateService", LiveshareStateService );
	/** @ngInject */
	function LiveshareStateService( $rootScope, config ) {
		var fbUserRef = new Firebase( config.firebaseUrl + "users/" + config.userID );
		var fbTargetRef = new Firebase( config.firebaseUrl + "/users/" + config.userID + "/target" );
		var fbRedirectUrlRef = new Firebase( config.firebaseUrl + "/redirectUrl" );
		var fbParticipantsRef = "";
		var fbParticipantRef;
		var liveshareStatusRef;
		var liveshareRef;
		var fbConferenceRef;
		var fbCallRef;
		var liveshareData = {
			target: "liveshare_" + guid(),
			currentTarget: null,
			conferenceId: "",
			participants: 0,
			node: "",
			key: ""
		};

		function getState() {
			return liveshareData;
		}

		function setTarget( target ) {
			liveshareData.target = target;
			fbTargetRef.set( target );
			$rootScope.$broadcast( "liveshare.stateChange", liveshareData );
		}

		function setKey( key ) {
			liveshareData.key = key;
			$rootScope.$broadcast( "liveshare.stateChange", liveshareData );
		}
		/**
		 * Generates a GUID string, according to RFC4122 standards.
		 * @returns {String} The generated GUID.
		 * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa
		 * @author Slavik Meltser (slavik@meltser.info).
		 * @link http://slavik.meltser.info/?p=142
		 */
		function guid() {
			function _p8( s ) {
				var p = ( Math.random().toString( 16 ) + "000000000" ).substr( 2, 8 );
				return s ? "-" + p.substr( 0, 4 ) + "-" + p.substr( 4, 4 ) : p;
			}
			return _p8() + _p8( true ) + _p8( true ) + _p8();
		}
		fbUserRef.auth( config.firebaseToken, function ( error, result ) {
			if ( error ) {
				console.log( 'auth failed', error );
			} else {
				fbUserRef.on( "value", function ( snap ) {
					if ( snap.val() != null ) {
						var userRecord = snap.val();
						var oldnode = liveshareData.node;
						if ( liveshareStatusRef ) {
							liveshareStatusRef.off( "value" );
						}
						if ( fbParticipantsRef ) {
							fbParticipantsRef.off( "value" );
						}
						if ( fbParticipantRef ) {
							fbParticipantRef.off( "value" );
						}
						if ( !userRecord.sharekey ) {
							return;
						}
						liveshareData.node = "liveshare/" + userRecord.sharekey;
						liveshareStatusRef = new Firebase( config.firebaseUrl + liveshareData.node + "/status" );
						fbParticipantsRef = new Firebase( config.firebaseUrl + liveshareData.node + "/sharebar/participants" );
						fbParticipantRef = new Firebase( config.firebaseUrl + liveshareData.node + "/sharebar/participants/" + userRecord.key );
						fbParticipantRef.on( "value", function ( participant ) {
							var participantVal = participant.val();
							if ( participantVal == null ) {
								if ( liveshareStatusRef ) {
									liveshareStatusRef.off( "value" );
								}
								if ( fbParticipantsRef ) {
									fbParticipantsRef.off( "value" );
								}
								if ( fbParticipantRef ) {
									fbParticipantRef.off( "value" );
								}
								liveshareData.conferenceId = "";
								liveshareData.currentTarget = null;
								liveshareData.participants = 0;
								liveshareData.key = "";
								$rootScope.$broadcast( "liveshare.stateChange", liveshareData );
								return;
							}
							if ( participantVal.isPresenter ) {
								liveshareStatusRef.on( "value", function ( status ) {
									if ( ( status.val() == "open" || status.val() == "redirecting" || status.val() == "redirecting_prep" ) && userRecord.target ) {
										liveshareData.key = userRecord.sharekey;
										fbParticipantsRef = new Firebase( config.firebaseUrl + "liveshare/" + userRecord.sharekey + "/sharebar/participants" );
										fbParticipantsRef.on( "value", function ( participants ) {
											var participantsVal = participants.val();
											if ( participantsVal != null ) {
												liveshareData.participants = Object.keys( participantsVal ).length - 1; // we don't count the presenter amongst the # of participants
											} else {
												liveshareData.participants = 0;
											}
											$rootScope.$broadcast( "liveshare.stateChange", liveshareData );
										} );
										liveshareData.conferenceId = userRecord.conferenceId;
										liveshareData.currentTarget = userRecord.target;
									} else {
										liveshareData.conferenceId = "";
										liveshareData.currentTarget = null;
										liveshareData.participants = 0;
										liveshareData.key = "";
									}
									$rootScope.$broadcast( "liveshare.stateChange", liveshareData );
								} );
							}
						} );
					}
				} );
			}
		} );
		return ( {
			guid: guid,
			getState: getState,
			setTarget: setTarget,
			setKey: setKey
		} );
	}
} )( angular, InVision );;;
/*! lodash.js */
;;
( function ( ng, app, _ ) {
	"use strict";
	app.factory( "_", Factory );
	/** @ngInject */
	function Factory() {
		_.capitalizeFirstLetter = function ( value ) {
			if ( !value ) {
				return ( "" );
			}
			return ( value.slice( 0, 1 ).toUpperCase() + value.slice( 1 ) );
		};
		_.containsWithProperty = function ( collection, name, value ) {
			return ( !!this.findWithProperty( collection, name, value ) );
		};
		_.countWithProperty = function ( collection, name, value ) {
			var count = 0;
			for ( var i = 0; i < collection.length; i++ ) {
				if ( collection[ i ][ name ] === value ) {
					count++;
				}
			}
			return ( count );
		};
		_.extendExistingProperties = function ( destination, source ) {
			if ( !( destination && source ) ) {
				return ( destination );
			}
			var angularKeyPattern = new RegExp( "^\\$+", "i" );
			for ( var key in source ) {
				if (
					source.hasOwnProperty( key ) &&
					destination.hasOwnProperty( key ) &&
					!angularKeyPattern.test( key ) &&
					!_.isFunction( source[ key ] )
				) {
					destination[ key ] = source[ key ];
				}
			}
			return ( destination );
		};
		_.filterWithProperty = function ( collection, name, value ) {
			var filteredCollection = _.filter(
				collection,
				function ( item ) {
					return ( item[ name ] === value );
				}
			);
			return ( filteredCollection );
		};
		_.findWithProperty = function ( collection, name, value ) {
			var result = _.find(
				collection,
				function ( item ) {
					return ( item[ name ] === value );
				}
			);
			return ( result );
		};
		_.indexOfWithProperty = function ( collection, name, value ) {
			for ( var i = 0; i < collection.length; i++ ) {
				if ( collection[ i ][ name ] === value ) {
					return ( i );
				}
			}
			return ( -1 );
		};
		_.notContainsProperty = function ( collection, name, value ) {
			var filteredCollection = this.filter(
				collection,
				function ( item ) {
					return ( !_.contains( item[ name ].toLowerCase(), value.toLowerCase() ) );
				}
			);
			return ( filteredCollection );
		};
		_.maxProperty = function ( collection, name ) {
			if ( !collection.length ) {
				return;
			}
			return (
				_.max(
					_.pluck( collection, name )
				)
			);
		};
		_.minProperty = function ( collection, name ) {
			return (
				_.min(
					_.pluck( collection, name )
				)
			);
		};
		_.normalizeMixedDataValue = function ( value ) {
			var padding = "000000000000000";
			value = value.replace(
				/(\d+)((\.\d+)+)?/g,
				function ( $0, integer, decimal, repeatDecimal ) {
					if ( decimal !== repeatDecimal ) {
						return (
							padding.slice( integer.length ) +
							integer +
							decimal
						);
					}
					decimal = ( decimal || ".0" );
					return (
						padding.slice( integer.length ) +
						integer +
						decimal +
						padding.slice( decimal.length )
					);
				}
			);
			return ( value );
		};
		_.rejectWithProperty = function ( collection, name, value ) {
			var filteredCollection = _.reject(
				collection,
				function ( item ) {
					return ( item[ name ] === value );
				}
			);
			return ( filteredCollection );
		};
		_.setProperty = function ( collection, name, value ) {
			this.forEach(
				collection,
				function ( item ) {
					item[ name ] = value;
				}
			);
			return ( collection );
		};
		_.sortOnProperty = function ( collection, name, direction ) {
			direction = ( direction || "asc" );
			var sortIndicator = ( direction === "asc" ? -1 : 1 );
			collection.sort(
				function ( a, b ) {
					return ( a[ name ] < b[ name ] ? sortIndicator : -sortIndicator );
				}
			);
			return ( collection );
		};
		_.sortOnPropertyUsingNaturalOrder = function ( collection, name, direction ) {
			direction = ( direction || "asc" );
			var sortIndicator = ( direction === "asc" ? -1 : 1 );
			collection.sort(
				function ( a, b ) {
					var aMixed = _.normalizeMixedDataValue( a.name.toLowerCase() );
					var bMixed = _.normalizeMixedDataValue( b.name.toLowerCase() );
					return ( aMixed < bMixed ? sortIndicator : -sortIndicator );
				}
			);
			return ( collection );
		};
		_.sumProperty = function ( collection, name ) {
			var sum = 0;
			for ( var i = 0; i < collection.length; i++ ) {
				sum += collection[ i ][ name ];
			}
			return ( sum );
		};
		_.withoutProperty = function ( collection, name, value ) {
			var filteredCollection = this.filter(
				collection,
				function ( item ) {
					return ( item[ name ] !== value );
				}
			);
			return ( filteredCollection );
		};
		_.withoutPropertyRange = function ( collection, name, valueRange ) {
			var filteredCollection = this.filter(
				collection,
				function ( item ) {
					return ( _.indexOf( valueRange, item[ name ] ) === -1 );
				}
			);
			return ( filteredCollection );
		};
		_.withProperty = function ( collection, name, value ) {
			var filteredCollection = this.filter(
				collection,
				function ( item ) {
					return ( item[ name ] === value );
				}
			);
			return ( filteredCollection );
		};
		_.withPropertyRange = function ( collection, name, valueRange ) {
			var filteredCollection = this.filter(
				collection,
				function ( item ) {
					return ( _.indexOf( valueRange, item[ name ] ) !== -1 );
				}
			);
			return ( filteredCollection );
		};
		return ( _ );
	}
} )( angular, InVision, _ );;;
/*! modal-window-request.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "modalWindowRequest", ModalWindowRequest );
	/** @ngInject */
	function ModalWindowRequest() {
		function getData( index, defaultValue ) {
			if ( arguments.length === 0 ) {
				return ( modalData );
			} else if (
				( index > modalData.length ) &&
				( arguments.length == 2 )
			) {
				return ( defaultValue );
			} else {
				return ( modalData[ index ] );
			}
		}

		function getType() {
			return ( modalType );
		}

		function isSuppressFade() {
			return ( suppressFade === true );
		}

		function setRequest( newModalType, newModalData, newSuppressFade ) {
			modalType = newModalType;
			modalData = newModalData;
			suppressFade = ( newSuppressFade || false );
		}

		function setSuppressFade( newSuppressFade ) {
			suppressFade = ( newSuppressFade || false );
		}

		function isSuppressClose() {
			return ( suppressClose === true );
		}

		function setSuppressClose( newSuppressClose ) {
			suppressClose = ( newSuppressClose || false );
		}
		var modalType = "";
		var modalData = [];
		var suppressFade = false;
		var suppressClose = false;
		return ( {
			getData: getData,
			getType: getType,
			isSuppressFade: isSuppressFade,
			setRequest: setRequest,
			setSuppressFade: setSuppressFade,
			isSuppressClose: isSuppressClose,
			setSuppressClose: setSuppressClose
		} );
	}
} )( angular, InVision );;;
/*! model-events.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "modelEvents", ModelEventsFactory );
	/** @ngInject */
	function ModelEventsFactory( PubSub ) {
		return ( new PubSub() );
	}
} )( angular, InVision );;;
/*! moment.js */
;;
( function ( ng, app, moment ) {
	"use strict";
	app.factory( "moment", Factory );
	/** @ngInject */
	function Factory() {
		return moment;
	}
} )( angular, InVision, moment );;;
/*! notifications-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "notificationsService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function getSettings() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getSettings"
			} );
			return ( promise );
		}

		function updateSendDigestAt( wantsDigestAtFrequencyInHours, digestSendTime ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateSendDigestAt",
				parameters: {
					command: "digestSendTime",
					wantsDigestAtFrequencyInHours: wantsDigestAtFrequencyInHours,
					sendNextDigestAt: digestSendTime
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function updateSettings( settings ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateSettings",
				parameters: settings,
				successCallback: function ( response ) {
					modelEvents.trigger( "notificationSettingsUpdated", settings );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/notifications/:command", {
				command: "@command"
			}, {
				getSettings: {
					method: "GET"
				},
				updateSendDigestAt: {
					method: "POST",
					command: "digestSendTime"
				},
				updateSettings: {
					method: "POST"
				}
			}
		);
		return ( {
			getSettings: getSettings,
			updateSendDigestAt: updateSendDigestAt,
			updateSettings: updateSettings
		} );
	}
} )( angular, InVision );;;
/*! partial-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "partialHelper", PartialHelper );
	/** @ngInject */
	function PartialHelper( Deferred ) {
		function applyCacheIfAvailable( deferred, resourceResponse, cachedResponse ) {
			if ( cachedResponse !== null ) {
				deferred.resolve(
					applyCacheToResourceResponse( resourceResponse, cachedResponse )
				);
			}
		}

		function applyCacheToResourceResponse( resourceResponse, cachedResponse ) {
			if ( ng.isArray( resourceResponse ) ) {
				resourceResponse.splice.apply(
					resourceResponse, [ 0, 0 ].concat( cachedResponse )
				);
			} else {
				ng.extend( resourceResponse, cachedResponse );
			}
			return ( resourceResponse );
		}

		function executeRequest( options ) {
			var resource = options.resource;
			var name = options.name;
			var parameters = ( options.parameters || {} );
			var cachedResponse = ( options.cachedResponse || null );
			var successCallback = ( options.successCallback || ng.noop );
			var errorCallback = ( options.errorCallback || ng.noop );
			var deferred = new Deferred();
			var resourceResponse = resource[ name ](
				parameters,
				function ( response ) {
					successCallback( response );
					deferred.resolve( response );
				},
				function ( response ) {
					errorCallback( response );
					deferred.reject(
						unwrapErrorMessage( response )
					);
				}
			);
			applyCacheIfAvailable( deferred, resourceResponse, cachedResponse );
			return ( deferred.promise );
		}

		function unwrapErrorMessage( errorResponse ) {
			try {
				var response = ng.fromJson( errorResponse.data );
				if ( ng.isString( response ) ) {
					response = {
						message: response,
						code: -1,
						id: -1
					};
				}
			} catch ( error ) {
				var response = {
					message: errorResponse.data,
					code: -1,
					id: -1
				};
			}
			return ( response );
		}
		return ( {
			executeRequest: executeRequest
		} );
	}
} )( angular, InVision );;;
/*! project-group-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectGroupService", ProjectGroupService );
	/** @ngInject */
	function ProjectGroupService( $resource, serviceHelper, modelEvents, _ ) {
		function createGroup( group ) {
			var promise = serviceHelper.executeRequest( {
				resource: nonSpecificResource,
				name: "createGroup",
				parameters: {
					name: group.name,
					projectIDs: _.pluck( group.projects, "id" ).join( "," ),
					sort: group.sort,
					isForUsersOwnProjects: group.isForUsersOwnProjects
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectGroupCreated", response );
				}
			} );
			return ( promise );
		}

		function updateGroup( group ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateGroup",
				parameters: {
					id: group.id,
					name: group.name,
					projectIDs: _.pluck( group.projects, "id" ).join( "," ),
					sort: group.sort,
					isForUsersOwnProjects: group.isForUsersOwnProjects
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectGroupUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateGroupSort( groups ) {
			var promise = serviceHelper.executeRequest( {
				resource: nonSpecificResource,
				name: "updateGroupSort",
				parameters: {
					groupIDs: _.pluck( groups, "id" ).join( "," )
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function deleteGroup( group ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteGroup",
				parameters: {
					id: group.id
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectGroupDeleted", group.id );
				}
			} );
			return ( promise );
		}

		function removeProjectsFromGroups( projects ) {
			var promise = serviceHelper.executeRequest( {
				resource: nonSpecificResource,
				name: "removeProjectsFromGroups",
				parameters: {
					projectIDs: _.pluck( projects, "id" ).join( "," )
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/project-group/:id/:command", {
				id: "@id",
				command: "@command"
			}, {
				deleteGroup: {
					method: "POST",
					isArray: true,
					params: {
						command: "delete"
					}
				},
				updateGroup: {
					method: "POST",
					isArray: true,
					params: {
						command: "update"
					}
				}
			}
		);
		var nonSpecificResource = $resource(
			"/api/project-group/:command", {
				command: "@command"
			}, {
				createGroup: {
					method: "POST"
				},
				removeProjectsFromGroups: {
					method: "POST",
					params: {
						command: "remove-projects-from-groups"
					}
				},
				updateGroupSort: {
					method: "POST",
					params: {
						command: "update-group-sort"
					}
				}
			}
		);
		return ( {
			createGroup: createGroup,
			updateGroup: updateGroup,
			updateGroupSort: updateGroupSort,
			deleteGroup: deleteGroup,
			removeProjectsFromGroups: removeProjectsFromGroups
		} );
	}
} )( angular, InVision );;;
/*! project-overview-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectOverviewService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, dateHelper, _ ) {
		function getActivityAndStats( projectID, offset, duration ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getActivityAndStats",
				parameters: {
					id: projectID,
					offset: offset,
					duration: duration,
					command: "withStats"
				}
			} );
			return ( promise );
		}

		function getActivity( projectID, offset, duration ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getActivity",
				parameters: {
					id: projectID,
					offset: offset,
					duration: duration,
					command: "activityOnly"
				}
			} );
			return ( promise );
		}

		function getStatsByUser( userID, startTime, endTime ) {
			var promise = serviceHelper.executeRequest( {
				resource: userResource,
				name: "getStatsByUser",
				parameters: {
					id: userID,
					startTime: startTime,
					endTime: endTime
				}
			} );
			return ( promise );
		}

		function getCompanyStats( userID, startTime, endTime ) {
			var promise = serviceHelper.executeRequest( {
				resource: userResource,
				name: "getCompanyStats",
				parameters: {
					id: userID,
					startTime: startTime,
					endTime: endTime
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/projects/activity/:command/:id/:offset/:duration", {
				id: "@id",
				offset: "@offset",
				duration: "@duration",
				command: "@command"
			}, {
				getActivity: {
					method: "GET",
					isArray: false,
					command: "activityOnly"
				},
				getActivityAndStats: {
					method: "GET",
					isArray: false,
					command: "withStats"
				}
			}
		);
		var userResource = $resource(
			"/api/apps/:command/:id/:startTime/:endTime", {
				id: "@id",
				startTime: "@startTime",
				endTime: "@endTime",
				command: "@command"
			}, {
				getStatsByUser: {
					method: "GET",
					isArray: false,
					params: {
						command: "userstats"
					}
				},
				getCompanyStats: {
					method: "GET",
					isArray: false,
					params: {
						command: "companystats"
					}
				}
			}
		);
		return ( {
			getActivity: getActivity,
			getActivityAndStats: getActivityAndStats,
			getStatsByUser: getStatsByUser,
			getCompanyStats: getCompanyStats
		} );
	}
} )( angular, InVision );;;
/*! project-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectService", ProjectsService );
	/** @ngInject */
	function ProjectsService( $resource, serviceHelper, modelEvents ) {
		function activateProject( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "activateProject",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function addSampleScreensToProject( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addSampleScreensToProject",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					var screens = ng.fromJson( response );
					for ( var screenIndex in screens ) {
						modelEvents.trigger( "screenUploaded", screens[ screenIndex ] );
					}
				}
			} );
			return ( promise );
		}

		function addUsersToProject( projectID, userIDList ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addUsersToProject",
				parameters: {
					id: projectID,
					userIDList: userIDList
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUsersAdded", projectID, userIDList.split( "," ) );
				}
			} );
			return ( promise );
		}

		function addUserToProject( projectID, userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addUserToProject",
				parameters: {
					id: projectID,
					userID: userID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUserAdded", projectID, userID );
				}
			} );
			return ( promise );
		}

		function addUserToTeamProject( projectID, userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addUserToTeamProject",
				parameters: {
					id: projectID,
					userID: userID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUserAdded", projectID, userID );
				}
			} );
			return ( promise );
		}

		function archiveProject( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "archiveProject",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function changeUsersOnProject( projectID, addUserIDList, removeUserIDList, newUsersEmailMsg ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "changeUsersOnProject",
				parameters: {
					id: projectID,
					addUserIDList: addUserIDList.join( "," ),
					removeUserIDList: removeUserIDList.join( "," ),
					newUsersEmailMsg: newUsersEmailMsg
				},
				successCallback: function ( response ) {
					if ( addUserIDList.length ) {
						modelEvents.trigger( "projectUsersAdded", projectID, addUserIDList );
					}
					if ( removeUserIDList.length ) {
						modelEvents.trigger( "projectUsersRemoved", projectID, removeUserIDList );
					}
				}
			} );
			return ( promise );
		}

		function changeEnterpriseUsersOnProject( projectID, addUserIDList, removeUserIDList, companyTeamIDList, newUsersEmailMsg ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "changeEnterpriseUsersOnProject",
				parameters: {
					id: projectID,
					addUserIDList: addUserIDList.join( "," ),
					removeUserIDList: removeUserIDList.join( "," ),
					companyTeamIDList: companyTeamIDList.join( "," ),
					newUsersEmailMsg: newUsersEmailMsg
				},
				successCallback: function ( response ) {
					if ( addUserIDList.length ) {
						modelEvents.trigger( "projectUsersAdded", projectID, addUserIDList );
					}
					if ( removeUserIDList.length ) {
						modelEvents.trigger( "projectUsersRemoved", projectID, removeUserIDList );
					}
				}
			} );
			return ( promise );
		}

		function changeInviteesOnProject( projectID, addInviteIDs, removeInviteIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "changeInviteesOnProject",
				parameters: {
					id: projectID,
					addInviteIDList: addInviteIDs.join( "," ),
					removeInviteIDList: removeInviteIDs.join( "," )
				},
				successCallback: function ( response ) {
					if ( addInviteIDs.length ) {
						modelEvents.trigger( "projectInviteesAdded", projectID, addInviteIDs );
					}
					if ( removeInviteIDs.length ) {
						modelEvents.trigger( "projectInviteesRemoved", projectID, removeInviteIDs );
					}
				}
			} );
			return ( promise );
		}

		function deleteProject( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteProject",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectDeleted", projectID );
				}
			} );
			return ( promise );
		}

		function duplicateProject( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicateProject",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectCreated", response );
				}
			} );
			return ( promise );
		}

		function exportPDF( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "exportPDF",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectCreated", response );
				}
			} );
			return ( promise );
		}

		function getByID( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getByID",
				parameters: {
					id: id
				}
			} );
			return ( promise );
		}

		function getMembers( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getMembers",
				parameters: {
					id: id
				}
			} );
			return ( promise );
		}

		function getSnapProject() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getSnapProject"
			} );
			return ( promise );
		}

		function getStakeholders( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getStakeholders",
				parameters: {
					id: id
				}
			} );
			return ( promise );
		}

		function removeStakeholderFromProject( projectID, userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "removeStakeholder",
				parameters: {
					id: projectID,
					userID: userID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectStakeholderRemoved", projectID, userID );
				}
			} );
			return ( promise );
		}

		function removeUserFromProject( projectID, userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "removeUserFromProject",
				parameters: {
					id: projectID,
					userID: userID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUserRemoved", projectID, userID );
				}
			} );
			return ( promise );
		}

		function renameProject( projectID, name ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "renameProject",
				parameters: {
					id: projectID,
					name: name
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function setConfigDefaults( projectID, config ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setConfigDefaults",
				parameters: {
					id: projectID,
					backgroundColor: config.backgroundColor,
					backgroundImageID: config.backgroundImage.id,
					backgroundImagePosition: config.backgroundImagePosition,
					alignment: config.alignment,
					zoomScrollBehavior: config.zoomScrollBehavior
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function setMobileConfig( projectID, config ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setMobileConfig",
				parameters: {
					id: projectID,
					mobileStatusbarIsVisible: config.mobileStatusbarIsVisible,
					mobileStatusbarIsOpaque: config.mobileStatusbarIsOpaque,
					mobileStatusbarBackgroundColor: config.mobileStatusbarBackgroundColor,
					mobileStatusbarFontColor: config.mobileStatusbarFontColor,
					mobileDeviceID: config.mobileDeviceID
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function setIsMinimizedInTimeline( projectID, isMinimizedInTimeline ) {
			var methodName = ( isMinimizedInTimeline ? "collapseActivity" : "expandActivity" );
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: methodName,
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function setIsHiddenInTimeline( projectID, isHiddenInTimeline ) {
			var methodName = ( isHiddenInTimeline ? "hideActivity" : "showActivity" );
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: methodName,
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function save( parameters ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {
					modelEvents.trigger( "projectCreated", response );
				}
			} );
			return ( promise );
		}

		function transferOwnership( projectID, email ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "transferOwnership",
				parameters: {
					id: projectID,
					email: email
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function setProjectType( projectID, isMobile, mobileDeviceID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setProjectType",
				parameters: {
					id: projectID,
					isMobile: isMobile,
					mobileDeviceID: mobileDeviceID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateSort( projectIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: nonSpecificResource,
				name: "updateSort",
				parameters: {
					projectIDs: projectIDs.join( "," )
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectsSorted", projectIDs );
				}
			} );
			return ( promise );
		}

		function setViewPreference( projectID, showThumbnailView ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setViewPreference",
				parameters: {
					id: projectID,
					thumbnails: showThumbnailView
				}
			} );
			return ( promise );
		}

		function sendRequestPermission( projectIDThatNeedsPermission ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendRequestPermission",
				parameters: {
					id: projectIDThatNeedsPermission
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/project/:id/:command", {
				id: "@id",
				command: "@command"
			}, {
				activateProject: {
					method: "POST",
					params: {
						command: "activate"
					}
				},
				addSampleScreensToProject: {
					method: "POST",
					isArray: true,
					params: {
						command: "add-sample-screens"
					}
				},
				addUserToProject: {
					method: "POST",
					params: {
						command: "add-user"
					}
				},
				addUserToTeamProject: {
					method: "POST",
					params: {
						command: "add-user-team"
					}
				},
				addUsersToProject: {
					method: "POST",
					params: {
						command: "add-users"
					}
				},
				archiveProject: {
					method: "POST",
					params: {
						command: "archive"
					}
				},
				changeUsersOnProject: {
					method: "POST",
					params: {
						command: "change-users"
					}
				},
				changeEnterpriseUsersOnProject: {
					method: "POST",
					params: {
						command: "change-enterprise-users"
					}
				},
				changeInviteesOnProject: {
					method: "POST",
					params: {
						command: "change-invitees"
					}
				},
				collapseActivity: {
					method: "POST",
					params: {
						command: "collapse-activity"
					}
				},
				getSnapProject: {
					method: "GET",
					params: {
						id: 0,
						command: "snap-project"
					}
				},
				hideActivity: {
					method: "POST",
					params: {
						command: "hide-activity"
					}
				},
				showActivity: {
					method: "POST",
					params: {
						command: "show-activity"
					}
				},
				deleteProject: {
					method: "DELETE"
				},
				duplicateProject: {
					method: "POST",
					params: {
						command: "duplicate"
					}
				},
				expandActivity: {
					method: "POST",
					params: {
						command: "expand-activity"
					}
				},
				exportPDF: {
					method: "POST",
					params: {
						command: "export-pdf"
					}
				},
				getByID: {
					method: "GET"
				},
				getMembers: {
					method: "GET",
					isArray: true,
					params: {
						command: "members"
					}
				},
				getStakeholders: {
					method: "GET",
					isArray: true,
					params: {
						command: "stakeholders"
					}
				},
				removeStakeholder: {
					method: "POST",
					params: {
						command: "remove-stakeholder"
					}
				},
				removeUserFromProject: {
					method: "POST",
					params: {
						command: "remove-user"
					}
				},
				renameProject: {
					method: "POST",
					params: {
						command: "rename"
					}
				},
				setConfigDefaults: {
					method: "POST",
					params: {
						command: "set-config-defaults"
					}
				},
				save: {
					method: "POST"
				},
				transferOwnership: {
					method: "POST",
					params: {
						command: "transfer-ownership"
					}
				},
				setProjectType: {
					method: "POST",
					params: {
						command: "setProjectType"
					}
				},
				setMobileConfig: {
					method: "POST",
					params: {
						command: "setMobileConfig"
					}
				},
				setViewPreference: {
					method: "POST",
					params: {
						command: "setViewPreference"
					}
				},
				sendRequestPermission: {
					method: "POST",
					params: {
						command: "sendRequestPermission"
					}
				}
			}
		);
		var nonSpecificResource = $resource(
			"/api/project/:command", {
				command: "@command"
			}, {
				updateSort: {
					method: "POST",
					isArray: true,
					params: {
						command: "update-sort"
					}
				}
			}
		);
		return ( {
			activateProject: activateProject,
			addSampleScreensToProject: addSampleScreensToProject,
			addUsersToProject: addUsersToProject,
			addUserToProject: addUserToProject,
			addUserToTeamProject: addUserToTeamProject,
			archiveProject: archiveProject,
			changeUsersOnProject: changeUsersOnProject,
			changeEnterpriseUsersOnProject: changeEnterpriseUsersOnProject,
			changeInviteesOnProject: changeInviteesOnProject,
			deleteProject: deleteProject,
			duplicateProject: duplicateProject,
			exportPDF: exportPDF,
			getByID: getByID,
			getMembers: getMembers,
			getSnapProject: getSnapProject,
			getStakeholders: getStakeholders,
			removeStakeholderFromProject: removeStakeholderFromProject,
			removeUserFromProject: removeUserFromProject,
			renameProject: renameProject,
			setConfigDefaults: setConfigDefaults,
			setIsMinimizedInTimeline: setIsMinimizedInTimeline,
			setIsHiddenInTimeline: setIsHiddenInTimeline,
			save: save,
			transferOwnership: transferOwnership,
			setProjectType: setProjectType,
			setMobileConfig: setMobileConfig,
			updateSort: updateSort,
			setViewPreference: setViewPreference,
			sendRequestPermission: sendRequestPermission
		} );
	}
} )( angular, InVision );;;
/*! pusher.js */
;;
( function ( ng, app ) {
	"use strict";
	app.value( "Pusher", Pusher );
} )( angular, InVision );;;
/*! release-notification-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "releaseNotificationService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function getReleaseNotifications() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getReleaseNotifications"
			} );
			return ( promise );
		}

		function getReleaseNotificationsWithoutContent() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getReleaseNotificationsWithoutContent"
			} );
			return ( promise );
		}

		function getLatestReleaseNotification() {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getLatestReleaseNotification"
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/release-notification/:modifier", {
				modifier: "@modifier"
			}, {
				getReleaseNotifications: {
					method: "GET",
					isArray: true
				},
				getLatestReleaseNotification: {
					method: "GET",
					isArray: false,
					params: {
						modifier: "latest"
					}
				},
				getReleaseNotificationsWithoutContent: {
					method: "GET",
					isArray: true,
					params: {
						modifier: "noContent"
					}
				}
			}
		);
		return ( {
			getReleaseNotifications: getReleaseNotifications,
			getLatestReleaseNotification: getLatestReleaseNotification,
			getReleaseNotificationsWithoutContent: getReleaseNotificationsWithoutContent
		} );
	}
} )( angular, InVision );;;
/*! render-context.js */
;;
( function ( ng, app ) {
	"use strict";
	app.value( "RenderContext", RenderContext );

	function RenderContext( requestContext, actionPrefix, paramNames ) {
		this._requestContext = requestContext;
		this._actionPrefix = actionPrefix;
		this._paramNames = paramNames;
		return ( this );
	}
	RenderContext.prototype = {
		getNextSection: function () {
			return (
				this._requestContext.getNextSection( this._actionPrefix )
			);
		},
		isChangeLocal: function () {
			return (
				this._requestContext.startsWith( this._actionPrefix )
			);
		},
		isChangeRelevant: function () {
			if ( !this._requestContext.startsWith( this._actionPrefix ) ) {
				return ( false );
			}
			if ( this._requestContext.hasActionChanged() ) {
				return ( true );
			}
			return (
				this._paramNames.length &&
				this._requestContext.haveParamsChanged( this._paramNames )
			);
		}
	};
} )( angular, InVision );;;
/*! request-context.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "requestContext", RequestContext );
	/** @ngInject */
	function RequestContext( RenderContext ) {
		this.RenderContext = RenderContext;
		this._action = "";
		this._sections = [];
		this._params = {};
		this._previousAction = "";
		this._previousParams = {};
		return ( this );
	}
	RequestContext.prototype = {
		getAction: function () {
			return ( this._action );
		},
		getNextSection: function ( prefix ) {
			if ( !this.startsWith( prefix ) ) {
				return ( null );
			}
			if ( prefix === "" ) {
				return ( this._sections[ 0 ] );
			}
			var depth = prefix.split( "." ).length;
			if ( depth === this._sections.length ) {
				return ( null );
			}
			return ( this._sections[ depth ] );
		},
		getParam: function ( name ) {
			return ( this._params[ name ] || null );
		},
		getParamAsInt: function ( name, defaultValue ) {
			var valueAsInt = parseInt( this.getParam( name ) );
			if ( isNaN( valueAsInt ) ) {
				return ( defaultValue || 0 );
			} else {
				return ( valueAsInt );
			}
		},
		getRenderContext: function ( requestActionLocation, paramNames ) {
			requestActionLocation = ( requestActionLocation || "" );
			paramNames = ( paramNames || [] );
			if ( !ng.isArray( paramNames ) ) {
				paramNames = [ paramNames ];
			}
			return (
				new this.RenderContext( this, requestActionLocation, paramNames )
			);
		},
		hasActionChanged: function () {
			return ( this._action !== this._previousAction );
		},
		hasParamChanged: function ( paramName, paramValue ) {
			if ( !ng.isUndefined( paramValue ) ) {
				return ( !this.isParam( paramName, paramValue ) );
			}
			if ( !( paramName in this._previousParams ) &&
				( paramName in this._params )
			) {
				return ( true );
			} else if (
				( paramName in this._previousParams ) &&
				!( paramName in this._params )
			) {
				return ( true );
			}
			return ( this._previousParams[ paramName ] !== this._params[ paramName ] );
		},
		haveParamsChanged: function ( paramNames ) {
			for ( var i = 0, length = paramNames.length; i < length; i++ ) {
				if ( this.hasParamChanged( paramNames[ i ] ) ) {
					return ( true );
				}
			}
			return ( false );
		},
		isParam: function ( paramName, paramValue ) {
			if (
				( paramName in this._params ) &&
				( this._params[ paramName ] == paramValue )
			) {
				return ( true );
			}
			return ( false );
		},
		setContext: function ( action, routeParams ) {
			this._previousAction = this._action;
			this._previousParams = this._params;
			this._action = action;
			this._sections = action.split( "." );
			this._params = ng.copy( routeParams );
		},
		startsWith: function ( prefix ) {
			if ( !prefix.length ||
				( this._action === prefix ) ||
				( this._action.indexOf( prefix + "." ) === 0 )
			) {
				return ( true );
			}
			return ( false );
		}
	};
} )( angular, InVision );;;
/*! screen-divider-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "screenDividerService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function createScreenDivider( projectID, label, screenPosition, sort, displayObjectsPosition ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "createScreenDivider",
				parameters: {
					projectID: projectID,
					label: label,
					position: screenPosition,
					sort: sort
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "dividerCreated", response, displayObjectsPosition );
				}
			} );
			return ( promise );
		}

		function deleteScreenDivider( projectID, dividerID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteScreenDivider",
				parameters: {
					projectID: projectID,
					dividerID: dividerID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "dividerDeleted", dividerID );
				}
			} );
			return ( promise );
		}

		function getByProjectID( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getByProjectID",
				parameters: {
					projectID: projectID
				}
			} );
			return ( promise );
		}

		function updateScreenDivider( projectID, dividerID, label, expanded ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateScreenDivider",
				parameters: {
					projectID: projectID,
					dividerID: dividerID,
					label: label,
					expanded: expanded
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "dividerUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateScreenDividerPositions( projectID, dividers ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateScreenDividerPositions",
				parameters: {
					projectID: projectID,
					dividers: dividers
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "dividerPositionsUpdated", response );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/screen-divider/:docCommand", {
				docCommand: "@docCommand"
			}, {
				createScreenDivider: {
					method: "POST",
					params: {
						docCommand: "create"
					}
				},
				deleteScreenDivider: {
					method: "POST",
					params: {
						docCommand: "delete"
					}
				},
				getByProjectID: {
					method: "GET"
				},
				updateScreenDivider: {
					method: "POST",
					params: {
						docCommand: "update"
					}
				},
				updateScreenDividerPositions: {
					method: "POST",
					params: {
						docCommand: "update-divider-positions"
					}
				}
			}
		);
		return ( {
			createScreenDivider: createScreenDivider,
			deleteScreenDivider: deleteScreenDivider,
			getByProjectID: getByProjectID,
			updateScreenDivider: updateScreenDivider,
			updateScreenDividerPositions: updateScreenDividerPositions
		} );
	}
} )( angular, InVision );;;
/*! screen-history-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "screenHistoryService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function get( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					screenID: screenID
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function createShare( screenID, version ) {
			var promise = serviceHelper.executeRequest( {
				resource: shareResource,
				name: "create",
				parameters: {
					screenID: screenID,
					version: version
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/screen-versions/:screenID/:command", {
				screenID: "@screenID",
				command: "@command"
			}, {
				get: {
					method: "GET"
				}
			}
		);
		var shareResource = $resource(
			"/api/screen-versions/share", {
				screenID: "@screenID",
				version: "@version"
			}, {
				create: {
					method: "POST"
				}
			}
		);
		return ( {
			get: get,
			createShare: createShare
		} );
	}
} )( angular, InVision );;;
/*! screen-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "screenService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function activateScreen( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "activateScreen",
				parameters: {
					id: screenID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenUpdated", response );
					modelEvents.trigger( "screenActivated", response );
				}
			} );
			return ( promise );
		}

		function archiveScreen( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "archiveScreen",
				parameters: {
					id: screenID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenUpdated", response );
					modelEvents.trigger( "screenArchived", response );
				}
			} );
			return ( promise );
		}

		function archiveScreens( screenIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "archiveScreens",
				parameters: {
					screenIDs: screenIDs
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function copyScreensToProject( screenIDs, toProjectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "copyScreensToProject",
				parameters: {
					screenIDs: screenIDs,
					toProjectID: toProjectID
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function deleteScreen( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteScreen",
				parameters: {
					id: screenID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenDeleted", screenID );
				}
			} );
			return ( promise );
		}

		function deleteScreens( screenIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteScreens",
				parameters: {
					screenIDs: screenIDs
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function duplicateScreen( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicateScreen",
				parameters: {
					id: screenID
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function duplicateScreens( screenIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicateScreens",
				parameters: {
					screenIDs: screenIDs
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function getByID( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getByID",
				parameters: {
					id: id
				}
			} );
			return ( promise );
		}

		function getProcessingStatus( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getProcessingStatus",
				parameters: {
					projectID: projectID
				}
			} );
			return ( promise );
		}

		function markScreenAsRead( screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "markScreenAsRead",
				parameters: {
					id: screenID
				}
			} );
			return ( promise );
		}

		function renameScreen( screenID, name ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "renameScreen",
				parameters: {
					id: screenID,
					name: name
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenUpdated", response );
				}
			} );
			return ( promise );
		}

		function saveConfig( screen ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "saveConfig",
				parameters: screen
			} );
			return ( promise );
		}

		function sendWorkflowStatusNotification( screenID, userIDList ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendWorkflowStatusNotification",
				parameters: {
					id: screenID,
					userIDList: userIDList
				}
			} );
			return ( promise );
		}

		function setWorkflowStatus( screenID, workflowStatusID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setWorkflowStatus",
				parameters: {
					id: screenID,
					workflowStatusID: workflowStatusID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenUpdated", response );
				}
			} );
			return ( promise );
		}

		function setWorkflowStatuses( screenIDs, workflowStatusID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setWorkflowStatuses",
				parameters: {
					screenIDs: screenIDs,
					workflowStatusID: workflowStatusID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "screenUpdated", response );
				}
			} );
			return ( promise );
		}

		function updateSort( projectID, screenIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateSort",
				parameters: {
					projectID: projectID,
					screenIDs: screenIDs.join( "," )
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "projectScreensSorted", projectID, screenIDs );
				}
			} );
			return ( promise );
		}

		function setFixedHeaderHeight( screen ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setFixedHeaderHeight",
				parameters: {
					screenID: screen.id,
					fixedHeaderHeight: screen.fixedHeaderHeight
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function setFixedFooterHeight( screen ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setFixedFooterHeight",
				parameters: {
					screenID: screen.id,
					fixedFooterHeight: screen.fixedFooterHeight
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function moveScreensToProject( screenIDs, toProjectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "moveScreensToProject",
				parameters: {
					screenIDs: screenIDs,
					toProjectID: toProjectID
				},
				successCallback: function ( response ) { // added to let snaps know to update the view when a snap is moved
					modelEvents.trigger( "screenDeleted", screenIDs );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/screens/:listCommand:id/:docCommand", {
				id: "@id",
				listCommand: "@listCommand",
				docCommand: "@docCommand"
			}, {
				activateScreen: {
					method: "POST",
					params: {
						docCommand: "activate"
					}
				},
				archiveScreen: {
					method: "POST",
					params: {
						docCommand: "archive"
					}
				},
				archiveScreens: {
					method: "POST",
					isArray: true,
					params: {
						listCommand: "archive"
					}
				},
				copyScreensToProject: {
					method: "POST",
					params: {
						listCommand: "copy"
					}
				},
				deleteScreen: {
					method: "DELETE"
				},
				deleteScreens: {
					method: "POST",
					params: {
						listCommand: "delete"
					}
				},
				duplicateScreen: {
					method: "POST",
					params: {
						docCommand: "duplicate"
					}
				},
				duplicateScreens: {
					method: "POST",
					isArray: true,
					params: {
						docCommand: "duplicate"
					}
				},
				getByID: {
					method: "GET"
				},
				getProcessingStatus: {
					method: "GET",
					params: {
						listCommand: "processing-status"
					}
				},
				markScreenAsRead: {
					method: "POST",
					params: {
						docCommand: "mark-as-read"
					}
				},
				renameScreen: {
					method: "POST",
					params: {
						docCommand: "rename"
					}
				},
				saveConfig: {
					method: "POST",
					params: {
						docCommand: "config"
					}
				},
				sendWorkflowStatusNotification: {
					method: "POST",
					params: {
						docCommand: "send-workflow-status-notification"
					}
				},
				setWorkflowStatus: {
					method: "POST",
					params: {
						docCommand: "set-workflow-status"
					}
				},
				setWorkflowStatuses: {
					method: "POST",
					isArray: true,
					params: {
						docCommand: "set-workflow-status"
					}
				},
				updateSort: {
					method: "POST",
					isArray: true,
					params: {
						listCommand: "update-sort"
					}
				},
				setFixedHeaderHeight: {
					method: "POST",
					params: {
						listCommand: "setFixedHeaderHeight"
					}
				},
				setFixedFooterHeight: {
					method: "POST",
					params: {
						listCommand: "setFixedFooterHeight"
					}
				},
				moveScreensToProject: {
					method: "POST",
					params: {
						listCommand: "move"
					}
				}
			}
		);
		var workflowStatus = {
			IN_PROGRESS: 1,
			COMPLETE: 2,
			COMPLETE_AND_APPROVED: 3
		};
		var zoomScrollBehaviors = {
			NORMAL: 1,
			DISABLE_HORIZONTAL_SCROLLING: 2,
			ZOOM_OUT_TO_BROWSER_WIDTH: 3
		};
		return ( {
			activateScreen: activateScreen,
			archiveScreen: archiveScreen,
			archiveScreens: archiveScreens,
			copyScreensToProject: copyScreensToProject,
			deleteScreen: deleteScreen,
			deleteScreens: deleteScreens,
			duplicateScreen: duplicateScreen,
			duplicateScreens: duplicateScreens,
			getByID: getByID,
			getProcessingStatus: getProcessingStatus,
			markScreenAsRead: markScreenAsRead,
			renameScreen: renameScreen,
			saveConfig: saveConfig,
			sendWorkflowStatusNotification: sendWorkflowStatusNotification,
			setWorkflowStatus: setWorkflowStatus,
			setWorkflowStatuses: setWorkflowStatuses,
			updateSort: updateSort,
			workflowStatus: workflowStatus,
			setFixedHeaderHeight: setFixedHeaderHeight,
			setFixedFooterHeight: setFixedFooterHeight,
			moveScreensToProject: moveScreensToProject,
			zoomScrollBehaviors: zoomScrollBehaviors
		} );
	}
} )( angular, InVision );;;
/*! service-helper.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "serviceHelper", ServiceHelper );
	/** @ngInject */
	function ServiceHelper( Deferred ) {
		function executeRequest( options ) {
			var resource = options.resource;
			var name = options.name;
			var parameters = ( options.parameters || {} );
			var successCallback = ( options.successCallback || ng.noop );
			var errorCallback = ( options.errorCallback || ng.noop );
			var deferred = new Deferred();
			var resourceResponse = resource[ name ](
				parameters,
				function ( response ) {
					successCallback( response );
					deferred.resolve( response );
				},
				function ( response ) {
					errorCallback( response );
					deferred.reject(
						unwrapErrorMessage( response )
					);
				}
			);
			return ( deferred.promise );
		}

		function unwrapErrorMessage( errorResponse ) {
			try {
				var response = ng.fromJson( errorResponse.data );
				if ( ng.isString( response ) ) {
					response = {
						message: response,
						code: -1,
						id: -1
					};
				}
			} catch ( error ) {
				var response = {
					message: errorResponse.data,
					code: -1,
					id: -1
				};
			}
			return ( response );
		}
		return ( {
			executeRequest: executeRequest
		} );
	}
} )( angular, InVision );;;
/*! session-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "sessionService", SessionService );
	/** @ngInject */
	function SessionService( $q, $resource, serviceHelper, userService, _ ) {
		function authenticate() {
			var deferred = $q.defer();
			resource.get( {},
				function ( response ) {
					ng.extend( user, response.account );
					ng.extend( subscription, response.subscription );
					user.initials = userService.getInitials( user.name );
					user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
					user.isSyncEnabled = response.sync.enabled;
					user.syncClients = response.sync.clients;
					deferred.resolve( response );
				},
				function () {
					deferred.reject();
				}
			);
			return ( deferred.promise );
		}

		function get( key, defaultValue ) {
			var localKey = getDataKey( key );
			if ( data.hasOwnProperty( localKey ) ) {
				return ( data[ localKey ] );
			} else if ( !ng.isUndefined( defaultValue ) ) {
				data[ localKey ] = defaultValue;
				return ( defaultValue );
			}
		}

		function getDataKey( key ) {
			return ( "session__" + key );
		}

		function isAuthenticated() {
			return ( user.isAccountAuthenticated );
		}

		function set( key, value ) {
			var localKey = getDataKey( key );
			data[ localKey ] = value;
		}

		function update() {
			resource.get( {},
				function ( response ) {
					ng.extend( user, response.account );
					ng.extend( subscription, response.subscription );
					user.initials = userService.getInitials( user.name );
					user.hasSystemAvatar = userService.isSystemAvatar( user.avatarID );
				}
			);
		}
		var resource = $resource(
			"/api/account", {}, {
				getUser: {
					method: "GET"
				}
			}
		);
		var user = {
			id: 0,
			name: "",
			initials: "",
			hasSystemAvatar: true,
			email: "",
			isAccountAuthenticated: false
		};
		var subscription = {};
		var data = {};
		return ( {
			authenticate: authenticate,
			get: get,
			isAuthenticated: isAuthenticated,
			set: set,
			update: update,
			subscription: subscription,
			user: user
		} );
	}
} )( angular, InVision );;;
/*! share-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "shareService", ShareService );
	/** @ngInject */
	function ShareService( $resource, serviceHelper, modelEvents ) {
		function createShare(
			projectID,
			screenID,
			isCommentingAllowed,
			isNavigateAllowed,
			isResizeWindow,
			isLoadAllScreens,
			isUserTesting,
			isAnonymousViewingAllowed,
			isForceAddToHomescreenOnMobile,
			password,
			forceNew,
			isEmbed,
			selectedScreens
		) {
			if ( typeof ( forceNew ) === 'undefined' ) {
				forceNew = false;
			}
			selectedScreens = selectedScreens || [];
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "createShare",
				parameters: {
					projectID: projectID,
					screenID: screenID,
					isCommentingAllowed: isCommentingAllowed,
					isNavigateAllowed: isNavigateAllowed,
					isResizeWindow: isResizeWindow,
					isLoadAllScreens: isLoadAllScreens,
					isUserTesting: isUserTesting,
					isAnonymousViewingAllowed: isAnonymousViewingAllowed,
					isForceAddToHomescreenOnMobile: isForceAddToHomescreenOnMobile,
					password: password,
					forceNew: forceNew,
					isEmbed: isEmbed,
					selectedScreens: selectedScreens
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "shareCreated", response );
				}
			} );
			return ( promise );
		}

		function revokeAllShares( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "revokeAllShares",
				parameters: {
					projectID: projectID
				}
			} );
			return ( promise );
		}

		function revokeShare( shareID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "revokeShare",
				parameters: {
					id: shareID
				}
			} );
			return ( promise );
		}

		function sendEmail( shareID, emailList, message ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendEmail",
				parameters: {
					id: shareID,
					emailList: emailList,
					message: message
				}
			} );
			return ( promise );
		}

		function sendSMS( shareID, phoneNumber ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendSMS",
				parameters: {
					id: shareID,
					phoneNumber: phoneNumber
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/share/:listCommand:id/:docCommand", {
				id: "@id",
				listCommand: "@listCommand",
				docCommand: "@docCommand"
			}, {
				createShare: {
					method: "POST"
				},
				revokeAllShares: {
					method: "POST",
					params: {
						listCommand: "revoke-all"
					}
				},
				revokeShare: {
					method: "DELETE"
				},
				sendEmail: {
					method: "POST",
					params: {
						docCommand: "send-email"
					}
				},
				sendSMS: {
					method: "POST",
					params: {
						docCommand: "send-sms"
					}
				}
			}
		);
		return ( {
			createShare: createShare,
			revokeAllShares: revokeAllShares,
			revokeShare: revokeShare,
			sendEmail: sendEmail,
			sendSMS: sendSMS
		} );
	}
} )( angular, InVision );;;
/*! stack-trace-service.js */
;;
( function ( ng, app, printStackTrace ) {
	"use strict";
	app.factory( "stackTraceService", Factory );
	/** @ngInject */
	function Factory() {
		return ( {
			print: printStackTrace
		} );
	}
} )( angular, InVision, printStackTrace );;;
/*! subscription-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "subscriptionService", Service );
	/** @ngInject */
	function Service( _, $resource, partialHelper, PartialCache, modelEvents, sessionService ) {
		function getAllPlans() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getAllPlans",
				cachedResponse: cache.getResponse( "allPlans" ),
				successCallback: function ( response ) {
					cache.setResponse( "allPlans", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "allPlans" );
				}
			} );
			return ( promise );
		}

		function getCurrentPlan() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getCurrentPlan",
				cachedResponse: cache.getResponse( "currentPlan" ),
				successCallback: function ( response ) {
					cache.setResponse( "currentPlan", response );
				},
				errorCallback: function () {
					cache.deleteResponse( "currentPlan" );
				}
			} );
			return ( promise );
		}

		function changePlan( plan, coupon, customPriceFlag, projectIdsToDelete ) {
			var coupon = coupon || "";
			var projectIdsToDelete = projectIdsToDelete || [];
			var creationParams = {
				planId: plan.id,
				coupon: coupon,
				projectIdsToDelete: projectIdsToDelete
			};
			if ( !_.isUndefined( customPriceFlag ) && customPriceFlag ) {
				creationParams.price = plan.price;
			}
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "changePlan",
				parameters: creationParams,
				successCallback: function ( response ) {
					cache.setResponse( "currentPlan", response );
					modelEvents.trigger( "subscriptionChanged", response );
					modelEvents.trigger( "projectUpdated", response );
					sessionService.update();
				},
				errorCallback: function ( response ) {
					modelEvents.trigger( "subscriptionUpdateError", response );
					sessionService.update();
				}
			} );
			return ( promise );
		}

		function pauseUserAccount( pausePlanID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "pauseUserAccount",
				parameters: {
					planID: pausePlanID
				},
				successCallback: function ( response ) {
					cache.setResponse( "currentPlan", response );
					modelEvents.trigger( "subscriptionChanged", response );
					modelEvents.trigger( "projectUpdated", response );
					sessionService.update();
				},
				errorCallback: function () {
					modelEvents.trigger( "subscriptionUpdateError", response );
					sessionService.update();
				}
			} );
			return ( promise );
		}

		function deleteUserAccount( currentSubscriptionID, rating, cancelComments, otherSoftware ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "deleteUserAccount",
				parameters: {
					currentSubscriptionID: currentSubscriptionID,
					rating: rating,
					cancelComments: cancelComments,
					otherSoftware: otherSoftware
				},
				successCallback: function ( response ) {
					cache.setResponse( "currentPlan", response );
					modelEvents.trigger( "subscriptionChanged", response );
					modelEvents.trigger( "teamMemberUpdated", response );
					sessionService.update();
				},
				errorCallback: function () {
					modelEvents.trigger( "subscriptionUpdateError", response );
					sessionService.update();
				}
			} );
			return ( promise );
		}
		var cache = new PartialCache( "subscriptionService" );
		var resource = $resource(
			"/api/:rootObject/:command", {
				command: "@command",
				rootObject: "@rootObject"
			}, {
				getAllPlans: {
					method: "GET",
					isArray: true,
					params: {
						command: "",
						rootObject: "plans"
					}
				},
				getCurrentPlan: {
					method: "GET",
					isArray: false,
					params: {
						rootObject: "billing",
						command: "get-current-plan"
					}
				},
				changePlan: {
					method: "POST",
					isArray: false,
					params: {
						command: "",
						rootObject: "subscriptions"
					}
				},
				pauseUserAccount: {
					method: "POST",
					isArray: false,
					params: {
						command: "pause-user-account",
						rootObject: "subscriptions"
					}
				},
				deleteUserAccount: {
					method: "POST",
					isArray: false,
					params: {
						command: "delete-user-account",
						rootObject: "subscriptions"
					}
				}
			}
		);
		return ( {
			getAllPlans: getAllPlans,
			getCurrentPlan: getCurrentPlan,
			changePlan: changePlan,
			pauseUserAccount: pauseUserAccount,
			deleteUserAccount: deleteUserAccount
		} );
	};
} )( angular, InVision );;;
/*! team-invitation-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamInvitationService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents ) {
		function cancel( id, leadUserID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "cancel",
				parameters: {
					id: id
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "teamInvitationDeleted", id, leadUserID );
				}
			} );
			return ( promise );
		}

		function resend( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "resend",
				parameters: {
					id: id
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "teamInvitationResent", response );
				}
			} );
			return ( promise );
		}

		function send(
			memberEmail,
			messageFromUser,
			canCreateProjectsForLead,
			initialProjectMembershipList
		) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "send",
				parameters: {
					memberEmail: memberEmail,
					messageFromUser: messageFromUser,
					canCreateProjectsForLead: canCreateProjectsForLead,
					initialProjectMembershipList: initialProjectMembershipList
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "teamInvitationCreated", response );
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/team-invitation/:id/:command", {
				id: "@id",
				command: "@command"
			}, {
				cancel: {
					method: "DELETE"
				},
				resend: {
					method: "POST",
					params: {
						command: "resend"
					}
				},
				send: {
					method: "POST",
					isArray: true
				}
			}
		);
		return ( {
			cancel: cancel,
			resend: resend,
			send: send
		} );
	}
} )( angular, InVision );;;
/*! team-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamService", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents, _ ) {
		function grantAdminStatus( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "grantAdminStatus",
				parameters: {
					id: id
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "teamMemberUpdated", response );
				}
			} );
			return ( promise );
		};

		function remove( id ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "remove",
				parameters: {
					id: id
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "teamMemberDeleted", id );
				}
			} );
			return ( promise );
		};

		function revokeAdminStatus( id, leadUserID ) {
			var parameters = {
				id: id
			};
			if ( !_.isUndefined( leadUserID ) ) {
				parameters.leadUserID = leadUserID;
			}
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "revokeAdminStatus",
				parameters: parameters,
				successCallback: function ( response ) {
					if ( !_.isUndefined( parameters.leadUserID ) ) {
						modelEvents.trigger( "teamMemberRemovedFromTeam", response, leadUserID );
					}
					modelEvents.trigger( "teamMemberUpdated", response );
				}
			} );
			return ( promise );
		};

		function setAdminStatus( id, isAdmin ) {
			if ( isAdmin ) {
				return ( grantAdminStatus( id ) );
			} else {
				return ( revokeAdminStatus( id ) );
			}
		};

		function setProjectVisibility( areProjectsVisibleToTeam ) {
			var promise = serviceHelper.executeRequest( {
				resource: commandOnlyResource,
				name: "updateProjectVisibility",
				parameters: {
					canTeamViewAllProjects: areProjectsVisibleToTeam
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		};

		function changeTeamMembers( teamAccountID, addUserIDs, removeUserIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: commandOnlyResource,
				name: "changeTeamMembers",
				parameters: {
					teamAccountID: teamAccountID,
					addUserIDs: addUserIDs.join( "," ),
					removeUserIDs: removeUserIDs.join( "," )
				},
				successCallback: function ( response ) {
					if ( addUserIDs.length ) {
						modelEvents.trigger( "teamMemberUpdated.teamList", teamAccountID, addUserIDs );
					}
					if ( removeUserIDs.length ) {
						modelEvents.trigger( "teamMemberUpdated.teamList", teamAccountID, removeUserIDs );
					}
				}
			} );
			return ( promise );
		};

		function changeInviteesOnTeam( teamAccountID, addInviteeIDs, removeInviteeIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: commandOnlyResource,
				name: "changeInviteesOnTeam",
				parameters: {
					teamAccountID: teamAccountID,
					addInviteeIDs: addInviteeIDs.join( "," ),
					removeInviteeIDs: removeInviteeIDs.join( "," )
				},
				successCallback: function ( response ) {
					if ( addInviteeIDs.length ) {
						modelEvents.trigger( "teamMemberUpdated.teamList", teamAccountID, addInviteeIDs );
					}
					if ( removeInviteeIDs.length ) {
						modelEvents.trigger( "teamMemberUpdated.teamList", teamAccountID, removeInviteeIDs );
					}
				}
			} );
			return ( promise );
		};

		function removeTeamConnectionInvitees( removeInviteeIDs ) {
			var promise = serviceHelper.executeRequest( {
				resource: commandOnlyResource,
				name: "removeTeamConnectionInvitees",
				parameters: {
					removeConnectionInviteeIDs: removeInviteeIDs.join( "," )
				},
				successCallback: function ( response ) {
					if ( removeInviteeIDs.length ) {
						modelEvents.trigger( "teamMemberUpdated.teamList", removeInviteeIDs );
					}
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/team/:id/:command", {
				id: "@id",
				command: "@command"
			}, {
				grantAdminStatus: {
					method: "POST",
					params: {
						command: "grant-admin-status"
					}
				},
				remove: {
					method: "DELETE"
				},
				revokeAdminStatus: {
					method: "POST",
					params: {
						command: "revoke-admin-status"
					}
				}
			}
		);
		var commandOnlyResource = $resource(
			"/api/team/:command", {
				command: "@command"
			}, {
				updateProjectVisibility: {
					method: "POST",
					params: {
						command: "update-project-visibility"
					}
				},
				changeTeamMembers: {
					method: "POST",
					params: {
						command: "change-team-members"
					}
				},
				changeInviteesOnTeam: {
					method: "POST",
					params: {
						command: "change-team-invitees"
					}
				},
				removeTeamConnectionInvitees: {
					method: "POST",
					params: {
						command: "remove-team-connection-invitees"
					}
				}
			}
		);
		return ( {
			grantAdminStatus: grantAdminStatus,
			remove: remove,
			revokeAdminStatus: revokeAdminStatus,
			setAdminStatus: setAdminStatus,
			setProjectVisibility: setProjectVisibility,
			changeTeamMembers: changeTeamMembers,
			changeInviteesOnTeam: changeInviteesOnTeam,
			removeTeamConnectionInvitees: removeTeamConnectionInvitees
		} );
	}
} )( angular, InVision );;;
/*! template-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "templateService", TemplateService );
	/** @ngInject */
	function TemplateService( _, $resource, serviceHelper, modelEvents ) {
		function getByProjectID( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "query",
				parameters: {
					projectID: projectID
				},
				successCallback: function ( conversations ) {}
			} );
			return promise;
		}

		function saveTemplate( template ) {
			var parameters = _.pick( template, "id", "projectID", "name" );
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {
					template.id = response.id;
				}
			} );
			return promise;
		}

		function deleteTemplate( template ) {
			var parameters = _.pick( template, "id" );
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "delete",
				parameters: parameters,
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function addScreen( templateID, screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addScreen",
				parameters: {
					id: templateID,
					screenID: screenID
				},
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function duplicateTemplate( templateID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicateTemplate",
				parameters: {
					id: templateID
				},
				successCallback: function ( response ) {}
			} );
			return promise;
		}

		function removeScreen( templateID, screenID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "removeScreen",
				parameters: {
					id: templateID,
					screenID: screenID
				},
				successCallback: function ( response ) {}
			} );
			return promise;
		}
		var resource = $resource(
			"/api/templates/:id/:command/:screenID", {
				id: "@id",
				command: "@command",
				screenID: "@screenID"
			}, {
				addScreen: {
					method: "POST",
					params: {
						command: "screens"
					}
				},
				duplicateTemplate: {
					method: "POST",
					params: {
						command: "duplicate"
					}
				},
				removeScreen: {
					method: "DELETE",
					params: {
						command: "screens"
					}
				}
			}
		);
		return {
			getByProjectID: getByProjectID,
			saveTemplate: saveTemplate,
			deleteTemplate: deleteTemplate,
			duplicateTemplate: duplicateTemplate,
			addScreen: addScreen,
			removeScreen: removeScreen
		};
	}
} )( angular, InVision );;;
/*! testing-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "testingService", Factory );
	/** @ngInject */
	function Factory( $rootScope, $resource, serviceHelper, Deferred, projectTestingPartial, modelEvents, _ ) {
		var service = {
			data: {}
		};
		service.default = {
			projectID: 0,
			testId: 0,
			mode: "list", // list | create | edit | test | review
			testType: "",
			testTypeId: 0
		};
		service.data = angular.copy( service.default );
		service.reset = function () {
			var projectID = service.data.projectID;
			service.data = angular.extend( angular.copy( service.default ), {
				projectID: projectID
			} );
			$rootScope.$broadcast( "valuesUpdated" );
		};
		service.set = function ( obj, triggerChange ) {
			var targetModes = [ "edit", "view" ],
				otherModes = [ "list" ];
			triggerChange = ( triggerChange != undefined ) ? triggerChange : false;
			angular.extend( service.data, obj );
			if ( service.data.participantCount != undefined && service.data.participantCount > 0 ) {
				service.data.mode = "view";
			}
			if ( triggerChange ) {
				$rootScope.$broadcast( "valuesUpdated" );
			} else {
				return service.data;
			}
		};
		service.setById = function ( id, type, action ) {
			var projectID = service.data.projectID;
			var add = {
				mode: action
			};
			Deferred.handlePromise(
				projectTestingPartial.getTest( id, type ),
				function ( response ) {
					var test = response.test;
					if ( test.projectID == 0 && projectID != 0 ) { // to keep current projectID on new records
						add.projectID = projectID;
					}
					angular.extend( service.data, test, add );
					$rootScope.$broadcast( "setById" );
				},
				function ( response ) {
					$rootScope.openModalWindow( "error", "For some reason we couldn't load your User Tests. Try refreshing your browser." );
				}
			);
		};
		service.getTestData = function () {
			return service.data;
		};
		return service;
	}
} )( angular, InVision );;;
/*! user-preference-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "userPreferenceService", Service );
	/** @ngInject */
	function Service( _, serviceHelper, $resource, modelEvents, $q, config ) {
		function cacheType( name, response ) {
			cachedTypes[ name.toLowerCase() ] = response;
		}

		function cacheValue( id, response ) {
			cachedValues[ id ] = response;
		}

		function getCachedType( name ) {
			return ( cachedTypes[ name.toLowerCase() ] );
		}

		function getCachedTypeResolution( name ) {
			var deferred = $q.defer();
			var promise = deferred.promise;
			deferred.resolve( getCachedType( name.toLowerCase() ) );
			return ( promise );
		}

		function getCachedValue( id ) {
			return ( cachedValues[ id ] );
		}

		function getCachedValueResolution( id ) {
			var deferred = $q.defer();
			var promise = deferred.promise;
			deferred.resolve( getCachedValue( id ) );
			return ( promise );
		}
		/**
		 * I get all the details about a specific user preference by it's name
		 * @param  {string} preferenceName  - name of the preference to lookup
		 * @param  {boolean} doCreate       - create the preference if it doesn't exist?
		 * @param  {string} dataType 		- type of data the new preferenceType is
		 * @param  {string} defaultValue 	- default value of the preference
		 * @return {object}
		 */
		function getPreferenceTypeByName( preferenceName, doCreate, dataType, defaultValue ) {
			if ( isTypeCached( preferenceName ) ) {
				return ( getCachedTypeResolution( preferenceName ) );
			}
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getPreferenceTypeByName",
				parameters: {
					preferenceName: preferenceName,
					doCreate: doCreate,
					dataType: dataType,
					defaultValue: defaultValue
				},
				successCallback: function ( response ) {
					cacheType( preferenceName, response );
				}
			} );
			return ( promise );
		}
		/**
		 * I get a user's preference based by preference id
		 * @param  {int} preferenceId   - ID of the preference to lookup
		 * @return {object}
		 */
		function getUserPreferenceById( preferenceId ) {
			if ( isValueCached( preferenceId ) ) {
				return ( getCachedValueResolution( preferenceId ) );
			}
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getUserPreferenceById",
				parameters: {
					userPreferenceTypeId: preferenceId
				},
				successCallback: function ( response ) {
					if ( !response.data ) {
						response.data = {
							name: "",
							value: null
						};
					}
					cacheValue( preferenceId, response );
				}
			} );
			return ( promise );
		}

		function isTypeCached( name ) {
			return ( name.toLowerCase() in cachedTypes );
		}

		function isValueCached( id ) {
			return ( cachedValues.hasOwnProperty( id ) );
		}
		/**
		 * I set a user's preference
		 * @param {int} preferenceId   - the id of the preferenceType to set
		 * @param {any} value          - the value of that preferenceType
		 */
		function setUserPreferenceById( preferenceId, value ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "setUserPreferenceById",
				parameters: {
					userPreferenceTypeId: preferenceId,
					userPreferenceTypeValue: value
				},
				successCallback: function ( response ) {
					updateCachedValue( preferenceId, value );
				}
			} );
			return ( promise );
		}

		function updateCachedValue( id, value ) {
			if ( isValueCached( id ) ) {
				var cachedValue = getCachedValue( id );
				cachedValue.exists = "true";
				cachedValue.data.value = value;
			}
		}

		function updateTellAFriendTooltipLastViewedAt( dateTimeInMillisecs ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateTellAFriendTooltipLastViewedAt",
				parameters: {
					tellAFriendTooltipLastViewedAt: dateTimeInMillisecs
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "accountUpdated", response );
				}
			} );
			return ( promise );
		}

		function preloadCaches( userPreferences ) {
			_.each( userPreferences, function ( pref ) {
				cacheType( pref.preferencetype, {
					exists: "true",
					data: {
						id: pref.preferencetypeid,
						preferencedatatype: pref.datatype,
						preferencename: pref.preferencetype,
						createdAt: pref.createdAt
					}
				} );
				cacheValue( pref.preferencetypeid, {
					exists: "true",
					data: {
						name: pref.preferencetype,
						value: pref.preferencevalue,
						createdAt: pref.createdAt
					}
				} );
			} );
		}
		var resource = $resource(
			"/api/userPreference/:command", {
				command: "@command"
			}, {
				updateTellAFriendTooltipLastViewedAt: {
					method: "POST",
					params: {
						command: "updateTellAFriendTooltipViewed"
					}
				},
				getPreferenceTypeByName: {
					method: "POST",
					params: {
						command: "getPreferenceTypeByName"
					}
				},
				getUserPreferenceById: {
					method: "POST",
					params: {
						command: "getUserPreferenceById"
					}
				},
				setUserPreferenceById: {
					method: "POST",
					params: {
						command: "setUserPreferenceById"
					}
				}
			}
		);
		var cachedTypes = {};
		var cachedValues = {};
		preloadCaches( config.userPreferences );
		return ( {
			updateTellAFriendTooltipLastViewedAt: _.memoize( updateTellAFriendTooltipLastViewedAt ),
			getPreferenceTypeByName: getPreferenceTypeByName,
			getUserPreferenceById: getUserPreferenceById,
			setUserPreferenceById: setUserPreferenceById
		} );
	}
} )( angular, InVision );;;
/*! user-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "userService", Service );
	/** @ngInject */
	function Service( _ ) {
		function getInitials( name ) {
			if ( !name ) {
				return ( "" );
			}
			var nameParts = name.replace( /^\s+|\s+$/i, "" ).split( /\s+/i );
			var namePartsCount = nameParts.length;
			if ( namePartsCount > 1 ) {
				return (
					nameParts[ 0 ].slice( 0, 1 ) +
					nameParts[ namePartsCount - 1 ].slice( 0, 1 )
				);
			}
			return ( nameParts[ 0 ].slice( 0, 1 ) );
		}

		function getOnlineStatus( lastRequestAt ) {
			var now = ( new Date() ).getTime();
			var onlineCutoff = ( 10 * 60 * 1000 ); // 10 minutes.
			var awayCutoff = ( 30 * 60 * 1000 ); // 30 minutes.
			if ( lastRequestAt > ( now - onlineCutoff ) ) {
				return ( "Online" );
			} else if ( lastRequestAt > ( now - awayCutoff ) ) {
				return ( "Away" );
			}
			return ( "Offline" );
		}

		function getShortName( name ) {
			if ( !name ) {
				return ( "" );
			}
			var nameParts = name.replace( /^\s+|\s+$/i, "" ).split( /\s+/i );
			var namePartsCount = nameParts.length;
			if ( namePartsCount > 1 ) {
				return (
					nameParts[ 0 ] +
					" " +
					nameParts[ namePartsCount - 1 ].slice( 0, 1 ) +
					( ( nameParts[ namePartsCount - 1 ].length > 1 ) ? "." : "" )
				);
			}
			return ( nameParts[ 0 ] );
		}

		function getFirstName( name ) {
			if ( !name ) {
				return ( "" );
			}
			var nameParts = name.replace( /^\s+|\s+$/i, "" ).split( /\s+/i );
			return ( nameParts[ 0 ] );
		}

		function isSystemAvatar( avatarID ) {
			return ( avatarID.indexOf( "00000000" ) === 0 );
		}

		function getNiceUsername( defaultUsername, userID, currentUserID ) {
			return userID === currentUserID ? "me" : defaultUsername;
		}
		var ROLES = {
			ADMIN: 1,
			MANAGER: 2,
			CONTRIBUTOR: 3,
			REVIEWER: 4
		};
		return ( {
			getInitials: _.memoize( getInitials ),
			getOnlineStatus: getOnlineStatus,
			getShortName: _.memoize( getShortName ),
			getFirstName: _.memoize( getFirstName ),
			isSystemAvatar: _.memoize( isSystemAvatar ),
			getNiceUsername: getNiceUsername,
			ROLES: ROLES
		} );
	}
} )( angular, InVision );;;
/*! validation-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "validationService", ValidationService );
	/** @ngInject */
	function ValidationService() {
		this.errorCodes = [ {
			code: 400,
			message: "Invalid request for this resource."
		}, {
			code: 400,
			message: "Invalid request body content."
		}, {
			code: 401,
			message: "The credentials you provided are not valid."
		}, {
			code: 403,
			message: "Forbidden."
		}, {
			code: 404,
			message: "The requested resource could not be found."
		}, {
			code: 405,
			message: "The requested resource does not support the given method."
		}, {
			code: 406,
			message: "The screen you were attempting to view was not found."
		}, {
			code: 407,
			message: "The project you were attempting to view was not found."
		}, {
			code: 1100,
			message: "Validation failure"
		}, {
			code: 1101,
			message: "Validation failure: missing field"
		}, {
			code: 1102,
			message: "Validation failure: invalid field"
		}, {
			code: 1103,
			message: "Validation failure: already exists"
		}, {
			code: 5001,
			message: "Sorry, you aren't a collaborator on the project you tried to access. Please inform the project owner."
		}, {
			code: 5002,
			message: "Sorry, you aren't a collaborator on the project you tried to access. Would you like to Join this project?"
		}, {
			code: 500,
			message: "Unexpected error"
		} ];
		return ( this );
	}
	ValidationService.prototype = {
		isAlreadyExists: function ( error ) {
			return ( error.code === 1103 );
		},
		isBadRequest: function ( error ) {
			return ( error.code === 400 );
		},
		isForbidden: function ( error ) {
			return ( error.code === 403 );
		},
		isInvalid: function ( error ) {
			return ( error.code === 1100 );
		},
		isInvalidField: function ( error ) {
			return ( error.code === 1102 );
		},
		isMissingField: function ( error ) {
			return ( error.code === 1101 );
		},
		isNotFound: function ( error ) {
			return ( error.code === 404 );
		},
		isScreenNotFound: function ( error ) {
			return ( error.code === 406 );
		},
		isProjectNotFound: function ( error ) {
			return ( error.code === 407 );
		},
		isOverQuota: function ( error ) {
			return (
				( error.code === 3000 ) ||
				( error.code === 3001 )
			);
		},
		isMissingProjectPermission: function ( error ) {
			return ( error.code === 5001 );
		},
		canJoinProject: function ( error ) {
			return ( error.code === 5002 );
		}
	};
} )( angular, InVision );;;
/*! zero-clipboard.js */
;;
( function ( ng, app ) {
	"use strict";
	app.factory( "ZeroClipboard", Factory );
	/** @ngInject */
	function Factory() {
		ZeroClipboard.setMoviePath( "/assets/zeroclipboard/ZeroClipboard.swf" );
		return ( ZeroClipboard );
	}
} )( angular, InVision );;;
/*! add-to-project-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "addToProjectModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, _ ) {
		function get( userID, projectID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: userID,
					projectID: projectID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/add-to-project-modal/:id/:projectID", {
				id: "@id",
				projectID: "@projectID"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! affiliate-activity-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "affiliateActivityModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, _ ) {
		function get( userID, projectID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: userID,
					projectID: projectID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/affiliate-activity-modal/:id/:projectID", {
				id: "@id",
				projectID: "@projectID"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! change-plans-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "changePlansPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function deleteUserAccount() {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "deleteUserAccount"
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "planListing" );
		}
		var cache = new PartialCache( "changePlansPartial" );
		var resource = $resource(
			"/api/partials/desktop/change-plans", {}, {
				get: {
					method: "GET",
					isArray: false
				},
				deleteUserAccount: {
					method: "GET",
					isArray: false,
					params: {
						command: "delete-user-account"
					}
				},
			}
		);
		modelEvents.on(
			"subscriptionChanged",
			function ( event ) {
				cache.deleteResponse( getCacheKey() );
			}
		);
		modelEvents.on(
			"subscriptionUpdateError",
			function ( event, screenID ) {
				cache.deleteResponse( getCacheKey() );
			}
		);
		return ( {
			get: get,
			deleteUserAccount: deleteUserAccount
		} );
	}
} )( angular, InVision );;;
/*! console-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "consolePartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( screenID ) {
			var cacheKey = getCacheKey( screenID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: screenID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( screenID ) {
			return ( screenID );
		}
		var cache = new PartialCache( "console" );
		var resource = $resource(
			"/api/partials/desktop/console/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"screenDeleted",
			function ( event, screenID ) {
				cache.deleteResponse( getCacheKey( screenID ) );
			}
		);
		modelEvents.on(
			"screenArchived",
			function ( event, screen ) {
				cache.deleteResponse( getCacheKey( screen.id ) );
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateResponses(
					function ( response ) {
						return ( response.project.id === project.id );
					},
					function ( response ) {
						response.project.mobileDeviceID = project.mobileDeviceID;
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! dashboard-activity-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "dashboardActivityPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( offset, durationInDays, ignoreCache, userID ) {
			userID = ( userID || 0 );
			var cacheKey = getCacheKey( offset, durationInDays );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					offset: offset,
					durationInDays: durationInDays,
					userID: userID
				},
				cachedResponse: !ignoreCache && cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				}
			} );
			return ( promise );
		}

		function hasNewActivity( offset ) {
			var cacheKey = "hasNewActivity" + "-" + offset;
			var promise = partialHelper.executeRequest( {
				resource: hasNewActivityResource,
				name: "get",
				parameters: {
					offset: offset
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function getCacheKey( offset, durationInDays ) {
			return ( offset + "-" + durationInDays );
		}
		var cache = new PartialCache( "dashboardActivity", ( 2 * PartialCache.DAY ) );
		var resource = $resource(
			"/api/partials/desktop/dashboard/activity/:offset/:durationInDays/:userID", {
				offset: "@offset",
				durationInDays: "@durationInDays",
				userID: "@userID"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		var hasNewActivityResource = $resource(
			"/api/partials/desktop/dashboard/hasNewActivity/:offset/", {
				offset: "@offset"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateResponses(
					function ( response ) {
						return (
							_.findWithProperty( response.activity.projects, "id", projectID )
						);
					},
					function ( response ) {
						response.projects = _.rejectWithProperty( response.activity.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateResponses(
					function ( response ) {
						return (
							_.findWithProperty( response.activity.projects, "id", project.id )
						);
					},
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.activity.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get,
			hasNewActivity: hasNewActivity
		} );
	}
} )( angular, InVision );;;
/*! dashboard-projects-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "dashboardProjectsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "projects" );
		}
		var cache = new PartialCache( "dashboardProjects" );
		var resource = $resource(
			"/api/partials/desktop/dashboard/projects", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.rejectWithProperty( response.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! dashboard-stat-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "dashboardStatPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( leadUserID, offset, durationInDays ) {
			var cacheKey = getCacheKey( leadUserID, offset, durationInDays );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					leadUserID: leadUserID,
					offset: offset,
					durationInDays: durationInDays
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				}
			} );
			return ( promise );
		}

		function getCacheKey( leadUserID, offset, durationInDays ) {
			return ( leadUserID + "-" + offset + "-" + durationInDays );
		}
		var cache = new PartialCache( "dashboardStats", ( 2 * PartialCache.DAY ) );
		var resource = $resource(
			"/api/partials/desktop/dashboard/stats/:leadUserID/:offset/:durationInDays", {
				leadUserID: "@leadUserID",
				offset: "@offset",
				durationInDays: "@durationInDays"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! enterprise-projects-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "enterpriseProjectsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function getAllProjects( params ) {
			var cacheKey = getCacheKey( params.id );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getAllProjects",
				parameters: params,
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getRelatedProjects( params ) {
			var cacheKey = getCacheKey( params.id + "_relatedProjects" );
			var promise = partialHelper.executeRequest( {
				resource: sharedResource,
				name: "getRelatedProjects",
				parameters: params,
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getActivity( offset, durationInDays, userID, ignoreCache, showLimited ) {
			ignoreCache = ( ignoreCache || false );
			showLimited = ( showLimited || false );
			var cacheKey = getCacheKey( userID );
			var promise = partialHelper.executeRequest( {
				resource: activityResource,
				name: "getActivity",
				parameters: {
					offset: offset,
					durationInDays: durationInDays,
					userID: userID,
					collaborting: showLimited
				},
				cachedResponse: !ignoreCache && cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				}
			} );
			return ( promise );
		}

		function getCacheKey( userId ) {
			return ( "entProjects:" + userId );
		}
		var cache = new PartialCache( "projectsProjects" );
		var resource = $resource(
			"/api/partials/desktop/enterprise-projects-per-user", {}, {
				getAllProjects: {
					method: "GET",
					isArray: false
				}
			}
		);
		var sharedResource = $resource(
			"/api/partials/desktop/get-shared-projects/:id", {
				id: "@id"
			}, {
				getRelatedProjects: {
					method: "GET",
					isArray: false
				}
			}
		);
		var activityResource = $resource(
			"/api/partials/desktop/dashboard/user-activity/:offset/:durationInDays/:userID", {
				offset: "@offset",
				durationInDays: "@durationInDays",
				userID: "@userID"
			}, {
				getActivity: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.rejectWithProperty( response.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			getAllProjects: getAllProjects,
			getRelatedProjects: getRelatedProjects,
			getActivity: getActivity
		} );
	}
} )( angular, InVision );;;
/*! existing-shares-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "existingSharesModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/existing-shares-modal/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! live-embed-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "liveEmbedModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper ) {
		function get( screenID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					screenID: screenID
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/live-embed-modal/:screenID", {
				screenID: "@screenID"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! new-project-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "newProjectModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "na" );
		}
		var cache = new PartialCache( "newProjectModal" );
		var resource = $resource(
			"/api/partials/desktop/new-project-modal", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! new-share-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "newShareModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper ) {
		function get( projectID, screenID, selectedScreens ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID,
					screenID: ( screenID || 0 ),
					selectedScreens: ( selectedScreens ? selectedScreens : [] )
				}
			} );
			return ( promise );
		}
		var resource = $resource(
			"/api/partials/desktop/new-share-modal/:id", {
				id: "@id"
			}, {
				get: {
					method: "POST",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! new-team-member-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "newTeamMemberModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function transferProjectOwnership( projectIDs, toEmail ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "transferProjectOwnership",
				parameters: {
					projectIDs: projectIDs,
					email: toEmail
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "na" );
		}
		var cache = new PartialCache( "newTeamMemberModal" );
		var resource = $resource(
			"/api/partials/desktop/:command", {
				command: "@command"
			}, {
				get: {
					method: "GET",
					isArray: false,
					params: {
						command: 'new-team-member-modal'
					}
				},
				transferProjectOwnership: {
					method: "POST",
					isArray: false,
					params: {
						command: 'transfer-project-ownership'
					}
				}
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get,
			transferProjectOwnership: transferProjectOwnership
		} );
	}
} )( angular, InVision );;;
/*! project-assets-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectAssetsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID, folderID ) {
			var cacheKey = getCacheKey( projectID, folderID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID,
					folderid: folderID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID, folderID ) {
			return ( projectID + "_" - folderID );
		}
		var cache = new PartialCache( "projectAssets" );
		var resource = $resource(
			"/api/partials/desktop/projects/detail/:id/assets?folderid=:folderid", {
				id: "@id",
				folderid: "@folderid"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectAssetsSorted",
			function ( event, projectID, assetIDs ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						for ( var i = 0, length = assetIDs.length; i < length; i++ ) {
							var assetID = assetIDs[ i ];
							var sortIndex = ( i + 1 );
							var cachedAsset = _.findWithProperty( response.asset, "id", assetID );
							if ( cachedAsset ) {
								cachedAsset.sort = sortIndex;
							}
						}
					}
				);
			}
		);
		modelEvents.on(
			"assetDeleted",
			function ( event, assetID ) {
				cache.updateResponses(
					function ( response ) {
						return ( _.findWithProperty( response.assets, "id", assetID ) );
					},
					function ( response ) {
						response.assets = _.withoutProperty( response.assets, "id", assetID );
					}
				);
			}
		);
		modelEvents.on(
			"assetUpdated",
			function ( event, asset ) {
				cache.updateResponse(
					getCacheKey( asset.projectID ),
					function ( response ) {
						var cachedAsset = _.findWithProperty( response.assets, "id", asset.id );
						if ( cachedAsset ) {
							_.extendExistingProperties( cachedAsset, asset );
						} else {
							response.assets.push( asset );
						}
					}
				);
			}
		);
		modelEvents.on(
			"assetUploaded",
			function ( event, asset ) {
				cache.updateResponse(
					getCacheKey( asset.projectID ),
					function ( response ) {
						var cachedAsset = _.findWithProperty( response.asset, "id", asset.id );
						if ( cachedAsset ) {
							_.extendExistingProperties( cachedAsset, asset );
						} else {
							response.assets.push( asset );
						}
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! project-conversations-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectConversationsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID, status ) {
			if ( status === "open" ) {
				return ( getOpenConversations( projectID, status ) );
			} else {
				return ( getOtherConversations( projectID, status ) );
			}
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}

		function getOpenConversations( projectID, status ) {
			var cacheKey = getCacheKey( projectID, status );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID,
					status: status
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function getOtherConversations( projectID, status ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID,
					status: status
				}
			} );
			return ( promise );
		}

		function updateFilters( filters ) {
			var promise = partialHelper.executeRequest( {
				resource: filterResource,
				name: "updateFilters",
				parameters: {
					commentFilterRead: filters.read.value,
					commentFilterStatus: filters.status.value,
					commentFilterType: filters.type.value
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}
		var cache = new PartialCache( "projectConversations" );
		var resource = $resource(
			"/api/partials/desktop/projects/detail/:id/conversations/:status", {
				id: "@id",
				status: "@status"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		var filterResource = $resource(
			"/api/account/filters", {}, {
				updateFilters: {
					method: "POST",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		return ( {
			get: get,
			updateFilters: updateFilters
		} );
	}
} )( angular, InVision );;;
/*! project-detail-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectDetailPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID ) {
			var cacheKey = getCacheKey( projectID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var cache = new PartialCache( "projectDetail" );
		var resource = $resource(
			"/api/partials/desktop/projects/detail/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateResponses(
					function ( response ) {
						return ( response.project.id === project.id );
					},
					function ( response ) {
						_.extendExistingProperties( response.project, project );
					}
				);
			}
		);
		modelEvents.on(
			"viewChanged.projectScreens",
			function ( event, projectID, viewScreensAsThumbnails ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						response.project.viewScreensAsThumbnails = viewScreensAsThumbnails;
					}
				);
			}
		);
		modelEvents.on(
			"subscriptionChanged",
			function ( event, newPlan ) {
				cache.rejectResponses( function ( project ) {
					return true;
				} );
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! project-members-last-viewed-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectMembersLastViewedPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, _ ) {
		function get( projectID ) {
			var cacheKey = getCacheKey( projectID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( "projectMembersViewed" + projectID );
		}
		var cache = new PartialCache( "projectMembersLastViewedPartial" );
		var resource = $resource(
			"/api/partials/desktop/delete-project-teamlist/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! project-members-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectMembersModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID ) {
			var cacheKey = getCacheKey( projectID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var cache = new PartialCache( "projectMembersModal" );
		var resource = $resource(
			"/api/partials/desktop/project-members-modal/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateResponse(
					getCacheKey( project.id ),
					function ( response ) {
						_.extendExistingProperties( response.project, project );
					}
				);
			}
		);
		modelEvents.on(
			"projectUserAdded",
			function ( event, projectID, userID ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						var cachedUsers = _.filterWithProperty( response.teamMembers, "id", userID );
						_.setProperty( cachedUsers, "isProjectMember", true );
					}
				);
			}
		);
		modelEvents.on(
			"projectUsersAdded",
			function ( event, projectID, userIDs ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						var cachedUsers = _.withPropertyRange( response.teamMembers, "id", userIDs );
						_.setProperty( cachedUsers, "isProjectMember", true );
					}
				);
			}
		);
		modelEvents.on(
			"projectUserRemoved",
			function ( event, projectID, userID ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						var cachedUsers = _.filterWithProperty( response.teamMembers, "id", userID );
						_.setProperty( cachedUsers, "isProjectMember", false );
					}
				);
			}
		);
		modelEvents.on(
			"projectUsersRemoved",
			function ( event, projectID, userIDs ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						var cachedUsers = _.withPropertyRange( response.teamMembers, "id", userIDs );
						_.setProperty( cachedUsers, "isProjectMember", false );
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! project-screens-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectScreensPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID, isSnap ) {
			var cacheKey = getCacheKey( projectID );
			var params = {
				id: projectID
			};
			if ( isSnap ) {
				params.snap = true;
			}
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: params,
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var cache = new PartialCache( "projectScreens" );
		var resource = $resource(
			"/api/partials/desktop/projects/detail/:id/screens", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectScreensSorted",
			function ( event, projectID, screenIDs ) {
				cache.updateResponse(
					getCacheKey( projectID ),
					function ( response ) {
						for ( var i = 0, length = screenIDs.length; i < length; i++ ) {
							var screenID = screenIDs[ i ];
							var sortIndex = ( i + 1 );
							var cachedScreen = _.findWithProperty( response.screens, "id", screenID );
							if ( cachedScreen ) {
								cachedScreen.sort = sortIndex;
							}
						}
					}
				);
			}
		);
		modelEvents.on(
			"screenActivated",
			function ( event, screen ) {
				cache.updateResponse(
					getCacheKey( screen.projectID ),
					function ( response ) {
						var cachedScreen = _.findWithProperty( response.screens, "id", screen.id );
						if ( cachedScreen ) {
							_.extendExistingProperties( cachedScreen, screen );
						} else {
							response.screens.push( screen );
						}
					}
				);
			}
		);
		modelEvents.on(
			"screenArchived",
			function ( event, screen ) {
				cache.updateResponses(
					function ( response ) {
						return ( _.findWithProperty( response.screens, "id", screen.id ) );
					},
					function ( response ) {
						response.screens = _.withoutProperty( response.screens, "id", screen.id );
					}
				);
			}
		);
		modelEvents.on(
			"screenDeleted",
			function ( event, screenID ) {
				cache.updateResponses(
					function ( response ) {
						return ( _.findWithProperty( response.screens, "id", screenID ) );
					},
					function ( response ) {
						response.screens = _.withoutProperty( response.screens, "id", screenID );
					}
				);
			}
		);
		modelEvents.on(
			"screenUpdated",
			function ( event, screen ) {
				cache.updateResponse(
					getCacheKey( screen.projectID ),
					function ( response ) {
						var cachedScreen = _.findWithProperty( response.screens, "id", screen.id );
						if ( cachedScreen ) {
							_.extendExistingProperties( cachedScreen, screen );
						} else {
							response.screens.push( screen );
						}
					}
				);
			}
		);
		modelEvents.on(
			"screenUploaded",
			function ( event, screen ) {
				cache.updateResponse(
					getCacheKey( screen.projectID ),
					function ( response ) {
						var cachedScreen = _.findWithProperty( response.screens, "id", screen.id );
						if ( cachedScreen ) {
							_.extendExistingProperties( cachedScreen, screen );
						} else {
							response.screens.push( screen );
						}
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! project-testing-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectTestingPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, serviceHelper, modelEvents, _ ) {
		function get( projectID ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "list",
				parameters: {
					id: projectID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		};

		function getTest( testId, type ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getTestByTestId",
				parameters: {
					id: testId,
					type: type
				},
				successCallback: function ( response ) {
					var test = response.test;
					for ( var item in test.participantInfo.options ) {
						if ( typeof test.participantInfo.options[ item ] === "string" ) {
							test.participantInfo.options[ item ] = ( test.participantInfo.options[ item ] === "true" ) ? true : false;
						}
					}
				},
				errorCallback: function () {}
			} );
			return ( promise );
		};
		var getResults = function ( testId ) {
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "getResults",
				parameters: {
					id: testId
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		};

		function save( parameters ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "save",
				parameters: parameters,
				successCallback: function ( response ) {
					modelEvents.trigger( "testing:partialSaved", response.test, response.share );
				}
			} );
			return ( promise );
		};

		function addNotificationRequest( userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "addNotificationRequest",
				parameters: {
					id: userID
				},
				successCallback: function ( response ) {}
			} );
			return ( promise );
		}

		function duplicate( testId, userID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicate",
				parameters: {
					id: testId,
					userID: userID
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "testing:partialDuplicated" );
				}
			} );
			return ( promise );
		};

		function deleteTest( testId ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "deleteTest",
				parameters: {
					testId: testId
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "testing:partialDeleted" );
				}
			} );
			return ( promise );
		};

		function sendTest( testId, emailAddresses ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendTest",
				parameters: {
					testId: testId,
					recipients: emailAddresses
				}
			} );
			return ( promise );
		};

		function audienceShare( testId ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "audienceShare",
				parameters: {
					testId: testId
				}
			} );
			return ( promise );
		};
		var resource = $resource(
			"/api/testing/:command/:id", {
				id: "@id",
				command: "@command"
			}, {
				list: {
					method: "GET",
					params: {
						command: "list"
					},
					isArray: false
				},
				addNotificationRequest: {
					method: "GET",
					params: {
						command: "addNotificationRequest"
					}
				},
				getTestByTestId: {
					method: "GET",
					params: {
						command: "getTestByTestId",
						type: "@type"
					},
					isArray: false
				},
				getResults: {
					method: "GET",
					params: {
						command: "getResults"
					}
				},
				save: {
					method: "POST",
					params: {
						command: "save"
					},
					isArray: false
				},
				duplicate: {
					method: "POST",
					params: {
						command: "duplicate"
					}
				},
				deleteTest: {
					method: "POST",
					params: {
						command: "delete"
					}
				},
				sendTest: {
					method: "POST",
					params: {
						command: "sendTest"
					}
				}, //audienceShare
				audienceShare: {
					method: "POST",
					params: {
						command: "audienceShare"
					}
				}
			}
		);
		return ( {
			get: get,
			getTest: getTest,
			getResults: getResults,
			save: save,
			duplicate: duplicate,
			deleteTest: deleteTest,
			sendTest: sendTest,
			addNotificationRequest: addNotificationRequest,
			audienceShare: audienceShare
		} );
	}
} )( angular, InVision );;;
/*! projects-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "projectsProjectsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "projects" );
		}
		var cache = new PartialCache( "projectsProjects" );
		var resource = $resource(
			"/api/partials/desktop/projectsProjects", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectHomeScreenUpdated",
			function ( event, projectID, screenID ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.findWithProperty( response.projects, "id", projectID );
						if ( cachedProject ) {
							cachedProject.homeScreenID = screenID;
						}
					}
				);
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.rejectWithProperty( response.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! standard-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "standardPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "projects" );
		}
		var cache = new PartialCache( "standardProjects" );
		var resource = $resource(
			"/api/partials/desktop/standard/projects", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.rejectWithProperty( response.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! team-activity-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamActivityPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( userID, offset, durationInDays, companyID ) {
			if ( typeof companyID === 'undefined' ) {
				companyID = 0;
			}
			var cacheKey = getCacheKey( userID, offset, durationInDays, companyID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: userID,
					offset: offset,
					durationInDays: durationInDays
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				}
			} );
			return ( promise );
		}

		function getCacheKey( userID, offset, durationInDays, companyID ) {
			return ( userID + "-" + offset + "-" + durationInDays + "-" + companyID );
		}
		var cache = new PartialCache( "teamActivity", ( 2 * PartialCache.DAY ) );
		var resource = $resource(
			"/api/partials/desktop/team/detail/:id/activity/:offset/:durationInDays", {
				id: "@id",
				offset: "@offset",
				durationInDays: "@durationInDays"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateResponses(
					function ( response ) {
						return (
							_.findWithProperty( response.activity.projects, "id", projectID )
						);
					},
					function ( response ) {
						response.projects = _.rejectWithProperty( response.activity.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateResponses(
					function ( response ) {
						return (
							_.findWithProperty( response.activity.projects, "id", project.id )
						);
					},
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.activity.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! team-detail-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamDetailPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, sessionService, _ ) {
		function get( userID ) {
			var cacheKey = getCacheKey( userID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: userID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( userID ) {
			return ( userID );
		}
		var cache = new PartialCache( "teamDetail" );
		var resource = $resource(
			"/api/partials/desktop/team/detail/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"accountUpdated",
			function ( event, account ) {
				cache.updateResponses(
					function ( response ) {
						return ( response.teamMember.id === account.id );
					},
					function ( response ) {
						_.extendExistingProperties( response.teamMember, account );
					}
				);
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.withoutProperty( response.projects, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		modelEvents.on(
			"projectUserAdded",
			function ( event, projectID, userID ) {
				cache.updateResponse(
					getCacheKey( userID ),
					function ( response ) {
						var cachedProject = _.findWithProperty( response.projects, "id", projectID );
						if ( cachedProject ) {
							cachedProject.includesTeamMember = true;
						}
					}
				);
			}
		);
		modelEvents.on(
			"projectUserRemoved",
			function ( event, projectID, userID ) {
				if ( userID === sessionService.user.id ) {
					cache.updateResponse(
						getCacheKey( userID ),
						function ( response ) {
							response.projects = _.withoutProperty( response.projects, "id", projectID );
						}
					);
				} else {
					cache.updateResponse(
						getCacheKey( userID ),
						function ( response ) {
							var cachedProject = _.findWithProperty( response.projects, "id", projectID );
							if ( cachedProject ) {
								cachedProject.includesTeamMember = false;
							}
						}
					);
				}
			}
		);
		modelEvents.on(
			"teamMemberDeleted",
			function ( event, userID ) {
				cache.deleteResponse( getCacheKey( userID ) );
			}
		);
		modelEvents.on(
			"teamMemberUpdated",
			function ( event, teamMember ) {
				cache.updateResponse(
					getCacheKey( teamMember.id ),
					function ( response ) {
						var cachedTeamMember = _.extendExistingProperties(
							_.findWithProperty( response.teamMembers, "id", teamMember.id ),
							teamMember
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! team-list-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamListPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "teamList" );
		}
		var cache = new PartialCache( "teamList" );
		var resource = $resource(
			"/api/partials/desktop/team/list", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			[ "accountUpdated", "teamCreated.forFirstTime" ],
			function ( event, account ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedTeamMember = _.extendExistingProperties(
							_.findWithProperty( response.teamMembers, "id", account.id ),
							account
						);
					}
				);
			}
		);
		modelEvents.on(
			"projectUserAdded",
			function ( event, projectID, userID ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedTeamMember = _.findWithProperty( response.teamMembers, "id", userID );
						if ( cachedTeamMember ) {
							cachedTeamMember.projectCount++;
						}
					}
				);
			}
		);
		modelEvents.on(
			"projectUserRemoved",
			function ( event, projectID, userID ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedTeamMember = _.findWithProperty( response.teamMembers, "id", userID );
						if ( cachedTeamMember ) {
							cachedTeamMember.projectCount--;
						}
					}
				);
			}
		);
		modelEvents.on(
			"teamInvitationDeleted",
			function ( event, invitationID, teamLeadUserID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.invitations = _.withoutProperty( response.invitations, "id", invitationID );
						var team = _.withProperty( response.companyMembers, "leadUserID", teamLeadUserID )[ 0 ];
						team.teamConnectionInvitations = _.withoutProperty( team.teamConnectionInvitations, "id", invitationID );
						team.teamInvitations = _.withoutProperty( team.teamInvitations, "id", invitationID );
						response.companyMembers = _.withoutProperty( response.companyMembers, "leadUserID", teamLeadUserID );
						response.companyMembers.unshift( team );
					}
				);
			}
		);
		modelEvents.on(
			"teamMemberDeleted",
			function ( event, userID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.teamMembers = _.withoutProperty( response.teamMembers, "id", userID );
					}
				);
			}
		);
		modelEvents.on(
			"teamMemberUpdated",
			function ( event, teamMember ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedTeamMember = _.extendExistingProperties(
							_.findWithProperty( response.teamMembers, "id", teamMember.id ),
							teamMember
						);
					}
				);
			}
		);
		modelEvents.on(
			"teamMemberRemovedFromTeam",
			function ( event, teamMember, teamLeadUserID ) {
				cache.updateAllResponses(
					function ( response ) {
						var team = _.withProperty( response.companyMembers, "leadUserID", teamLeadUserID );
						team.teamMembers = _.withoutProperty( team.teamMembers, "id", teamLeadUserID );
						response.companyMembers = _.withoutProperty( response.companyMembers, "leadUserID", teamLeadUserID );
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! team-notifications-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamNotificationsPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "na" );
		}
		var cache = new PartialCache( "teamNotifications", ( 2 * PartialCache.DAY ) );
		var resource = $resource(
			"/api/partials/desktop/team/detail/notifications", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"notificationSettingsUpdated",
			function ( event, settings ) {
				cache.updateAllResponses(
					function ( response ) {
						response.notificationSettings = settings;
					}
				);
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.updateAllResponses(
					function ( response ) {
						response.projects = _.rejectWithProperty( response.projects, "id", projectID );
						response.notificationSettings.projectNotifications = _.rejectWithProperty( response.notificationSettings.projectNotifications, "id", projectID );
					}
				);
			}
		);
		modelEvents.on(
			"projectUpdated",
			function ( event, project ) {
				cache.updateAllResponses(
					function ( response ) {
						var cachedProject = _.extendExistingProperties(
							_.findWithProperty( response.projects, "id", project.id ),
							project
						);
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! team-profile-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "teamProfilePartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get() {
			var cacheKey = getCacheKey();
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey() {
			return ( "na" );
		}
		var cache = new PartialCache( "teamProfile" );
		var resource = $resource(
			"/api/partials/desktop/team/list", {}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"accountUpdated",
			function ( event, account ) {
				cache.updateAllResponses(
					function ( response ) {
						_.extendExistingProperties( response.account, account );
					}
				);
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! transfer-project-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "transferProjectModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID ) {
			var cacheKey = getCacheKey( projectID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var cache = new PartialCache( "transferProjectModal" );
		var resource = $resource(
			"/api/partials/desktop/transfer-project-modal/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! workflow-status-notification-modal-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "workflowStatusNotificationModalPartial", Service );
	/** @ngInject */
	function Service( $resource, partialHelper, PartialCache, modelEvents, _ ) {
		function get( projectID, screenID ) {
			var cacheKey = getCacheKey( projectID );
			var promise = partialHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID
				},
				cachedResponse: cache.getResponse( cacheKey ),
				successCallback: function ( response ) {
					cache.setResponse( cacheKey, response );
				},
				errorCallback: function () {
					cache.deleteResponse( cacheKey );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var cache = new PartialCache( "workflowStatusNotificationModal" );
		var resource = $resource(
			"/api/partials/desktop/workflow-status-notification-modal/:id", {
				id: "@id"
			}, {
				get: {
					method: "GET",
					isArray: false
				}
			}
		);
		modelEvents.on(
			"projectDeleted",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectUserAdded",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		modelEvents.on(
			"projectUserRemoved",
			function ( event, projectID ) {
				cache.deleteResponse( getCacheKey( projectID ) );
			}
		);
		return ( {
			get: get
		} );
	}
} )( angular, InVision );;;
/*! app-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "PresentationAppController", Controller );
	/** @ngInject */
	function Controller( $scope, $route, $routeParams, $location, $window, $timeout, config, requestContext, sessionService, shareService, projectService, screenService, Deferred, projectViewingService, _, modelEvents, ipInfoService, presentationService ) {
		function addScreenToHistory( screenID ) {
			if (
				screenHistory.length &&
				( screenHistory[ screenHistory.length - 1 ] === screenID )
			) {
				return;
			}
			screenHistory.push( screenID );
		}

		function applyBackgroundStyles( screen, suppressBackgroundOptions ) {
			var style = {};
			if ( $scope.project.isMobile ) {
				style[ "background" ] = "#afb2bd top center no-repeat";
			} else {
				style[ "border-style" ] = "";
				style[ "border-image" ] = "none";
				style[ "border-width" ] = "";
				style[ "height" ] = "";
				style[ "border-image-outset" ] = "";
				style[ "background-color" ] = ( "#" + ( screen.backgroundColor || "FFFFFF" ) );
				if ( screen.backgroundImageUrl ) {
					var offsetTop = $scope.subview == "comments" ? "55px" : "0px";
					style[ "background-image" ] = ( "url( '" + screen.backgroundImageUrl + "' )" )
					switch ( screen.backgroundImagePosition ) {
					case "center":
					case "50% 0 no-repeat": // TODO: remove after db is updated
						style[ "background-position" ] = "50% " + offsetTop;
						style[ "background-repeat" ] = "no-repeat";
						break;
					case "tile":
					case "repeat": // TODO: remove after db is updated
						style[ "background-position" ] = "0px " + offsetTop;
						style[ "background-repeat" ] = "repeat";
						break;
					case "tile-horizontally":
					case "0 0 repeat-x": // TODO: remove after db is updated
						style[ "background-position" ] = "0px " + offsetTop;
						style[ "background-repeat" ] = "repeat-x";
						break;
					}
				}
				if ( screen.backgroundImageClientFilename.indexOf( "@2x" ) >= 0 ) {
					style[ "background-size" ] = screen.backgroundImageWidth * 0.5 + "px " + screen.backgroundImageHeight * 0.5 + "px";
				} else if ( screen.backgroundImageClientFilename.indexOf( "@print" ) > 0 ) {
					style[ "background-size" ] = screen.backgroundImageWidth * 0.3333 + "px " + screen.backgroundImageHeight * 0.3333 + "px";
				}
				if ( screen.backgroundAutostretch ) {
					style[ "background-image" ] = "";
					style[ "border-style" ] = "solid";
					style[ "border-image" ] = "url('" + screen.imageUrl + "') 0 0 0 " + ( screen.width - 1 ) + " fill stretch";
					style[ "border-width" ] = "0px 1px 0px 1px";
					style[ "height" ] = screen.height * screen.displayScale;
					style[ "border-image-outset" ] = "0% 100%";
					style[ "margin-left" ] = "-1px";
					style[ "margin-right" ] = "-2px";
				}
			}
			$scope.setBodyStyle( style );
			$scope.setBodyClass( screen.backgroundFrame ? "framed" : "" );
		}

		function getCurrentScreenID() {
			return ( $scope.screenID );
		}

		function getPreviousScreenFromHistory() {
			if ( screenHistory.length < 2 ) {
				return ( null );
			}
			var currentScreenID = screenHistory.pop();
			var previousScreenID = screenHistory.pop();
			return ( previousScreenID );
		}

		function isRouteRedirect( route ) {
			return ( !route.current.action );
		}

		function loadCountryCode() {
			Deferred.handlePromise(
				ipInfoService.getGeolocationData(),
				function ( response ) {
					$scope.share.countryCode = response.country.toLowerCase();
				},
				function ( response ) {
					$scope.share.countryCode = "us";
				}
			);
		}
		$scope.clearBodyStyle = function () {
			$scope.bodyStyle = {};
		};
		$scope.closeBrowse = function () {
			$scope.isBrowseOpen = false;
		};
		$scope.closeLoading = function () {
			$scope.isLoadingOpen = false;
			$scope.$broadcast( "loadingSequenceCompleted" );
		};
		$scope.getPercentOfScreensLoaded = function () {
			return ( percentOfScreensLoaded );
		};
		$scope.getScreenHistory = function () {
			return screenHistory;
		}
		$scope.openModalWindow = function ( type ) {
			var modalData = _.toArray( arguments );
			var modalType = modalData.shift();
			$scope.$broadcast( "openModalWindow", modalType, modalData );
		};
		$scope.setBodyClass = function ( className ) {
			var bodyClass = $scope.subview;
			bodyClass += " p-console";
			if ( $scope.project.isMobile ) {
				bodyClass += " mobile";
			}
			$scope.bodyClass = ( bodyClass + " " + className );
		};
		$scope.setBodyStyle = function ( style ) {
			$scope.bodyStyle = style;
		};
		$scope.setPercentOfScreensLoaded = function ( percent ) {
			if ( percentOfScreensLoaded !== 100 && !$scope.project.isSnap ) {
				$scope.setWindowTitle( percent + "% Loaded" );
			}
			percentOfScreensLoaded = percent;
		};
		$scope.setWindowTitle = function ( title ) {
			$scope.windowTitle = title;
			if ( $scope.isLiveShare ) {
				$scope.$emit( "liveshare.windowTitle", title );
			}
		};
		$scope.appliedClass = function () {
			if ( $scope.subview == "comments" ) {
				return "desktop";
			} else {
				if ( $scope.project.mobileStatusbarIsOpaque && $scope.project.mobileStatusbarIsVisible ) {
					var statusbarClass = "opaqueStatusbar";
				} else if ( !$scope.project.mobileStatusbarIsOpaque || !$scope.project.mobileStatusbarIsVisible ) {
					var statusbarClass = "transparentStatusbar";
				}
				var classNames = $scope.deviceTemplate.className + " " + statusbarClass;
				if ( $scope.deviceTemplate.mobileSkinColor == 'white' ) {
					classNames = classNames + " white";
				}
				if ( $scope.project.mobileStatusbarIsVisible ) {
					classNames = classNames + " statusbarIsVisible";
				}
				return classNames;
			}
		}
		$scope.applyScreenDisplayScale = function () {
			if ( $scope.screen ) {
				if ( $scope.project.isMobile ) {
					$scope.screen.displayScale = ( $scope.deviceTemplate.viewportWidth / $scope.screen.width );
				} else if ( !$scope.project.isMobile && $scope.screen.clientFilename.indexOf( "@2x" ) > 0 ) {
					$scope.screen.displayScale = 0.5;
				} else if ( !$scope.project.isMobile && $scope.screen.clientFilename.indexOf( "@print" ) > 0 ) {
					$scope.screen.displayScale = 0.3333;
				} else {
					$scope.screen.displayScale = 1;
				}
			}
		}
		$scope.getScreenDisplayScale = function ( screen ) {
			if ( $scope.project.isMobile ) {
				var displayScale = ( $scope.deviceTemplate.viewportWidth / screen.width );
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				var displayScale = 0.5;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				var displayScale = 0.3333;
			} else {
				var displayScale = 1;
			}
			return displayScale;
		}
		$scope.getReverseDisplayScale = function ( screen ) {
			if ( $scope.project.isMobile ) {
				var displayScale = ( screen.width / $scope.deviceTemplate.viewportWidth );
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				var displayScale = 2;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				var displayScale = 3;
			} else {
				var displayScale = 1;
			}
			return displayScale;
		}
		$scope.setIsTransitioning = function ( value ) {
			$scope.isTransitioning = value;
		}
		$scope.setTransitionData = function ( data ) {
			$scope.transitionData = data;
		}
		$scope.setScreen = function ( screen ) {
			if ( !screen ) {
				return;
			}
			if ( screen.displayScale == undefined ) {
				screen.displayScale = $scope.getScreenDisplayScale( screen );
			}
			$scope.screen = screen;
		}
		$scope.updateShareConfig = function () {
			var presentationKey = config.presentation.key;
			Deferred.handlePromise(
				presentationService.getShareConfig( presentationKey ),
				function ( response ) {
					config.project = response.project;
					config.screens = response.screens;
					config.metaScreens = response.metaScreens;
					config.hotspots = response.hotspots;
					config.conversations = response.conversations;
					config.comments = response.comments;
					config.commentSketches = response.commentsketches;
					config.dividers = response.dividers;
					config.presentation = response.presentation;
					$scope.$broadcast( "configUpdated.share", config );
				},
				function ( response ) {}
			);
		}
		$scope.updateDeviceTemplate = function () {
			$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", config.project.mobileDeviceID )[ 0 ];
		}
		var renderContext = requestContext.getRenderContext( "", "stepID" );
		var percentOfScreensLoaded = 0;
		var screenHistory = [];
		var share = shareService.getShare();
		$scope.windowTitle = "InVision Tour";
		$scope.bodyClass = "";
		$scope.subview = null;
		$scope.isLoadingOpen = true;
		$scope.isBrowseOpen = false;
		$scope.shouldShowPoweredBy = config.shouldShowPoweredBy;
		$scope.isModalOpen = false;
		if ( shareService.getShare().screenID == 0 ) {
			$scope.defaultScreenIDForShare = screenService.getScreens()[ 0 ].id;
		} else {
			$scope.defaultScreenIDForShare = shareService.getShare().screenID;
		}
		$scope.project = config.project;
		$scope.deviceTemplates = config.mobileDevices;
		$scope.share = shareService.getShare();
		$scope.deviceTemplate = _.withProperty( $scope.deviceTemplates, "mobileDeviceID", config.project.mobileDeviceID )[ 0 ];
		$scope.appIcon = screenService.getAppIcon();
		$scope.loadingScreen = screenService.getLoadingScreen();
		$scope.screenID = $scope.defaultScreenIDForShare;
		$scope.screen = screenService.getScreenByID( $scope.screenID );
		$scope.screens = config.presentation.slides;
		$scope.stepID = requestContext.getParamAsInt( "stepID", $scope.defaultScreenIDForShare );
		$scope.applyScreenDisplayScale();
		$scope.isTransitioning = false;
		$scope.transitionData = {};
		$scope.isShowingSmsForm = false;
		$scope.sms = {};
		$scope.sms.phoneNumber = "";
		$scope.sms.messageSent = false;
		$scope.sms.message = "";
		$scope.isPresentation = true;
		$scope.isFirstLoad = true;
		if ( $window.localStorage && localStorage.getItem( 'smsPhoneNumber' ) ) {
			$scope.sms.phoneNumber = localStorage.getItem( "smsPhoneNumber" );
		}
		$scope.branding = config.branding;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				$scope.setBodyClass( "" );
			}
		);
		$scope.$on(
			"$routeChangeSuccess",
			function ( event, currentRoute, previousRoute ) {
				if ( isRouteRedirect( $route ) ) {
					return;
				}
				requestContext.setContext( $route.current.action, $routeParams );
				$scope.$broadcast( "requestContextChanged", requestContext );
			}
		);
		$scope.$on( "modal.isWindowOpen", function ( event, isOpen ) {
			$scope.isModalOpen = isOpen;
		} );
		$scope.$on( "presentation.goToSlide", function ( event, idx ) {
			if ( idx == 0 ) {
				$scope.screen = null;
				$scope.screenID = null;
			} else {
				$scope.screen = config.screens[ idx - 1 ];
				$scope.screenID = $scope.screen.screenID;
				$scope.applyScreenDisplayScale();
			}
			$scope.selectedScreen = $scope.screen;
			if ( $scope.selectedScreen ) {
				applyBackgroundStyles( $scope.selectedScreen );
			}
		} );
		$scope.$on( "presentation.firstLoad", function () {
			$scope.isFirstLoad = false;
		} );
		modelEvents.on(
			"projectUpdated.share",
			function ( event, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"screenUploaded.share",
			function ( event, screen ) {
				if ( screen.projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"screenConfigUpdated.share",
			function ( event, screen ) {
				if ( screen.projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"screenDeleted.share",
			function ( event, screenID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"commentAdded.share",
			function ( event, commentID, conversationID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"commentUpdated.share",
			function ( event, commentID, conversationID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"commentDeleted.share",
			function ( event, commentID, conversationID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"conversationUpdated.share",
			function ( event, conversationID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"hotspotCreated.share",
			function ( event, hotspotID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"hotspotUpdated.share",
			function ( event, hotspotID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		modelEvents.on(
			"hotspotDeleted.share",
			function ( event, hotspotID, projectID ) {
				if ( projectID == config.project.id ) {
					$scope.updateShareConfig();
				}
			}
		);
		$scope.$on(
			"configUpdated.share",
			function ( event, localConfig ) {
				$scope.project = config.project;
			}
		);
		/*if ( $scope.project.isMobile ) {
loadCountryCode();
}*/
	}
} )( angular, InVision );;;
/*! screens-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "presentations.ScreensController", Controller );
	/** @ngInject */
	function Controller( $scope, $timeout, $location, requestContext, screenService, hashKeyCopier, projectService, shareService, projectViewingService, hotspotService, _, config ) {
		function applyBackgroundStyles( screen, suppressBackgroundOptions ) {
			var style = {};
			if ( $scope.project.isMobile ) {
				style[ "background" ] = "#afb2bd top center no-repeat";
			} else {
				style[ "border-style" ] = "";
				style[ "border-image" ] = "none";
				style[ "border-width" ] = "";
				style[ "height" ] = "";
				style[ "border-image-outset" ] = "";
				style[ "background-color" ] = ( "#" + ( screen.backgroundColor || "FFFFFF" ) );
				if ( screen.backgroundImageUrl ) {
					var offsetTop = $scope.subview == "comments" ? "55px" : "0px";
					style[ "background-image" ] = ( "url( '" + screen.backgroundImageUrl + "' )" )
					switch ( screen.backgroundImagePosition ) {
					case "center":
					case "50% 0 no-repeat": // TODO: remove after db is updated
						style[ "background-position" ] = "50% " + offsetTop;
						style[ "background-repeat" ] = "no-repeat";
						break;
					case "tile":
					case "repeat": // TODO: remove after db is updated
						style[ "background-position" ] = "0px " + offsetTop;
						style[ "background-repeat" ] = "repeat";
						break;
					case "tile-horizontally":
					case "0 0 repeat-x": // TODO: remove after db is updated
						style[ "background-position" ] = "0px " + offsetTop;
						style[ "background-repeat" ] = "repeat-x";
						break;
					}
				}
				if ( screen.backgroundImageClientFilename.indexOf( "@2x" ) >= 0 ) {
					style[ "background-size" ] = screen.backgroundImageWidth * 0.5 + "px " + screen.backgroundImageHeight * 0.5 + "px";
				} else if ( screen.backgroundImageClientFilename.indexOf( "@print" ) > 0 ) {
					style[ "background-size" ] = screen.backgroundImageWidth * 0.3333 + "px " + screen.backgroundImageHeight * 0.3333 + "px";
				}
				if ( screen.backgroundAutostretch ) {
					style[ "background-image" ] = "";
					style[ "border-style" ] = "solid";
					style[ "border-image" ] = "url('" + screen.imageUrl + "') 0 0 0 " + ( screen.width - 1 ) + " fill stretch";
					style[ "border-width" ] = "0px 1px 0px 1px";
					style[ "height" ] = screen.height * screen.displayScale;
					style[ "border-image-outset" ] = "0% 100%";
				} else if ( screen.backgroundFrame ) {}
			}
			$scope.setBodyStyle( style );
			$scope.setBodyClass( screen.backgroundFrame ? "framed" : "" );
		}

		function augmentScreen( screen ) {
			if ( $scope.isPresentation && screen.title ) {
				return;
			}
			screen.isImageLoaded = false;
			screen.isGif = /\.gif$/i.test( screen.clientFilename );
			if ( $scope.project.isMobile ) {
				screen.displayScale = ( $scope.deviceTemplate.viewportWidth / screen.width );
			} else if ( screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				screen.displayScale = 0.5;
			} else if ( screen.clientFilename.indexOf( "@print" ) > 0 ) {
				screen.displayScale = 0.3333;
			} else {
				screen.displayScale = 1;
			}
			screen.now = new Date().getTime();
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function getScreensToPreload() {
			return ( $scope.screens );
			/*var screens = _.filter(
$scope.screens,
function( screen ) {
return( screen.distanceFromStartScreen <= 1 );
}
);
return( screens );*/
		}

		function setFixedAreaColors( screen ) {
			if ( screen.fixedHeaderBgColor != undefined && screen.fixedHeaderBgColor != undefined ) {
				return;
			}
			var image = new Image();
			image.crossOrigin = "anonymous";
			image.src = screen.imageUrl;
			image.onload = function ( event ) {
				var canvas = document.createElement( "canvas" );
				canvas.width = image.width;
				canvas.height = image.height;
				var ctx = canvas.getContext( "2d" );
				ctx.drawImage( image, 0, 0 );
				var imageData = ctx.getImageData( 0, 0, canvas.width, canvas.height );
				var index = 4 * ( ( screen.fixedHeaderHeight + 2 ) * imageData.width + 1 );
				var r = imageData.data[ index ];
				var g = imageData.data[ index + 1 ];
				var b = imageData.data[ index + 2 ];
				var a = imageData.data[ index + 3 ];
				var fixedHeaderBgColor = "rgba(" + r + "," + g + "," + b + "," + a + ")";
				var index = 4 * ( ( screen.height - screen.fixedFooterHeight - 2 ) * imageData.width + 1 );
				var r = imageData.data[ index ];
				var g = imageData.data[ index + 1 ];
				var b = imageData.data[ index + 2 ];
				var a = imageData.data[ index + 3 ];
				var fixedFooterBgColor = "rgba(" + r + "," + g + "," + b + "," + a + ")";
				screenService.setScreenFixedAreaColors( screen.id, fixedHeaderBgColor, fixedFooterBgColor );
				if ( $scope.screen && screen.screenID == $scope.screen.screenID ) {
					screen = screenService.getScreenByID( screen.screenID );
				}
			}
		}
		$scope.imageLoadedForScreen = function ( screen ) {
			if ( !screen ) {
				return;
			}
			screen.isImageLoaded = true;
			if ( $scope.project.isMobile ) {
				setFixedAreaColors( screen );
			}
			if ( $scope.getPercentOfScreensLoaded() >= 100 ) {
				return;
			}
			if ( _.findWithProperty( $scope.screensToPreload, "screenID", screen.screenID ) ) {
				$scope.screensThatHavePreloaded.push( screen );
			}
			var percent = Math.floor( $scope.screensThatHavePreloaded.length / $scope.screensToPreload.length * 100 );
			$scope.setPercentOfScreensLoaded( percent );
		}
		augmentScreens( $scope.screens );
		$scope.screensToPreload = getScreensToPreload();
		$scope.screensThatHavePreloaded = [];
		$scope.project = projectService.getProject();
	}
} )( angular, InVision );;;
/*! sidebar-slide-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "presentations.SidebarSlideController", Controller );
	/** @ngInject */
	function Controller( $scope, _ ) {
		$scope.hideDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = false;
		};
		$scope.showDeleteConfirmation = function () {
			$scope.isShowingDeleteConfirmation = true;
		};
		$scope.isShowingDeleteConfirmation = false;
	}
} )( angular, InVision );;;
/*! presentation-console-controller.js */
;;
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.PresentationConsoleController", Controller );
	/** @ngInject */
	function Controller( _, $rootScope, $scope, $window, $timeout, $location, sessionService, requestContext, Debouncer, Deferred, projectDetailPartial, validationService, presentationConsolePartial, screenService, presentationService, hashKeyCopier ) {
		$scope.views = {
			'build': 'build.htm',
			'preview': 'preview.htm'
		};

		function applyRemoteData( project ) {
			$scope.project = project;
		}

		function augmentPresentation( presentation ) {
			presentation.slides.unshift( {
				name: "Title Screen",
				title: true
			} );
			if ( presentation.bgScreenID ) {
				presentation.bgscreen = getScreen( presentation.bgScreenID );
				presentation.bgimage = "/screens/" + presentation.bgScreenID + "/" + presentation.bgImageVersion;
				presentation.bgimage_thumbnail = "/thumbnails/" + presentation.bgScreenID + "/" + presentation.bgImageVersion;
			}
			if ( presentation.slides.length && _.isUndefined( presentation.slides[ 0 ].displayScale ) ) {
				presentation.slides = augmentScreens( presentation.slides );
			}
			return ( presentation );
		}

		function augmentScreen( screen ) {
			if ( screen.title ) {
				return screen;
			}
			screen.workflowStatus = "In Progress";
			screen.isCompleted = false;
			screen.isApproved = false;
			screen.type = "screenObj";
			screen.displayScale = $scope.getScreenDisplayScale( screen );
			if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE ) {
				screen.workflowStatus = "Needs Approval";
				screen.isCompleted = true;
				screen.isApproved = false;
			} else if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE_AND_APPROVED ) {
				screen.workflowStatus = "Approved";
				screen.isCompleted = false;
				screen.isApproved = true;
			}
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function getDefaultSlide() {
			var slide = {
				title: false,
				name: "",
				imageUrl: "",
				thumbnailUrl: "",
				screenID: 0,
				callouts: []
			}
			return $.extend( {}, slide );
		}

		function getScreen( screenID ) {
			return _.findWithProperty( $scope.screens, "id", screenID );
		}

		function getScreenIndex( screenID ) {
			return (
				_.indexOfWithProperty( $scope.screens, "id", screenID )
			);
		}
		$scope.activateSlide = function ( idx, calloutIdx ) {
			/*if ( idx == $scope.presentationSelectedIndex ) {
return;
}*/
			var slide = $scope.getSlide( idx );
			$scope.removeMarkers();
			$scope.$broadcast( "presentation.closeModal" );
			$scope.presentationSelectedIndex = idx;
			$scope.$broadcast( "presentation.sizeBuilderWindow" );
			if ( $scope.subview == "build" ) {
				$timeout( function () {
					$scope.loadMarkers();
				}, 200 );
			} else if ( slide.callouts && slide.callouts.length ) {
				$timeout( function () {
					$scope.loadCallout( calloutIdx );
				}, 500 );
			}
		};
		$scope.getScreenDisplayScale = function ( screen ) {
			if ( $scope.project.isMobile ) {
				var displayScale = ( $scope.project.mobileTemplate.viewportWidth / screen.width );
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@2x" ) > 0 ) {
				var displayScale = 0.5;
			} else if ( !$scope.project.isMobile && screen.clientFilename.indexOf( "@print" ) > 0 ) {
				var displayScale = 0.3333;
			} else {
				var displayScale = 1;
			}
			return displayScale;
		};
		$scope.applyScreenDisplayScaleToScreens = function () {
			_.each( $scope.screens, $scope.getScreenDisplayScale );
		};
		$scope.applyScreenDisplayScaleToSlides = function () {
			_.each( $scope.presentation.slides, $scope.getScreenDisplayScale );
		};
		$scope.deleteSlide = function ( idx ) {
			$scope.presentation.slides.splice( idx, 1 );
			if ( idx == $scope.presentationSelectedIndex ) {
				$scope.activateSlide( idx - 1 );
			}
			$scope.updateData();
		};
		$scope.getCurrentSlide = function () {
			return $scope.presentation.slides[ $scope.presentationSelectedIndex ];
		};
		$scope.getSlide = function ( idx ) {
			return $scope.presentation.slides[ idx ];
		};
		$scope.getScreenUrl = function ( slide ) {
			if ( !slide ) {
				var slide = $scope.presentation.slides[ $scope.presentationSelectedIndex ];
			}
			if ( !slide || !slide.screenID ) {
				return;
			}
			return "/screens/" + slide.screenID + "/" + slide.imageVersion;
		};
		$scope.getThumbnailUrl = function ( index ) {
			var slide = $scope.presentation.slides[ index ];
			if ( !slide.screenID ) {
				return;
			}
			return "/thumbnails/" + slide.screenID + "/" + slide.imageVersion;
		};
		$scope.loadCallout = function ( idx ) {
			$scope.$broadcast( "presentation.loadCallout", idx );
		};
		$scope.loadMarkers = function ( subview ) {
			$scope.$broadcast( "presentation.loadMarkers", subview );
		};
		$scope.loadData = function ( isFullLoad ) {
			$scope.isLoading = true;
			$scope.isDataLoading = true;
			Deferred.handleAllPromises(
				[
					presentationConsolePartial.get( $scope.projectID, $scope.presentationID )
				],
				function ( consolePartialResponse ) {
					if ( consolePartialResponse.project.isMobile === "" ) {
						$location.path( "/projects/" + consolePartialResponse.project.id + "/screens" );
					}
					if ( isFullLoad ) {
						$scope.project = consolePartialResponse.project;
						$scope.mobileDeviceTemplates = consolePartialResponse.mobileDevices;
						$scope.project.mobileTemplate = _.withProperty( $scope.mobileDeviceTemplates, "mobileDeviceID", $scope.project.mobileDeviceID )[ 0 ];
						$scope.screens = augmentScreens( consolePartialResponse.activeScreens );
						$scope.presentation = augmentPresentation( consolePartialResponse.presentation );
						if ( $scope.presentationID === 0 ) {
							$scope.presentationID = $scope.presentation.id;
							$location.path( "/presentations/" + $scope.projectID + "/" + $scope.presentationID );
						}
						$scope.displayObjects = $scope.screens;
						$scope.$broadcast( "presentation.loaded" );
					}
					$timeout( function () {
						$scope.isLoading = false;
						$scope.isDataLoading = false;
						initialized = true;
					}, 1000 );
				},
				function ( error ) {
					if ( validationService.isScreenNotFound( error ) ) {
						var message = "The screen the comment was left on has been deleted or archived.";
					} else if ( validationService.isNotFound( error ) ) {
						var message = "Sorry, you aren't a collaborator on the project you tried to access. Please inform the project owner.";
					} else {
						var message = "For some reason, we can't load your project. Try refreshing your browser.";
					}
					if ( error.id ) {
						message += ( " [ID: " + error.id + "]" );
					}
					$scope.openModalWindow( "error", message );
					$scope.isLoading = false;
					$scope.isDataLoading = false;
					$location.path( "/" );
				}
			);
		};
		$scope.updateData = function () {
			$scope.isUpdating = true;
			var promise = Deferred.handlePromise(
				presentationConsolePartial.update( $scope.projectID, $scope.presentation ),
				function ( response ) {
					$scope.presentation = hashKeyCopier.copyHashKeys( $scope.presentation, augmentPresentation( response ) );
					$scope.$broadcast( "presentation.sizeBuilderWindow" );
					$scope.isUpdating = false;
					$scope.loadMarkers( "build" );
				},
				function ( error ) {
					console.log( 'error', error );
					$scope.isUpdating = false;
				}
			);
			return ( promise );
		};
		$scope.removeMarkers = function () {
			$scope.$broadcast( "presentation.removeMarkers" );
		};
		$scope.selectScreen = function ( screen, mode, fromBrowse ) {
			var slide = getDefaultSlide();
			slide.id = 0;
			slide.screenID = screen.id;
			slide.name = screen.name;
			slide.imageVersion = screen.imageVersion;
			slide.width = screen.width;
			slide.height = screen.height;
			slide.callouts = [];
			slide.clientFilename = screen.clientFilename;
			slide.displayScale = $scope.getScreenDisplayScale( slide );
			var idx = $scope.presentation.slides.push( slide );
			$scope.activateSlide( idx - 1 );
			$scope.$broadcast( "presentation.screenAddedToSidebar" );
			$scope.$broadcast( "presentation.sizeBuilderWindow" );
			$timeout( function delayCloseThumbnailTray() {
				$scope.$broadcast( "closeThumbnailTray" );
			}, 600 );
			$scope.$emit( "presentation.save" );
		};
		$scope.switchToPreview = function () {
			$scope.subview = "preview";
		};
		$scope.switchToBuild = function () {
			$scope.subview = "build";
		};
		var renderContext = requestContext.getRenderContext( "presentationconsole", [ "projectID", "presentationID" ] );
		var loadRemoteDataDebouncer = new Debouncer( Debouncer.THREE_SECONDS );
		var lastCopy;
		var tempID = 1;
		var initialized = false;
		var updateTimeout;
		$scope.subview = ( renderContext.getNextSection() || "build" );
		$scope.presentationID = requestContext.getParamAsInt( "presentationID" );
		$scope.projectID = requestContext.getParamAsInt( "projectID" );
		$scope.isLoading = false;
		$scope.isDataLoading = true; // initialize to true
		$scope.screens = [];
		$scope.screen = null;
		$scope.isPresentation = true; // used for shared resources
		$scope.selectedCalloutIndex = 0;
		$scope.user = sessionService.user;
		$scope.userID = sessionService.user.id;
		$scope.presentation = presentationService.create( $scope.presentationID );
		$scope.presentationSelectedIndex = 0;
		$scope.project = null;
		$scope.mobileDeviceTemplates = [];
		$scope.hideIntroduction = $scope.user.hasClosedPresentationTourIntro;
		$scope.settings = {
			selectedCalloutIndex: 0,
			final: false,
			isLiquid: true // set to 'true' for 'fit to screen' logic
		};
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
			}
		);
		$scope.$on( "presentation.save", function ( event ) {
			if ( $scope.isDataLoading || !initialized || $scope.isUpdating || $scope.subview == "preview" ) {
				return;
			}
			clearTimeout( updateTimeout );
			updateTimeout = setTimeout( function () {
				$scope.updateData();
			}, 500 );
		} );
		$scope.setBodyClass( "p-console" );
		$window.olark( 'api.box.hide' );
		$scope.loadData( true );
	}
} )( angular, InVision );;;
/*! presentation-share-controller.js */
;;
/*
This unholy union, and the custom presentation app-controller, bridges the gap between presentations and share mode...
This integration is a continuing work-in-progress.
Ultimately, some features of presentations should probably be built in as options to share mode, so that there's a unified codebase there.
This will have to do for now.  I'm modifying Share as little as possible, but when I need specific logic in share,
I reference $scope.isPresentation, which is defined here as true.
*/
( function ( ng, app ) {
	"use strict";
	app.controller( "layouts.PresentationShareController", Controller );
	/** @ngInject */
	function Controller( _, $rootScope, $scope, $window, $timeout, $location, requestContext, Deferred, validationService, screenService, presentationService, projectViewingService, config, hashKeyCopier ) {
		function applyRemoteData( project ) {
			$scope.project = project;
		}

		function augmentPresentation( presentation ) {
			presentation.slides.unshift( {
				name: "Title Screen",
				title: true
			} );
			/*if ( presentation.bgScreenID ) {
presentation.bgscreen = getScreen( presentation.bgScreenID );
presentation.bgimage = "/screens/" + presentation.bgScreenID + "/" + presentation.bgImageVersion;
presentation.bgimage_thumbnail = "/thumbnails/" + presentation.bgScreenID + "/" + presentation.bgImageVersion;
}*/
			return ( presentation );
		}

		function augmentScreen( screen ) {
			screen.workflowStatus = "In Progress";
			screen.isCompleted = false;
			screen.isApproved = false;
			screen.type = "screenObj";
			if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE ) {
				screen.workflowStatus = "Needs Approval";
				screen.isCompleted = true;
				screen.isApproved = false;
			} else if ( screen.workflowStatusID === screenService.workflowStatus.COMPLETE_AND_APPROVED ) {
				screen.workflowStatus = "Approved";
				screen.isCompleted = false;
				screen.isApproved = true;
			}
			return ( screen );
		}

		function augmentScreens( screens ) {
			_.each( screens, augmentScreen );
			return ( screens );
		}

		function getCurrentStepID() {
			return requestContext.getParamAsInt( "stepID", $scope.defaultScreenIDForShare );
		}

		function getDefaultSlide() {
			var slide = {
				title: false,
				name: "",
				imageUrl: "",
				thumbnailUrl: "",
				screenID: 0,
				callouts: []
			}
			return $.extend( {}, slide );
		}

		function getScreen( screenID ) {
			return _.findWithProperty( $scope.screens, "id", screenID );
		}

		function getScreenIndex( screenID ) {
			return (
				_.indexOfWithProperty( $scope.screens, "id", screenID )
			);
		}
		$scope.activateSlide = function ( idx, calloutIdx ) {
			/*if ( idx == $scope.presentationSelectedIndex ) {
return;
}*/
			var slide = $scope.getSlide( idx );
			var currentSlide = $scope.getCurrentSlide()
			$scope.removeMarkers();
			$scope.$broadcast( "presentation.closeModal" );
			$scope.presentationSelectedIndex = idx;
			$scope.settings.final = false;
			$scope.$emit( "presentation.goToSlide", idx );
			if ( idx == 0 ) {
				$scope.setWindowTitle( $scope.presentation.name );
			} else {
				$scope.setWindowTitle( slide.name );
				if ( currentSlide.id !== slide.id ) {
					projectViewingService.incrementSlideCount( $scope.presentation.id );
				}
			}
			if ( !$scope.isLoadingOpen && slide.callouts && slide.callouts.length ) {
				$timeout( function () {
					$scope.loadCallout( calloutIdx );
				}, 250 );
			} else {
				$scope.$broadcast( "presentation.loadEmptySlide" );
			}
		};
		$scope.activateSlideWithRedirect = function ( idx, calloutIdx ) {
			$scope.$broadcast( "presentation.resetTour" );
			$timeout( function () {
				$scope.activateSlide( idx, calloutIdx );
				$scope.$broadcast( "presentation.goToStep", 1 );
			}, 150 );
			$timeout( function () {
				$scope.$broadcast( "presentation.closeModal", true );
			}, 1000 );
		};
		$scope.getCurrentSlide = function () {
			return $scope.presentation.slides[ $scope.presentationSelectedIndex ];
		};
		$scope.getSlide = function ( idx ) {
			return $scope.presentation.slides[ idx ];
		};
		$scope.getScreenUrl = function ( index ) {
			if ( !index ) {
				index = $scope.presentationSelectedIndex;
			}
			var slide = $scope.presentation.slides[ index ];
			if ( !slide || !slide.screenID ) {
				return;
			}
			return config.screens[ index - 1 ].imageUrl;
		};
		$scope.getThumbnailUrl = function ( index ) {
			var slide = $scope.presentation.slides[ index ];
			if ( !slide.screenID ) {
				return;
			}
			return "/thumbnails/" + slide.screenID + "/" + slide.imageVersion;
		};
		$scope.loadCallout = function ( idx ) {
			$scope.$broadcast( "presentation.loadCallout", idx );
		};
		$scope.loadMarkers = function ( subview ) {
			$scope.$broadcast( "presentation.loadMarkers", subview );
		};
		$scope.removeMarkers = function () {
			$scope.$broadcast( "presentation.removeMarkers" );
		};
		$scope.switchToPreview = function () {
			var scrollTop = $( window ).scrollTop(),
				duration = scrollTop > 0 ? 500 : 0;
			$( "html, body" ).animate( {
				scrollTop: 0,
				scrollLeft: 0
			}, duration, "easeInOutCubic", function () {
				$timeout( function () {
					$scope.subview = "preview";
					$scope.$broadcast( "presentation.setTopBar", false );
				}, 1 );
			} );
		};
		$scope.switchToComments = function () {
			$scope.$broadcast( "presentation.closeModal" );
			$scope.$broadcast( "presentation.switchToComments" );
			$timeout( function () {
				$scope.subview = "comments";
				$scope.$broadcast( "presentation.setCommentScroll" );
			}, 750 );
		};
		var renderContext = requestContext.getRenderContext( "", "stepID" );
		var lastCopy;
		var tempID = 1;
		var initialized = false;
		var updateTimeout;
		var firstRun = true;
		$scope.subview = ( renderContext.getNextSection() || "preview" );
		$scope.isLoading = false;
		$scope.isDataLoading = true; // initialize to true
		$scope.screens = config.screens;
		$scope.screen = null;
		$scope.screenID = 0;
		$scope.isPresentation = true; // used for shared resources
		$scope.presentation = augmentPresentation( config.presentation );
		$scope.presentationSelectedIndex = 0;
		$scope.settings = {
			selectedCalloutIndex: 0,
			final: false,
			isLiquid: $scope.presentation.scaleToScreen // set to 'true' for 'fit to screen' logic
		};
		$scope.presentationID = $scope.presentation.id;
		$scope.projectID = $scope.presentation.projectID;
		$scope.project = config.project;
		$scope.disableBuildMode = true;
		$scope.isShowingSketchBuilder = false;
		$scope.$on(
			"requestContextChanged",
			function () {
				if ( !renderContext.isChangeRelevant() ) {
					return;
				}
				if ( $scope.stepID != getCurrentStepID() && $scope.subview == "preview" ) {
					$scope.stepID = getCurrentStepID();
					if ( firstRun ) {
						firstRun = false;
						$timeout( function () {
							$scope.$broadcast( "presentation.goToStep", $scope.stepID );
						}, 500 );
					} else {
						$scope.$broadcast( "presentation.goToStep", $scope.stepID );
					}
				}
			}
		);
		$scope.$watch( "presentationSelectedIndex", function ( newVal ) {
			if ( newVal === 0 ) {
				$scope.screen = null;
				$scope.screenID = 0;
			} else {
				$scope.screen = config.screens[ newVal - 1 ];
				$scope.settings.isLiquid = $scope.screen.zoomScrollBehavior == 3 ? true : false;
				$scope.screenID = $scope.screen.screenID;
				$scope.applyScreenDisplayScale();
			}
		} );
		$scope.$watch( "settings.selectedCalloutIndex", function ( indexCallout ) {
			$scope.settings.final = false;
			if ( $scope.screenID !== 0 && indexCallout && indexCallout !== 0 && indexCallout.index ) {
				$location.path( "/step/" + indexCallout.index );
			}
		} );
		$scope.$on(
			"isShowingSketchBuilder",
			function ( element, value ) {
				$scope.isShowingSketchBuilder = value;
			}
		);
		$scope.$on(
			"configUpdated.share",
			function ( event, localConfig ) {
				$scope.presentation = hashKeyCopier.copyHashKeys( $scope.presentation, augmentPresentation( config.presentation ) );
			}
		);
		$scope.$on(
			"loadingSequenceCompleted",
			function ( event ) {
				if ( $scope.stepID == 0 ) {
					$scope.setWindowTitle( $scope.presentation.name );
				}
			}
		);
		$scope.setBodyClass( "p-console" );
	}
} )( angular, InVision );;;
/*! presentation-builder.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPresentationBuilder", Directive );
	var ellipsisHTML = '<span class="ellip">&hellip;</span>';
	var initialized = false;
	/** @ngInject */
	function Directive( _, $window, $timeout, modelEvents, $location ) {
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				var beginTourTriggered = false;

				function calculateCalloutIndexes() {
					var steps = 0;
					var callouts = [];
					var currentStep = 0;
					for ( var idx in $scope.presentation.slides ) {
						var slide = $scope.presentation.slides[ idx ];
						if ( slide.callouts && slide.callouts.length ) {
							steps += slide.callouts.length;
							for ( var calloutIdx in slide.callouts ) {
								currentStep++;
								callouts.push( {
									index: currentStep,
									slideIndex: idx,
									calloutIndex: calloutIdx
								} );
							}
						} else if ( !slide.title ) { // for slides without callouts
							steps++;
							currentStep++;
							callouts.push( {
								index: currentStep,
								slideIndex: idx,
								calloutIndex: 0
							} );
						}
					}
					$scope.totalSteps = steps;
					$scope.calloutIndexes = callouts;
					if ( $scope.settings.selectedCalloutIndex == 0 ) {
						$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ 0 ];
					} else {
						$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ $scope.settings.selectedCalloutIndex.index - 1 ]
					}
				}

				function getContrast50( hexcolor ) {
					return ( parseInt( hexcolor, 16 ) > 0xffffff / 2 ) ? 'black' : 'white';
				}

				function getContrastYIQ( hexcolor ) {
					var r = parseInt( hexcolor.substr( 0, 2 ), 16 );
					var g = parseInt( hexcolor.substr( 2, 2 ), 16 );
					var b = parseInt( hexcolor.substr( 4, 2 ), 16 );
					var yiq = ( ( r * 299 ) + ( g * 587 ) + ( b * 114 ) ) / 1000;
					return ( yiq >= 128 ) ? '#252729' : 'white';
				}

				function injectEllipsisPagination() {
					var firstGap = false;
					var visibleGap = false;
					var lastGap = false;
					$( 'span.ellip' ).remove(); // remove existing ellipsis
					$( '.pagination li a' ).each( function ( idx, el ) {
						if ( !$( el ).is( ":visible" ) && firstGap === false ) {
							var ellip = $( ellipsisHTML );
							$( el ).after( ellipsisHTML );
							$( el ).parent().removeClass( "hidden" );
							firstGap = true;
						} else if ( $( el ).is( ":visible" ) && firstGap === true ) {
							visibleGap = true;
						} else if ( !$( el ).is( ":visible" ) && lastGap === false && visibleGap === true ) {
							$( el ).after( ellipsisHTML );
							$( el ).parent().removeClass( "hidden" );
							lastGap = true;
						}
					} );
				};
				$scope.addScreen = function () {
					$scope.isShowingThumbnailTray = true;
				};
				$scope.disableEditDescription = function ( event ) {
					$scope.editDescription = false;
					if ( $scope.working.presentation.description.length === 0 ) {
						$scope.presentation.description = "";
					} else {
						$scope.presentation.description = $scope.working.presentation.description;
					}
					$scope.$emit( "presentation.save" );
				};
				$scope.disableEditTitle = function ( event ) {
					$scope.editTitle = false;
					if ( $scope.working.presentation.name.length === 0 ) {
						$scope.presentation.name = "No Title";
					} else {
						$scope.presentation.name = $scope.working.presentation.name;
					}
					$scope.$emit( "presentation.save" );
				};
				$scope.getWorkingPresentationName = function () {
					return $scope.isLoading ? "Loading..." : $scope.working.presentation.name;
				};
				$scope.goBack = function () {
					var slide = $scope.getCurrentSlide();
					if ( slide.callouts && slide.callouts.length && $scope.calloutIndex != 0 ) {
						$scope.isTopBarClosed = false;
						$scope.calloutIndex--;
						$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ $scope.settings.selectedCalloutIndex.index - 2 ];
					} else if ( $scope.presentationSelectedIndex !== 0 ) {
						var backSlide = $scope.getSlide( $scope.presentationSelectedIndex - 1 );
						$scope.calloutIndex = ( backSlide.callouts ) ? backSlide.callouts.length - 1 : 0;
						if ( $scope.calloutIndex < 0 ) {
							$scope.calloutIndex = 0;
						}
						if ( $scope.settings.selectedCalloutIndex.index !== 1 ) {
							$scope.closeInstantly = true;
							$scope.isTopBarClosed = false;
							$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ $scope.settings.selectedCalloutIndex.index - 2 ];
						}
					}
				};
				$scope.goNext = function () {
					var slide = $scope.getCurrentSlide();
					if ( $scope.isShowingIntroSlide && beginTourTriggered ) {
						$scope.$broadcast( "presentation.closeModal", true );
						$timeout( function () {
							$scope.isShowingIntroSlide = false;
							$timeout( function () {
								$scope.$emit( "presentation.goToStep", 1 );
								injectEllipsisPagination();
							}, 1000 );
							$timeout( function () {
								$scope.isTopBarFullyClosed = false;
								$scope.isTopBarClosed = false;
							}, 1300 );
						}, 100 );
						return;
					} else if ( $scope.isShowingIntroSlide && !beginTourTriggered ) {
						$scope.beginTour();
						return;
					}
					$scope.isTopBarClosed = false;
					if ( slide.callouts && slide.callouts.length - 1 > $scope.calloutIndex ) {
						$scope.calloutIndex++;
						$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ $scope.settings.selectedCalloutIndex.index ];
					} else if ( $scope.presentation.slides.length - 1 > $scope.presentationSelectedIndex ) {
						$scope.calloutIndex = 0;
						$scope.closeInstantly = true;
						$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ $scope.settings.selectedCalloutIndex.index ];
					} else {
						$scope.$broadcast( "presentation.closeModal", true );
						$scope.settings.final = true;
					}
				};
				$scope.hideThumbnailTray = function () {
					$scope.isShowingThumbnailTray = false;
				};
				$scope.isVisibleIndex = function ( idx ) {
					if ( !$scope.settings.selectedCalloutIndex ) {
						return false;
					}
					if ( idx == 1 || idx == 2 || idx == $scope.calloutIndexes.length || idx == ( $scope.calloutIndexes.length - 1 ) || ( idx > ( $scope.settings.selectedCalloutIndex.index - 3 ) && idx < ( $scope.settings.selectedCalloutIndex.index + 3 ) ) ) {
						return true;
					} else {
						return false;
					}
				};
				$scope.setCloseInstantly = function ( option ) {
					$scope.closeInstantly = option;
				};
				$scope.toggleTopBarClosed = function () {
					$scope.isTopBarClosed = !$scope.isTopBarClosed;
					if ( $scope.isTopBarClosed ) {
						$scope.$broadcast( "presentation.closeModal" );
					} else if ( $scope.getCurrentSlide().callouts && $scope.getCurrentSlide().callouts.length ) {
						$scope.$broadcast( "presentation.loadCallout", $scope.calloutIndex );
					}
				};
				$scope.toggleSettingsFlyout = function () {
					$scope.isShowingSettingsFlyout = !$scope.isShowingSettingsFlyout;
				};
				$scope.goToCallout = function ( index ) {
					$scope.settings.selectedCalloutIndex = $scope.calloutIndexes[ index - 1 ];
				};
				$scope.beginTour = function () {
					beginTourTriggered = true;
					var $body = $( ".presentation-body" ),
						$title = $( "#presentation-title" ),
						$topBar = $( ".topbar" ),
						duration = 1100,
						ease = "easeInOutCubic",
						introHeight = $window.height();
					$topBar.css( {
						top: introHeight
					} );
					$body.css( {
						top: introHeight
					} );
					$title.find( ".button" ).animate( {
						opacity: 0
					}, 500, ease );
					$timeout( function () {
						$body.css( {
							position: "relative"
						} );
						$title.find( ".title" ).animate( {
							top: introHeight / 80
						}, duration, ease );
					}, 250 );
					$timeout( function () {
						$title.animate( {
							top: '-' + introHeight
						}, duration, ease, function () {
							$title.remove();
							$body.css( {
								position: "static"
							} );
							$scope.goNext();
						} );
						$body.animate( {
							top: 0
						}, duration, ease );
						$topBar.animate( {
							top: 0
						}, duration, ease );
					}, 350 );
				};
				$scope.closeCallouts = function () {
					$scope.$broadcast( "presentation.closeModal" );
				};
				var $window = $( window ),
					$builderWindow = $( ".presentation-body" ),
					$slide = $builderWindow.find( "#slide" ),
					$wrapper = $slide.find( ".imgwrapper" ),
					$introOptions = $( "#intro_options" ),
					$sidebar = $( "#sidebar" ),
					$title = $( "#presentation-title" );
				$window.on( "resize", sizeBuilderWindow );
				$scope.isShowingThumbnailTray = false;
				$scope.isBrowse = false;
				$scope.titleStyle = "";
				$scope.editTitle = false;
				$scope.curWidth = 0;
				$scope.working = {
					presentation: {
						name: $scope.presentation.name,
						description: $scope.presentation.description
					}
				};
				$scope.closeInstantly = false;
				$scope.calloutIndex = 0;
				$scope.calloutIndexes = [];
				$scope.isTopBarClosed = false;
				$scope.isTopBarFullyClosed = false;
				$scope.totalSteps = 0;
				$scope.isEditing = false;
				$scope.isShowingSettingsFlyout = false;
				$scope.isShowingIntroSlide = $scope.stepID == 1 && $scope.isFirstLoad ? true : false;
				if ( $scope.isFirstLoad ) {
					$scope.$emit( "presentation.firstLoad", false );
				}
				$scope.$watch( "presentationSelectedIndex", function ( newVal, oldVal ) {
					if ( newVal === oldVal ) {
						return;
					}
					sizeBuilderWindow();
					injectEllipsisPagination();
				} );
				$scope.$watch( "calloutIndexes", function ( newVal, oldVal ) {
					injectEllipsisPagination();
				} );
				$scope.$watch( "presentation.bgcolor", function ( newVal, oldVal ) {
					var $title = $( "#presentation-title" );
					var $titleSidebar = $( '#sidebar .screen .titleslide' );
					if ( newVal.substring( 0, 1 ) !== "#" && newVal.length > 0 ) {
						$scope.presentation.bgcolor = "#" + $scope.presentation.bgcolor;
						return;
					}
					if ( newVal.length == 4 || newVal.length == 7 ) {
						$title.css( "background-color", newVal );
						$scope.presentation.complementColor = getContrastYIQ( newVal.substring( 1, 7 ) );
					} else if ( newVal.length === 0 ) {
						$title.css( "background-color", "#ffffff" );
						$scope.presentation.complementColor = "#000000";
					}
					$scope.$emit( "presentation.save" );
				} );
				$scope.$watch( "presentation.bgimage", function ( newVal, oldVal ) {
					$scope.titleStyle = {
						backgroundImage: "url('" + newVal + "')",
						backgroundColor: $scope.presentation.bgcolor
					};
				} );
				$scope.$watch( "presentation.bgscreen", function ( newVal, oldVal ) {
					if ( $scope.subview == "build" ) {
						if ( newVal === null ) {
							$scope.presentation.bgimage = "";
							$scope.presentation.bgimage_thumbnail = "";
							$scope.presentation.bgScreenID = "";
							$scope.presentation.bgImageVersion = "";
							$scope.$emit( "presentation.save" );
							return;
						}
						if ( _.isUndefined( newVal ) ) {
							$scope.presentation.bgimage = "";
							$scope.presentation.bgimage_thumbnail = "";
							$scope.presentation.bgScreenID = "";
							$scope.presentation.bgImageVersion = "";
						} else if ( newVal && newVal.id ) {
							$scope.presentation.bgimage = "/screens/" + newVal.id + "/" + newVal.imageVersion;
							$scope.presentation.bgimage_thumbnail = "/thumbnails/" + newVal.id + "/" + newVal.imageVersion;
							$scope.presentation.bgScreenID = newVal.id;
							$scope.presentation.bgImageVersion = newVal.imageVersion;
						}
						$scope.$emit( "presentation.save" );
					}
				} );
				$scope.$watch( "subview", function ( subview, a ) {
					if ( subview == "preview" ) {
						var slide = $scope.getCurrentSlide();
						if ( slide.callouts && slide.callouts.length > 0 ) {
							if ( !$scope.isLoadingOpen ) {
								setTimeout( function () {
									$scope.$broadcast( "presentation.loadCallout", $scope.settings.selectedCalloutIndex.calloutIndex );
								}, 100 );
							}
						}
						calculateCalloutIndexes();
					} else {
						$scope.loadMarkers();
					}
				} );
				$scope.$watch( "working.presentation.description", function ( description ) {
					if ( description.length > 100 ) {
						$scope.working.presentation.description = $scope.working.presentation.description.substring( 0, 100 );
					}
				} );
				$scope.$watch( "isShowingIntroSlide", function ( newValue, oldValue ) {
					var $body = $( "body" );
					if ( newValue ) {
						$body.addClass( "showing-intro-slide" );
					} else {
						$body.removeClass( "showing-intro-slide" );
					}
				} );
				$scope.$watch( "presentation.slides", function ( newVal, oldVal ) {
					if ( newVal === oldVal ) {
						return;
					}
					$( ".screen-item" ).removeClass( "active" );
					$timeout( function () {
						_.forEach( newVal, function ( screen ) {
							$( ".screen-item#screen" + screen.screenID ).addClass( "active" );
						} );
					} );
				} );
				var unwatchLoader = $scope.$watch( "isLoadingOpen", function ( isOpen ) {
					if ( !initialized && $scope.subview == "preview" && !isOpen ) {
						unwatchLoader();
						sizeBuilderWindow();
						var slide = $scope.getCurrentSlide();
						if ( slide.callouts && slide.callouts.length > 0 ) {
							$scope.setWindowTitle( slide.name );
							if ( !$scope.isShowingIntroSlide ) {
								$scope.$broadcast( "presentation.loadCallout", $scope.settings.selectedCalloutIndex.calloutIndex );
							}
						} else {
							$scope.setWindowTitle( $scope.presentation.name );
						}
						calculateCalloutIndexes();
						initialized = true;
					}
				} );
				$scope.$on( "presentation.goToStep", function ( event, index ) {
					var indexCallout = $scope.calloutIndexes[ index - 1 ];
					if ( indexCallout && indexCallout.slideIndex ) {
						$scope.settings.selectedCalloutIndex = indexCallout;
						$scope.calloutIndex = indexCallout.calloutIndex;
						$scope.activateSlide( indexCallout.slideIndex, indexCallout.calloutIndex );
						$scope.settings.final = false;
					} else {
						$scope.activateSlide( 0, 0 );
					}
					injectEllipsisPagination();
				} );
				$scope.$on( "presentation.loaded", function () {
					$scope.working = {
						presentation: {
							name: $scope.presentation.name,
							description: $scope.presentation.description
						}
					};
					if ( $scope.subview == "build" ) {
						setTimeout( function () {
							$title.find( "input.edit-title" )
								.css( "width", "auto" )
								.autoGrowInput( {
									comfortZone: 10,
									minWidth: 1,
									maxWidth: 2000
								} );
							$title.find( "input.edit-description" )
								.css( {
									"min-width": 300
								} )
								.autoGrowInput( {
									comfortZone: 10,
									minWidth: 300,
									maxWidth: 2000
								} );
						}, 5 );
					}
				} );
				$scope.$on( "presentation.sizeBuilderWindow", function () {
					sizeBuilderWindow();
				} );
				$scope.$on( "presentation.toggleTopBarClosed", function () {
					$scope.toggleTopBarClosed();
				} );
				$scope.$on( "presentation.setTopBar", function ( event, status ) {
					$scope.isTopBarClosed = status;
					$scope.isTopBarFullyClosed = status;
				} );
				$scope.$on( "presentation.switchToComments", function () {
					$scope.previousScrollPosition = $window.scrollTop();
					$scope.isTopBarClosed = true;
					$scope.isTopBarFullyClosed = true;
					$( "html, body" ).animate( {
						scrollTop: 0,
						scrollLeft: 0
					}, 500, "easeInOutCubic" );
				} );
				$scope.$on( "presentation.setCommentScroll", function () {
					$timeout( function () {
						$( "html, body" ).animate( {
							scrollTop: $scope.previousScrollPosition
						}, 500, "easeInOutCubic" );
					} );
				} );
				$scope.$on( "presentation.resetTour", function () {
					beginTourTriggered = false;
					sizeBuilderWindow();
					$scope.isShowingIntroSlide = true;
				} );
				$scope.$on( "$destroy", function () {} );

				function sizeBuilderWindow() {
					var offsetX = $scope.subview == "preview" ? 0 : 261,
						offsetY = $scope.subview == "preview" ? 0 : 60,
						builderWidth = $window.width(),
						slide = $scope.getCurrentSlide();
					if ( $scope.subview == "build" ) {
						builderWidth = $window.width() - ( offsetX + 44 );
					}
					$builderWindow.css( {
						height: $window.height() - ( offsetY + 52 ),
						width: builderWidth
					} );
					$( "#bgimage_wrapper" ).css( 'height', $window.height() );
					$( '#slide .imgwrapper img' ).on( 'dragstart', function ( event ) {
						event.preventDefault();
					} );
					/*$sidebar.css({
height: $window.height() - ( 52 )
});*/
					$introOptions.css( {
						width: $window.width() - offsetX
					} );
					$timeout( function () {
						var slide = $scope.getCurrentSlide(),
							$img = $slide.find( "img" ),
							maxWidth,
							width = $scope.presentationSelectedIndex === 0 ? 0 : slide.width,
							$title = $( "#presentation-title" );
						$wrapper = $slide.find( ".imgwrapper" );
						if ( $scope.subview == "build" && $scope.presentationSelectedIndex !== 0 ) {
							width = slide.width * $scope.getScreenDisplayScale( slide );
						}
						if ( width === 0 ) {
							width = $window.width() - ( offsetX + 52 );
						}
						if ( width > $window.width() - ( offsetX + 52 ) ) {
							width = $window.width() - ( offsetX + 52 );
						}
						if ( $scope.subview == "build" || ( !$scope.project.isMobile && $scope.settings.isLiquid ) ) {
							$slide.css( "max-width", width );
						} else if ( $scope.subview == "preview" && !$scope.project.isMobile && !$scope.settings.isLiquid ) {
							$slide.css( "width", width );
						}
						if ( $scope.subview == "build" || $scope.settings.isLiquid ) {
							$img.css( "max-width", width );
						}
						if ( $scope.subview == "preview" && slide && !slide.title ) {
							maxWidth = ( slide.width * $scope.getScreenDisplayScale( slide ) );
							if ( maxWidth < width ) {
								$img.css( "max-width", maxWidth );
							} else if ( maxWidth > width ) {
								$slide.css( "width", maxWidth );
								$builderWindow.css( "width", maxWidth );
							}
						}
						$title.css( {
							"background-color": $scope.presentation.bgcolor
						} );
						if ( $scope.subview == "build" ) {
							$title.css( "height", ( $window.height() - ( offsetY + 52 ) - 69 ) );
						}
						$scope.curWidth = $title.find( "input" ).width();
					}, 1 );
				}

				function init() {
					sizeBuilderWindow();
					$timeout( function () {
						var $introBgColor = $( "#intro_bg_color" );
						$introBgColor.ColorPicker( {
							onChange: function ( hsb, hex, rgb, el ) {
								$scope.$apply( function () {
									$scope.presentation.bgcolor = "#" + hex;
								} );
							},
							onSubmit: function ( hsb, hex, rgb, el ) {
								$( el ).ColorPickerHide();
								$scope.$apply( function () {
									$scope.presentation.bgcolor = "#" + hex;
								} );
							},
							onBeforeShow: function () {
								$( this ).ColorPickerSetColor( this.value );
							}
						} )
							.bind( 'keyup', function () {
								$( this ).ColorPickerSetColor( this.value );
							} );
						$( ".color-preview" ).on( "click", function () {
							$introBgColor.ColorPickerShow();
						} )
					}, 100 );
				}
				if ( $scope.subview == "build" ) {
					init();
					if ( !$scope.user.hasClosedPresentationTourIntro ) {
						$scope.openModalWindow( "presentationIntro" );
					}
				}
				$( element ).focus();
			}
		};
	}
} )( angular, InVision );;;
/*! presentation-callout-builder.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPresentationCalloutBuilder", Directive );
	/** @ngInject */
	function Directive( _, $timeout, $compile ) {
		var calloutHTML = [ '<div class="calloutModal">',
				'<div class="close">&times;</div>',
				'<span class="header">LEAVE A NOTE:</span>',
				'<span class="message"><textarea inv-autosize placeholder="Type your note here..."></textarea></span>',
				'<span class="footer"><button type="button" class="button save">Save</button><button type="button" class="button delete">Delete</button></span>',
				'</div>'
			].join( '' ),
			calloutViewHTML = [ '<div class="calloutModal preview">',
				'<div class="close">&times;</div>',
				'<span class="header">x of XX</span>',
				'<span class="message"></span>',
				'<span class="footer"><a class="button next">Next</a></span>',
				'<div class="tip"></div>',
				'</div>'
			].join( '' ),
			positionDivHTML = '<div class="position-div"></div>',
			markerHTML = '<div class="marker"></div>';
		return {
			restrict: 'A',
			link: function ( $scope, element, attrs ) {
				var $container = element;
				var $window = $( window );
				var $selection;
				var $modal;
				var isSelectionPercentage = false;
				var resizeTimeout;
				var calloutTimeout;
				var highlightOnly = $( element ).attr( "data-highlight-only" ) || false;
				var maxCalloutLength = 1000;

				function addMarker( positionDiv, index ) {
					var marker = $( markerHTML );
					marker.attr( "data-index", index ).appendTo( $container.parent() );
					marker.position( {
						my: "center center",
						at: "center center",
						of: positionDiv
					} );
					var dimensions = convertDimensionsToPercentage( {
						top: marker.position().top,
						left: marker.position().left
					} );
					marker.css( {
						top: dimensions.top,
						left: dimensions.left
					} )
					marker.on( "click", function ( e ) {
						loadCallout( $( this ).attr( 'data-index' ) );
					} );
					$scope.$broadcast( "presentation.markerAdded" );
				}

				function closeModal( instant ) {
					if ( $scope.closeInstantly ) {
						instant = true;
						$scope.setCloseInstantly( false );
					}
					if ( _.isUndefined( $selection ) ) {
						var $selection = $container.find( '.selection-box' );
					}
					var $modal = $( "body" ).find( '.calloutModal' ),
						$overlay = $selection;
					if ( $scope.subview === "build" ) {
						$container.find( ".background" ).hide();
						$modal.remove();
						$overlay.remove();
					} else {
						if ( $scope.presentationSelectedIndex === 0 || instant ) {
							$modal.fadeTo( 1, 0 );
						} else {
							$modal.fadeTo( 250, 0 );
						}
						if ( !instant ) {
							$overlay.fadeTo( 250, 0 );
							$timeout( function () {
								$modal.remove();
								$overlay.remove();
							}, 250 );
						} else {
							$modal.remove();
							$overlay.remove();
						}
						$( '.mobileViewport' ).css( 'pointer-events', '' );
					}
					$selection = null;
					$scope.isEditing = false;
					$scope.calloutOpen = false;
					$( "#presentation-viewer, #presentation-builder" ).focus();
				}

				function convertDimensionsToPercentage( dimensions ) {
					var percentages = {
						height: ( dimensions.height / $container.innerHeight() ) * 100 + "%",
						width: ( dimensions.width / $container.innerWidth() ) * 100 + "%",
						top: ( dimensions.top / $container.innerHeight() ) * 100 + "%",
						left: ( dimensions.left / $container.innerWidth() ) * 100 + "%"
					};
					return percentages;
				}

				function convertDimensionsToPixels( dimensions ) {
					var pixels = {
						top: $container.innerHeight() * ( parseFloat( dimensions.top ) / 100 ),
						left: $container.innerWidth() * ( parseFloat( dimensions.left ) / 100 ),
						width: $container.innerWidth() * ( parseFloat( dimensions.width ) / 100 ),
						height: $container.innerHeight() * ( parseFloat( dimensions.height ) / 100 )
					};
					return pixels;
				}

				function loadCallout( idx ) {
					var slide = $scope.getCurrentSlide(),
						selectedCallout = slide.callouts[ idx ],
						dimensions;
					if ( !selectedCallout ) {
						return;
					}
					dimensions = convertDimensionsToPixels( selectedCallout )
					selectedCallout.index = idx;
					if ( !highlightOnly ) {
						closeModal();
					}
					$scope.isEditing = true;
					$scope.calloutOpen = true;
					$scope.selectedCallout = idx;
					removeMarkers();
					$selection = $( '<div>' ).addClass( "selection-box" );
					if ( $scope.subview == "build" ) {
						$selection.css( {
							top: dimensions.top,
							left: dimensions.left,
							width: dimensions.width,
							height: dimensions.height
						} );
					}
					if ( $scope.subview !== "build" ) {
						$selection.hide();
					}
					$selection.appendTo( $container );
					if ( $scope.subview == "build" ) {
						initializeSelection( $selection, $modal, selectedCallout );
					} else {
						$selection.css( {
							top: selectedCallout.top,
							left: selectedCallout.left,
							width: selectedCallout.width,
							height: selectedCallout.height
						} );
						$selection.fadeIn( 250 );
						$selection.addClass( "viewonly" );
						initializeViewableSelection( $selection, $modal, selectedCallout );
					}
				}

				function loadEmptySlide() {
					var slide = $scope.getCurrentSlide();
					closeModal();
					$scope.isEditing = true;
					$scope.calloutOpen = true;
					$scope.selectedCallout = 0;
					removeMarkers();
					if ( !$scope.project.isMobile ) {
						$( ".presentation-body" ).stop( true ).animate( {
							scrollTop: 0
						}, 500 );
					} else {
						$scope.scrollMobileViewport( 0, 400 );
					}
				}

				function loadMarkers() {
					removeMarkers();
					var slide = $scope.getCurrentSlide();
					if ( slide && slide.callouts && slide.callouts.length ) {
						$.each( slide.callouts, function ( idx, callout ) {
							var positionDiv = $( positionDivHTML );
							positionDiv.css( {
								top: callout.top,
								left: callout.left,
								width: callout.width,
								height: callout.height
							} );
							positionDiv.appendTo( $container );
							addMarker( positionDiv, idx );
							positionDiv.remove();
						} );
					}
				}

				function removeMarkers() {
					$container.parent().find( ".marker" ).remove();
				}

				function initializeSelection( $selection, $modal, callout ) {
					$selection.draggable( {
						cancel: ".viewonly",
						containment: ".imgwrapper",
						drag: function ( event, ui ) {
							positionModal();
						},
						start: function ( event, ui ) {
							event.stopPropagation();
							resizeBgMask( {
								width: $( event.target ).width(),
								height: $( event.target ).height()
							} );
						}
					} ).resizable( {
						autoHide: false,
						cancel: ".viewonly",
						containment: ".imgwrapper",
						handles: "nw, n, ne, e, se, s, sw, w",
						create: function ( event, ui ) {
							resizeBgMask( {
								width: $( event.target ).width(),
								height: $( event.target ).height()
							} );
							$container.parent().find( '.calloutModal' ).remove();
							$modal = $( $compile( calloutHTML )( $scope ) );
							$modal.appendTo( $container.parent() );
							positionModal();
							$modal.on( "keyup.calloutModal", function ( e ) {
								if ( e.keyCode === 27 ) {
									closeModal();
									$timeout( function () {
										loadMarkers();
									}, 1 );
								}
							} );
							$modal.find( "button.save" ).on( "click.saveNote", function ( e ) {
								var slide = $scope.getCurrentSlide();
								var calloutData = {
									id: 0,
									height: ( $selection.height() / $container.innerHeight() ) * 100 + "%",
									width: ( $selection.width() / $container.innerWidth() ) * 100 + "%",
									top: ( $selection.position().top / $container.innerHeight() ) * 100 + "%",
									left: ( $selection.position().left / $container.innerWidth() ) * 100 + "%",
									note: $modal.find( "textarea" ).val(),
									slideID: slide.id
								};
								var idx = 0;
								if ( calloutData.note.length == 0 ) {
									$modal.find( "textarea" ).focus();
									return false;
								}
								$scope.$apply( function () {
									if ( callout ) { // edit
										calloutData.id = callout.id;
										$scope.presentation.slides[ $scope.presentationSelectedIndex ].callouts[ callout.index ] = calloutData;
										idx = callout.index;
									} else { // add
										$scope.presentation.slides[ $scope.presentationSelectedIndex ].callouts.push( calloutData );
										idx = $scope.presentation.slides[ $scope.presentationSelectedIndex ].callouts.length - 1;
									}
								} );
								closeModal();
								$timeout( function () {
									loadMarkers();
								}, 1 );
								$scope.$emit( "presentation.save" );
							} );
							if ( callout ) {
								$modal.find( "button.delete" ).on( "click.deleteNote", function ( e ) {
									$scope.presentation.slides[ $scope.presentationSelectedIndex ].callouts.splice( callout.index, 1 );
									closeModal();
									$scope.$emit( "presentation.save" );
									$timeout( function () {
										loadMarkers();
									}, 1 );
								} );
							} else { // remove the delete button for new items
								$modal.find( "button.delete" ).remove();
							}
							$modal.find( "textarea" ).val( "" );
							if ( callout ) {
								$modal.find( "textarea" ).val( callout.note );
								$modal.find( "span.header" ).text( "CLICK TO EDIT NOTE:" );
							}
							setTimeout( function () {
								$modal.find( "textarea" ).on( "keypress.calloutModal", function ( event ) {
									if ( $( this ).val().length > maxCalloutLength ) {
										return false;
									}
								} );
								$modal.find( "textarea" ).focus();
							}, 100 );
							$modal.find( ".close" ).on( "click.closeCallout", function ( e ) {
								closeModal();
								$timeout( function () {
									loadMarkers();
								}, 100 );
							} );
						},
						resize: function ( event, ui ) {
							resizeBgMask( ui.size );
							/*$selection.css({
width: ( ui.helper.width() / $container.innerWidth() ) * 100 + "%",
height: ( ui.helper.height() / $container.innerHeight() ) * 100 + "%",
top: ( ui.position.top / $container.innerHeight() ) * 100 + "%",
left: ( ui.position.left / $container.innerWidth() ) * 100 + "%"
});*/
							positionModal();
						}
					} );
				}
				$window.on( "scroll", function () {} );

				function forcePositive( number ) {
					return number < 0 ? 0 : number;
				}

				function getScrollTop( selection ) {
					var position = selection.position().top;
					position = position - ( ( $window.height() - ( selection.height() + 210 ) ) / 2 );
					return forcePositive( position );
				}

				function getScrollLeft( selection ) {
					var position = selection.position().left;
					position = position - ( ( $window.width() - selection.width() ) / 2 );
					return forcePositive( position );
				}

				function withinWindow( selection ) {
					var selectionRight = selection.position().left + selection.width(),
						windowRight = $window.width() + $window.scrollLeft();
					if (
						selection.position().left > $window.scrollLeft() &&
						selectionRight < windowRight ) {
						return true;
					}
					return false;
				}

				function initializeViewableSelection( $selection, $modal, callout ) {
					$container.parent().find( '.calloutModal' ).remove();
					if ( !highlightOnly ) {
						$modal = $( calloutViewHTML );
						$modal.fadeTo( 0, 0 );
						$modal.appendTo( $container.parent() );
						if ( $scope.project.isMobile ) {
							$( '.headerSlice,footerSlice' ).addClass( 'callout-open', 500 );
						}
						$modal.find( "a.next" ).on( "click.goNext", function ( e ) {
							e.preventDefault();
							$scope.$apply( function () {
								$scope.goNext();
							} );
						} );
						if ( $scope.settings.selectedCalloutIndex.index == $scope.calloutIndexes.length ) {
							$modal.find( "a.next" ).addClass( "finish" ).html( "Finish" )
						}
						$modal.find( ".header" ).text( $scope.settings.selectedCalloutIndex.index + " of " + $scope.totalSteps );
						$modal.find( ".message" ).text( callout.note );
						$modal.find( ".close" ).on( "click.closeCallout", function ( e ) {
							$scope.$apply( function () {
								closeModal();
								$scope.toggleTopBarClosed();
							} );
						} );
						$timeout( function () {
							var targetPosition = 0,
								props;
							if ( !$scope.project.isMobile ) {
								props = {
									scrollTop: getScrollTop( $selection )
								};
								if ( !$scope.settings.isLiquid ) {
									props.scrollLeft = getScrollLeft( $selection );
									if ( withinWindow( $selection ) ) {
										props.scrollLeft = $window.scrollLeft();
									}
								}
								$( "html, body" )
									.stop( true )
									.animate( props, 500, "easeInOutCubic",
										function () {
											positionModal();
										} );
							} else {
								targetPosition = $selection.position().top - $scope.screen.fixedHeaderHeight;
								if ( targetPosition < 75 ) {
									targetPosition = 0;
								} else {
									targetPosition -= 75;
								}
								$scope.scrollMobileViewport( targetPosition, 400, function mobilePresentationScrollCallback() {
									positionModal();
								} );
								lastValidScrollTop = $selection.position().top - $scope.screen.fixedHeaderHeight - 75;
							}
							$( '.mobileViewport' ).css( 'pointer-events', 'none' );
							/*if ( $scope.stepID !== 0 ) {
projectViewingService.incrementCalloutCount( $scope.presentation.id );
}*/
						} );
					}
				}

				function positionModal() {
					var offset = 24,
						$selection = $container.find( '.selection-box' ),
						$modal = $container.parent().find( '.calloutModal' ),
						$slide = $( "#slide" );
					$modal.position( {
						my: "center top+" + offset,
						at: "center bottom",
						of: $selection,
						collision: "flipfit flip",
						within: $scope.project.isMobile ? $slide : $container.parent()
					} );
					$modal.find( ".tip" ).position( {
						my: $modal.hasClass( "ui-flipped-top" ) ? "center bottom-12" : "center top+16",
						at: $modal.hasClass( "ui-flipped-top" ) ? "center top" : "center bottom",
						of: $selection
					} );
					$modal.fadeTo( 250, 1 );
					if ( $scope.subview == "preview" && $scope.project.isMobile ) {
						$modal.addClass( "is-mobile" ).css( {
							marginLeft: ( $selection.width() - 76 ) / 2
						} );
						$modal.detach().appendTo( $slide );
						$modal.position( {
							my: "center top+" + offset,
							at: "center bottom",
							of: $selection,
							collision: "flipfit flip",
							within: $slide
						} );
						if ( $modal.position() && $modal.position().top < $scope.screen.fixedHeaderHeight ) {
							lastValidScrollTop = 0;
							setTimeout( function () {
								$modal.position( {
									my: "center top+" + offset,
									at: "center bottom",
									of: $selection,
									collision: "flipfit flip",
									within: $slide
								} );
							}, 50 );
						}
					}
				}

				function resizeBgMask( size ) {
					var $top = $( ".ui-resizable-n, .ui-resizable-s" ),
						$sides = $( ".ui-resizable-e, .ui-resizable-w" );
					$top.css( {
						width: size.width,
						"z-index": ""
					} );
					$sides.css( {
						height: size.height,
						"z-index": ""
					} );
				}
				var lastValidScrollTop = 0;
				$scope.calloutOpen = false;
				if ( $scope.subview == "build" ) {
					$container.on( "mousedown", function ( e ) {
						if ( $scope.isEditing ) {
							return;
						}
						$scope.$apply( function () {
							$scope.isEditing = true;
						} );
						var click_y = e.pageY,
							click_x = e.pageX;
						$selection = $( '<div>' ).addClass( "selection-box" );
						$selection.css( {
							"top": click_y,
							"left": click_x,
							"width": 0,
							"height": 0
						} );
						$selection.appendTo( $container );
						$container.on( "mousemove", function ( e ) {
							var move_x = e.pageX,
								move_y = e.pageY,
								width = Math.abs( move_x - click_x ),
								height = Math.abs( move_y - click_y ),
								new_x,
								new_y;
							new_x = ( move_x < click_x ) ? ( click_x - width ) : click_x;
							new_y = ( move_y < click_y ) ? ( click_y - height ) : click_y;
							/*$selection.css({
"width": ( width / $container.innerWidth() ) * 100 + "%",
"height": ( height / $container.innerHeight() ) * 100 + "%",
"top": ( ( new_y - $container.offset().top ) / $container.innerHeight() ) * 100 + "%",
"left": ( ( new_x - $container.offset().left ) / $container.innerWidth() ) * 100 + "%"
});*/
							$selection.css( {
								"width": width,
								"height": height,
								"top": new_y - $container.offset().top,
								"left": new_x - $container.offset().left
							} );
						} ).on( "mouseup", function ( e ) {
							if ( ( click_x == e.pageX && click_y == e.pageY ) || $selection.width() === 0 ) {
								$container.off( "mousemove" );
								$container.off( "mouseup" );
								closeModal();
								return;
							}
							removeMarkers();
							$container.off( "mousemove" );
							$container.off( "mouseup" );
							initializeSelection( $selection, $modal );
						} );
					} );
				}
				$window.on( "resize.calloutBuilder", function ( e ) {
					e.stopPropagation();
					if ( $( e.target ).hasClass( "selection-box" ) ) {
						return;
					}
					if ( $scope.isEditing && $scope.settings.isLiquid ) {
						clearTimeout( resizeTimeout );
						resizeBgMask( {
							width: $container.find( ".selection-box" ).width(),
							height: $container.find( ".selection-box" ).height()
						} );
						positionModal();
						if ( _.isUndefined( $selection ) ) {
							$selection = $container.find( ".selection-box" );
						}
						if ( !isSelectionPercentage ) {
							var percentages = convertDimensionsToPercentage( {
								top: $selection.position().top,
								left: $selection.position().left,
								width: $selection.width(),
								height: $selection.height()
							} );
							$selection.css( {
								top: percentages.top,
								left: percentages.left,
								height: percentages.height,
								width: percentages.width
							} );
							isSelectionPercentage = true;
						}
						if ( $scope.subview == "build" ) {
							resizeTimeout = setTimeout( function () {
								resizeBgMask( {
									width: $container.find( ".selection-box" ).width(),
									height: $container.find( ".selection-box" ).height()
								} );
								$selection.css( {
									top: $selection.position().top,
									left: $selection.position().left,
									width: $selection.width(),
									height: $selection.height()
								} );
								isSelectionPercentage = false;
							}, 100 );
						}
					}
				} );
				$scope.$on( "presentation.loadCallout", function ( event, idx ) {
					loadCallout( idx );
				} );
				$scope.$on( "presentation.loadEmptySlide", function ( event ) {
					loadEmptySlide();
				} );
				$scope.$on( "presentation.loadMarkers", function ( event ) {
					$timeout( function () {
						loadMarkers();
					}, 100 );
				} );
				$scope.$on( "presentation.removeMarkers", function () {
					removeMarkers();
				} );
				$scope.$on( "presentation.closeModal", function ( event, isInstant ) {
					closeModal( isInstant );
				} );
				$scope.$on(
					"$destroy",
					function () {
						$container.off( "mousedown" );
						$window.off( "resize.calloutBuilder" );
						$( 'button.save' ).off( "click.saveNote" );
						$( 'button.next' ).off( "click.goNext" );
						$( 'button.delete' ).off( "click.deleteNote" );
					}
				);
			}
		};
	}
} )( angular, InVision );;;
/*! presentation-cursor-tooltip.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invPresentationCursorTooltip",
		function () {
			var linkFunction = function ( $scope, element, attributes ) {
				$( document ).on( "mousemove.cursorTooltip", function ( e ) {
					$( element ).css( {
						left: e.pageX + 6,
						top: e.pageY + 6
					} );
					if ( $( e.target ).parent().hasClass( "imgwrapper" ) ) {
						isHidden = false;
					} else {
						isHidden = true;
					}
					if ( isHidden !== $scope.isHidden ) {
						$scope.$apply( function () {
							$scope.isHidden = isHidden;
						} );
					}
				} );
				var isHidden = true; // this is the working value, so we don't call the digest all the time
				$scope.isHidden = true;
				$scope.$on(
					"$destroy",
					function () {
						$( document ).off( "mousemove.cursorTooltip" );
					}
				);
			};
			return ( {
				link: linkFunction,
				restrict: "A",
				scope: false
			} );
		}
	);
} )( angular, InVision );;;
/*! presentation-screen.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive(
		"invPresentationScreen",
		/** @ngInject */
		function ( $timeout, _, config ) {
			var linkFunction = function ( $scope, element, attributes ) {
				var screen = null;
				attributes.$observe(
					"index",
					function ( newValue ) {
						screen = getScreenByIndex( newValue );
						element.on( "load.invPresentationScreen", handleImageLoaded );
						element.on( "error.invPresentationScreen", handleImageLoaded );
						if ( screen && screen.isGif ) {
							element.css( "transform", "translateZ( 0 )" );
							$scope.$watch( "( selectedScreen.screenID == screen.screenID )", handleScreenSelectionForGif );
						}
					}
				);

				function getScreenByIndex( index ) {
					return config.screens[ index ];
				}

				function handleImageLoaded() {
					element
						.off( "load.invPresentationScreen" )
						.off( "error.invPresentationScreen" );
					$timeout(
						function () {
							$scope.imageLoadedForScreen( screen );
						}
					);
				}

				function handleScreenSelectionForGif( newValue, oldValue ) {
					if ( newValue === oldValue ) {
						return;
					}
					if ( !newValue ) {
						return;
					}
					if ( !element.prop( "src" ) ) {
						return;
					}
					element
						.prop( "src", "" )
						.prop( "src", element.attr( "ng-src" ) );
				}
				$scope.$on(
					"$destroy",
					function () {
						element.off( "load.invPresentationScreen" );
						element.off( "error.invPresentationScreen" );
					}
				);
			};
			return ( {
				link: linkFunction,
				restrict: "A"
			} );
		}
	);
} )( angular, InVision );;;
/*! presentation-sidebar.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invPresentationSidebar", Directive );
	/** @ngInject */
	function Directive( _, $window, $timeout ) {
		return {
			restrict: "A",
			link: function ( $scope, element ) {
				var $element = $( element );
				var startIndex = 0;

				function buildSorter() {
					$element.sortable( {
						items: ".screen.sortable",
						placeholder: "placeholder",
						start: function ( event, ui ) {
							startIndex = ui.item.index();
							var scroller = $element.getNiceScroll()[ 0 ];
							$( ui.item ).css( {
								"margin-top": scroller.getScrollTop()
							} );
						},
						stop: function ( event, ui ) {
							$( ui.item ).css( "margin-top", "" );
						},
						update: function ( event, ui ) {
							var idx = ui.item.index();
							var slideCopy = $.extend( {}, $scope.presentation.slides[ startIndex ] );
							$scope.$apply( function () {
								$scope.presentation.slides.splice( startIndex, 1 );
								$scope.presentation.slides.splice( idx, 0, slideCopy );
								$scope.activateSlide( idx );
								$scope.$emit( "presentation.save" );
							} );
							buildSorter();
						}
					} );
				}

				function getSidebarSize() {
					var sidebarHeight = $element.height(),
						totalSidebarHeight = $element.find( ".screen" ).length * 220;
					$scope.smallAddScreenButton = sidebarHeight < totalSidebarHeight;
					$element.find( ".viewport, .overview" ).height( totalSidebarHeight );
				}
				$scope.$watch(
					function () {
						return ( $element[ 0 ].innerHTML );
					},
					function () {
						getSidebarSize();
					}
				);
				$timeout( function () {
					buildSorter();
					getSidebarSize();
				} );
				$scope.$on( "presentation.markerAdded", function () {
					buildSorter();
					getSidebarSize();
				} );
				$scope.$on( "subview", function ( subview ) {
					if ( subview == "build" ) {
						setTimeout( function () {
							buildSorter();
							getSidebarSize();
						}, 1000 );
					}
				} );
				$scope.$on( "closeThumbnailTray", function () {
					setTimeout( function () {
						$element.sortable( "refresh" );
						getSidebarSize();
					}, 100 );
				} );
				$scope.$on( "$destroy", function () {} );
			}
		};
	}
} )( angular, InVision );;;
/*! select-presentation-background-menu.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSelectPresentationBackgroundMenu", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			var selectTimer = null,
				$element = $( element ),
				$dropdownLinks;
			selectTimer = $timeout(
				function () {
					var $window = $( window ),
						$parent = $element.parent(),
						maxHeight = 458,
						dropdownSize = $element.find( "option" ).length > 15 ? 15 : false,
						$ddWrapper,
						$thumbTemplate = $( '<span class="thumb"><span class="loading">Loading...</span></span>' ),
						$thumbPreview,
						previewOffset = 0,
						picker;
					if ( attributes.usesNgRepeatOptions && attributes.ngModel ) {
						$element.find( "option:first" ).remove();
					};
					$element
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							size: $( element ).data( "size" ) || false
						} );
					$element.parent().on(
						"click",
						".selectPicker",
						function ( event ) {
							$scope.$apply( attributes.ngClick );
						}
					);
					$element
						.on( 'isActive', function ( e, obj ) {
							var $this = $( obj ),
								rel = $this.parent().attr( "rel" );
							if ( !isNaN( rel ) && isFinite( rel ) && rel != 0 ) {
								rel = rel - 1;
								$thumbPreview = $thumbTemplate.clone();
								var $thumbLoader = $( 'span', $thumbPreview ),
									top = $this.parent().position().top + $this.parent().height() + $this.height(),
									img = "/thumbnails/" + $scope.screens[ rel ].id + "/" + $scope.screens[ rel ].imageVersion,
									imgW = 0,
									imgH = 0;
								$thumbPreview
									.appendTo( $ddWrapper )
									.css( 'top', ( top - previewOffset ) )
									.show();
								$( '<img />' )
									.load( function () {
										imgW = this.width;
										imgH = this.height;
										$thumbPreview
											.html( $( this ) );
									} )
									.attr( 'src', img );
							}
						} )
						.on( 'isNonActive', function () {
							$ddWrapper.find( '.thumb' ).remove();
						} );
					$ddWrapper = $element.next();
					$dropdownLinks = $element.parent().find( 'ul.dropdown-menu a' );
					setupThumbHover();
					/*$element.parent().on(
"hover",
"button.btn",
function( event ) {
$(this).attr("title", "");
}
);*/
					$element.next().on( "click", function () {
						$scope.$apply( attributes.ngClick );
					} );
					if ( attributes.ngModel ) {
						$scope.$watch( attributes.ngModel, function watchNgModel() {
							$element.selectpicker( "refresh" );
							setupThumbHover();
						} );
					}
				}
			);

			function setupThumbHover() {
				if ( $dropdownLinks == undefined ) {
					return;
				}
				$element.parent().find( 'ul.dropdown-menu a' )
					.off( "mouseenter mouseleave click" )
					.on( "mouseenter", function ( e ) {
						$element.trigger( 'isActive', e.currentTarget );
					} )
					.on( "mouseleave click", function () {
						$element.trigger( 'isNonActive' );
					} );
			}
			$scope.$on(
				"$destroy",
				function () {
					$( element ).remove();
					$timeout.cancel( selectTimer );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! select.js */
;;
( function ( ng, app ) {
	"use strict";
	app.directive( "invSelect", Directive );
	/** @ngInject */
	function Directive( $timeout ) {
		function link( $scope, element, attributes ) {
			var selectTimer = null;
			selectTimer = $timeout(
				function () {
					var $element = $( element );
					if ( attributes.usesNgRepeatOptions && attributes.ngModel ) {
						$element.find( "option:first" ).remove();
					};
					$element
						.addClass( "selectPicker" )
						.selectpicker( {
							dropupAuto: false,
							size: $( element ).data( "size" ) || false
						} );
					$element.parent().on(
						"click",
						".selectPicker",
						function ( event ) {
							$scope.$apply( attributes.ngClick );
						}
					);
					$element.parent().on(
						"hover",
						"button.btn",
						function ( event ) {
							$( this ).attr( "title", "" );
						}
					);
					$element.next().on( "click", function () {
						$scope.$apply( attributes.ngClick );
					} );
					if ( attributes.ngModel ) {
						$scope.$watch( attributes.ngModel, function watchNgModel() {
							$element.selectpicker( "refresh" );
						} );
					}
				}
			);
			$scope.$on(
				"$destroy",
				function () {
					$( element ).remove();
					$timeout.cancel( selectTimer );
				}
			);
		}
		return ( {
			link: link,
			restrict: "A"
		} );
	}
} )( angular, InVision );;;
/*! presentation-service.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "presentationService", PresentationService );
	/** @ngInject */
	function PresentationService( $resource, config, Deferred, modelEvents, serviceHelper ) {
		function getDefaultPresentation( id ) {
			var defaultData = $.extend( {}, newPresentationData );
			return $.extend( defaultData, {
				id: id
			} );
		}

		function getPresentationsByProjectID( projectID ) {}

		function getShareConfig( presentationKey ) {
			/*if ( cachedShareConfigFailure !== null ) {
return( cachedShareConfigFailure );
}*/
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getShareConfig",
				parameters: {
					key: presentationKey
				}
			} );
			promise.then(
				null,
				function () {
					cachedShareConfigFailure = promise;
				}
			);
			return ( promise );
		}

		function identify( name, email ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "identify",
				parameters: {
					key: config.presentation.id,
					name: name,
					email: email
				},
				successCallback: function ( response ) {
					modelEvents.trigger( "shareIdentityChanged", response );
				}
			} );
			return ( promise );
		}

		function sendEmail( presentationID, emailList, message ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "sendEmail",
				parameters: {
					key: presentationID,
					emailList: emailList,
					message: message
				}
			} );
			return ( promise );
		}

		function updateShareConfig( presentationConfig ) {
			/*if ( cachedShareConfigFailure !== null ) {
return( cachedShareConfigFailure );
}*/
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "updateShareConfig",
				parameters: presentationConfig
			} );
			promise.then(
				null,
				function () {
					cachedShareConfigFailure = promise;
				}
			);
			return ( promise );
		}
		var newPresentationData = {
			id: 0,
			name: "No Title",
			description: "",
			bgcolor: "#ffffff",
			bgimage: "",
			bgimage_thumbnail: "",
			bgscreen: "",
			complementColor: "#000000",
			slides: [ {
				title: true,
				name: "Title Screen",
				description: ""
			} ],
			scaleToScreen: false,
			selected: 0
		};
		var cachedShareConfigFailure;
		var resource = $resource(
			"/api/presentation/:key/:command", {
				key: "@key",
				command: "@command"
			}, {
				identify: {
					method: "POST",
					params: {
						command: "change-identity"
					}
				},
				/*sendSMS: {
method: "POST",
params: {
command: "send-sms"
}
},*/
				sendEmail: {
					method: "POST",
					params: {
						command: "send-email"
					}
				},
				updateShareConfig: {
					method: "POST",
					params: {
						command: "update-share-config"
					}
				},
				getShareConfig: {
					method: "GET",
					params: {
						command: "get-share-config"
					}
				}
			}
		);
		return ( {
			create: getDefaultPresentation,
			identify: identify,
			getPresentationsByProjectID: getPresentationsByProjectID,
			getShareConfig: getShareConfig,
			sendEmail: sendEmail,
			updateShareConfig: updateShareConfig
		} );
	}
} )( angular, InVision );;;
/*! presentation-console-partial.js */
;;
( function ( ng, app ) {
	"use strict";
	app.service( "presentationConsolePartial", Service );
	/** @ngInject */
	function Service( $resource, serviceHelper, modelEvents, _ ) {
		function activate( projectID, presentationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "archive",
				parameters: {
					id: projectID,
					presentationID: presentationID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function archive( projectID, presentationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "archive",
				parameters: {
					id: projectID,
					presentationID: presentationID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function duplicate( projectID, presentationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "duplicate",
				parameters: {
					id: projectID,
					presentationID: presentationID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function get( projectID, presentationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "get",
				parameters: {
					id: projectID,
					presentationID: presentationID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function getByProjectID( projectID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "getByProjectID",
				parameters: {
					id: projectID,
					presentationID: "all"
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function remove( projectID, presentationID ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "remove",
				parameters: {
					id: projectID,
					presentationID: presentationID
				},
				successCallback: function ( response ) {},
				errorCallback: function () {}
			} );
			return ( promise );
		}

		function update( projectID, presentation ) {
			var promise = serviceHelper.executeRequest( {
				resource: resource,
				name: "update",
				parameters: {
					id: projectID,
					presentationID: presentation.id,
					presentation: presentation
				},
				successCallback: function ( response ) {},
				errorCallback: function ( error ) {
					console.log( 'error occurred in presentation update', error );
				}
			} );
			return ( promise );
		}

		function getCacheKey( projectID ) {
			return ( projectID );
		}
		var resource = $resource(
			"/api/partials/desktop/console/presentation/:id/:presentationID", {
				id: "@id",
				presentationID: "@presentationID"
			}, {
				archive: {
					method: "PUT",
					isArray: true
				},
				get: {
					method: "GET",
					isArray: false
				},
				getByProjectID: {
					method: "GET",
					isArray: true
				},
				update: {
					method: "POST",
					isArray: false
				},
				remove: {
					method: "DELETE",
					isArray: true
				},
				duplicate: {
					method: "COPY",
					isArray: true
				}
			}
		);
		return ( {
			activate: activate,
			archive: archive,
			duplicate: duplicate,
			get: get,
			removePresentation: remove,
			update: update,
			getByProjectID: getByProjectID
		} );
	}
} )( angular, InVision );